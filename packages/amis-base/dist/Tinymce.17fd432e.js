import { _ as HH, b as fH, j as VH } from "./index.7add3ddd.js";
import mH from "react";
import "react-dom";
var gH = { exports: {} };
(function(ns) {
  (function() {
    var To = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var n = typeof e;
      return n === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : n === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : n;
    }, Eo = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, In = function(e, n) {
      var o = Array.prototype.slice.call(e);
      return o.sort(n);
    }, Jn = function(e, n) {
      return uo(function(o, r) {
        return e.eq(n(o), n(r));
      });
    }, uo = function(e) {
      return { eq: e };
    }, ho = uo(function(e, n) {
      return e === n;
    }), Kt = ho, Bt = function(e) {
      return uo(function(n, o) {
        if (n.length !== o.length)
          return !1;
        for (var r = n.length, c = 0; c < r; c++)
          if (!e.eq(n[c], o[c]))
            return !1;
        return !0;
      });
    }, $t = function(e, n) {
      return Jn(Bt(e), function(o) {
        return In(o, n);
      });
    }, Un = function(e) {
      return uo(function(n, o) {
        var r = Object.keys(n), c = Object.keys(o);
        if (!$t(Kt).eq(r, c))
          return !1;
        for (var u = r.length, m = 0; m < u; m++) {
          var y = r[m];
          if (!e.eq(n[y], o[y]))
            return !1;
        }
        return !0;
      });
    }, Ao = uo(function(e, n) {
      if (e === n)
        return !0;
      var o = To(e), r = To(n);
      return o !== r ? !1 : Eo(o) ? e === n : o === "array" ? Bt(Ao).eq(e, n) : o === "object" ? Un(Ao).eq(e, n) : !1;
    });
    const tn = Object.getPrototypeOf, mt = (e, n, o) => {
      var r;
      return o(e, n.prototype) ? !0 : ((r = e.constructor) === null || r === void 0 ? void 0 : r.name) === n.name;
    }, an = (e) => {
      const n = typeof e;
      return e === null ? "null" : n === "object" && Array.isArray(e) ? "array" : n === "object" && mt(e, String, (o, r) => r.isPrototypeOf(o)) ? "string" : n;
    }, Ge = (e) => (n) => an(n) === e, At = (e) => (n) => typeof n === e, He = (e) => (n) => e === n, Ue = (e, n) => dn(e) && mt(e, n, (o, r) => tn(o) === r), ie = Ge("string"), dn = Ge("object"), _t = (e) => Ue(e, Object), Re = Ge("array"), oe = He(null), Je = At("boolean"), rt = He(void 0), lt = (e) => e == null, Q = (e) => !lt(e), wn = At("function"), ft = At("number"), Ot = (e, n) => {
      if (Re(e)) {
        for (let o = 0, r = e.length; o < r; ++o)
          if (!n(e[o]))
            return !1;
        return !0;
      }
      return !1;
    }, Se = () => {
    }, Qe = (e, n) => (...o) => e(n.apply(null, o)), z = (e, n) => (o) => e(n(o)), Pe = (e) => () => e, Rt = (e) => e, un = (e, n) => e === n;
    function Ct(e, ...n) {
      return (...o) => {
        const r = n.concat(o);
        return e.apply(null, r);
      };
    }
    const _o = (e) => (n) => !e(n), Fn = (e) => () => {
      throw new Error(e);
    }, Sn = (e) => e(), Dn = (e) => {
      e();
    }, Mn = Pe(!1), Xe = Pe(!0);
    class O {
      constructor(n, o) {
        this.tag = n, this.value = o;
      }
      static some(n) {
        return new O(!0, n);
      }
      static none() {
        return O.singletonNone;
      }
      fold(n, o) {
        return this.tag ? o(this.value) : n();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(n) {
        return this.tag ? O.some(n(this.value)) : O.none();
      }
      bind(n) {
        return this.tag ? n(this.value) : O.none();
      }
      exists(n) {
        return this.tag && n(this.value);
      }
      forall(n) {
        return !this.tag || n(this.value);
      }
      filter(n) {
        return !this.tag || n(this.value) ? this : O.none();
      }
      getOr(n) {
        return this.tag ? this.value : n;
      }
      or(n) {
        return this.tag ? this : n;
      }
      getOrThunk(n) {
        return this.tag ? this.value : n();
      }
      orThunk(n) {
        return this.tag ? this : n();
      }
      getOrDie(n) {
        if (this.tag)
          return this.value;
        throw new Error(n != null ? n : "Called getOrDie on None");
      }
      static from(n) {
        return Q(n) ? O.some(n) : O.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(n) {
        this.tag && n(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    O.singletonNone = new O(!1);
    const gt = Array.prototype.slice, en = Array.prototype.indexOf, Pt = Array.prototype.push, Ne = (e, n) => en.call(e, n), We = (e, n) => {
      const o = Ne(e, n);
      return o === -1 ? O.none() : O.some(o);
    }, Ae = (e, n) => Ne(e, n) > -1, Oe = (e, n) => {
      for (let o = 0, r = e.length; o < r; o++) {
        const c = e[o];
        if (n(c, o))
          return !0;
      }
      return !1;
    }, ae = (e, n) => {
      const o = e.length, r = new Array(o);
      for (let c = 0; c < o; c++) {
        const u = e[c];
        r[c] = n(u, c);
      }
      return r;
    }, X = (e, n) => {
      for (let o = 0, r = e.length; o < r; o++) {
        const c = e[o];
        n(c, o);
      }
    }, je = (e, n) => {
      for (let o = e.length - 1; o >= 0; o--) {
        const r = e[o];
        n(r, o);
      }
    }, ke = (e, n) => {
      const o = [], r = [];
      for (let c = 0, u = e.length; c < u; c++) {
        const m = e[c];
        (n(m, c) ? o : r).push(m);
      }
      return {
        pass: o,
        fail: r
      };
    }, ue = (e, n) => {
      const o = [];
      for (let r = 0, c = e.length; r < c; r++) {
        const u = e[r];
        n(u, r) && o.push(u);
      }
      return o;
    }, ct = (e, n, o) => (je(e, (r, c) => {
      o = n(o, r, c);
    }), o), Ht = (e, n, o) => (X(e, (r, c) => {
      o = n(o, r, c);
    }), o), vo = (e, n, o) => {
      for (let r = 0, c = e.length; r < c; r++) {
        const u = e[r];
        if (n(u, r))
          return O.some(u);
        if (o(u, r))
          break;
      }
      return O.none();
    }, Wn = (e, n) => vo(e, n, Mn), ko = (e, n) => {
      for (let o = 0, r = e.length; o < r; o++) {
        const c = e[o];
        if (n(c, o))
          return O.some(o);
      }
      return O.none();
    }, fo = (e) => {
      const n = [];
      for (let o = 0, r = e.length; o < r; ++o) {
        if (!Re(e[o]))
          throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
        Pt.apply(n, e[o]);
      }
      return n;
    }, yn = (e, n) => fo(ae(e, n)), ds = (e, n) => {
      for (let o = 0, r = e.length; o < r; ++o) {
        const c = e[o];
        if (n(c, o) !== !0)
          return !1;
      }
      return !0;
    }, Ho = (e) => {
      const n = gt.call(e, 0);
      return n.reverse(), n;
    }, mn = (e, n) => ue(e, (o) => !Ae(n, o)), Io = (e, n) => {
      const o = {};
      for (let r = 0, c = e.length; r < c; r++) {
        const u = e[r];
        o[String(u)] = n(u, r);
      }
      return o;
    }, ro = (e, n) => {
      const o = gt.call(e, 0);
      return o.sort(n), o;
    }, Ln = (e, n) => n >= 0 && n < e.length ? O.some(e[n]) : O.none(), Go = (e) => Ln(e, 0), Ro = (e) => Ln(e, e.length - 1), Os = wn(Array.from) ? Array.from : (e) => gt.call(e), Qs = (e, n) => {
      for (let o = 0; o < e.length; o++) {
        const r = n(e[o], o);
        if (r.isSome())
          return r;
      }
      return O.none();
    }, we = (e, n) => {
      const o = [], r = wn(n) ? (c) => Oe(o, (u) => n(u, c)) : (c) => Ae(o, c);
      for (let c = 0, u = e.length; c < u; c++) {
        const m = e[c];
        r(m) || o.push(m);
      }
      return o;
    }, $e = Object.keys, Vt = Object.hasOwnProperty, Jt = (e, n) => {
      const o = $e(e);
      for (let r = 0, c = o.length; r < c; r++) {
        const u = o[r], m = e[u];
        n(m, u);
      }
    }, ht = (e, n) => qn(e, (o, r) => ({
      k: r,
      v: n(o, r)
    })), qn = (e, n) => {
      const o = {};
      return Jt(e, (r, c) => {
        const u = n(r, c);
        o[u.k] = u.v;
      }), o;
    }, pr = (e) => (n, o) => {
      e[o] = n;
    }, zr = (e, n, o, r) => {
      const c = {};
      return Jt(e, (u, m) => {
        (n(u, m) ? o : r)(u, m);
      }), c;
    }, Zs = (e, n) => {
      const o = {}, r = {};
      return zr(e, n, pr(o), pr(r)), {
        t: o,
        f: r
      };
    }, hr = (e, n) => {
      const o = {};
      return zr(e, n, pr(o), Se), o;
    }, Fs = (e, n) => {
      const o = [];
      return Jt(e, (r, c) => {
        o.push(n(r, c));
      }), o;
    }, Tr = (e) => Fs(e, Rt), Xo = (e, n) => Gn(e, n) ? O.from(e[n]) : O.none(), Gn = (e, n) => Vt.call(e, n), er = (e, n) => Gn(e, n) && e[n] !== void 0 && e[n] !== null, Ss = (e, n, o = Ao) => Un(o).eq(e, n), ir = (e) => {
      const n = {};
      return X(e, (o) => {
        n[o] = {};
      }), $e(n);
    }, Ka = Array.isArray, Ra = (e) => {
      if (Ka(e))
        return e;
      {
        const n = [];
        for (let o = 0, r = e.length; o < r; o++)
          n[o] = e[o];
        return n;
      }
    }, Ur = (e, n, o) => {
      let r, c;
      if (!e)
        return !1;
      if (o = o || e, e.length !== void 0) {
        for (r = 0, c = e.length; r < c; r++)
          if (n.call(o, e[r], r, e) === !1)
            return !1;
      } else
        for (r in e)
          if (Gn(e, r) && n.call(o, e[r], r, e) === !1)
            return !1;
      return !0;
    }, rs = (e, n) => {
      const o = [];
      return Ur(e, (r, c) => {
        o.push(n(r, c, e));
      }), o;
    }, cc = (e, n) => {
      const o = [];
      return Ur(e, (r, c) => {
        (!n || n(r, c, e)) && o.push(r);
      }), o;
    }, Z = (e, n) => {
      if (e) {
        for (let o = 0, r = e.length; o < r; o++)
          if (e[o] === n)
            return o;
      }
      return -1;
    }, le = (e, n, o, r) => {
      let c = rt(o) ? e[0] : o;
      for (let u = 0; u < e.length; u++)
        c = n.call(r, c, e[u], u);
      return c;
    }, Ce = (e, n, o) => {
      let r, c;
      for (r = 0, c = e.length; r < c; r++)
        if (n.call(o, e[r], r, e))
          return r;
      return -1;
    }, wt = (e) => e[e.length - 1], Rn = (e) => {
      let n = !1, o;
      return (...r) => (n || (n = !0, o = e.apply(null, r)), o);
    }, Ft = (e, n, o, r) => {
      const c = e.isiOS() && /ipad/i.test(o) === !0, u = e.isiOS() && !c, m = e.isiOS() || e.isAndroid(), y = m || r("(pointer:coarse)"), v = c || !u && m && r("(min-device-width:768px)"), x = u || m && !v, R = n.isSafari() && e.isiOS() && /safari/i.test(o) === !1, F = !x && !v && !R;
      return {
        isiPad: Pe(c),
        isiPhone: Pe(u),
        isTablet: Pe(v),
        isPhone: Pe(x),
        isTouch: Pe(y),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: Pe(R),
        isDesktop: Pe(F)
      };
    }, Co = (e, n) => {
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        if (r.test(n))
          return r;
      }
    }, tr = (e, n) => {
      const o = Co(e, n);
      if (!o)
        return {
          major: 0,
          minor: 0
        };
      const r = (c) => Number(n.replace(o, "$" + c));
      return yr(r(1), r(2));
    }, Bn = (e, n) => {
      const o = String(n).toLowerCase();
      return e.length === 0 ? No() : tr(e, o);
    }, No = () => yr(0, 0), yr = (e, n) => ({
      major: e,
      minor: n
    }), bt = {
      nu: yr,
      detect: Bn,
      unknown: No
    }, se = (e, n) => Qs(n.brands, (o) => {
      const r = o.brand.toLowerCase();
      return Wn(e, (c) => {
        var u;
        return r === ((u = c.brand) === null || u === void 0 ? void 0 : u.toLowerCase());
      }).map((c) => ({
        current: c.name,
        version: bt.nu(parseInt(o.version, 10), 0)
      }));
    }), me = (e, n) => {
      const o = String(n).toLowerCase();
      return Wn(e, (r) => r.search(o));
    }, tt = (e, n) => me(e, n).map((o) => {
      const r = bt.detect(o.versionRegexes, n);
      return {
        current: o.name,
        version: r
      };
    }), Lt = (e, n) => me(e, n).map((o) => {
      const r = bt.detect(o.versionRegexes, n);
      return {
        current: o.name,
        version: r
      };
    }), zt = (e, n) => e.substring(n), Nt = (e, n, o) => n === "" || e.length >= n.length && e.substr(o, o + n.length) === n, on = (e, n) => On(e, n) ? zt(e, n.length) : e, Yt = (e, n) => e.indexOf(n) !== -1, On = (e, n) => Nt(e, n, 0), os = (e, n) => Nt(e, n, e.length - n.length), $s = (e) => (n) => n.replace(e, ""), zo = $s(/^\s+|\s+$/g), Ya = $s(/^\s+/g), sa = $s(/\s+$/g), Bo = (e) => e.length > 0, fs = (e) => !Bo(e), Lo = (e, n) => n <= 0 ? "" : new Array(n + 1).join(e), br = (e, n = 10) => {
      const o = parseInt(e, n);
      return isNaN(o) ? O.none() : O.some(o);
    }, Er = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ra = (e) => (n) => Yt(n, e), nl = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => Yt(e, "edge/") && Yt(e, "chrome") && Yt(e, "safari") && Yt(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          Er
        ],
        search: (e) => Yt(e, "chrome") && !Yt(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => Yt(e, "msie") || Yt(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          Er,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: ra("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: ra("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          Er,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (Yt(e, "safari") || Yt(e, "mobile/")) && Yt(e, "applewebkit")
      }
    ], pa = [
      {
        name: "Windows",
        search: ra("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => Yt(e, "iphone") || Yt(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: ra("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: ra("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: ra("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: ra("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: ra("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: ra("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], Wr = {
      browsers: Pe(nl),
      oses: Pe(pa)
    }, Ma = "Edge", ci = "Chromium", ol = "IE", aa = "Opera", Xa = "Firefox", kl = "Safari", Ja = () => li({
      current: void 0,
      version: bt.unknown()
    }), li = (e) => {
      const n = e.current, o = e.version, r = (c) => () => n === c;
      return {
        current: n,
        version: o,
        isEdge: r(Ma),
        isChromium: r(ci),
        isIE: r(ol),
        isOpera: r(aa),
        isFirefox: r(Xa),
        isSafari: r(kl)
      };
    }, Qa = {
      unknown: Ja,
      nu: li,
      edge: Pe(Ma),
      chromium: Pe(ci),
      ie: Pe(ol),
      opera: Pe(aa),
      firefox: Pe(Xa),
      safari: Pe(kl)
    }, Fc = "Windows", Hl = "iOS", or = "Android", U = "Linux", fe = "macOS", _e = "Solaris", nt = "FreeBSD", Et = "ChromeOS", So = () => Ko({
      current: void 0,
      version: bt.unknown()
    }), Ko = (e) => {
      const n = e.current, o = e.version, r = (c) => () => n === c;
      return {
        current: n,
        version: o,
        isWindows: r(Fc),
        isiOS: r(Hl),
        isAndroid: r(or),
        isMacOS: r(fe),
        isLinux: r(U),
        isSolaris: r(_e),
        isFreeBSD: r(nt),
        isChromeOS: r(Et)
      };
    }, js = {
      unknown: So,
      nu: Ko,
      windows: Pe(Fc),
      ios: Pe(Hl),
      android: Pe(or),
      linux: Pe(U),
      macos: Pe(fe),
      solaris: Pe(_e),
      freebsd: Pe(nt),
      chromeos: Pe(Et)
    }, Jr = { detect: (e, n, o) => {
      const r = Wr.browsers(), c = Wr.oses(), u = n.bind((v) => se(r, v)).orThunk(() => tt(r, e)).fold(Qa.unknown, Qa.nu), m = Lt(c, e).fold(js.unknown, js.nu), y = Ft(m, u, e, o);
      return {
        browser: u,
        os: m,
        deviceType: y
      };
    } }, to = (e) => window.matchMedia(e).matches;
    let Ic = Rn(() => Jr.detect(navigator.userAgent, O.from(navigator.userAgentData), to));
    const Vo = () => Ic(), ha = navigator.userAgent, Vl = Vo(), nr = Vl.browser, ca = Vl.os, lc = Vl.deviceType, Lc = ha.indexOf("Windows Phone") !== -1, Qt = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: nr.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !nr.isIE(),
      windowsPhone: Lc,
      browser: {
        current: nr.current,
        version: nr.version,
        isChromium: nr.isChromium,
        isEdge: nr.isEdge,
        isFirefox: nr.isFirefox,
        isIE: nr.isIE,
        isOpera: nr.isOpera,
        isSafari: nr.isSafari
      },
      os: {
        current: ca.current,
        version: ca.version,
        isAndroid: ca.isAndroid,
        isChromeOS: ca.isChromeOS,
        isFreeBSD: ca.isFreeBSD,
        isiOS: ca.isiOS,
        isLinux: ca.isLinux,
        isMacOS: ca.isMacOS,
        isSolaris: ca.isSolaris,
        isWindows: ca.isWindows
      },
      deviceType: {
        isDesktop: lc.isDesktop,
        isiPad: lc.isiPad,
        isiPhone: lc.isiPhone,
        isPhone: lc.isPhone,
        isTablet: lc.isTablet,
        isTouch: lc.isTouch,
        isWebView: lc.isWebView
      }
    }, Zr = /^\s*|\s*$/g, wl = (e) => e == null ? "" : ("" + e).replace(Zr, ""), qr = (e, n) => n ? n === "array" && Ka(e) ? !0 : typeof e === n : e !== void 0, B = (e, n, o) => {
      let r;
      for (e = e || [], n = n || ",", typeof e == "string" && (e = e.split(n)), o = o || {}, r = e.length; r--; )
        o[e[r]] = {};
      return o;
    }, j = Gn, ce = (e, ...n) => {
      for (let o = 0; o < n.length; o++) {
        const r = n[o];
        for (const c in r)
          if (Gn(r, c)) {
            const u = r[c];
            u !== void 0 && (e[c] = u);
          }
      }
      return e;
    }, Fe = function(e, n, o, r) {
      r = r || this, e && (o && (e = e[o]), Ur(e, (c, u) => {
        if (n.call(r, c, u, o) === !1)
          return !1;
        Fe(c, n, o, r);
      }));
    }, it = {
      trim: wl,
      isArray: Ka,
      is: qr,
      toArray: Ra,
      makeMap: B,
      each: Ur,
      map: rs,
      grep: cc,
      inArray: Z,
      hasOwn: j,
      extend: ce,
      walk: Fe,
      resolve: (e, n) => {
        let o, r;
        for (n = n || window, e = e.split("."), o = 0, r = e.length; o < r && (n = n[e[o]], !!n); o++)
          ;
        return n;
      },
      explode: (e, n) => !e || qr(e, "array") ? e : rs(e.split(n || ","), wl),
      _addCacheSuffix: (e) => {
        const n = Qt.cacheSuffix;
        return n && (e += (e.indexOf("?") === -1 ? "?" : "&") + n), e;
      }
    }, hs = (e, n, o = un) => e.exists((r) => o(r, n)), Ca = (e) => {
      const n = [], o = (r) => {
        n.push(r);
      };
      for (let r = 0; r < e.length; r++)
        e[r].each(o);
      return n;
    }, qs = (e, n, o) => e.isSome() && n.isSome() ? O.some(o(e.getOrDie(), n.getOrDie())) : O.none(), Hc = (e, n, o, r) => e.isSome() && n.isSome() && o.isSome() ? O.some(r(e.getOrDie(), n.getOrDie(), o.getOrDie())) : O.none(), as = (e, n) => e ? O.some(n) : O.none();
    typeof window < "u" || Function("return this;")();
    const G = 8, re = 9, Me = 11, Ye = 1, bn = 3, An = (e) => e.dom.nodeName.toLowerCase(), Wo = (e) => e.dom.nodeType, Xs = (e) => (n) => Wo(n) === e, ic = (e) => Wo(e) === G || An(e) === "#comment", Oo = Xs(Ye), Ps = Xs(bn), uc = Xs(re), dc = Xs(Me), su = (e) => (n) => Oo(n) && An(n) === e, fc = (e, n, o) => {
      if (ie(o) || Je(o) || ft(o))
        e.setAttribute(n, o + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", n, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
    }, ms = (e, n, o) => {
      fc(e.dom, n, o);
    }, ur = (e, n) => {
      const o = e.dom;
      Jt(n, (r, c) => {
        fc(o, c, r);
      });
    }, Na = (e, n) => {
      const o = e.dom.getAttribute(n);
      return o === null ? void 0 : o;
    }, _l = (e, n) => O.from(Na(e, n)), Ni = (e, n) => {
      const o = e.dom;
      return o && o.hasAttribute ? o.hasAttribute(n) : !1;
    }, $r = (e, n) => {
      e.dom.removeAttribute(n);
    }, Cl = (e) => {
      const n = e.dom.attributes;
      return n == null || n.length === 0;
    }, Sa = (e) => Ht(e.dom.attributes, (n, o) => (n[o.name] = o.value, n), {}), Mu = (e, n) => {
      const o = Na(e, n);
      return o === void 0 || o === "" ? [] : o.split(" ");
    }, sm = (e, n, o) => {
      const c = Mu(e, n).concat([o]);
      return ms(e, n, c.join(" ")), !0;
    }, Sl = (e, n, o) => {
      const r = ue(Mu(e, n), (c) => c !== o);
      return r.length > 0 ? ms(e, n, r.join(" ")) : $r(e, n), !1;
    }, xl = (e) => e.dom.classList !== void 0, Bi = (e) => Mu(e, "class"), ru = (e, n) => sm(e, "class", n), Ba = (e, n) => Sl(e, "class", n), sf = (e, n) => Ae(Bi(e), n) ? Ba(e, n) : ru(e, n), jl = (e, n) => {
      xl(e) ? e.dom.classList.add(n) : ru(e, n);
    }, dd = (e) => {
      (xl(e) ? e.dom.classList : Bi(e)).length === 0 && $r(e, "class");
    }, Nu = (e, n) => {
      xl(e) ? e.dom.classList.remove(n) : Ba(e, n), dd(e);
    }, fd = (e, n) => {
      const o = xl(e) ? e.dom.classList.toggle(n) : sf(e, n);
      return dd(e), o;
    }, Bu = (e, n) => xl(e) && e.dom.classList.contains(n), Tl = (e) => e.style !== void 0 && wn(e.style.getPropertyValue), og = (e, n) => {
      const r = (n || document).createElement("div");
      if (r.innerHTML = e, !r.hasChildNodes() || r.childNodes.length > 1) {
        const c = "HTML does not have a single root node";
        throw console.error(c, e), new Error(c);
      }
      return mc(r.childNodes[0]);
    }, $u = (e, n) => {
      const r = (n || document).createElement(e);
      return mc(r);
    }, rf = (e, n) => {
      const r = (n || document).createTextNode(e);
      return mc(r);
    }, mc = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, be = {
      fromHtml: og,
      fromTag: $u,
      fromText: rf,
      fromDom: mc,
      fromPoint: (e, n, o) => O.from(e.dom.elementFromPoint(n, o)).map(mc)
    }, Pu = (e, n) => {
      const o = [], r = (u) => (o.push(u), n(u));
      let c = n(e);
      do
        c = c.bind(r);
      while (c.isSome());
      return o;
    }, El = (e, n) => {
      const o = e.dom;
      if (o.nodeType !== Ye)
        return !1;
      {
        const r = o;
        if (r.matches !== void 0)
          return r.matches(n);
        if (r.msMatchesSelector !== void 0)
          return r.msMatchesSelector(n);
        if (r.webkitMatchesSelector !== void 0)
          return r.webkitMatchesSelector(n);
        if (r.mozMatchesSelector !== void 0)
          return r.mozMatchesSelector(n);
        throw new Error("Browser lacks native selectors");
      }
    }, cf = (e) => e.nodeType !== Ye && e.nodeType !== re && e.nodeType !== Me || e.childElementCount === 0, wy = (e, n) => {
      const o = n === void 0 ? document : n.dom;
      return cf(o) ? [] : ae(o.querySelectorAll(e), be.fromDom);
    }, sg = (e, n) => {
      const o = n === void 0 ? document : n.dom;
      return cf(o) ? O.none() : O.from(o.querySelector(e)).map(be.fromDom);
    }, Is = (e, n) => e.dom === n.dom, ya = (e, n) => {
      const o = e.dom, r = n.dom;
      return o === r ? !1 : o.contains(r);
    }, Ul = (e) => be.fromDom(e.dom.ownerDocument), ii = (e) => uc(e) ? e : Ul(e), rm = (e) => be.fromDom(ii(e).dom.documentElement), $i = (e) => be.fromDom(ii(e).dom.defaultView), ec = (e) => O.from(e.dom.parentNode).map(be.fromDom), am = (e) => O.from(e.dom.parentElement).map(be.fromDom), rg = (e, n) => {
      const o = wn(n) ? n : Mn;
      let r = e.dom;
      const c = [];
      for (; r.parentNode !== null && r.parentNode !== void 0; ) {
        const u = r.parentNode, m = be.fromDom(u);
        if (c.push(m), o(m) === !0)
          break;
        r = u;
      }
      return c;
    }, cm = (e) => {
      const n = (o) => ue(o, (r) => !Is(e, r));
      return ec(e).map(Qr).map(n).getOr([]);
    }, sl = (e) => O.from(e.dom.previousSibling).map(be.fromDom), lf = (e) => O.from(e.dom.nextSibling).map(be.fromDom), uf = (e) => Ho(Pu(e, sl)), Ec = (e) => Pu(e, lf), Qr = (e) => ae(e.dom.childNodes, be.fromDom), au = (e, n) => {
      const o = e.dom.childNodes;
      return O.from(o[n]).map(be.fromDom);
    }, md = (e) => au(e, 0), rl = (e) => au(e, e.dom.childNodes.length - 1), al = (e) => e.dom.childNodes.length, lm = (e) => {
      const n = e.dom.head;
      if (n == null)
        throw new Error("Head is not available yet");
      return be.fromDom(n);
    }, im = (e) => dc(e) && Q(e.dom.host), df = wn(Element.prototype.attachShadow) && wn(Node.prototype.getRootNode), E = Pe(df), M = df ? (e) => be.fromDom(e.dom.getRootNode()) : ii, H = (e) => im(e) ? e : lm(ii(e)), ye = (e) => {
      const n = M(e);
      return im(n) ? O.some(n) : O.none();
    }, ze = (e) => be.fromDom(e.dom.host), sn = (e) => {
      if (E() && Q(e.target)) {
        const n = be.fromDom(e.target);
        if (Oo(n) && Yn(n) && e.composed && e.composedPath) {
          const o = e.composedPath();
          if (o)
            return Go(o);
        }
      }
      return O.from(e.target);
    }, Yn = (e) => Q(e.dom.shadowRoot), xo = (e) => {
      const n = Ps(e) ? e.dom.parentNode : e.dom;
      if (n == null || n.ownerDocument === null)
        return !1;
      const o = n.ownerDocument;
      return ye(be.fromDom(n)).fold(() => o.body.contains(n), z(xo, ze));
    }, Zo = (e, n, o) => {
      if (!ie(o))
        throw console.error("Invalid call to CSS.set. Property ", n, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
      Tl(e) && e.style.setProperty(n, o);
    }, jo = (e, n) => {
      Tl(e) && e.style.removeProperty(n);
    }, ws = (e, n, o) => {
      const r = e.dom;
      Zo(r, n, o);
    }, Or = (e, n) => {
      const o = e.dom;
      Jt(n, (r, c) => {
        Zo(o, c, r);
      });
    }, Gr = (e, n) => {
      const o = e.dom, c = window.getComputedStyle(o).getPropertyValue(n);
      return c === "" && !xo(e) ? ui(o, n) : c;
    }, ui = (e, n) => Tl(e) ? e.style.getPropertyValue(n) : "", gd = (e, n) => {
      const o = e.dom, r = ui(o, n);
      return O.from(r).filter((c) => c.length > 0);
    }, Ip = (e) => {
      const n = {}, o = e.dom;
      if (Tl(o))
        for (let r = 0; r < o.style.length; r++) {
          const c = o.style.item(r);
          n[c] = o.style[c];
        }
      return n;
    }, Lp = (e, n) => {
      const o = e.dom;
      jo(o, n), hs(_l(e, "style").map(zo), "") && $r(e, "style");
    }, yo = (e) => e.dom.offsetWidth, Mr = (e, n) => {
      ec(e).each((r) => {
        r.dom.insertBefore(n.dom, e.dom);
      });
    }, cl = (e, n) => {
      lf(e).fold(() => {
        ec(e).each((c) => {
          Kr(c, n);
        });
      }, (r) => {
        Mr(r, n);
      });
    }, _y = (e, n) => {
      md(e).fold(() => {
        Kr(e, n);
      }, (r) => {
        e.dom.insertBefore(n.dom, r.dom);
      });
    }, Kr = (e, n) => {
      e.dom.appendChild(n.dom);
    }, Cy = (e, n) => {
      Mr(e, n), Kr(n, e);
    }, um = (e, n) => {
      X(n, (o, r) => {
        const c = r === 0 ? e : n[r - 1];
        cl(c, o);
      });
    }, Fu = (e, n) => {
      X(n, (o) => {
        Kr(e, o);
      });
    }, ff = (e) => {
      e.dom.textContent = "", X(Qr(e), (n) => {
        Gs(n);
      });
    }, Gs = (e) => {
      const n = e.dom;
      n.parentNode !== null && n.parentNode.removeChild(n);
    }, $a = (e) => {
      const n = Qr(e);
      n.length > 0 && um(e, n), Gs(e);
    }, Al = (e, n) => {
      const r = (n || document).createElement("div");
      return r.innerHTML = e, Qr(be.fromDom(r));
    }, vs = (e) => ae(e, be.fromDom), ag = (e) => e.dom.innerHTML, mf = (e, n) => {
      const r = Ul(e).dom, c = be.fromDom(r.createDocumentFragment()), u = Al(n, r);
      Fu(c, u), ff(e), Kr(e, c);
    }, dm = (e) => {
      const n = be.fromTag("div"), o = be.fromDom(e.dom.cloneNode(!0));
      return Kr(n, o), ag(n);
    }, Iu = (e, n, o, r, c, u, m) => ({
      target: e,
      x: n,
      y: o,
      stop: r,
      prevent: c,
      kill: u,
      raw: m
    }), cg = (e) => {
      const n = be.fromDom(sn(e).getOr(e.target)), o = () => e.stopPropagation(), r = () => e.preventDefault(), c = Qe(r, o);
      return Iu(n, e.clientX, e.clientY, o, r, c, e);
    }, Sy = (e, n) => (o) => {
      e(o) && n(cg(o));
    }, sr = (e, n, o, r, c) => {
      const u = Sy(o, r);
      return e.dom.addEventListener(n, u, c), { unbind: Ct(di, e, n, u, c) };
    }, fm = (e, n, o, r) => sr(e, n, o, r, !1), di = (e, n, o, r) => {
      e.dom.removeEventListener(n, o, r);
    }, gf = (e, n) => ({
      left: e,
      top: n,
      translate: (r, c) => gf(e + r, n + c)
    }), Lu = gf, lg = (e) => {
      const n = e.getBoundingClientRect();
      return Lu(n.left, n.top);
    }, cu = (e, n) => e !== void 0 ? e : n !== void 0 ? n : 0, pf = (e) => {
      const n = e.dom.ownerDocument, o = n.body, r = n.defaultView, c = n.documentElement;
      if (o === e.dom)
        return Lu(o.offsetLeft, o.offsetTop);
      const u = cu(r == null ? void 0 : r.pageYOffset, c.scrollTop), m = cu(r == null ? void 0 : r.pageXOffset, c.scrollLeft), y = cu(c.clientTop, o.clientTop), v = cu(c.clientLeft, o.clientLeft);
      return pd(e).translate(m - v, u - y);
    }, pd = (e) => {
      const n = e.dom, r = n.ownerDocument.body;
      return r === n ? Lu(r.offsetLeft, r.offsetTop) : xo(e) ? lg(n) : Lu(0, 0);
    }, Po = (e) => {
      const n = e !== void 0 ? e.dom : document, o = n.body.scrollLeft || n.documentElement.scrollLeft, r = n.body.scrollTop || n.documentElement.scrollTop;
      return Lu(o, r);
    }, hd = (e, n, o) => {
      const c = (o !== void 0 ? o.dom : document).defaultView;
      c && c.scrollTo(e, n);
    }, mm = (e, n) => {
      Vo().browser.isSafari() && wn(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(n);
    }, ig = (e) => {
      const n = e === void 0 ? window : e;
      return Vo().browser.isFirefox() ? O.none() : O.from(n.visualViewport);
    }, gm = (e, n, o, r) => ({
      x: e,
      y: n,
      width: o,
      height: r,
      right: e + o,
      bottom: n + r
    }), Hp = (e) => {
      const n = e === void 0 ? window : e, o = n.document, r = Po(be.fromDom(o));
      return ig(n).fold(() => {
        const c = n.document.documentElement, u = c.clientWidth, m = c.clientHeight;
        return gm(r.left, r.top, u, m);
      }, (c) => gm(Math.max(c.pageLeft, r.left), Math.max(c.pageTop, r.top), c.width, c.height));
    }, fi = (e) => (n) => !!n && n.nodeType === e, hf = (e) => !!e && !Object.getPrototypeOf(e), Vn = fi(1), Wl = (e) => {
      const n = e.map((o) => o.toLowerCase());
      return (o) => {
        if (o && o.nodeName) {
          const r = o.nodeName.toLowerCase();
          return Ae(n, r);
        }
        return !1;
      };
    }, yf = (e, n) => {
      const o = n.toLowerCase().split(" ");
      return (r) => {
        if (Vn(r))
          for (let c = 0; c < o.length; c++) {
            const u = r.ownerDocument.defaultView.getComputedStyle(r, null);
            if ((u ? u.getPropertyValue(e) : null) === o[c])
              return !0;
          }
        return !1;
      };
    }, Vp = (e) => (n) => Vn(n) && n.hasAttribute(e), ll = (e, n) => (o) => Vn(o) && o.getAttribute(e) === n, Hu = (e) => Vn(e) && e.hasAttribute("data-mce-bogus"), ug = (e) => Vn(e) && e.getAttribute("data-mce-bogus") === "all", mi = (e) => Vn(e) && e.tagName === "TABLE", xy = (e) => (n) => !!(Vn(n) && (n.contentEditable === e || n.getAttribute("data-mce-contenteditable") === e)), pm = Wl([
      "textarea",
      "input"
    ]), rn = fi(3), Ty = fi(4), jp = fi(7), hm = fi(8), gc = fi(9), Pn = fi(11), Cr = Wl(["br"]), Up = Wl(["img"]), Zl = xy("true"), Dr = xy("false"), yd = Wl([
      "td",
      "th"
    ]), tc = Wl([
      "video",
      "audio",
      "object",
      "embed"
    ]), Wp = Vo().browser, Pi = (e) => Wn(e, Oo), Pr = (e) => Wp.isFirefox() && An(e) === "table" ? Pi(Qr(e)).filter((n) => An(n) === "caption").bind((n) => Pi(Ec(n)).map((o) => {
      const r = o.dom.offsetTop, c = n.dom.offsetTop, u = n.dom.offsetHeight;
      return r <= c ? -u : 0;
    })).getOr(0) : 0, bf = (e, n) => e.children && Ae(e.children, n), dg = (e, n, o) => {
      let r = 0, c = 0;
      const u = e.ownerDocument;
      if (o = o || e, n) {
        if (o === e && n.getBoundingClientRect && Gr(be.fromDom(e), "position") === "static") {
          const y = n.getBoundingClientRect();
          return r = y.left + (u.documentElement.scrollLeft || e.scrollLeft) - u.documentElement.clientLeft, c = y.top + (u.documentElement.scrollTop || e.scrollTop) - u.documentElement.clientTop, {
            x: r,
            y: c
          };
        }
        let m = n;
        for (; m && m !== o && m.nodeType && !bf(m, o); ) {
          const y = m;
          r += y.offsetLeft || 0, c += y.offsetTop || 0, m = y.offsetParent;
        }
        for (m = n.parentNode; m && m !== o && m.nodeType && !bf(m, o); )
          r -= m.scrollLeft || 0, c -= m.scrollTop || 0, m = m.parentNode;
        c += Pr(be.fromDom(n));
      }
      return {
        x: r,
        y: c
      };
    };
    var ym = (e, n, o, r, c) => e(o, r) ? O.some(o) : wn(c) && c(o) ? O.none() : n(o, r, c);
    const vf = (e, n, o) => {
      let r = e.dom;
      const c = wn(o) ? o : Mn;
      for (; r.parentNode; ) {
        r = r.parentNode;
        const u = be.fromDom(r);
        if (n(u))
          return O.some(u);
        if (c(u))
          break;
      }
      return O.none();
    }, bd = (e, n, o) => ym((c, u) => u(c), vf, e, n, o), fg = (e, n) => {
      const o = e.dom;
      return o.parentNode ? x1(be.fromDom(o.parentNode), (r) => !Is(e, r) && n(r)) : O.none();
    }, x1 = (e, n) => {
      const o = (c) => n(be.fromDom(c));
      return Wn(e.dom.childNodes, o).map(be.fromDom);
    }, kf = (e, n) => {
      const o = (r) => {
        for (let c = 0; c < r.childNodes.length; c++) {
          const u = be.fromDom(r.childNodes[c]);
          if (n(u))
            return O.some(u);
          const m = o(r.childNodes[c]);
          if (m.isSome())
            return m;
        }
        return O.none();
      };
      return o(e.dom);
    }, vd = (e, n, o) => vf(e, (r) => El(r, n), o), kd = (e, n) => sg(n, e), Js = (e, n, o) => ym((c, u) => El(c, u), vd, e, n, o), gi = (e, n = {}) => {
      let o = 0;
      const r = {}, c = be.fromDom(e), u = ii(c), m = n.maxLoadTime || 5e3, y = (J) => {
        n.referrerPolicy = J;
      }, v = (J) => {
        Kr(H(c), J);
      }, x = (J) => {
        const te = H(c);
        kd(te, "#" + J).each(Gs);
      }, R = (J) => Xo(r, J).getOrThunk(() => ({
        id: "mce-u" + o++,
        passed: [],
        failed: [],
        count: 0
      })), F = (J) => new Promise((te, ve) => {
        let De;
        const Be = it._addCacheSuffix(J), qe = R(Be);
        r[Be] = qe, qe.count++;
        const pt = (En, fn) => {
          X(En, Dn), qe.status = fn, qe.passed = [], qe.failed = [], De && (De.onload = null, De.onerror = null, De = null);
        }, pn = () => pt(qe.passed, 2), vt = () => pt(qe.failed, 3), xt = (En, fn) => {
          En() || (Date.now() - Qn < m ? setTimeout(fn) : vt());
        }, Zt = () => {
          xt(() => {
            const En = e.styleSheets;
            let fn = En.length;
            for (; fn--; ) {
              const Us = En[fn].ownerNode;
              if (Us && Us.id === De.id)
                return pn(), !0;
            }
            return !1;
          }, Zt);
        };
        if (te && qe.passed.push(te), ve && qe.failed.push(ve), qe.status === 1)
          return;
        if (qe.status === 2) {
          pn();
          return;
        }
        if (qe.status === 3) {
          vt();
          return;
        }
        qe.status = 1;
        const Xt = be.fromTag("link", u.dom);
        ur(Xt, {
          rel: "stylesheet",
          type: "text/css",
          id: qe.id
        });
        const Qn = Date.now();
        n.contentCssCors && ms(Xt, "crossOrigin", "anonymous"), n.referrerPolicy && ms(Xt, "referrerpolicy", n.referrerPolicy), De = Xt.dom, De.onload = Zt, De.onerror = vt, v(Xt), ms(Xt, "href", Be);
      }), W = (J) => Promise.allSettled(ae(J, (ve) => F(ve).then(Pe(ve)))).then((ve) => {
        const De = ke(ve, (Be) => Be.status === "fulfilled");
        return De.fail.length > 0 ? Promise.reject(ae(De.fail, (Be) => Be.reason)) : ae(De.pass, (Be) => Be.value);
      }), K = (J) => {
        const te = it._addCacheSuffix(J);
        Xo(r, te).each((ve) => {
          --ve.count === 0 && (delete r[te], x(ve.id));
        });
      };
      return {
        load: F,
        loadAll: W,
        unload: K,
        unloadAll: (J) => {
          X(J, (te) => {
            K(te);
          });
        },
        _setReferrerPolicy: y
      };
    }, wd = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (o, r) => {
        const u = M(o).dom;
        return O.from(e.get(u)).getOrThunk(() => {
          const m = gi(u, r);
          return e.set(u, m), m;
        });
      } };
    })();
    class rr {
      constructor(n, o) {
        this.node = n, this.rootNode = o, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(n) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", n), this.node;
      }
      prev(n) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", n), this.node;
      }
      prev2(n) {
        return this.node = this.findPreviousNode(this.node, n), this.node;
      }
      findSibling(n, o, r, c) {
        let u, m;
        if (n) {
          if (!c && n[o])
            return n[o];
          if (n !== this.rootNode) {
            if (u = n[r], u)
              return u;
            for (m = n.parentNode; m && m !== this.rootNode; m = m.parentNode)
              if (u = m[r], u)
                return u;
          }
        }
      }
      findPreviousNode(n, o) {
        let r, c, u;
        if (n) {
          if (r = n.previousSibling, this.rootNode && r === this.rootNode)
            return;
          if (r) {
            if (!o) {
              for (u = r.lastChild; u; u = u.lastChild)
                if (!u.lastChild)
                  return u;
            }
            return r;
          }
          if (c = n.parentNode, c && c !== this.rootNode)
            return c;
        }
      }
    }
    const T1 = [
      "article",
      "aside",
      "details",
      "div",
      "dt",
      "figcaption",
      "footer",
      "form",
      "fieldset",
      "header",
      "hgroup",
      "html",
      "main",
      "nav",
      "section",
      "summary",
      "body",
      "p",
      "dl",
      "multicol",
      "dd",
      "figure",
      "address",
      "center",
      "blockquote",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "listing",
      "xmp",
      "pre",
      "plaintext",
      "menu",
      "dir",
      "ul",
      "ol",
      "li",
      "hr",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "th",
      "tr",
      "td",
      "caption"
    ], ba = [
      "td",
      "th"
    ], va = [
      "thead",
      "tbody",
      "tfoot"
    ], Zp = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], ut = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ], Ac = [
      "li",
      "dd",
      "dt"
    ], Ey = [
      "ul",
      "ol",
      "dl"
    ], la = [
      "pre",
      "script",
      "textarea",
      "style"
    ], bm = ["pre"].concat(ut), Vu = (e) => {
      let n;
      return (o) => (n = n || Io(e, Xe), Gn(n, An(o)));
    }, xa = Vu(T1), E1 = (e) => An(e) === "table", Fi = (e) => Oo(e) && !xa(e), _d = (e) => Oo(e) && An(e) === "br", jc = Vu(Zp), xs = Vu(Ey), zl = Vu(Ac), wf = Vu(va), pc = Vu(ba), vm = Vu(la), _f = Vu(bm), mg = (e) => _f(e) || Fi(e), zc = (e, n, o) => vd(e, n, o).isSome(), km = "\uFEFF", Te = "\xA0", Uc = (e) => e === km, gg = (e) => e.replace(/\uFEFF/g, ""), lu = (e, n) => {
      let o = [];
      return X(Qr(e), (r) => {
        n(r) && (o = o.concat([r])), o = o.concat(lu(r, n));
      }), o;
    }, ia = (e, n) => wy(n, e), Fr = ((e, n) => {
      const o = (u) => {
        if (!e(u))
          throw new Error("Can only get " + n + " value of a " + n + " node");
        return r(u).getOr("");
      }, r = (u) => e(u) ? O.from(u.dom.nodeValue) : O.none();
      return {
        get: o,
        getOption: r,
        set: (u, m) => {
          if (!e(u))
            throw new Error("Can only set raw " + n + " value of a " + n + " node");
          u.dom.nodeValue = m;
        }
      };
    })(Ps, "text"), Cd = (e) => Fr.get(e), ju = (e) => Fr.getOption(e), qp = (e) => {
      const n = [];
      let o = e.dom;
      for (; o; )
        n.push(be.fromDom(o)), o = o.lastChild;
      return n;
    }, Xn = (e) => {
      const n = ia(e, "br"), o = ue(qp(e).slice(-1), _d);
      n.length === o.length && X(o, Gs);
    }, Sd = () => {
      const e = be.fromTag("br");
      return ms(e, "data-mce-bogus", "1"), e;
    }, Pa = (e) => {
      ff(e), Kr(e, Sd());
    }, A1 = (e) => {
      rl(e).each((n) => {
        sl(n).each((o) => {
          xa(e) && _d(n) && xa(o) && Gs(n);
        });
      });
    }, k = km, S = Uc, P = gg, q = Vn, ge = rn, Ze = (e) => (ge(e) && (e = e.parentNode), q(e) && e.hasAttribute("data-mce-caret")), St = (e) => ge(e) && S(e.data), jt = (e) => Ze(e) || St(e), mo = (e) => e.firstChild !== e.lastChild || !Cr(e.firstChild), Fo = (e, n) => {
      const r = e.ownerDocument.createTextNode(k), c = e.parentNode;
      if (n) {
        const u = e.previousSibling;
        if (ge(u)) {
          if (jt(u))
            return u;
          if (Fa(u))
            return u.splitText(u.data.length - 1);
        }
        c.insertBefore(r, e);
      } else {
        const u = e.nextSibling;
        if (ge(u)) {
          if (jt(u))
            return u;
          if (hc(u))
            return u.splitText(1), u;
        }
        e.nextSibling ? c.insertBefore(r, e.nextSibling) : c.appendChild(r);
      }
      return r;
    }, Rr = (e) => {
      const n = e.container();
      return rn(n) ? n.data.charAt(e.offset()) === k || e.isAtStart() && St(n.previousSibling) : !1;
    }, ks = (e) => {
      const n = e.container();
      return rn(n) ? n.data.charAt(e.offset() - 1) === k || e.isAtEnd() && St(n.nextSibling) : !1;
    }, vr = (e, n, o) => {
      const c = n.ownerDocument.createElement(e);
      c.setAttribute("data-mce-caret", o ? "before" : "after"), c.setAttribute("data-mce-bogus", "all"), c.appendChild(Sd().dom);
      const u = n.parentNode;
      return o ? u.insertBefore(c, n) : n.nextSibling ? u.insertBefore(c, n.nextSibling) : u.appendChild(c), c;
    }, hc = (e) => ge(e) && e.data[0] === k, Fa = (e) => ge(e) && e.data[e.data.length - 1] === k, iu = (e) => {
      const n = e.getElementsByTagName("br"), o = n[n.length - 1];
      Hu(o) && o.parentNode.removeChild(o);
    }, Ii = (e) => e && e.hasAttribute("data-mce-caret") ? (iu(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, pg = (e) => Ze(e.startContainer), wm = Zl, Nr = Dr, Wc = Cr, Uu = rn, uu = Wl([
      "script",
      "style",
      "textarea"
    ]), Cf = Wl([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), ql = Wl(["table"]), hg = jt, Do = (e) => hg(e) ? !1 : Uu(e) ? !uu(e.parentNode) : Cf(e) || Wc(e) || ql(e) || Br(e), dr = (e) => Vn(e) && e.getAttribute("unselectable") === "true", Br = (e) => dr(e) === !1 && Nr(e), Ta = (e, n) => {
      for (e = e.parentNode; e && e !== n; e = e.parentNode) {
        if (Br(e))
          return !1;
        if (wm(e))
          return !0;
      }
      return !0;
    }, z1 = (e) => Br(e) ? Ht(Os(e.getElementsByTagName("*")), (n, o) => n || wm(o), !1) !== !0 : !1, xd = (e) => Cf(e) || z1(e), Li = (e, n) => Do(e) && Ta(e, n), Zc = /^[ \t\r\n]*$/, Gl = (e) => Zc.test(e), yg = (e) => " \f	\v".indexOf(e) !== -1, O1 = (e) => e === `
` || e === "\r", Gp = (e, n) => n < e.length && n >= 0 ? O1(e[n]) : !1, Hk = (e, n = 4, o = !0, r = !0) => {
      const c = Lo(" ", n), u = e.replace(/\t/g, c);
      return Ht(u, (y, v) => yg(v) || v === Te ? y.pcIsSpace || y.str === "" && o || y.str.length === u.length - 1 && r || Gp(u, y.str.length + 1) ? {
        pcIsSpace: !1,
        str: y.str + Te
      } : {
        pcIsSpace: !0,
        str: y.str + " "
      } : {
        pcIsSpace: O1(v),
        str: y.str + v
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, MC = (e, n) => {
      const o = be.fromDom(n), r = be.fromDom(e);
      return zc(r, "pre,code", Ct(Is, o));
    }, ea = (e, n) => rn(e) && Gl(e.data) && MC(e, n) === !1, NC = (e) => Vn(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), du = (e, n) => Do(e) && ea(e, n) === !1 || NC(e) || D1(e), D1 = Vp("data-mce-bookmark"), Ay = Vp("data-mce-bogus"), _m = ll("data-mce-bogus", "all"), Kl = (e, n) => {
      let o = 0;
      if (du(e, e))
        return !1;
      {
        let r = e.firstChild;
        if (!r)
          return !0;
        const c = new rr(r, e);
        do {
          if (n) {
            if (_m(r)) {
              r = c.next(!0);
              continue;
            }
            if (Ay(r)) {
              r = c.next();
              continue;
            }
          }
          if (Cr(r)) {
            o++, r = c.next();
            continue;
          }
          if (du(r, e))
            return !1;
          r = c.next();
        } while (r);
        return o <= 1;
      }
    }, ta = (e, n = !0) => Kl(e.dom, n), bg = (e) => e.nodeName.toLowerCase() === "span", Vk = (e, n) => Q(e) && (du(e, n) || Fi(be.fromDom(e))), zy = (e, n) => {
      const o = new rr(e, n).prev(!1), r = new rr(e, n).next(!1), c = rt(o) || Vk(o, n), u = rt(r) || Vk(r, n);
      return c && u;
    }, vg = (e) => bg(e) && e.getAttribute("data-mce-type") === "bookmark", Oy = (e, n) => rn(e) && e.data.length > 0 && zy(e, n), Dy = (e) => Vn(e) ? e.childNodes.length > 0 : !1, BC = (e) => Pn(e) || gc(e), Sf = (e, n, o) => {
      const r = o || n;
      if (Vn(n) && vg(n))
        return n;
      const c = n.childNodes;
      for (let u = c.length - 1; u >= 0; u--)
        Sf(e, c[u], r);
      if (Vn(n)) {
        const u = n.childNodes;
        u.length === 1 && vg(u[0]) && n.parentNode.insertBefore(u[0], n);
      }
      return !BC(n) && !du(n, r) && !Dy(n) && !Oy(n, r) && e.remove(n), n;
    }, Ry = it.makeMap, Wu = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, xf = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, kg = /[<>&\"\']/g, jk = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, Uk = {
      128: "\u20AC",
      130: "\u201A",
      131: "\u0192",
      132: "\u201E",
      133: "\u2026",
      134: "\u2020",
      135: "\u2021",
      136: "\u02C6",
      137: "\u2030",
      138: "\u0160",
      139: "\u2039",
      140: "\u0152",
      142: "\u017D",
      145: "\u2018",
      146: "\u2019",
      147: "\u201C",
      148: "\u201D",
      149: "\u2022",
      150: "\u2013",
      151: "\u2014",
      152: "\u02DC",
      153: "\u2122",
      154: "\u0161",
      155: "\u203A",
      156: "\u0153",
      158: "\u017E",
      159: "\u0178"
    }, Td = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, Wk = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, R1 = (e) => {
      const n = be.fromTag("div").dom;
      return n.innerHTML = e, n.textContent || n.innerText || e;
    }, Kp = (e, n) => {
      let o, r, c;
      const u = {};
      if (e) {
        for (e = e.split(","), n = n || 10, o = 0; o < e.length; o += 2)
          r = String.fromCharCode(parseInt(e[o], n)), Td[r] || (c = "&" + e[o + 1] + ";", u[r] = c, u[c] = r);
        return u;
      }
    }, Yp = Kp("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), Ts = (e, n) => e.replace(n ? Wu : xf, (o) => Td[o] || o), no = (e) => ("" + e).replace(kg, (n) => Td[n] || n), Zu = (e, n) => e.replace(n ? Wu : xf, (o) => o.length > 1 ? "&#" + ((o.charCodeAt(0) - 55296) * 1024 + (o.charCodeAt(1) - 56320) + 65536) + ";" : Td[o] || "&#" + o.charCodeAt(0) + ";"), Xp = (e, n, o) => (o = o || Yp, e.replace(n ? Wu : xf, (r) => Td[r] || o[r] || r)), Ls = {
      encodeRaw: Ts,
      encodeAllRaw: no,
      encodeNumeric: Zu,
      encodeNamed: Xp,
      getEncodeFunc: (e, n) => {
        const o = Kp(n) || Yp, r = (m, y) => m.replace(y ? Wu : xf, (v) => Td[v] !== void 0 ? Td[v] : o[v] !== void 0 ? o[v] : v.length > 1 ? "&#" + ((v.charCodeAt(0) - 55296) * 1024 + (v.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + v.charCodeAt(0) + ";"), c = (m, y) => Xp(m, y, o), u = Ry(e.replace(/\+/g, ","));
        return u.named && u.numeric ? r : u.named ? n ? c : Xp : u.numeric ? Zu : Ts;
      },
      decode: (e) => e.replace(jk, (n, o) => o ? (o.charAt(0).toLowerCase() === "x" ? o = parseInt(o.substr(1), 16) : o = parseInt(o, 10), o > 65535 ? (o -= 65536, String.fromCharCode(55296 + (o >> 10), 56320 + (o & 1023))) : Uk[o] || String.fromCharCode(o)) : Wk[n] || Yp[n] || R1(n))
    }, qu = {}, PC = {}, Tf = it.makeMap, dt = it.each, Jp = it.extend, Qp = it.explode, My = it.inArray, yc = (e, n) => (e = it.trim(e), e ? e.split(n || " ") : []), Ed = (e, n) => {
      const o = Tf(e, " ", Tf(e.toUpperCase(), " "));
      return Jp(o, n);
    }, Ny = (e) => Ed("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), Ad = (e) => {
      const n = {};
      let o, r, c, u, m, y;
      const v = (R, F = "", W = "") => {
        const K = yc(W), ee = yc(R);
        let J = ee.length;
        for (; J--; ) {
          const te = yc([
            o,
            F
          ].join(" "));
          n[ee[J]] = {
            attributes: Io(te, () => ({})),
            attributesOrder: te,
            children: Io(K, Pe(PC))
          };
        }
      }, x = (R, F) => {
        const W = yc(R), K = yc(F);
        let ee = W.length;
        for (; ee--; ) {
          const J = n[W[ee]];
          for (let te = 0, ve = K.length; te < ve; te++)
            J.attributes[K[te]] = {}, J.attributesOrder.push(K[te]);
        }
      };
      return qu[e] ? qu[e] : (o = "id accesskey class dir lang style tabindex title role", r = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", c = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4" && (o += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", r += " article aside details dialog figure main header footer hgroup section nav", c += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen"), e !== "html5-strict" && (o += " xml:lang", y = "acronym applet basefont big font strike tt", c = [
        c,
        y
      ].join(" "), dt(yc(y), (R) => {
        v(R, "", c);
      }), m = "center dir isindex noframes", r = [
        r,
        m
      ].join(" "), u = [
        r,
        c
      ].join(" "), dt(yc(m), (R) => {
        v(R, "", u);
      })), u = u || [
        r,
        c
      ].join(" "), v("html", "manifest", "head body"), v("head", "", "base command link meta noscript script style title"), v("title hr noscript br"), v("base", "href target"), v("link", "href rel media hreflang type sizes hreflang"), v("meta", "name http-equiv content charset"), v("style", "media type scoped"), v("script", "src async defer type charset"), v("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", u), v("address dt dd div caption", "", u), v("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", c), v("blockquote", "cite", u), v("ol", "reversed start type", "li"), v("ul", "", "li"), v("li", "value", u), v("dl", "", "dt dd"), v("a", "href target rel media hreflang type", c), v("q", "cite", c), v("ins del", "cite datetime", u), v("img", "src sizes srcset alt usemap ismap width height"), v("iframe", "src name width height", u), v("embed", "src type width height"), v("object", "data type typemustmatch name usemap form width height", [
        u,
        "param"
      ].join(" ")), v("param", "name value"), v("map", "name", [
        u,
        "area"
      ].join(" ")), v("area", "alt coords shape href target rel media hreflang type"), v("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), v("colgroup", "span", "col"), v("col", "span"), v("tbody thead tfoot", "", "tr"), v("tr", "", "td th"), v("td", "colspan rowspan headers", u), v("th", "colspan rowspan headers scope abbr", u), v("form", "accept-charset action autocomplete enctype method name novalidate target", u), v("fieldset", "disabled form name", [
        u,
        "legend"
      ].join(" ")), v("label", "form for", c), v("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), v("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? u : c), v("select", "disabled form multiple name required size", "option optgroup"), v("optgroup", "disabled label", "option"), v("option", "disabled label selected value"), v("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), v("menu", "type label", [
        u,
        "li"
      ].join(" ")), v("noscript", "", u), e !== "html4" && (v("wbr"), v("ruby", "", [
        c,
        "rt rp"
      ].join(" ")), v("figcaption", "", u), v("mark rt rp summary bdi", "", c), v("canvas", "width height", u), v("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        u,
        "track source"
      ].join(" ")), v("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        u,
        "track source"
      ].join(" ")), v("picture", "", "img source"), v("source", "src srcset type media sizes"), v("track", "kind src srclang label default"), v("datalist", "", [
        c,
        "option"
      ].join(" ")), v("article section nav aside main header footer", "", u), v("hgroup", "", "h1 h2 h3 h4 h5 h6"), v("figure", "", [
        u,
        "figcaption"
      ].join(" ")), v("time", "datetime", c), v("dialog", "open", u), v("command", "type label icon disabled checked radiogroup command"), v("output", "for form name", c), v("progress", "value max", c), v("meter", "value min max low high optimum", c), v("details", "open", [
        u,
        "summary"
      ].join(" ")), v("keygen", "autofocus challenge disabled form keytype name")), e !== "html5-strict" && (x("script", "language xml:space"), x("style", "xml:space"), x("object", "declare classid code codebase codetype archive standby align border hspace vspace"), x("embed", "align name hspace vspace"), x("param", "valuetype type"), x("a", "charset name rev shape coords"), x("br", "clear"), x("applet", "codebase archive code object alt name width height align hspace vspace"), x("img", "name longdesc align border hspace vspace"), x("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), x("font basefont", "size color face"), x("input", "usemap align"), x("select"), x("textarea"), x("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), x("ul", "type compact"), x("li", "type"), x("ol dl menu dir", "compact"), x("pre", "width xml:space"), x("hr", "align noshade size width"), x("isindex", "prompt"), x("table", "summary width frame rules cellspacing cellpadding align bgcolor"), x("col", "width align char charoff valign"), x("colgroup", "width align char charoff valign"), x("thead", "align char charoff valign"), x("tr", "align char charoff valign bgcolor"), x("th", "axis align char charoff valign nowrap bgcolor width height"), x("form", "accept"), x("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), x("tfoot", "align char charoff valign"), x("tbody", "align char charoff valign"), x("area", "nohref"), x("body", "background bgcolor text link vlink alink")), e !== "html4" && (x("input button select textarea", "autofocus"), x("input textarea", "placeholder"), x("a", "download"), x("link script img", "crossorigin"), x("img", "loading"), x("iframe", "sandbox seamless allowfullscreen loading")), e !== "html4" && X([
        n.video,
        n.audio
      ], (R) => {
        delete R.children.audio, delete R.children.video;
      }), dt(yc("a form meter progress dfn"), (R) => {
        n[R] && delete n[R].children[R];
      }), delete n.caption.children.table, delete n.script, qu[e] = n, n);
    }, N1 = (e, n) => {
      let o;
      return e && (o = {}, typeof e == "string" && (e = { "*": e }), dt(e, (r, c) => {
        o[c] = o[c.toUpperCase()] = n === "map" ? Tf(r, /[, ]/) : Qp(r, /[, ]/);
      })), o;
    }, pi = (e) => {
      var n;
      const o = {}, r = {};
      let c = [];
      const u = {}, m = {}, y = (po, eo, Vs) => {
        let Ws = e[po];
        return Ws ? Ws = Tf(Ws, /[, ]/, Tf(Ws.toUpperCase(), /[, ]/)) : (Ws = qu[po], Ws || (Ws = Ed(eo, Vs), qu[po] = Ws)), Ws;
      };
      e = e || {};
      const v = (n = e.schema) !== null && n !== void 0 ? n : "html5", x = Ad(v);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const R = N1(e.valid_styles), F = N1(e.invalid_styles, "map"), W = N1(e.valid_classes, "map"), K = y("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), ee = y("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), J = y("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), te = y("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), ve = "td th iframe video audio object script code", De = y("non_empty_elements", ve + " pre", J), Be = y("move_caret_before_on_enter_elements", ve + " table", J), qe = y("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), pt = y("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", qe), pn = y("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");
      dt("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (po) => {
        m[po] = new RegExp("</" + po + "[^>]*>", "gi");
      });
      const vt = (po) => new RegExp("^" + po.replace(/([?+*])/g, ".$1") + "$"), xt = (po) => {
        let eo, Vs, Ws, Ga, mr, bs, gr, yl, bl, Tc, tf, oi, Il, Ou, $p, Jf, Qf, si;
        const ky = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, Pp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, Du = /[*?+]/;
        if (po) {
          const nf = yc(po, ",");
          for (o["@"] && (Jf = o["@"].attributes, Qf = o["@"].attributesOrder), eo = 0, Vs = nf.length; eo < Vs; eo++)
            if (mr = ky.exec(nf[eo]), mr) {
              if (Ou = mr[1], bl = mr[2], $p = mr[3], yl = mr[5], oi = {}, Il = [], bs = {
                attributes: oi,
                attributesOrder: Il
              }, Ou === "#" && (bs.paddEmpty = !0), Ou === "-" && (bs.removeEmpty = !0), mr[4] === "!" && (bs.removeEmptyAttrs = !0), Jf && (Jt(Jf, (Fp, ou) => {
                oi[ou] = Fp;
              }), Il.push.apply(Il, Qf)), yl) {
                for (yl = yc(yl, "|"), Ws = 0, Ga = yl.length; Ws < Ga; Ws++)
                  if (mr = Pp.exec(yl[Ws]), mr) {
                    if (gr = {}, tf = mr[1], Tc = mr[2].replace(/[\\:]:/g, ":"), Ou = mr[3], si = mr[4], tf === "!" && (bs.attributesRequired = bs.attributesRequired || [], bs.attributesRequired.push(Tc), gr.required = !0), tf === "-") {
                      delete oi[Tc], Il.splice(My(Il, Tc), 1);
                      continue;
                    }
                    Ou && (Ou === "=" && (bs.attributesDefault = bs.attributesDefault || [], bs.attributesDefault.push({
                      name: Tc,
                      value: si
                    }), gr.defaultValue = si), Ou === "~" && (bs.attributesForced = bs.attributesForced || [], bs.attributesForced.push({
                      name: Tc,
                      value: si
                    }), gr.forcedValue = si), Ou === "<" && (gr.validValues = Tf(si, "?"))), Du.test(Tc) ? (bs.attributePatterns = bs.attributePatterns || [], gr.pattern = vt(Tc), bs.attributePatterns.push(gr)) : (oi[Tc] || Il.push(Tc), oi[Tc] = gr);
                  }
              }
              !Jf && bl === "@" && (Jf = oi, Qf = Il), $p && (bs.outputName = bl, o[$p] = bs), Du.test(bl) ? (bs.pattern = vt(bl), c.push(bs)) : o[bl] = bs;
            }
        }
      }, Zt = (po) => {
        c = [], X($e(o), (eo) => {
          delete o[eo];
        }), xt(po), dt(x, (eo, Vs) => {
          r[Vs] = eo.children;
        });
      }, Xt = (po) => {
        const eo = /^(~)?(.+)$/;
        po && (qu.text_block_elements = qu.block_elements = null, dt(yc(po, ","), (Vs) => {
          const Ws = eo.exec(Vs), Ga = Ws[1] === "~", mr = Ga ? "span" : "div", bs = Ws[2];
          if (r[bs] = r[mr], u[bs] = mr, De[bs.toUpperCase()] = {}, De[bs] = {}, Ga || (pt[bs.toUpperCase()] = {}, pt[bs] = {}), !o[bs]) {
            let gr = o[mr];
            gr = Jp({}, gr), delete gr.removeEmptyAttrs, delete gr.removeEmpty, o[bs] = gr;
          }
          dt(r, (gr, yl) => {
            gr[mr] && (r[yl] = gr = Jp({}, r[yl]), gr[bs] = gr[mr]);
          });
        }));
      }, Qn = (po) => {
        const eo = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        qu[v] = null, po && dt(yc(po, ","), (Vs) => {
          const Ws = eo.exec(Vs);
          let Ga, mr;
          Ws && (mr = Ws[1], mr ? Ga = r[Ws[2]] : Ga = r[Ws[2]] = { "#comment": {} }, Ga = r[Ws[2]], dt(yc(Ws[3], "|"), (bs) => {
            mr === "-" ? delete Ga[bs] : Ga[bs] = {};
          }));
        });
      }, En = (po) => {
        let eo = o[po], Vs;
        if (eo)
          return eo;
        for (Vs = c.length; Vs--; )
          if (eo = c[Vs], eo.pattern.test(po))
            return eo;
      };
      e.valid_elements ? Zt(e.valid_elements) : (dt(x, (po, eo) => {
        o[eo] = {
          attributes: po.attributes,
          attributesOrder: po.attributesOrder
        }, r[eo] = po.children;
      }), dt(yc("strong/b em/i"), (po) => {
        const eo = yc(po, "/");
        o[eo[1]].outputName = eo[0];
      }), dt(pn, (po, eo) => {
        o[eo] && (e.padd_empty_block_inline_children && (o[eo].paddInEmptyBlock = !0), o[eo].removeEmpty = !0);
      }), dt(yc("ol ul blockquote a table tbody"), (po) => {
        o[po] && (o[po].removeEmpty = !0);
      }), dt(yc("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), (po) => {
        o[po].paddEmpty = !0;
      }), dt(yc("span"), (po) => {
        o[po].removeEmptyAttrs = !0;
      })), Xt(e.custom_elements), Qn(e.valid_children), xt(e.extended_valid_elements), Qn("+ol[ul|ol],+ul[ul|ol]"), dt({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, (po, eo) => {
        o[eo] && (o[eo].parentsRequired = yc(po));
      }), e.invalid_elements && dt(Qp(e.invalid_elements), (po) => {
        o[po] && delete o[po];
      }), En("span") || xt("span[!data-mce-type|*]");
      const fn = Pe(R), As = Pe(F), Us = Pe(W), lr = Pe(te), qa = Pe(pt), Gt = Pe(qe), Hn = Pe(pn), ps = Pe(Object.seal(J)), ss = Pe(ee), ac = Pe(De), ln = Pe(Be), lo = Pe(K), zn = Pe(Object.seal(m)), nn = (po, eo) => {
        const Vs = r[po.toLowerCase()];
        return !!(Vs && Vs[eo.toLowerCase()]);
      }, is = (po, eo) => {
        let Vs, Ws;
        const Ga = En(po);
        if (Ga)
          if (eo) {
            if (Ga.attributes[eo])
              return !0;
            if (Vs = Ga.attributePatterns, Vs) {
              for (Ws = Vs.length; Ws--; )
                if (Vs[Ws].pattern.test(eo))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, _s = Pe(u);
      return {
        type: v,
        children: r,
        elements: o,
        getValidStyles: fn,
        getValidClasses: Us,
        getBlockElements: qa,
        getInvalidStyles: As,
        getVoidElements: ps,
        getTextBlockElements: Gt,
        getTextInlineElements: Hn,
        getBoolAttrs: lr,
        getElementRule: En,
        getSelfClosingElements: ss,
        getNonEmptyElements: ac,
        getMoveCaretBeforeOnEnterElements: ln,
        getWhitespaceElements: lo,
        getSpecialElements: zn,
        isValidChild: nn,
        isValid: is,
        getCustomElements: _s,
        addValidElements: xt,
        setValidElements: Zt,
        addCustomElements: Xt,
        addValidChildren: Qn
      };
    }, kr = (e, n) => {
      const o = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, r = /\s*([^:]+):\s*([^;]+);?/g, c = /\s+$/;
      let u;
      const m = {};
      let y, v;
      const x = km;
      e = e || {}, n && (y = n.getValidStyles(), v = n.getInvalidStyles());
      const R = (`\\" \\' \\; \\: ; : ` + x).split(" ");
      for (u = 0; u < R.length; u++)
        m[R[u]] = x + u, m[x + u] = R[u];
      const F = {
        parse: (W) => {
          const K = {};
          let ee, J, te, ve;
          const De = e.url_converter, Be = e.url_converter_scope || F, qe = (En, fn, As) => {
            const Us = K[En + "-top" + fn];
            if (!Us)
              return;
            const lr = K[En + "-right" + fn];
            if (!lr)
              return;
            const qa = K[En + "-bottom" + fn];
            if (!qa)
              return;
            const Gt = K[En + "-left" + fn];
            if (!Gt)
              return;
            const Hn = [
              Us,
              lr,
              qa,
              Gt
            ];
            for (u = Hn.length - 1; u-- && Hn[u] === Hn[u + 1]; )
              ;
            u > -1 && As || (K[En + fn] = u === -1 ? Hn[0] : Hn.join(" "), delete K[En + "-top" + fn], delete K[En + "-right" + fn], delete K[En + "-bottom" + fn], delete K[En + "-left" + fn]);
          }, pt = (En) => {
            let fn = K[En], As;
            if (!!fn) {
              for (fn = fn.split(" "), As = fn.length; As--; )
                if (fn[As] !== fn[0])
                  return !1;
              return K[En] = fn[0], !0;
            }
          }, pn = (En, fn, As, Us) => {
            !pt(fn) || !pt(As) || !pt(Us) || (K[En] = K[fn] + " " + K[As] + " " + K[Us], delete K[fn], delete K[As], delete K[Us]);
          }, vt = (En) => (ve = !0, m[En]), xt = (En, fn) => (ve && (En = En.replace(/\uFEFF[0-9]/g, (As) => m[As])), fn || (En = En.replace(/\\([\'\";:])/g, "$1")), En), Zt = (En) => String.fromCharCode(parseInt(En.slice(1), 16)), Xt = (En) => En.replace(/\\[0-9a-f]+/gi, Zt), Qn = (En, fn, As, Us, lr, qa) => {
            if (lr = lr || qa, lr)
              return lr = xt(lr), "'" + lr.replace(/\'/g, "\\'") + "'";
            if (fn = xt(fn || As || Us), !e.allow_script_urls) {
              const Gt = fn.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(Gt) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(Gt))
                return "";
            }
            return De && (fn = De.call(Be, fn, "style")), "url('" + fn.replace(/\'/g, "\\'") + "')";
          };
          if (W) {
            for (W = W.replace(/[\u0000-\u001F]/g, ""), W = W.replace(/\\[\"\';:\uFEFF]/g, vt).replace(/\"[^\"]+\"|\'[^\']+\'/g, (En) => En.replace(/[;:]/g, vt)); ee = r.exec(W); )
              if (r.lastIndex = ee.index + ee[0].length, J = ee[1].replace(c, "").toLowerCase(), te = ee[2].replace(c, ""), J && te) {
                if (J = Xt(J), te = Xt(te), J.indexOf(x) !== -1 || J.indexOf('"') !== -1 || !e.allow_script_urls && (J === "behavior" || /expression\s*\(|\/\*|\*\//.test(te)))
                  continue;
                J === "font-weight" && te === "700" ? te = "bold" : (J === "color" || J === "background-color") && (te = te.toLowerCase()), te = te.replace(o, Qn), K[J] = ve ? xt(te, !0) : te;
              }
            qe("border", "", !0), qe("border", "-width"), qe("border", "-color"), qe("border", "-style"), qe("padding", ""), qe("margin", ""), pn("border", "border-width", "border-style", "border-color"), K.border === "medium none" && delete K.border, K["border-image"] === "none" && delete K["border-image"];
          }
          return K;
        },
        serialize: (W, K) => {
          let ee = "";
          const J = (ve) => {
            let De;
            const Be = y[ve];
            if (Be)
              for (let qe = 0, pt = Be.length; qe < pt; qe++)
                ve = Be[qe], De = W[ve], De && (ee += (ee.length > 0 ? " " : "") + ve + ": " + De + ";");
          }, te = (ve, De) => {
            let Be = v["*"];
            return Be && Be[ve] ? !1 : (Be = v[De], !(Be && Be[ve]));
          };
          return K && y ? (J("*"), J(K)) : Jt(W, (ve, De) => {
            ve && (!v || te(De, K)) && (ee += (ee.length > 0 ? " " : "") + De + ": " + ve + ";");
          }), ee;
        }
      };
      return F;
    }, Hi = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, FC = (e) => e instanceof Event || wn(e.initEvent), zd = (e) => e.isDefaultPrevented === Xe || e.isDefaultPrevented === Mn, IC = (e) => lt(e.preventDefault) || FC(e), eh = (e, n) => {
      const o = n != null ? n : {};
      for (const r in e)
        Gn(Hi, r) || (o[r] = e[r]);
      return Q(o.composedPath) && (o.composedPath = () => e.composedPath()), o;
    }, Ef = (e, n, o, r) => {
      var c;
      const u = eh(n, r);
      return u.type = e, lt(u.target) && (u.target = (c = u.srcElement) !== null && c !== void 0 ? c : o), IC(n) && (u.preventDefault = () => {
        u.defaultPrevented = !0, u.isDefaultPrevented = Xe, wn(n.preventDefault) && n.preventDefault();
      }, u.stopPropagation = () => {
        u.cancelBubble = !0, u.isPropagationStopped = Xe, wn(n.stopPropagation) && n.stopPropagation();
      }, u.stopImmediatePropagation = () => {
        u.isImmediatePropagationStopped = Xe, u.stopPropagation();
      }, zd(u) || (u.isDefaultPrevented = u.defaultPrevented === !0 ? Xe : Mn, u.isPropagationStopped = u.cancelBubble === !0 ? Xe : Mn, u.isImmediatePropagationStopped = Mn)), u;
    }, B1 = "mce-data-", Gu = /^(?:mouse|contextmenu)|click/, $1 = (e, n, o, r) => {
      e.addEventListener ? e.addEventListener(n, o, r || !1) : e.attachEvent && e.attachEvent("on" + n, o);
    }, By = (e, n, o, r) => {
      e.removeEventListener ? e.removeEventListener(n, o, r || !1) : e.detachEvent && e.detachEvent("on" + n, o);
    }, Af = (e) => Q(e) && Gu.test(e.type), wg = (e, n) => {
      const o = Ef(e.type, e, document, n);
      if (Af(e) && rt(e.pageX) && !rt(e.clientX)) {
        const r = o.target.ownerDocument || document, c = r.documentElement, u = r.body, m = o;
        m.pageX = e.clientX + (c && c.scrollLeft || u && u.scrollLeft || 0) - (c && c.clientLeft || u && u.clientLeft || 0), m.pageY = e.clientY + (c && c.scrollTop || u && u.scrollTop || 0) - (c && c.clientTop || u && u.clientTop || 0);
      }
      return o;
    }, LC = (e, n, o) => {
      const r = e.document, c = { type: "ready" };
      if (o.domLoaded) {
        n(c);
        return;
      }
      const u = () => r.readyState === "complete" || r.readyState === "interactive" && r.body, m = () => {
        By(e, "DOMContentLoaded", m), By(e, "load", m), o.domLoaded || (o.domLoaded = !0, n(c)), e = null;
      };
      u() ? m() : $1(e, "DOMContentLoaded", m), o.domLoaded || $1(e, "load", m);
    };
    class fu {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = B1 + (+new Date()).toString(32), this.hasMouseEnterLeave = "onmouseenter" in document.documentElement, this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(n, o, r, c) {
        const u = this;
        let m, y, v, x, R, F, W;
        const K = window, ee = (te) => {
          u.executeHandlers(wg(te || K.event), m);
        };
        if (!n || n.nodeType === 3 || n.nodeType === 8)
          return;
        n[u.expando] ? m = n[u.expando] : (m = u.count++, n[u.expando] = m, u.events[m] = {}), c = c || n;
        const J = o.split(" ");
        for (v = J.length; v--; ) {
          if (x = J[v], F = ee, R = W = !1, x === "DOMContentLoaded" && (x = "ready"), u.domLoaded && x === "ready" && n.readyState === "complete") {
            r.call(c, wg({ type: x }));
            continue;
          }
          u.hasMouseEnterLeave || (R = u.mouseEnterLeave[x], R && (F = (te) => {
            const ve = te.currentTarget;
            let De = te.relatedTarget;
            if (De && ve.contains)
              De = ve.contains(De);
            else
              for (; De && De !== ve; )
                De = De.parentNode;
            De || (te = wg(te || K.event), te.type = te.type === "mouseout" ? "mouseleave" : "mouseenter", te.target = ve, u.executeHandlers(te, m));
          })), !u.hasFocusIn && (x === "focusin" || x === "focusout") && (W = !0, R = x === "focusin" ? "focus" : "blur", F = (te) => {
            te = wg(te || K.event), te.type = te.type === "focus" ? "focusin" : "focusout", u.executeHandlers(te, m);
          }), y = u.events[m][x], y ? x === "ready" && u.domLoaded ? r(wg({ type: x })) : y.push({
            func: r,
            scope: c
          }) : (u.events[m][x] = y = [{
            func: r,
            scope: c
          }], y.fakeName = R, y.capture = W, y.nativeHandler = F, x === "ready" ? LC(n, F, u) : $1(n, R || x, F, W));
        }
        return n = y = null, r;
      }
      unbind(n, o, r) {
        let c, u, m, y, v;
        if (!n || n.nodeType === 3 || n.nodeType === 8)
          return this;
        const x = n[this.expando];
        if (x) {
          if (v = this.events[x], o) {
            const R = o.split(" ");
            for (u = R.length; u--; )
              if (y = R[u], c = v[y], c) {
                if (r) {
                  for (m = c.length; m--; )
                    if (c[m].func === r) {
                      const F = c.nativeHandler, W = c.fakeName, K = c.capture;
                      c = c.slice(0, m).concat(c.slice(m + 1)), c.nativeHandler = F, c.fakeName = W, c.capture = K, v[y] = c;
                    }
                }
                (!r || c.length === 0) && (delete v[y], By(n, c.fakeName || y, c.nativeHandler, c.capture));
              }
          } else
            Jt(v, (R, F) => {
              By(n, R.fakeName || F, R.nativeHandler, R.capture);
            }), v = {};
          for (y in v)
            if (Gn(v, y))
              return this;
          delete this.events[x];
          try {
            delete n[this.expando];
          } catch {
            n[this.expando] = null;
          }
        }
        return this;
      }
      fire(n, o, r) {
        return this.dispatch(n, o, r);
      }
      dispatch(n, o, r) {
        let c;
        if (!n || n.nodeType === 3 || n.nodeType === 8)
          return this;
        const u = wg({
          type: o,
          target: n
        }, r);
        do
          c = n[this.expando], c && this.executeHandlers(u, c), n = n.parentNode || n.ownerDocument || n.defaultView || n.parentWindow;
        while (n && !u.isPropagationStopped());
        return this;
      }
      clean(n) {
        let o, r;
        if (!n || n.nodeType === 3 || n.nodeType === 8)
          return this;
        if (n[this.expando] && this.unbind(n), n.getElementsByTagName || (n = n.document), n && n.getElementsByTagName)
          for (this.unbind(n), r = n.getElementsByTagName("*"), o = r.length; o--; )
            n = r[o], n[this.expando] && this.unbind(n);
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(n) {
        return n && (n.preventDefault(), n.stopImmediatePropagation()), !1;
      }
      executeHandlers(n, o) {
        const r = this.events[o], c = r && r[n.type];
        if (c)
          for (let u = 0, m = c.length; u < m; u++) {
            const y = c[u];
            if (y && y.func.call(y.scope, n) === !1 && n.preventDefault(), n.isImmediatePropagationStopped())
              return;
          }
      }
    }
    fu.Event = new fu();
    const th = it.each, $n = it.grep, $y = "data-mce-style", nh = (e, n, o) => {
      lt(o) || o === "" ? $r(e, n) : ms(e, n, o);
    }, HC = (e, n, o) => {
      const r = n.keep_values, c = {
        set: (m, y, v) => {
          const x = be.fromDom(m);
          wn(n.url_converter) && Q(y) && (y = n.url_converter.call(n.url_converter_scope || o(), y, v, m[0]));
          const R = "data-mce-" + v;
          nh(x, R, y), nh(x, v, y);
        },
        get: (m, y) => {
          const v = be.fromDom(m);
          return Na(v, "data-mce-" + y) || Na(v, y);
        }
      }, u = {
        style: {
          set: (m, y) => {
            const v = be.fromDom(m);
            if (dn(y)) {
              Or(v, y);
              return;
            }
            r && nh(v, $y, y), $r(v, "style"), ie(y) && Or(v, e.parse(y));
          },
          get: (m) => {
            const y = be.fromDom(m), v = Na(y, $y) || Na(y, "style");
            return e.serialize(e.parse(v), An(y));
          }
        }
      };
      return r && (u.href = u.src = c), u;
    }, Zk = (e, n) => {
      const o = Na(n, "style"), r = e.serialize(e.parse(o), An(n));
      nh(n, $y, r);
    }, _g = (e, n) => {
      let o = 0, r, c;
      if (e)
        for (r = e.nodeType, e = e.previousSibling; e; e = e.previousSibling)
          c = e.nodeType, !(n && c === 3 && (c === r || !e.nodeValue.length)) && (o++, r = c);
      return o;
    }, Cg = it.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), Cm = (e) => e.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase()), Ks = (e, n = {}) => {
      const o = {}, r = window, c = {};
      let u = 0;
      const m = !0, y = !0, v = wd.forElement(be.fromDom(e), {
        contentCssCors: n.contentCssCors,
        referrerPolicy: n.referrerPolicy
      }), x = [], R = n.schema ? n.schema : pi({}), F = kr({
        url_converter: n.url_converter,
        url_converter_scope: n.url_converter_scope
      }, n.schema), W = n.ownEvents ? new fu() : fu.Event, K = R.getBlockElements(), ee = (xe) => ie(xe) ? Gn(K, xe) : Vn(xe) && Gn(K, xe.nodeName), J = (xe) => xe && e && ie(xe) ? e.getElementById(xe) : xe, te = (xe) => {
        const Ie = J(xe);
        return Q(Ie) ? be.fromDom(Ie) : null;
      }, ve = (xe, Ie, Tt) => {
        let kt;
        const Zn = te(xe);
        if (Q(Zn) && Oo(Zn)) {
          const Rs = Ik[Ie];
          Rs && Rs.get ? kt = Rs.get(Zn.dom, Ie) : kt = Na(Zn, Ie);
        }
        return Q(kt) ? kt : Tt != null ? Tt : "";
      }, De = (xe) => {
        const Ie = J(xe);
        return lt(Ie) ? [] : Ie.attributes;
      }, Be = (xe, Ie, Tt) => {
        ps(xe, (kt) => {
          if (Vn(kt)) {
            const Zn = be.fromDom(kt);
            Tt === "" && (Tt = null);
            const Rs = Na(Zn, Ie), Cs = Ik[Ie];
            Cs && Cs.set ? Cs.set(Zn.dom, Tt, Ie) : nh(Zn, Ie, Tt), Rs !== Tt && n.onSetAttrib && n.onSetAttrib({
              attrElm: Zn,
              attrName: Ie,
              attrValue: Tt
            });
          }
        });
      }, qe = (xe, Ie) => xe.cloneNode(Ie), pt = () => n.root_element || e.body, pn = (xe) => {
        const Ie = Hp(xe);
        return {
          x: Ie.x,
          y: Ie.y,
          w: Ie.width,
          h: Ie.height
        };
      }, vt = (xe, Ie) => dg(e.body, J(xe), Ie), xt = (xe, Ie, Tt) => {
        const kt = (Rs, Cs) => ie(Rs) ? Rs : ft(Rs) ? Gn(Cg, Cs) ? Rs + "" : Rs + "px" : ht(Rs, kt), Zn = (Rs, Cs, ri) => {
          const ud = Cm(Cs);
          lt(ri) || ri === "" ? Lp(Rs, ud) : ws(Rs, ud, kt(ri, ud));
        };
        ps(xe, (Rs) => {
          const Cs = be.fromDom(Rs);
          ie(Ie) ? Zn(Cs, Ie, Tt) : Jt(Ie, (ri, ud) => {
            Zn(Cs, ud, ri);
          }), n.update_styles && Zk(F, Cs);
        });
      }, Zt = (xe, Ie) => {
        xt(xe, Ie);
      }, Xt = (xe, Ie, Tt) => {
        const kt = J(xe);
        if (!(lt(kt) || !Vn(kt)))
          return Tt ? Gr(be.fromDom(kt), Cm(Ie)) : (Ie = Ie.replace(/-(\D)/g, (Zn, Rs) => Rs.toUpperCase()), Ie === "float" && (Ie = "cssFloat"), kt.style ? kt.style[Ie] : void 0);
      }, Qn = (xe) => {
        let Ie, Tt;
        const kt = J(xe);
        return Ie = Xt(kt, "width"), Tt = Xt(kt, "height"), Ie.indexOf("px") === -1 && (Ie = 0), Tt.indexOf("px") === -1 && (Tt = 0), {
          w: parseInt(Ie, 10) || kt.offsetWidth || kt.clientWidth,
          h: parseInt(Tt, 10) || kt.offsetHeight || kt.clientHeight
        };
      }, En = (xe) => {
        const Ie = J(xe), Tt = vt(Ie), kt = Qn(Ie);
        return {
          x: Tt.x,
          y: Tt.y,
          w: kt.w,
          h: kt.h
        };
      }, fn = (xe, Ie) => {
        if (!xe)
          return !1;
        const Tt = Re(xe) ? xe : [xe];
        return Oe(Tt, (kt) => El(be.fromDom(kt), Ie));
      }, As = (xe, Ie, Tt, kt) => {
        const Zn = [];
        let Rs, Cs = J(xe);
        for (kt = kt === void 0, Tt = Tt || (pt().nodeName !== "BODY" ? pt().parentNode : null), ie(Ie) && (Rs = Ie, Ie === "*" ? Ie = Vn : Ie = (ri) => fn(ri, Rs)); Cs && !(Cs === Tt || lt(Cs.nodeType) || gc(Cs) || Pn(Cs)); ) {
          if (!Ie || Ie(Cs))
            if (kt)
              Zn.push(Cs);
            else
              return [Cs];
          Cs = Cs.parentNode;
        }
        return kt ? Zn : null;
      }, Us = (xe, Ie, Tt) => {
        const kt = As(xe, Ie, Tt, !1);
        return kt && kt.length > 0 ? kt[0] : null;
      }, lr = (xe, Ie, Tt) => {
        let kt = Ie;
        if (xe) {
          for (ie(Ie) && (kt = (Zn) => fn(Zn, Ie)), xe = xe[Tt]; xe; xe = xe[Tt])
            if (wn(kt) && kt(xe))
              return xe;
        }
        return null;
      }, qa = (xe, Ie) => lr(xe, Ie, "nextSibling"), Gt = (xe, Ie) => lr(xe, Ie, "previousSibling"), Hn = (xe, Ie) => {
        var Tt, kt;
        const Zn = (kt = (Tt = J(Ie)) !== null && Tt !== void 0 ? Tt : n.root_element) !== null && kt !== void 0 ? kt : e;
        return Os(Zn.querySelectorAll(xe));
      }, ps = function(xe, Ie, Tt) {
        const kt = Tt != null ? Tt : this, Zn = ie(xe) ? J(xe) : xe;
        if (!Zn)
          return !1;
        if (Re(Zn) && (Zn.length || Zn.length === 0)) {
          const Rs = [];
          return th(Zn, (Cs, ri) => {
            Cs && Rs.push(Ie.call(kt, ie(Cs) ? J(Cs) : Cs, ri));
          }), Rs;
        } else
          return Ie.call(kt, Zn);
      }, ss = (xe, Ie) => {
        ps(xe, (Tt) => {
          Jt(Ie, (kt, Zn) => {
            Be(Tt, Zn, kt);
          });
        });
      }, ac = (xe, Ie) => {
        ps(xe, (Tt) => {
          const kt = be.fromDom(Tt);
          mf(kt, Ie);
        });
      }, ln = (xe, Ie, Tt, kt, Zn) => ps(xe, (Rs) => {
        const Cs = ie(Ie) ? e.createElement(Ie) : Ie;
        return Q(Tt) && ss(Cs, Tt), kt && (!ie(kt) && kt.nodeType ? Cs.appendChild(kt) : ie(kt) && ac(Cs, kt)), Zn ? Cs : Rs.appendChild(Cs);
      }), lo = (xe, Ie, Tt) => ln(e.createElement(xe), xe, Ie, Tt, !0), zn = Ls.decode, nn = Ls.encodeAllRaw, is = (xe, Ie, Tt = "") => {
        let kt = "", Zn;
        kt += "<" + xe;
        for (Zn in Ie)
          er(Ie, Zn) && (kt += " " + Zn + '="' + nn(Ie[Zn]) + '"');
        return fs(Tt) && Gn(R.getVoidElements(), xe) ? kt + " />" : kt + ">" + Tt + "</" + xe + ">";
      }, _s = (xe) => {
        let Ie;
        const Tt = e.createElement("div"), kt = e.createDocumentFragment();
        for (kt.appendChild(Tt), xe && (Tt.innerHTML = xe); Ie = Tt.firstChild; )
          kt.appendChild(Ie);
        return kt.removeChild(Tt), kt;
      }, po = (xe, Ie) => ps(xe, (Tt) => {
        const kt = be.fromDom(Tt);
        return Ie && X(Qr(kt), (Zn) => {
          Ps(Zn) && Zn.dom.length === 0 ? Gs(Zn) : Mr(kt, Zn);
        }), Gs(kt), kt.dom;
      }), eo = (xe) => ps(xe, (Ie) => {
        const Tt = Ie.attributes;
        for (let kt = Tt.length - 1; kt >= 0; kt--)
          Ie.removeAttributeNode(Tt.item(kt));
      }), Vs = (xe) => F.parse(xe), Ws = (xe, Ie) => F.serialize(xe, Ie), Ga = (xe) => {
        let Ie, Tt;
        if (nm !== Ks.DOM && e === document) {
          if (o[xe])
            return;
          o[xe] = !0;
        }
        Tt = e.getElementById("mceDefaultStyles"), Tt || (Tt = e.createElement("style"), Tt.id = "mceDefaultStyles", Tt.type = "text/css", Ie = e.getElementsByTagName("head")[0], Ie.firstChild ? Ie.insertBefore(Tt, Ie.firstChild) : Ie.appendChild(Tt)), Tt.styleSheet ? Tt.styleSheet.cssText += xe : Tt.appendChild(e.createTextNode(xe));
      }, mr = (xe) => {
        xe || (xe = ""), X(xe.split(","), (Ie) => {
          c[Ie] = !0, v.load(Ie).catch(Se);
        });
      }, bs = (xe, Ie, Tt) => {
        ps(xe, (kt) => {
          if (Vn(kt)) {
            const Zn = be.fromDom(kt), Rs = Ie.split(" ");
            X(Rs, (Cs) => {
              Q(Tt) ? (Tt ? jl : Nu)(Zn, Cs) : fd(Zn, Cs);
            });
          }
        });
      }, gr = (xe, Ie) => {
        bs(xe, Ie, !0);
      }, yl = (xe, Ie) => {
        bs(xe, Ie, !1);
      }, bl = (xe, Ie) => {
        const Tt = te(xe), kt = Ie.split(" ");
        return ds(kt, (Zn) => Bu(Tt, Zn));
      }, Tc = (xe) => {
        ps(xe, (Ie) => Lp(be.fromDom(Ie), "display"));
      }, tf = (xe) => {
        ps(xe, (Ie) => ws(be.fromDom(Ie), "display", "none"));
      }, oi = (xe) => {
        const Ie = te(xe);
        return hs(gd(Ie, "display"), "none");
      }, Il = (xe) => (xe || "mce_") + u++, Ou = (xe) => {
        const Ie = te(xe);
        return Vn(Ie.dom) ? Ie.dom.outerHTML : dm(Ie);
      }, $p = (xe, Ie) => {
        ps(xe, (Tt) => {
          Vn(Tt) && (Tt.outerHTML = Ie);
        });
      }, Jf = (xe, Ie) => {
        const Tt = J(Ie);
        return ps(xe, (kt) => {
          const Zn = Tt.parentNode, Rs = Tt.nextSibling;
          return Rs ? Zn.insertBefore(kt, Rs) : Zn.appendChild(kt), kt;
        });
      }, Qf = (xe, Ie, Tt) => ps(Ie, (kt) => (Re(kt) && (xe = xe.cloneNode(!0)), Tt && th($n(kt.childNodes), (Zn) => {
        xe.appendChild(Zn);
      }), kt.parentNode.replaceChild(xe, kt))), si = (xe, Ie) => {
        let Tt;
        return xe.nodeName !== Ie.toUpperCase() && (Tt = lo(Ie), th(De(xe), (kt) => {
          Be(Tt, kt.nodeName, ve(xe, kt.nodeName));
        }), Qf(Tt, xe, !0)), Tt || xe;
      }, ky = (xe, Ie) => {
        let Tt = xe, kt;
        for (; Tt; ) {
          for (kt = Ie; kt && Tt !== kt; )
            kt = kt.parentNode;
          if (Tt === kt)
            break;
          Tt = Tt.parentNode;
        }
        return !Tt && xe.ownerDocument ? xe.ownerDocument.documentElement : Tt;
      }, Pp = (xe) => {
        if (Vn(xe)) {
          const Ie = xe.nodeName.toLowerCase() === "a" && !ve(xe, "href") && ve(xe, "id");
          if (ve(xe, "name") || ve(xe, "data-mce-bookmark") || Ie)
            return !0;
        }
        return !1;
      }, Du = (xe, Ie) => {
        let Tt, kt, Zn = 0;
        if (Pp(xe))
          return !1;
        if (xe = xe.firstChild, xe) {
          const Rs = new rr(xe, xe.parentNode), Cs = R ? R.getWhitespaceElements() : {};
          Ie = Ie || (R ? R.getNonEmptyElements() : null);
          do {
            if (Tt = xe.nodeType, Vn(xe)) {
              const ri = xe.getAttribute("data-mce-bogus");
              if (ri) {
                xe = Rs.next(ri === "all");
                continue;
              }
              if (kt = xe.nodeName.toLowerCase(), Ie && Ie[kt]) {
                if (kt === "br") {
                  Zn++, xe = Rs.next();
                  continue;
                }
                return !1;
              }
              if (Pp(xe))
                return !1;
            }
            if (Tt === 8 || Tt === 3 && !Gl(xe.nodeValue) || Tt === 3 && xe.parentNode && Cs[xe.parentNode.nodeName] && Gl(xe.nodeValue))
              return !1;
            xe = Rs.next();
          } while (xe);
        }
        return Zn <= 1;
      }, nf = () => e.createRange(), Fp = (xe, Ie, Tt) => {
        let kt = nf(), Zn, Rs, Cs;
        if (xe && Ie)
          return kt.setStart(xe.parentNode, _g(xe)), kt.setEnd(Ie.parentNode, _g(Ie)), Zn = kt.extractContents(), kt = nf(), kt.setStart(Ie.parentNode, _g(Ie) + 1), kt.setEnd(xe.parentNode, _g(xe) + 1), Rs = kt.extractContents(), Cs = xe.parentNode, Cs.insertBefore(Sf(nm, Zn), xe), Tt ? Cs.insertBefore(Tt, xe) : Cs.insertBefore(Ie, xe), Cs.insertBefore(Sf(nm, Rs), xe), po(xe), Tt || Ie;
      }, ou = (xe, Ie, Tt, kt) => {
        if (Re(xe)) {
          let Zn = xe.length;
          const Rs = [];
          for (; Zn--; )
            Rs[Zn] = ou(xe[Zn], Ie, Tt, kt);
          return Rs;
        } else
          return n.collect && (xe === e || xe === r) && x.push([
            xe,
            Ie,
            Tt,
            kt
          ]), W.bind(xe, Ie, Tt, kt || nm);
      }, S1 = (xe, Ie, Tt) => {
        if (Re(xe)) {
          let kt = xe.length;
          const Zn = [];
          for (; kt--; )
            Zn[kt] = S1(xe[kt], Ie, Tt);
          return Zn;
        } else {
          if (x.length > 0 && (xe === e || xe === r)) {
            let kt = x.length;
            for (; kt--; ) {
              const Zn = x[kt];
              xe === Zn[0] && (!Ie || Ie === Zn[1]) && (!Tt || Tt === Zn[2]) && W.unbind(Zn[0], Zn[1], Zn[2]);
            }
          }
          return W.unbind(xe, Ie, Tt);
        }
      }, VE = (xe, Ie, Tt) => W.dispatch(xe, Ie, Tt), em = (xe, Ie, Tt) => W.dispatch(xe, Ie, Tt), tm = (xe) => {
        if (xe && Vn(xe)) {
          const Ie = xe.getAttribute("data-mce-contenteditable");
          return Ie && Ie !== "inherit" ? Ie : xe.contentEditable !== "inherit" ? xe.contentEditable : null;
        } else
          return null;
      }, nm = {
        doc: e,
        settings: n,
        win: r,
        files: c,
        stdMode: m,
        boxModel: y,
        styleSheetLoader: v,
        boundEvents: x,
        styles: F,
        schema: R,
        events: W,
        isBlock: ee,
        root: null,
        clone: qe,
        getRoot: pt,
        getViewPort: pn,
        getRect: En,
        getSize: Qn,
        getParent: Us,
        getParents: As,
        get: J,
        getNext: qa,
        getPrev: Gt,
        select: Hn,
        is: fn,
        add: ln,
        create: lo,
        createHTML: is,
        createFragment: _s,
        remove: po,
        setStyle: xt,
        getStyle: Xt,
        setStyles: Zt,
        removeAllAttribs: eo,
        setAttrib: Be,
        setAttribs: ss,
        getAttrib: ve,
        getPos: vt,
        parseStyle: Vs,
        serializeStyle: Ws,
        addStyle: Ga,
        loadCSS: mr,
        addClass: gr,
        removeClass: yl,
        hasClass: bl,
        toggleClass: bs,
        show: Tc,
        hide: tf,
        isHidden: oi,
        uniqueId: Il,
        setHTML: ac,
        getOuterHTML: Ou,
        setOuterHTML: $p,
        decode: zn,
        encode: nn,
        insertAfter: Jf,
        replace: Qf,
        rename: si,
        findCommonAncestor: ky,
        run: ps,
        getAttribs: De,
        isEmpty: Du,
        createRng: nf,
        nodeIndex: _g,
        split: Fp,
        bind: ou,
        unbind: S1,
        fire: em,
        dispatch: VE,
        getContentEditable: tm,
        getContentEditableParent: (xe) => {
          const Ie = pt();
          let Tt = null;
          for (; xe && xe !== Ie && (Tt = tm(xe), Tt === null); xe = xe.parentNode)
            ;
          return Tt;
        },
        destroy: () => {
          if (x.length > 0) {
            let xe = x.length;
            for (; xe--; ) {
              const Ie = x[xe];
              W.unbind(Ie[0], Ie[1], Ie[2]);
            }
          }
          Jt(c, (xe, Ie) => {
            v.unload(Ie), delete c[Ie];
          });
        },
        isChildOf: (xe, Ie) => xe === Ie || Ie.contains(xe),
        dumpRng: (xe) => "startContainer: " + xe.startContainer.nodeName + ", startOffset: " + xe.startOffset + ", endContainer: " + xe.endContainer.nodeName + ", endOffset: " + xe.endOffset
      }, Ik = HC(F, n, Pe(nm));
      return nm;
    };
    Ks.DOM = Ks(document), Ks.nodeIndex = _g;
    const Py = Ks.DOM, Fy = 0, qk = 1, Sg = 2, xg = 3;
    class Yl {
      constructor(n = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = n;
      }
      _setReferrerPolicy(n) {
        this.settings.referrerPolicy = n;
      }
      loadScript(n) {
        return new Promise((o, r) => {
          const c = Py;
          let u;
          const m = () => {
            c.remove(x), u && (u.onerror = u.onload = u = null);
          }, y = () => {
            m(), o();
          }, v = () => {
            m(), r("Failed to load script: " + n);
          }, x = c.uniqueId();
          u = document.createElement("script"), u.id = x, u.type = "text/javascript", u.src = it._addCacheSuffix(n), this.settings.referrerPolicy && c.setAttrib(u, "referrerpolicy", this.settings.referrerPolicy), u.onload = y, u.onerror = v, (document.getElementsByTagName("head")[0] || document.body).appendChild(u);
        });
      }
      isDone(n) {
        return this.states[n] === Sg;
      }
      markDone(n) {
        this.states[n] = Sg;
      }
      add(n) {
        const o = this;
        return o.queue.push(n), o.states[n] === void 0 && (o.states[n] = Fy), new Promise((c, u) => {
          o.scriptLoadedCallbacks[n] || (o.scriptLoadedCallbacks[n] = []), o.scriptLoadedCallbacks[n].push({
            resolve: c,
            reject: u
          });
        });
      }
      load(n) {
        return this.add(n);
      }
      remove(n) {
        delete this.states[n], delete this.scriptLoadedCallbacks[n];
      }
      loadQueue() {
        const n = this.queue;
        return this.queue = [], this.loadScripts(n);
      }
      loadScripts(n) {
        const o = this, r = (v, x) => {
          Xo(o.scriptLoadedCallbacks, x).each((R) => {
            X(R, (F) => F[v](x));
          }), delete o.scriptLoadedCallbacks[x];
        }, c = (v) => {
          const x = ue(v, (R) => R.status === "rejected");
          return x.length > 0 ? Promise.reject(yn(x, ({ reason: R }) => Re(R) ? R : [R])) : Promise.resolve();
        }, u = (v) => Promise.allSettled(ae(v, (x) => o.states[x] === Sg ? (r("resolve", x), Promise.resolve()) : o.states[x] === xg ? (r("reject", x), Promise.reject(x)) : (o.states[x] = qk, o.loadScript(x).then(() => {
          o.states[x] = Sg, r("resolve", x);
          const R = o.queue;
          if (R.length > 0)
            return o.queue = [], u(R).then(c);
        }, () => (o.states[x] = xg, r("reject", x), Promise.reject(x)))))), m = (v) => (o.loading = !0, u(v).then((x) => {
          o.loading = !1;
          const R = o.queueLoadedCallbacks.shift();
          return O.from(R).each(Dn), c(x);
        })), y = ir(n);
        return o.loading ? new Promise((v, x) => {
          o.queueLoadedCallbacks.push(() => m(y).then(v, x));
        }) : m(y);
      }
    }
    Yl.ScriptLoader = new Yl();
    const ka = (e) => {
      let n = e;
      return {
        get: () => n,
        set: (c) => {
          n = c;
        }
      };
    }, Iy = (e) => dn(e) && Gn(e, "raw"), P1 = (e) => Re(e) && e.length > 1, Sm = {}, Ly = ka("en"), oh = () => Xo(Sm, Ly.get()), Dl = {
      getData: () => ht(Sm, (e) => ({ ...e })),
      setCode: (e) => {
        e && Ly.set(e);
      },
      getCode: () => Ly.get(),
      add: (e, n) => {
        let o = Sm[e];
        o || (Sm[e] = o = {}), Jt(n, (r, c) => {
          o[c.toLowerCase()] = r;
        });
      },
      translate: (e) => {
        const n = oh().getOr({}), o = (m) => wn(m) ? Object.prototype.toString.call(m) : r(m) ? "" : "" + m, r = (m) => m === "" || m === null || m === void 0, c = (m) => {
          const y = o(m);
          return Xo(n, y.toLowerCase()).map(o).getOr(y);
        }, u = (m) => m.replace(/{context:\w+}$/, "");
        if (r(e))
          return "";
        if (Iy(e))
          return o(e.raw);
        if (P1(e)) {
          const m = e.slice(1), y = c(e[0]).replace(/\{([0-9]+)\}/g, (v, x) => Gn(m, x) ? o(m[x]) : v);
          return u(y);
        }
        return u(c(e));
      },
      isRtl: () => oh().bind((e) => Xo(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => Gn(Sm, e)
    }, Dc = () => {
      const e = [], n = {}, o = {}, r = [], c = (J, te) => {
        const ve = ue(r, (De) => De.name === J && De.state === te);
        X(ve, (De) => De.resolve());
      }, u = (J) => Gn(n, J), m = (J) => Gn(o, J), y = (J) => {
        if (o[J])
          return o[J].instance;
      }, v = (J, te) => {
        const ve = Dl.getCode(), De = "," + (te || "") + ",";
        !ve || te && De.indexOf("," + ve + ",") === -1 || Yl.ScriptLoader.add(n[J] + "/langs/" + ve + ".js");
      }, x = (J, te) => {
        Dc.languageLoad !== !1 && (u(J) ? v(J, te) : ee(J, "loaded").then(() => v(J, te)));
      }, R = (J, te) => (e.push(te), o[J] = { instance: te }, c(J, "added"), te), F = (J) => {
        delete n[J], delete o[J];
      }, W = (J, te) => ie(te) ? ie(J) ? {
        prefix: "",
        resource: te,
        suffix: ""
      } : {
        prefix: J.prefix,
        resource: te,
        suffix: J.suffix
      } : te, K = (J, te) => {
        if (n[J])
          return Promise.resolve();
        let ve = ie(te) ? te : te.prefix + te.resource + te.suffix;
        ve.indexOf("/") !== 0 && ve.indexOf("://") === -1 && (ve = Dc.baseURL + "/" + ve), n[J] = ve.substring(0, ve.lastIndexOf("/"));
        const De = () => (c(J, "loaded"), Promise.resolve());
        return o[J] ? De() : Yl.ScriptLoader.add(ve).then(De);
      }, ee = (J, te = "added") => te === "added" && m(J) || te === "loaded" && u(J) ? Promise.resolve() : new Promise((ve) => {
        r.push({
          name: J,
          state: te,
          resolve: ve
        });
      });
      return {
        items: e,
        urls: n,
        lookup: o,
        get: y,
        requireLangPack: x,
        add: R,
        remove: F,
        createUrl: W,
        load: K,
        waitFor: ee
      };
    };
    Dc.languageLoad = !0, Dc.baseURL = "", Dc.PluginManager = Dc(), Dc.ThemeManager = Dc(), Dc.ModelManager = Dc();
    const Gk = (e) => {
      const n = ka(O.none()), o = () => n.get().each(e);
      return {
        clear: () => {
          o(), n.set(O.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (y) => {
          o(), n.set(O.some(y));
        }
      };
    }, Od = () => {
      const e = Gk(Se);
      return {
        ...e,
        on: (o) => e.get().each(o)
      };
    }, zf = (e, n) => {
      let o = null;
      return {
        cancel: () => {
          oe(o) || (clearTimeout(o), o = null);
        },
        throttle: (...u) => {
          oe(o) && (o = setTimeout(() => {
            o = null, e.apply(null, u);
          }, n));
        }
      };
    }, Hy = (e, n) => {
      let o = null;
      const r = () => {
        oe(o) || (clearTimeout(o), o = null);
      };
      return {
        cancel: r,
        throttle: (...u) => {
          r(), o = setTimeout(() => {
            o = null, e.apply(null, u);
          }, n);
        }
      };
    }, xm = Pe("mce-annotation"), Tm = Pe("data-mce-annotation"), Tg = Pe("data-mce-annotation-uid"), sh = Pe("data-mce-annotation-active"), rh = Pe("data-mce-annotation-classes"), Eg = Pe("data-mce-annotation-attrs"), Kk = (e) => (n) => Is(n, e), Yk = (e, n) => {
      const o = e.selection.getRng(), r = be.fromDom(o.startContainer), c = be.fromDom(e.getBody()), u = n.fold(() => "." + xm(), (x) => `[${Tm()}="${x}"]`), m = au(r, o.startOffset).getOr(r), y = Js(m, u, Kk(c)), v = (x, R) => Ni(x, R) ? O.some(Na(x, R)) : O.none();
      return y.bind((x) => v(x, `${Tg()}`).bind((R) => v(x, `${Tm()}`).map((F) => {
        const W = ch(e, R);
        return {
          uid: R,
          name: F,
          elements: W
        };
      })));
    }, ah = (e) => Oo(e) && Bu(e, xm()), Of = (e, n) => Ni(e, "data-mce-bogus") || zc(e, '[data-mce-bogus="all"]', Kk(n)), ch = (e, n) => {
      const o = be.fromDom(e.getBody()), r = ia(o, `[${Tg()}="${n}"]`);
      return ue(r, (c) => !Of(c, o));
    }, Vy = (e, n) => {
      const o = be.fromDom(e.getBody()), r = ia(o, `[${Tm()}="${n}"]`), c = {};
      return X(r, (u) => {
        if (!Of(u, o)) {
          const m = Na(u, Tg()), y = Xo(c, m).getOr([]);
          c[m] = y.concat([u]);
        }
      }), c;
    }, F1 = (e, n) => {
      const o = ka({}), r = () => ({
        listeners: [],
        previous: Od()
      }), c = (F, W) => {
        u(F, (K) => (W(K), K));
      }, u = (F, W) => {
        const K = o.get(), ee = Xo(K, F).getOrThunk(r), J = W(ee);
        K[F] = J, o.set(K);
      }, m = (F, W, K) => {
        c(F, (ee) => {
          X(ee.listeners, (J) => J(!0, F, {
            uid: W,
            nodes: ae(K, (te) => te.dom)
          }));
        });
      }, y = (F) => {
        c(F, (W) => {
          X(W.listeners, (K) => K(!1, F));
        });
      }, v = (F, W) => {
        X(ch(e, F), (K) => {
          W ? ms(K, sh(), "true") : $r(K, sh());
        });
      }, x = Hy(() => {
        const F = ro(n.getNames());
        X(F, (W) => {
          u(W, (K) => {
            const ee = K.previous.get();
            return Yk(e, O.some(W)).fold(() => {
              ee.each((J) => {
                y(W), K.previous.clear(), v(J, !1);
              });
            }, ({ uid: J, name: te, elements: ve }) => {
              hs(ee, J) || (ee.each((De) => v(De, !1)), m(te, J, ve), K.previous.set(J), v(J, !0));
            }), {
              previous: K.previous,
              listeners: K.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        x.cancel();
      }), e.on("NodeChange", () => {
        x.throttle();
      }), { addListener: (F, W) => {
        u(F, (K) => ({
          previous: K.previous,
          listeners: K.listeners.concat([W])
        }));
      } };
    }, nc = (e, n) => {
      const o = Tm(), r = (u) => O.from(u.attr(o)).bind(n.lookup), c = (u) => {
        var m, y;
        u.attr(Tg(), null), u.attr(Tm(), null), u.attr(sh(), null);
        const v = O.from(u.attr(Eg())).map((W) => W.split(",")).getOr([]), x = O.from(u.attr(rh())).map((W) => W.split(",")).getOr([]);
        X(v, (W) => u.attr(W, null));
        const R = (y = (m = u.attr("class")) === null || m === void 0 ? void 0 : m.split(" ")) !== null && y !== void 0 ? y : [], F = mn(R, [xm()].concat(x));
        u.attr("class", F.length > 0 ? F.join(" ") : null), u.attr(rh(), null), u.attr(Eg(), null);
      };
      e.serializer.addTempAttr(sh()), e.serializer.addAttributeFilter(o, (u) => {
        for (const m of u)
          r(m).each((y) => {
            y.persistent === !1 && (m.name === "span" ? m.unwrap() : c(m));
          });
      });
    }, WC = () => {
      const e = {};
      return {
        register: (c, u) => {
          e[c] = {
            name: c,
            settings: u
          };
        },
        lookup: (c) => Xo(e, c).map((u) => u.settings),
        getNames: () => $e(e)
      };
    };
    let Ag = 0;
    const Xk = (e) => {
      const o = new Date().getTime(), r = Math.floor(Math.random() * 1e9);
      return Ag++, e + "_" + r + Ag + String(o);
    }, ZC = (e, n) => {
      X(n, (o) => {
        jl(e, o);
      });
    }, hi = (e, n) => {
      X(n, (o) => {
        Nu(e, o);
      });
    }, mu = (e, n) => be.fromDom(e.dom.cloneNode(n)), zg = (e) => mu(e, !1), I1 = (e) => mu(e, !0), Ea = (e, n) => {
      const o = be.fromTag(n), r = Sa(e);
      return ur(o, r), o;
    }, qC = (e, n) => {
      const o = Ea(e, n);
      cl(e, o);
      const r = Qr(e);
      return Fu(o, r), Gs(e), o;
    }, Yr = (e, n, o = Mn) => {
      const r = new rr(e, n), c = (u) => {
        let m;
        do
          m = r[u]();
        while (m && !rn(m) && !o(m));
        return O.from(m).filter(rn);
      };
      return {
        current: () => O.from(r.current()).filter(rn),
        next: () => c("next"),
        prev: () => c("prev"),
        prev2: () => c("prev2")
      };
    }, oc = (e, n) => {
      const o = n || ((m) => e.isBlock(m) || Cr(m) || Dr(m)), r = (m, y, v, x) => {
        if (rn(m)) {
          const R = x(m, y, m.data);
          if (R !== -1)
            return O.some({
              container: m,
              offset: R
            });
        }
        return v().bind((R) => r(R.container, R.offset, v, x));
      };
      return {
        backwards: (m, y, v, x) => {
          const R = Yr(m, x, o);
          return r(m, y, () => R.prev().map((F) => ({
            container: F,
            offset: F.length
          })), v).getOrNull();
        },
        forwards: (m, y, v, x) => {
          const R = Yr(m, x, o);
          return r(m, y, () => R.next().map((F) => ({
            container: F,
            offset: 0
          })), v).getOrNull();
        }
      };
    }, ji = Math.round, qc = (e) => e ? {
      left: ji(e.left),
      top: ji(e.top),
      bottom: ji(e.bottom),
      right: ji(e.right),
      width: ji(e.width),
      height: ji(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, Jk = (e, n) => (e = qc(e), n || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), Qk = (e, n) => e.left === n.left && e.top === n.top && e.bottom === n.bottom && e.right === n.right, L1 = (e, n, o) => e >= 0 && e <= Math.min(n.height, o.height) / 2, Ui = (e, n) => {
      const o = Math.min(n.height / 2, e.height / 2);
      return e.bottom - o < n.top ? !0 : e.top > n.bottom ? !1 : L1(n.top - e.bottom, e, n);
    }, yi = (e, n) => e.top > n.bottom ? !0 : e.bottom < n.top ? !1 : L1(n.bottom - e.top, e, n), GC = (e, n, o) => n >= e.left && n <= e.right && o >= e.top && o <= e.bottom, H1 = (e) => Ht(e, (n, o) => n.fold(() => O.some(o), (r) => {
      const c = Math.min(o.left, r.left), u = Math.min(o.top, r.top), m = Math.max(o.right, r.right), y = Math.max(o.bottom, r.bottom);
      return O.some({
        top: u,
        right: m,
        bottom: y,
        left: c,
        width: m - c,
        height: y - u
      });
    }), O.none()), jy = (e, n, o) => {
      const r = Math.max(Math.min(n, e.left + e.width), e.left), c = Math.max(Math.min(o, e.top + e.height), e.top);
      return Math.sqrt((n - r) * (n - r) + (o - c) * (o - c));
    }, Uy = (e, n) => Math.max(0, Math.min(e.bottom, n.bottom) - Math.max(e.top, n.top)), KC = (e, n, o) => Math.min(Math.max(e, n), o), Wy = (e) => {
      const n = e.startContainer, o = e.startOffset;
      return n === e.endContainer && n.hasChildNodes() && e.endOffset === o + 1 ? n.childNodes[o] : null;
    }, Dd = (e, n) => {
      if (Vn(e) && e.hasChildNodes()) {
        const o = e.childNodes, r = KC(n, 0, o.length - 1);
        return o[r];
      } else
        return e;
    }, lh = (e, n) => {
      if (!(n < 0 && Vn(e) && e.hasChildNodes()))
        return Dd(e, n);
    }, YC = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"), ew = (e) => typeof e == "string" && e.charCodeAt(0) >= 768 && YC.test(e), XC = (...e) => (n) => {
      for (let o = 0; o < e.length; o++)
        if (e[o](n))
          return !0;
      return !1;
    }, tw = (...e) => (n) => {
      for (let o = 0; o < e.length; o++)
        if (!e[o](n))
          return !1;
      return !0;
    }, nw = Vn, ow = Do, V1 = yf("display", "block table"), JC = yf("float", "left right"), Og = tw(nw, ow, _o(JC)), QC = _o(yf("white-space", "pre pre-line pre-wrap")), Dg = rn, j1 = Cr, wa = Ks.nodeIndex, ih = lh, U1 = (e) => "createRange" in e ? e.createRange() : Ks.DOM.createRng(), Zy = (e) => e && /[\r\n\t ]/.test(e), qy = (e) => !!e.setStart && !!e.setEnd, bc = (e) => {
      const n = e.startContainer, o = e.startOffset;
      if (Zy(e.toString()) && QC(n.parentNode) && rn(n)) {
        const r = n.data;
        if (Zy(r[o - 1]) || Zy(r[o + 1]))
          return !0;
      }
      return !1;
    }, bi = (e) => {
      const n = e.ownerDocument, o = U1(n), r = n.createTextNode(Te), c = e.parentNode;
      c.insertBefore(r, e), o.setStart(r, 0), o.setEnd(r, 1);
      const u = qc(o.getBoundingClientRect());
      return c.removeChild(r), u;
    }, sw = (e) => {
      const n = e.startContainer, o = e.endContainer, r = e.startOffset, c = e.endOffset;
      if (n === o && rn(o) && r === 0 && c === 1) {
        const u = e.cloneRange();
        return u.setEndAfter(o), Yu(u);
      } else
        return null;
    }, W1 = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Yu = (e) => {
      let n;
      const o = e.getClientRects();
      return o.length > 0 ? n = qc(o[0]) : n = qc(e.getBoundingClientRect()), !qy(e) && j1(e) && W1(n) ? bi(e) : W1(n) && qy(e) ? sw(e) : n;
    }, Rd = (e, n) => {
      const o = Jk(e, n);
      return o.width = 1, o.right = o.left + 1, o;
    }, rw = (e) => {
      const n = [], o = (m) => {
        m.height !== 0 && (n.length > 0 && Qk(m, n[n.length - 1]) || n.push(m));
      }, r = (m, y) => {
        const v = U1(m.ownerDocument);
        if (y < m.data.length) {
          if (ew(m.data[y]))
            return n;
          if (ew(m.data[y - 1]) && (v.setStart(m, y), v.setEnd(m, y + 1), !bc(v)))
            return o(Rd(Yu(v), !1)), n;
        }
        y > 0 && (v.setStart(m, y - 1), v.setEnd(m, y), bc(v) || o(Rd(Yu(v), !1))), y < m.data.length && (v.setStart(m, y), v.setEnd(m, y + 1), bc(v) || o(Rd(Yu(v), !0)));
      }, c = e.container(), u = e.offset();
      if (Dg(c))
        return r(c, u), n;
      if (nw(c))
        if (e.isAtEnd()) {
          const m = ih(c, u);
          Dg(m) && r(m, m.data.length), Og(m) && !j1(m) && o(Rd(Yu(m), !1));
        } else {
          const m = ih(c, u);
          if (Dg(m) && r(m, 0), Og(m) && e.isAtEnd())
            return o(Rd(Yu(m), !1)), n;
          const y = ih(e.container(), e.offset() - 1);
          Og(y) && !j1(y) && (V1(y) || V1(m) || !Og(m)) && o(Rd(Yu(y), !1)), Og(m) && o(Rd(Yu(m), !0));
        }
      return n;
    }, Ke = (e, n, o) => {
      const r = () => (Dg(e), n === 0), c = () => Dg(e) ? n >= e.data.length : n >= e.childNodes.length, u = () => {
        const R = U1(e.ownerDocument);
        return R.setStart(e, n), R.setEnd(e, n), R;
      }, m = () => (o || (o = rw(Ke(e, n))), o), y = () => m().length > 0, v = (R) => R && e === R.container() && n === R.offset(), x = (R) => ih(e, R ? n - 1 : n);
      return {
        container: Pe(e),
        offset: Pe(n),
        toRange: u,
        getClientRects: m,
        isVisible: y,
        isAtStart: r,
        isAtEnd: c,
        isEqual: v,
        getNode: x
      };
    };
    Ke.fromRangeStart = (e) => Ke(e.startContainer, e.startOffset), Ke.fromRangeEnd = (e) => Ke(e.endContainer, e.endOffset), Ke.after = (e) => Ke(e.parentNode, wa(e) + 1), Ke.before = (e) => Ke(e.parentNode, wa(e)), Ke.isAbove = (e, n) => qs(Go(n.getClientRects()), Ro(e.getClientRects()), Ui).getOr(!1), Ke.isBelow = (e, n) => qs(Ro(n.getClientRects()), Go(e.getClientRects()), yi).getOr(!1), Ke.isAtStart = (e) => e ? e.isAtStart() : !1, Ke.isAtEnd = (e) => e ? e.isAtEnd() : !1, Ke.isTextPosition = (e) => e ? rn(e.container()) : !1, Ke.isElementPosition = (e) => Ke.isTextPosition(e) === !1;
    const Df = (e, n) => {
      rn(n) && n.data.length === 0 && e.remove(n);
    }, eS = (e, n, o) => {
      n.insertNode(o), Df(e, o.previousSibling), Df(e, o.nextSibling);
    }, sc = (e, n, o) => {
      const r = O.from(o.firstChild), c = O.from(o.lastChild);
      n.insertNode(o), r.each((u) => Df(e, u.previousSibling)), c.each((u) => Df(e, u.nextSibling));
    }, Wi = (e, n, o) => {
      Pn(o) ? sc(e, n, o) : eS(e, n, o);
    }, Ia = rn, tS = Hu, Rf = Ks.nodeIndex, aw = (e) => {
      const n = e.parentNode;
      return tS(n) ? aw(n) : n;
    }, Md = (e) => e ? le(e.childNodes, (n, o) => (tS(o) && o.nodeName !== "BR" ? n = n.concat(Md(o)) : n.push(o), n), []) : [], Z1 = (e, n) => {
      for (; (e = e.previousSibling) && Ia(e); )
        n += e.data.length;
      return n;
    }, Em = (e) => (n) => e === n, q1 = (e) => {
      let n, o;
      n = Md(aw(e)), o = Ce(n, Em(e), e), n = n.slice(0, o + 1);
      const r = le(n, (c, u, m) => (Ia(u) && Ia(n[m - 1]) && c++, c), 0);
      return n = cc(n, Wl([e.nodeName])), o = Ce(n, Em(e), e), o - r;
    }, cw = (e) => {
      let n;
      return Ia(e) ? n = "text()" : n = e.nodeName.toLowerCase(), n + "[" + q1(e) + "]";
    }, nS = (e, n, o) => {
      const r = [];
      for (n = n.parentNode; n !== e && !(o && o(n)); n = n.parentNode)
        r.push(n);
      return r;
    }, lw = (e, n) => {
      let o, r, c = [], u, m, y;
      return o = n.container(), r = n.offset(), Ia(o) ? u = Z1(o, r) : (m = o.childNodes, r >= m.length ? (u = "after", r = m.length - 1) : u = "before", o = m[r]), c.push(cw(o)), y = nS(e, o), y = cc(y, _o(Hu)), c = c.concat(rs(y, (v) => cw(v))), c.reverse().join("/") + "," + u;
    }, oS = (e, n, o) => {
      let r = Md(e);
      return r = cc(r, (c, u) => !Ia(c) || !Ia(r[u - 1])), r = cc(r, Wl([n])), r[o];
    }, G1 = (e, n) => {
      let o = e, r = 0, c;
      for (; Ia(o); ) {
        if (c = o.data.length, n >= r && n <= r + c) {
          e = o, n = n - r;
          break;
        }
        if (!Ia(o.nextSibling)) {
          e = o, n = c;
          break;
        }
        r += c, o = o.nextSibling;
      }
      return Ia(e) && n > e.data.length && (n = e.data.length), Ke(e, n);
    }, uh = (e, n) => {
      let o;
      if (!n)
        return null;
      const r = n.split(","), c = r[0].split("/");
      o = r.length > 1 ? r[1] : "before";
      const u = le(c, (m, y) => {
        const v = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(y);
        return v ? (v[1] === "text()" && (v[1] = "#text"), oS(m, v[1], parseInt(v[2], 10))) : null;
      }, e);
      return u ? Ia(u) ? G1(u, parseInt(o, 10)) : (o === "after" ? o = Rf(u) + 1 : o = Rf(u), Ke(u.parentNode, o)) : null;
    }, Gy = Dr, iw = (e, n, o) => {
      let r, c;
      for (c = e(n.data.slice(0, o)).length, r = n.previousSibling; r && rn(r); r = r.previousSibling)
        c += e(r.data).length;
      return c;
    }, Ky = (e, n, o, r, c) => {
      let u = r[c ? "startContainer" : "endContainer"], m = r[c ? "startOffset" : "endOffset"];
      const y = [];
      let v, x = 0;
      const R = e.getRoot();
      for (rn(u) ? y.push(o ? iw(n, u, m) : m) : (v = u.childNodes, m >= v.length && v.length && (x = 1, m = Math.max(0, v.length - 1)), y.push(e.nodeIndex(v[m], o) + x)); u && u !== R; u = u.parentNode)
        y.push(e.nodeIndex(u, o));
      return y;
    }, Rg = (e, n, o, r) => {
      const c = n.dom, u = Ky(c, e, o, r, !0), m = n.isForward(), y = pg(r) ? { isFakeCaret: !0 } : {};
      if (n.isCollapsed())
        return {
          start: u,
          forward: m,
          ...y
        };
      {
        const v = Ky(c, e, o, r, !1);
        return {
          start: u,
          end: v,
          forward: m,
          ...y
        };
      }
    }, Yy = (e, n, o) => {
      let r = 0;
      return it.each(e.select(n), (c) => {
        if (c.getAttribute("data-mce-bogus") !== "all") {
          if (c === o)
            return !1;
          r++;
        }
      }), r;
    }, K1 = (e, n) => {
      let o, r;
      const c = n ? "start" : "end";
      if (o = e[c + "Container"], r = e[c + "Offset"], Vn(o) && o.nodeName === "TR") {
        const u = o.childNodes;
        o = u[Math.min(n ? r : r - 1, u.length - 1)], o && (r = n ? 0 : o.childNodes.length, e["set" + (n ? "Start" : "End")](o, r));
      }
    }, Mg = (e) => (K1(e, !0), K1(e, !1), e), Mf = (e, n) => {
      let o;
      if (Vn(e) && (e = Dd(e, n), Gy(e)))
        return e;
      if (jt(e) && (rn(e) && Ze(e) && (e = e.parentNode), o = e.previousSibling, Gy(o) || (o = e.nextSibling, Gy(o))))
        return o;
    }, Xy = (e) => Mf(e.startContainer, e.startOffset) || Mf(e.endContainer, e.endOffset), Es = (e, n, o) => {
      const r = o.getNode();
      let c = r ? r.nodeName : null;
      const u = o.getRng();
      if (Gy(r) || c === "IMG")
        return {
          name: c,
          index: Yy(o.dom, c, r)
        };
      const m = Xy(u);
      return m ? (c = m.tagName, {
        name: c,
        index: Yy(o.dom, c, m)
      }) : Rg(e, o, n, u);
    }, il = (e) => {
      const n = e.getRng();
      return {
        start: lw(e.dom.getRoot(), Ke.fromRangeStart(n)),
        end: lw(e.dom.getRoot(), Ke.fromRangeEnd(n)),
        forward: e.isForward()
      };
    }, Ng = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), Rc = (e, n, o) => {
      const r = {
        "data-mce-type": "bookmark",
        id: n,
        style: "overflow:hidden;line-height:0px"
      };
      return o ? e.create("span", r, "&#xFEFF;") : e.create("span", r);
    }, fr = (e, n) => {
      const o = e.dom;
      let r = e.getRng();
      const c = o.uniqueId(), u = e.isCollapsed(), m = e.getNode(), y = m.nodeName, v = e.isForward();
      if (y === "IMG")
        return {
          name: y,
          index: Yy(o, y, m)
        };
      const x = Mg(r.cloneRange());
      if (!u) {
        x.collapse(!1);
        const F = Rc(o, c + "_end", n);
        Wi(o, x, F);
      }
      r = Mg(r), r.collapse(!0);
      const R = Rc(o, c + "_start", n);
      return Wi(o, r, R), e.moveToBookmark({
        id: c,
        keep: !0,
        forward: v
      }), {
        id: c,
        forward: v
      };
    }, uw = (e, n, o) => n === 2 ? Es(P, o, e) : n === 3 ? il(e) : n ? Ng(e) : fr(e, !1), Y1 = Ct(Es, Rt, !0), La = (e) => {
      const n = (u) => u(e), o = Pe(e), r = () => c, c = {
        tag: !0,
        inner: e,
        fold: (u, m) => m(e),
        isValue: Xe,
        isError: Mn,
        map: (u) => ul.value(u(e)),
        mapError: r,
        bind: n,
        exists: n,
        forall: n,
        getOr: o,
        or: r,
        getOrThunk: o,
        orThunk: r,
        getOrDie: o,
        each: (u) => {
          u(e);
        },
        toOptional: () => O.some(e)
      };
      return c;
    }, gu = (e) => {
      const n = () => o, o = {
        tag: !1,
        inner: e,
        fold: (r, c) => r(e),
        isValue: Mn,
        isError: Xe,
        map: n,
        mapError: (r) => ul.error(r(e)),
        bind: n,
        exists: Mn,
        forall: Xe,
        getOr: Rt,
        or: Rt,
        getOrThunk: Sn,
        orThunk: Sn,
        getOrDie: Fn(String(e)),
        each: Se,
        toOptional: O.none
      };
      return o;
    }, ul = {
      value: La,
      error: gu,
      fromOption: (e, n) => e.fold(() => gu(n), La)
    }, vi = { generate: (e) => {
      if (!Re(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const n = [], o = {};
      return X(e, (r, c) => {
        const u = $e(r);
        if (u.length !== 1)
          throw new Error("one and only one name per case");
        const m = u[0], y = r[m];
        if (o[m] !== void 0)
          throw new Error("duplicate key detected:" + m);
        if (m === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!Re(y))
          throw new Error("case arguments must be an array");
        n.push(m), o[m] = (...v) => {
          const x = v.length;
          if (x !== y.length)
            throw new Error("Wrong number of arguments to case " + m + ". Expected " + y.length + " (" + y + "), got " + x);
          return {
            fold: (...F) => {
              if (F.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + F.length);
              return F[c].apply(null, v);
            },
            match: (F) => {
              const W = $e(F);
              if (n.length !== W.length)
                throw new Error("Wrong number of arguments to match. Expected: " + n.join(",") + `
Actual: ` + W.join(","));
              if (!ds(n, (ee) => Ae(W, ee)))
                throw new Error("Not all branches were specified when using match. Specified: " + W.join(", ") + `
Required: ` + n.join(", "));
              return F[m].apply(null, v);
            },
            log: (F) => {
              console.log(F, {
                constructors: n,
                constructor: m,
                params: v
              });
            }
          };
        };
      }), o;
    } };
    vi.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const Jy = (e) => {
      const n = [], o = [];
      return X(e, (r) => {
        r.fold((c) => {
          n.push(c);
        }, (c) => {
          o.push(c);
        });
      }), {
        errors: n,
        values: o
      };
    }, Qy = (e) => e.type === "inline-command" || e.type === "inline-format", Bg = (e) => e.type === "block-command" || e.type === "block-format", fw = (e) => ro(e, (n, o) => n.start.length === o.start.length ? 0 : n.start.length > o.start.length ? -1 : 1), mw = (e) => {
      const n = (r) => ul.error({
        message: r,
        pattern: e
      }), o = (r, c, u) => {
        if (e.format !== void 0) {
          let m;
          if (Re(e.format)) {
            if (!ds(e.format, ie))
              return n(r + " pattern has non-string items in the `format` array");
            m = e.format;
          } else if (ie(e.format))
            m = [e.format];
          else
            return n(r + " pattern has non-string `format` parameter");
          return ul.value(c(m));
        } else
          return e.cmd !== void 0 ? ie(e.cmd) ? ul.value(u(e.cmd, e.value)) : n(r + " pattern has non-string `cmd` parameter") : n(r + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!dn(e))
        return n("Raw pattern is not an object");
      if (!ie(e.start))
        return n("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!ie(e.end))
          return n("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return n("Inline pattern has empty `start` and `end` parameters");
        let r = e.start, c = e.end;
        return c.length === 0 && (c = r, r = ""), o("Inline", (u) => ({
          type: "inline-format",
          start: r,
          end: c,
          format: u
        }), (u, m) => ({
          type: "inline-command",
          start: r,
          end: c,
          cmd: u,
          value: m
        }));
      } else
        return e.replacement !== void 0 ? ie(e.replacement) ? e.start.length === 0 ? n("Replacement pattern has empty `start` parameter") : ul.value({
          type: "inline-command",
          start: "",
          end: e.start,
          cmd: "mceInsertContent",
          value: e.replacement
        }) : n("Replacement pattern has non-string `replacement` parameter") : e.start.length === 0 ? n("Block pattern has empty `start` parameter") : o("Block", (r) => ({
          type: "block-format",
          start: e.start,
          format: r[0]
        }), (r, c) => ({
          type: "block-command",
          start: e.start,
          cmd: r,
          value: c
        }));
    }, Gc = (e) => fw(ue(e, Bg)), $g = (e) => ue(e, Qy), Pg = (e) => ({
      inlinePatterns: $g(e),
      blockPatterns: Gc(e)
    }), ki = (e) => {
      const n = Jy(ae(e, mw));
      return X(n.errors, (o) => console.error(o.message, o.pattern)), n.values;
    }, X1 = Vo().deviceType, rc = X1.isTouch(), sS = Ks.DOM, Nf = (e) => {
      const n = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return Ht(n, (o, r) => {
        const c = r.split("="), u = c[0], m = c.length > 1 ? c[1] : u;
        return o[zo(u)] = zo(m), o;
      }, {});
    }, J1 = (e) => Ue(e, RegExp), _n = (e) => (n) => n.options.get(e), Fg = (e) => ie(e) || dn(e), eb = (e, n = "") => (o) => {
      const r = ie(o);
      if (r)
        if (o.indexOf("=") !== -1) {
          const c = Nf(o);
          return {
            value: Xo(c, e.id).getOr(n),
            valid: r
          };
        } else
          return {
            value: o,
            valid: r
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, Q1 = (e) => {
      const n = e.options.register;
      n("id", {
        processor: "string",
        default: e.id
      }), n("selector", { processor: "string" }), n("target", { processor: "object" }), n("suffix", { processor: "string" }), n("cache_suffix", { processor: "string" }), n("base_url", { processor: "string" }), n("referrer_policy", {
        processor: "string",
        default: ""
      }), n("language_load", { processor: "boolean" }), n("inline", {
        processor: "boolean",
        default: !1
      }), n("iframe_attrs", {
        processor: "object",
        default: {}
      }), n("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), n("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), n("body_id", {
        processor: eb(e, "tinymce"),
        default: "tinymce"
      }), n("body_class", {
        processor: eb(e),
        default: ""
      }), n("content_security_policy", {
        processor: "string",
        default: ""
      }), n("br_in_pre", {
        processor: "boolean",
        default: !0
      }), n("forced_root_block", {
        processor: (o) => {
          const r = ie(o) && Bo(o);
          return r ? {
            value: o,
            valid: r
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), n("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), n("newline_behavior", {
        processor: (o) => {
          const r = Ae([
            "block",
            "linebreak",
            "invert",
            "default"
          ], o);
          return r ? {
            value: o,
            valid: r
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), n("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), n("no_newline_selector", {
        processor: "string",
        default: ""
      }), n("keep_styles", {
        processor: "boolean",
        default: !0
      }), n("end_container_on_empty_block", {
        processor: (o) => Je(o) ? {
          valid: !0,
          value: o
        } : ie(o) ? {
          valid: !0,
          value: o
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), n("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), n("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), n("font_size_classes", {
        processor: "string",
        default: ""
      }), n("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), n("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), n("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), n("icons", {
        processor: "string",
        default: ""
      }), n("icons_url", {
        processor: "string",
        default: ""
      }), n("images_upload_url", {
        processor: "string",
        default: ""
      }), n("images_upload_base_path", {
        processor: "string",
        default: ""
      }), n("images_upload_base_path", {
        processor: "string",
        default: ""
      }), n("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), n("images_upload_handler", { processor: "function" }), n("language", {
        processor: "string",
        default: "en"
      }), n("language_url", {
        processor: "string",
        default: ""
      }), n("entity_encoding", {
        processor: "string",
        default: "named"
      }), n("indent", {
        processor: "boolean",
        default: !0
      }), n("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), n("indentation", {
        processor: "string",
        default: "40px"
      }), n("content_css", {
        processor: (o) => {
          const r = o === !1 || ie(o) || Ot(o, ie);
          return r ? ie(o) ? {
            value: ae(o.split(","), zo),
            valid: r
          } : Re(o) ? {
            value: o,
            valid: r
          } : o === !1 ? {
            value: [],
            valid: r
          } : {
            value: o,
            valid: r
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: mh(e) ? [] : ["default"]
      }), n("content_style", { processor: "string" }), n("content_css_cors", {
        processor: "boolean",
        default: !1
      }), n("font_css", {
        processor: (o) => {
          const r = ie(o) || Ot(o, ie);
          return r ? {
            value: Re(o) ? o : ae(o.split(","), zo),
            valid: r
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), n("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), n("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), n("object_resizing", {
        processor: (o) => {
          const r = Je(o) || ie(o);
          return r ? o === !1 || X1.isiPhone() || X1.isiPad() ? {
            value: "",
            valid: r
          } : {
            value: o === !0 ? "table,img,figure.image,div,video,iframe" : o,
            valid: r
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !rc
      }), n("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), n("event_root", { processor: "object" }), n("service_message", { processor: "string" }), n("theme", {
        processor: (o) => o === !1 || ie(o) || wn(o),
        default: "silver"
      }), n("theme_url", { processor: "string" }), n("formats", { processor: "object" }), n("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), n("preview_styles", {
        processor: (o) => {
          const r = o === !1 || ie(o);
          return r ? {
            value: o === !1 ? "" : o,
            valid: r
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), n("custom_ui_selector", {
        processor: "string",
        default: ""
      }), n("hidden_input", {
        processor: "boolean",
        default: !0
      }), n("submit_patch", {
        processor: "boolean",
        default: !0
      }), n("encoding", { processor: "string" }), n("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), n("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), n("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), n("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), n("readonly", {
        processor: "boolean",
        default: !1
      }), n("plugins", {
        processor: "string[]",
        default: []
      }), n("external_plugins", { processor: "object" }), n("forced_plugins", { processor: "string[]" }), n("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), n("model_url", { processor: "string" }), n("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), n("visual", {
        processor: "boolean",
        default: !0
      }), n("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), n("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), n("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), n("setup", { processor: "function" }), n("init_instance_callback", { processor: "function" }), n("url_converter", {
        processor: "function",
        default: e.convertURL
      }), n("url_converter_scope", {
        processor: "object",
        default: e
      }), n("urlconverter_callback", { processor: "function" }), n("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), n("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_svg_data_urls", { processor: "boolean" }), n("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), n("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), n("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), n("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), n("remove_trailing_brs", { processor: "boolean" }), n("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("element_format", {
        processor: "string",
        default: "html"
      }), n("entities", { processor: "string" }), n("schema", {
        processor: "string",
        default: "html5"
      }), n("convert_urls", {
        processor: "boolean",
        default: !0
      }), n("relative_urls", {
        processor: "boolean",
        default: !0
      }), n("remove_script_host", {
        processor: "boolean",
        default: !0
      }), n("custom_elements", { processor: "string" }), n("extended_valid_elements", { processor: "string" }), n("invalid_elements", { processor: "string" }), n("invalid_styles", { processor: Fg }), n("valid_children", { processor: "string" }), n("valid_classes", { processor: Fg }), n("valid_elements", { processor: "string" }), n("valid_styles", { processor: Fg }), n("verify_html", {
        processor: "boolean",
        default: !0
      }), n("auto_focus", { processor: (o) => ie(o) || o === !0 }), n("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), n("protect", { processor: "array" }), n("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), n("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), n("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), n("api_key", { processor: "string" }), n("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), n("paste_data_images", {
        processor: "boolean",
        default: !0
      }), n("paste_preprocess", { processor: "function" }), n("paste_postprocess", { processor: "function" }), n("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), n("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), n("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), n("smart_paste", {
        processor: "boolean",
        default: !0
      }), n("paste_as_text", {
        processor: "boolean",
        default: !1
      }), n("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), n("text_patterns", {
        processor: (o) => Ot(o, dn) || o === !1 ? {
          value: ki(o === !1 ? [] : o),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1"
          },
          {
            start: "##",
            format: "h2"
          },
          {
            start: "###",
            format: "h3"
          },
          {
            start: "####",
            format: "h4"
          },
          {
            start: "#####",
            format: "h5"
          },
          {
            start: "######",
            format: "h6"
          },
          {
            start: "1. ",
            cmd: "InsertOrderedList"
          },
          {
            start: "* ",
            cmd: "InsertUnorderedList"
          },
          {
            start: "- ",
            cmd: "InsertUnorderedList"
          }
        ]
      }), n("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), n("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), n("noneditable_regexp", {
        processor: (o) => Ot(o, J1) ? {
          value: o,
          valid: !0
        } : J1(o) ? {
          value: [o],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), n("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), e.on("ScriptsLoaded", () => {
        n("directionality", {
          processor: "string",
          default: Dl.isRtl() ? "rtl" : void 0
        }), n("placeholder", {
          processor: "string",
          default: sS.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, gw = _n("iframe_attrs"), rS = _n("doctype"), pw = _n("document_base_url"), vc = _n("body_id"), kc = _n("body_class"), Kc = _n("content_security_policy"), wc = _n("br_in_pre"), Ir = _n("forced_root_block"), ua = _n("forced_root_block_attrs"), e0 = _n("newline_behavior"), t0 = _n("br_newline_selector"), hw = _n("no_newline_selector"), yw = _n("keep_styles"), bw = _n("end_container_on_empty_block"), dh = _n("automatic_uploads"), Ig = _n("images_reuse_filename"), tb = _n("images_replace_blob_uris"), n0 = _n("icons"), aS = _n("icons_url"), vw = _n("images_upload_url"), cS = _n("images_upload_base_path"), kw = _n("images_upload_credentials"), fh = _n("images_upload_handler"), nb = _n("content_css_cors"), o0 = _n("referrer_policy"), ww = _n("language"), lS = _n("language_url"), s0 = _n("indent_use_margin"), qt = _n("indentation"), iS = _n("content_css"), Ha = _n("content_style"), _w = _n("font_css"), Cw = _n("directionality"), uS = _n("inline_boundaries_selector"), wi = _n("object_resizing"), YE = _n("resize_img_proportional"), dS = _n("placeholder"), Xu = _n("event_root"), fS = _n("service_message"), Am = _n("theme"), Nd = _n("theme_url"), _i = _n("model"), r0 = _n("model_url"), Rl = _n("inline_boundaries"), mS = _n("formats"), Sw = _n("preview_styles"), a0 = _n("format_empty_lines"), c0 = _n("custom_ui_selector"), mh = _n("inline"), Bd = _n("hidden_input"), gS = _n("submit_patch"), xw = _n("add_form_submit_trigger"), pS = _n("add_unload_trigger"), hS = _n("custom_undo_redo_levels"), ob = _n("disable_nodechange"), Aa = _n("readonly"), yS = _n("content_css_cors"), pu = _n("plugins"), Tw = _n("external_plugins"), l0 = _n("block_unsupported_drop"), bS = _n("visual"), sb = _n("visual_table_class"), Ew = _n("visual_anchor_class"), Aw = _n("iframe_aria_text"), vS = _n("setup"), zw = _n("init_instance_callback"), i0 = _n("urlconverter_callback"), rb = _n("auto_focus"), Ow = _n("browser_spellcheck"), Bf = _n("protect"), Ar = _n("paste_block_drop"), Ju = _n("paste_data_images"), Va = _n("paste_preprocess"), Dw = _n("paste_postprocess"), u0 = _n("paste_webkit_styles"), Rw = _n("paste_remove_styles_if_webkit"), ab = _n("paste_merge_formats"), kS = _n("smart_paste"), Mw = _n("paste_as_text"), wS = _n("paste_tab_spaces"), Nw = _n("allow_html_data_urls"), d0 = _n("text_patterns"), Bw = _n("noneditable_class"), _S = _n("editable_class"), CS = _n("noneditable_regexp"), SS = (e) => it.explode(e.options.get("font_size_style_values")), gh = (e) => it.explode(e.options.get("font_size_classes")), $w = (e) => e.options.get("encoding") === "xml", xS = (e) => it.explode(e.options.get("images_file_types")), zm = _n("table_tab_navigation"), TS = Vn, f0 = rn, Pw = (e) => {
      const n = e.parentNode;
      n && n.removeChild(e);
    }, Lg = (e) => {
      const n = P(e);
      return {
        count: e.length - n.length,
        text: n
      };
    }, cb = (e) => {
      let n;
      for (; (n = e.data.lastIndexOf(k)) !== -1; )
        e.deleteData(n, 1);
    }, lb = (e, n) => ($d(e), n), ES = (e, n) => {
      const o = Lg(e.data.substr(0, n.offset())), r = Lg(e.data.substr(n.offset()));
      return (o.text + r.text).length > 0 ? (cb(e), Ke(e, n.offset() - o.count)) : n;
    }, AS = (e, n) => {
      const o = n.container(), r = We(Os(o.childNodes), e).map((c) => c < n.offset() ? Ke(o, n.offset() - 1) : n).getOr(n);
      return $d(e), r;
    }, Hg = (e, n) => f0(e) && n.container() === e ? ES(e, n) : lb(e, n), ib = (e, n) => n.container() === e.parentNode ? AS(e, n) : lb(e, n), ub = (e, n) => Ke.isTextPosition(n) ? Hg(e, n) : ib(e, n), $d = (e) => {
      TS(e) && jt(e) && (mo(e) ? e.removeAttribute("data-mce-caret") : Pw(e)), f0(e) && (cb(e), e.data.length === 0 && Pw(e));
    }, zS = Dr, Qu = tc, db = yd, Fw = "*[contentEditable=false],video,audio,embed,object", ed = (e, n, o) => {
      const r = Jk(n.getBoundingClientRect(), o);
      let c, u;
      if (e.tagName === "BODY") {
        const y = e.ownerDocument.documentElement;
        c = e.scrollLeft || y.scrollLeft, u = e.scrollTop || y.scrollTop;
      } else {
        const y = e.getBoundingClientRect();
        c = e.scrollLeft - y.left, u = e.scrollTop - y.top;
      }
      r.left += c, r.right += c, r.top += u, r.bottom += u, r.width = 1;
      let m = n.offsetWidth - n.clientWidth;
      return m > 0 && (o && (m *= -1), r.left += m, r.right += m), r;
    }, ph = (e) => {
      const n = ia(be.fromDom(e), Fw);
      for (let o = 0; o < n.length; o++) {
        const r = n[o].dom;
        let c = r.previousSibling;
        if (Fa(c)) {
          const u = c.data;
          u.length === 1 ? c.parentNode.removeChild(c) : c.deleteData(u.length - 1, 1);
        }
        c = r.nextSibling, hc(c) && (c.data.length === 1 ? c.parentNode.removeChild(c) : c.deleteData(0, 1));
      }
    }, fb = (e, n, o, r) => {
      const c = Od();
      let u, m;
      const y = Ir(e), v = e.dom, x = (J, te) => {
        let ve;
        if (R(), db(te))
          return null;
        if (o(te)) {
          m = vr(y, te, J);
          const De = ed(n, te, J);
          v.setStyle(m, "top", De.top);
          const Be = v.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          v.setStyles(Be, { ...De }), v.add(n, Be), c.set({
            caret: Be,
            element: te,
            before: J
          }), J && v.addClass(Be, "mce-visual-caret-before"), F(), ve = te.ownerDocument.createRange(), ve.setStart(m, 0), ve.setEnd(m, 0);
        } else
          return m = Fo(te, J), ve = te.ownerDocument.createRange(), Om(m.nextSibling) ? (ve.setStart(m, 0), ve.setEnd(m, 0)) : (ve.setStart(m, 1), ve.setEnd(m, 1)), ve;
        return ve;
      }, R = () => {
        ph(n), m && ($d(m), m = null), c.on((J) => {
          v.remove(J.caret), c.clear();
        }), u && (clearInterval(u), u = void 0);
      }, F = () => {
        u = setInterval(() => {
          c.on((J) => {
            r() ? v.toggleClass(J.caret, "mce-visual-caret-hidden") : v.addClass(J.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: x,
        hide: R,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          c.on((J) => {
            const te = ed(n, J.element, J.before);
            v.setStyles(J.caret, { ...te });
          });
        },
        destroy: () => clearInterval(u)
      };
    }, Vg = () => Qt.browser.isFirefox(), Om = (e) => zS(e) || Qu(e), jg = (e) => Om(e) || mi(e) && Vg(), Iw = Zl, m0 = Dr, OS = tc, g0 = yf("display", "block table table-cell table-caption list-item"), Lw = jt, p0 = Ze, h0 = Vn, DS = Do, Ug = (e) => e > 0, $f = (e) => e < 0, hh = (e, n) => {
      let o;
      for (; o = e(n); )
        if (!p0(o))
          return o;
      return null;
    }, Wg = (e, n, o, r, c) => {
      const u = new rr(e, r), m = m0(e) || p0(e);
      if ($f(n)) {
        if (m && (e = hh(u.prev.bind(u), !0), o(e)))
          return e;
        for (; e = hh(u.prev.bind(u), c); )
          if (o(e))
            return e;
      }
      if (Ug(n)) {
        if (m && (e = hh(u.next.bind(u), !0), o(e)))
          return e;
        for (; e = hh(u.next.bind(u), c); )
          if (o(e))
            return e;
      }
      return null;
    }, RS = (e, n) => {
      const o = (c) => Iw(c.dom), r = (c) => c.dom === n;
      return vf(be.fromDom(e), o, r).map((c) => c.dom).getOr(n);
    }, Pf = (e, n) => {
      for (; e && e !== n; ) {
        if (g0(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, td = (e, n, o) => Pf(e.container(), o) === Pf(n.container(), o), y0 = (e, n) => {
      if (!n)
        return null;
      const o = n.container(), r = n.offset();
      return h0(o) ? o.childNodes[r + e] : null;
    }, mb = (e, n) => {
      const o = n.ownerDocument.createRange();
      return e ? (o.setStartBefore(n), o.setEndBefore(n)) : (o.setStartAfter(n), o.setEndAfter(n)), o;
    }, gb = (e, n, o) => Pf(n, e) === Pf(o, e), Zg = (e, n, o) => {
      const r = e ? "previousSibling" : "nextSibling";
      for (; o && o !== n; ) {
        let c = o[r];
        if (Lw(c) && (c = c[r]), m0(c) || OS(c)) {
          if (gb(n, c, o))
            return c;
          break;
        }
        if (DS(c))
          break;
        o = o.parentNode;
      }
      return null;
    }, Dm = Ct(mb, !0), qg = Ct(mb, !1), yh = (e, n, o) => {
      let r;
      const c = Ct(Zg, !0, n), u = Ct(Zg, !1, n);
      let m = o.startContainer;
      const y = o.startOffset;
      if (Ze(m)) {
        h0(m) || (m = m.parentNode);
        const v = m.getAttribute("data-mce-caret");
        if (v === "before" && (r = m.nextSibling, jg(r)))
          return Dm(r);
        if (v === "after" && (r = m.previousSibling, jg(r)))
          return qg(r);
      }
      if (!o.collapsed)
        return o;
      if (rn(m)) {
        if (Lw(m)) {
          if (e === 1) {
            if (r = u(m), r)
              return Dm(r);
            if (r = c(m), r)
              return qg(r);
          }
          if (e === -1) {
            if (r = c(m), r)
              return qg(r);
            if (r = u(m), r)
              return Dm(r);
          }
          return o;
        }
        if (Fa(m) && y >= m.data.length - 1)
          return e === 1 && (r = u(m), r) ? Dm(r) : o;
        if (hc(m) && y <= 1)
          return e === -1 && (r = c(m), r) ? qg(r) : o;
        if (y === m.data.length)
          return r = u(m), r ? Dm(r) : o;
        if (y === 0)
          return r = c(m), r ? qg(r) : o;
      }
      return o;
    }, b0 = (e, n) => O.from(y0(e ? 0 : -1, n)).filter(m0), Gg = (e, n, o) => {
      const r = yh(e, n, o);
      return e === -1 ? Ke.fromRangeStart(r) : Ke.fromRangeEnd(r);
    }, bh = (e) => O.from(e.getNode()).map(be.fromDom), pb = (e) => O.from(e.getNode(!0)).map(be.fromDom), hb = (e, n) => {
      for (; n = e(n); )
        if (n.isVisible())
          return n;
      return n;
    }, vh = (e, n) => {
      const o = td(e, n);
      return !o && Cr(e.getNode()) ? !0 : o;
    };
    var ja;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })(ja || (ja = {}));
    const v0 = Dr, nd = rn, Hw = Vn, k0 = Cr, Zi = Do, Vw = xd, yb = Li, jw = (e, n) => {
      const o = [];
      for (; e && e !== n; )
        o.push(e), e = e.parentNode;
      return o;
    }, w0 = (e, n) => e.hasChildNodes() && n < e.childNodes.length ? e.childNodes[n] : null, _0 = (e, n) => {
      if (Ug(e)) {
        if (Zi(n.previousSibling) && !nd(n.previousSibling))
          return Ke.before(n);
        if (nd(n))
          return Ke(n, 0);
      }
      if ($f(e)) {
        if (Zi(n.nextSibling) && !nd(n.nextSibling))
          return Ke.after(n);
        if (nd(n))
          return Ke(n, n.data.length);
      }
      return $f(e) ? k0(n) ? Ke.before(n) : Ke.after(n) : Ke.before(n);
    }, Yc = (e, n) => {
      const o = n.nextSibling;
      return o && Zi(o) ? nd(o) ? Ke(o, 0) : Ke.before(o) : Uw(ja.Forwards, Ke.after(n), e);
    }, Uw = (e, n, o) => {
      let r, c, u, m;
      if (!Hw(o) || !n)
        return null;
      if (n.isEqual(Ke.after(o)) && o.lastChild) {
        if (m = Ke.after(o.lastChild), $f(e) && Zi(o.lastChild) && Hw(o.lastChild))
          return k0(o.lastChild) ? Ke.before(o.lastChild) : m;
      } else
        m = n;
      const y = m.container();
      let v = m.offset();
      if (nd(y)) {
        if ($f(e) && v > 0)
          return Ke(y, --v);
        if (Ug(e) && v < y.length)
          return Ke(y, ++v);
        r = y;
      } else {
        if ($f(e) && v > 0 && (c = w0(y, v - 1), Zi(c)))
          return !Vw(c) && (u = Wg(c, e, yb, c), u) ? nd(u) ? Ke(u, u.data.length) : Ke.after(u) : nd(c) ? Ke(c, c.data.length) : Ke.before(c);
        if (Ug(e) && v < y.childNodes.length && (c = w0(y, v), Zi(c)))
          return k0(c) ? Yc(o, c) : !Vw(c) && (u = Wg(c, e, yb, c), u) ? nd(u) ? Ke(u, 0) : Ke.before(u) : nd(c) ? Ke(c, 0) : Ke.after(c);
        r = c || m.getNode();
      }
      if ((Ug(e) && m.isAtEnd() || $f(e) && m.isAtStart()) && (r = Wg(r, e, Xe, o, !0), yb(r, o)))
        return _0(e, r);
      c = Wg(r, e, yb, o);
      const x = wt(ue(jw(y, o), v0));
      return x && (!c || !x.contains(c)) ? (Ug(e) ? m = Ke.after(x) : m = Ke.before(x), m) : c ? _0(e, c) : null;
    }, _c = (e) => ({
      next: (n) => Uw(ja.Forwards, n, e),
      prev: (n) => Uw(ja.Backwards, n, e)
    }), Ww = (e, n, o) => {
      const r = e ? Ke.before(o) : Ke.after(o);
      return Ci(e, n, r);
    }, MS = (e) => Cr(e) ? Ke.before(e) : Ke.after(e), Zw = (e) => Ke.isTextPosition(e) ? e.offset() === 0 : Do(e.getNode()), qw = (e) => {
      if (Ke.isTextPosition(e)) {
        const n = e.container();
        return e.offset() === n.data.length;
      } else
        return Do(e.getNode(!0));
    }, C0 = (e, n) => !Ke.isTextPosition(e) && !Ke.isTextPosition(n) && e.getNode() === n.getNode(!0), Mc = (e) => !Ke.isTextPosition(e) && Cr(e.getNode()), S0 = (e, n, o) => e ? !C0(n, o) && !Mc(n) && qw(n) && Zw(o) : !C0(o, n) && Zw(n) && qw(o), Ci = (e, n, o) => {
      const r = _c(n);
      return O.from(e ? r.next(o) : r.prev(o));
    }, bb = (e, n, o) => Ci(e, n, o).bind((r) => td(o, r, n) && S0(e, o, r) ? Ci(e, n, r) : O.some(r)), Rm = (e, n, o, r) => bb(e, n, o).bind((c) => r(c) ? Rm(e, n, c, r) : O.some(c)), Mm = (e, n) => {
      const o = e ? n.firstChild : n.lastChild;
      return rn(o) ? O.some(Ke(o, e ? 0 : o.data.length)) : o ? Do(o) ? O.some(e ? Ke.before(o) : MS(o)) : Ww(e, n, o) : O.none();
    }, Si = Ct(Ci, !0), qi = Ct(Ci, !1), Xc = Ct(Mm, !0), hu = Ct(Mm, !1), NS = "_mce_caret", Xl = (e) => Vn(e) && e.id === NS, Pd = (e, n) => {
      for (; n && n !== e; ) {
        if (n.id === NS)
          return n;
        n = n.parentNode;
      }
      return null;
    }, Gw = (e) => ie(e.start), x0 = (e) => Gn(e, "rng"), kh = (e) => Gn(e, "id"), Kw = (e) => Gn(e, "name"), T0 = (e) => it.isArray(e.start), Nm = (e) => !Kw(e) && Je(e.forward) ? e.forward : !0, wh = (e, n) => (Vn(n) && e.isBlock(n) && !n.innerHTML && (n.innerHTML = '<br data-mce-bogus="1" />'), n), E0 = (e, n) => {
      const o = e.createRng(), r = uh(e.getRoot(), n.start);
      o.setStart(r.container(), r.offset());
      const c = uh(e.getRoot(), n.end);
      return o.setEnd(c.container(), c.offset()), {
        range: o,
        forward: Nm(n)
      };
    }, Bm = (e, n) => {
      const o = e.ownerDocument.createTextNode(k);
      e.appendChild(o), n.setStart(o, 0), n.setEnd(o, 0);
    }, Kg = (e) => e.hasChildNodes() === !1, Yw = (e, n) => hu(e).fold(Mn, (o) => (n.setStart(o.container(), o.offset()), n.setEnd(o.container(), o.offset()), !0)), vb = (e, n, o) => Kg(n) && Pd(e, n) ? (Bm(n, o), !0) : !1, Xw = (e, n, o, r) => {
      const c = o[n ? "start" : "end"];
      let u, m, y, v;
      const x = e.getRoot();
      if (c) {
        for (y = c[0], m = x, u = c.length - 1; u >= 1; u--) {
          if (v = m.childNodes, vb(x, m, r))
            return !0;
          if (c[u] > v.length - 1)
            return vb(x, m, r) ? !0 : Yw(m, r);
          m = v[c[u]];
        }
        m.nodeType === 3 && (y = Math.min(c[0], m.nodeValue.length)), m.nodeType === 1 && (y = Math.min(c[0], m.childNodes.length)), n ? r.setStart(m, y) : r.setEnd(m, y);
      }
      return !0;
    }, A0 = (e) => rn(e) && e.data.length > 0, kb = (e, n, o) => {
      let r = e.get(o.id + "_" + n), c, u, m, y;
      const v = o.keep;
      let x, R;
      if (r) {
        if (c = r.parentNode, n === "start" ? (v ? r.hasChildNodes() ? (c = r.firstChild, u = 1) : A0(r.nextSibling) ? (c = r.nextSibling, u = 0) : A0(r.previousSibling) ? (c = r.previousSibling, u = r.previousSibling.data.length) : (c = r.parentNode, u = e.nodeIndex(r) + 1) : u = e.nodeIndex(r), x = c, R = u) : (v ? r.hasChildNodes() ? (c = r.firstChild, u = 1) : A0(r.previousSibling) ? (c = r.previousSibling, u = r.previousSibling.data.length) : (c = r.parentNode, u = e.nodeIndex(r)) : u = e.nodeIndex(r), x = c, R = u), !v) {
          for (y = r.previousSibling, m = r.nextSibling, it.each(it.grep(r.childNodes), (F) => {
            rn(F) && (F.nodeValue = F.nodeValue.replace(/\uFEFF/g, ""));
          }); r = e.get(o.id + "_" + n); )
            e.remove(r, !0);
          y && m && y.nodeType === m.nodeType && rn(y) && !Qt.browser.isOpera() && (u = y.nodeValue.length, y.appendData(m.nodeValue), e.remove(m), x = y, R = u);
        }
        return O.some(Ke(x, R));
      } else
        return O.none();
    }, wb = (e, n) => {
      const o = e.createRng();
      return Xw(e, !0, n, o) && Xw(e, !1, n, o) ? O.some({
        range: o,
        forward: Nm(n)
      }) : O.none();
    }, BS = (e, n) => {
      const o = kb(e, "start", n), r = kb(e, "end", n);
      return qs(o, r.or(o), (c, u) => {
        const m = e.createRng();
        return m.setStart(wh(e, c.container()), c.offset()), m.setEnd(wh(e, u.container()), u.offset()), {
          range: m,
          forward: Nm(n)
        };
      });
    }, $S = (e, n) => O.from(e.select(n.name)[n.index]).map((o) => {
      const r = e.createRng();
      return r.selectNode(o), {
        range: r,
        forward: !0
      };
    }), Jw = (e, n) => {
      const o = e.dom;
      if (n) {
        if (T0(n))
          return wb(o, n);
        if (Gw(n))
          return O.some(E0(o, n));
        if (kh(n))
          return BS(o, n);
        if (Kw(n))
          return $S(o, n);
        if (x0(n))
          return O.some({
            range: n.rng,
            forward: Nm(n)
          });
      }
      return O.none();
    }, PS = (e, n, o) => uw(e, n, o), FS = (e, n) => {
      Jw(e, n).each(({ range: o, forward: r }) => {
        e.setRng(o, r);
      });
    }, Jl = (e) => Vn(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", $m = ((e) => (n) => e === n)(Te), Yg = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, _b = (e) => !Yg(e) && !$m(e) && !Uc(e), Qw = (e) => ({ value: e }), Cb = (e) => {
      const n = e.toString(16);
      return (n.length === 1 ? "0" + n : n).toUpperCase();
    }, XE = (e) => {
      const n = Cb(e.red) + Cb(e.green) + Cb(e.blue);
      return Qw(n);
    }, z0 = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, LS = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, HS = (e, n, o, r) => ({
      red: e,
      green: n,
      blue: o,
      alpha: r
    }), VS = (e, n, o, r) => {
      const c = parseInt(e, 10), u = parseInt(n, 10), m = parseInt(o, 10), y = parseFloat(r);
      return HS(c, u, m, y);
    }, dl = (e) => {
      if (e === "transparent")
        return O.some(HS(0, 0, 0, 0));
      const n = z0.exec(e);
      if (n !== null)
        return O.some(VS(n[1], n[2], n[3], "1"));
      const o = LS.exec(e);
      return o !== null ? O.some(VS(o[1], o[2], o[3], o[4])) : O.none();
    }, yu = (e) => dl(e).map(XE).map((n) => "#" + n.value).getOr(e), Ff = (e) => !!e.nodeType, _h = (e) => e && /^(IMG)$/.test(e.nodeName), O0 = (e, n, o) => {
      const r = o.startOffset;
      let c = o.startContainer;
      if (!(c === o.endContainer && _h(c.childNodes[r])) && Vn(c)) {
        const u = c.childNodes;
        let m;
        r < u.length ? (c = u[r], m = new rr(c, e.getParent(c, e.isBlock))) : (c = u[u.length - 1], m = new rr(c, e.getParent(c, e.isBlock)), m.next(!0));
        for (let y = m.current(); y; y = m.next())
          if (rn(y) && !D0(y)) {
            o.setStart(y, 0), n.setRng(o);
            return;
          }
      }
    }, Xg = (e, n, o) => {
      if (e) {
        const r = n ? "nextSibling" : "previousSibling";
        for (e = o ? e : e[r]; e; e = e[r])
          if (Vn(e) || !D0(e))
            return e;
      }
    }, Jg = (e, n) => (Ff(n) && (n = n.nodeName), !!e.schema.getTextBlockElements()[n.toLowerCase()]), Qg = (e, n, o) => e.schema.isValidChild(n, o), D0 = (e, n = !1) => {
      if (Q(e) && rn(e)) {
        const o = n ? e.data.replace(/ /g, "\xA0") : e.data;
        return Gl(o);
      } else
        return !1;
    }, jS = (e) => Q(e) && rn(e) && e.length === 0, Ml = (e, n) => (wn(e) ? e = e(n) : Q(n) && (e = e.replace(/%(\w+)/g, (o, r) => n[r] || o)), e), Sb = (e, n) => (e = e || "", n = n || "", e = "" + (e.nodeName || e), n = "" + (n.nodeName || n), e.toLowerCase() === n.toLowerCase()), Pm = (e, n) => ((n === "color" || n === "backgroundColor") && (e = yu(e)), n === "fontWeight" && e === 700 && (e = "bold"), n === "fontFamily" && (e = e.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), "" + e), Nl = (e, n, o) => Pm(e.getStyle(n, o), o), xb = (e, n) => {
      let o;
      return e.getParent(n, (r) => (o = e.getStyle(r, "text-decoration"), o && o !== "none")), o;
    }, ep = (e, n, o) => e.getParents(n, o, e.getRoot()), US = (e, n) => {
      const o = (r) => {
        const c = (u) => u.length > 1 && u.charAt(0) === "%";
        return Oe([
          "styles",
          "attributes"
        ], (u) => Xo(r, u).exists((m) => {
          const y = Re(m) ? m : Tr(m);
          return Oe(y, c);
        }));
      };
      return Oe(e.formatter.get(n), o);
    }, e_ = (e, n, o) => {
      const r = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], c = (u) => hr(u, (m, y) => Oe(r, (v) => v === y));
      return Oe(e.formatter.get(n), (u) => {
        const m = c(u);
        return Oe(e.formatter.get(o), (y) => {
          const v = c(y);
          return Ss(m, v);
        });
      });
    }, Ql = (e) => er(e, "block"), fl = (e) => er(e, "selector"), za = (e) => er(e, "inline"), t_ = (e) => fl(e) && za(e) && hs(Xo(e, "mixed"), !0), Fd = (e) => fl(e) && e.expand !== !1 && !za(e), Fm = Jl, Gi = ep, n_ = D0, o_ = Jg, WS = (e) => Cr(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, ZS = (e, n) => {
      let o = n;
      for (; o; ) {
        if (Vn(o) && e.getContentEditable(o))
          return e.getContentEditable(o) === "false" ? o : n;
        o = o.parentNode;
      }
      return n;
    }, R0 = (e, n, o, r) => {
      const c = n.data;
      for (let u = o; e ? u >= 0 : u < c.length; e ? u-- : u++)
        if (r(c.charAt(u)))
          return e ? u + 1 : u;
      return -1;
    }, qS = (e, n, o) => R0(e, n, o, (r) => $m(r) || Yg(r)), s_ = (e, n, o) => R0(e, n, o, _b), r_ = (e, n, o, r, c, u) => {
      let m;
      const y = e.getParent(o, e.isBlock) || n, v = (R, F, W) => {
        const K = oc(e), ee = c ? K.backwards : K.forwards;
        return O.from(ee(R, F, (J, te) => Fm(J.parentNode) ? -1 : (m = J, W(c, J, te)), y));
      };
      return v(o, r, qS).bind((R) => u ? v(R.container, R.offset + (c ? -1 : 0), s_) : O.some(R)).orThunk(() => m ? O.some({
        container: m,
        offset: c ? 0 : m.length
      }) : O.none());
    }, M0 = (e, n, o, r, c) => {
      rn(r) && fs(r.data) && r[c] && (r = r[c]);
      const u = Gi(e, r);
      for (let m = 0; m < u.length; m++)
        for (let y = 0; y < n.length; y++) {
          const v = n[y];
          if (!(Q(v.collapsed) && v.collapsed !== o.collapsed) && fl(v) && e.is(u[m], v.selector))
            return u[m];
        }
      return r;
    }, a_ = (e, n, o, r) => {
      let c = o;
      const u = e.dom, m = u.getRoot(), y = n[0];
      if (Ql(y) && (c = y.wrapper ? null : u.getParent(o, y.block, m)), !c) {
        const v = u.getParent(o, "LI,TD,TH");
        c = u.getParent(rn(o) ? o.parentNode : o, (x) => x !== m && o_(e, x), v);
      }
      if (c && Ql(y) && y.wrapper && (c = Gi(u, c, "ul,ol").reverse()[0] || c), !c)
        for (c = o; c[r] && !u.isBlock(c[r]) && (c = c[r], !Sb(c, "br")); )
          ;
      return c || o;
    }, N0 = (e, n, o, r) => {
      const c = o.parentNode;
      return Q(o[r]) ? !1 : c === n || lt(c) || e.isBlock(c) ? !0 : N0(e, n, c, r);
    }, Ch = (e, n, o, r, c) => {
      let u = o;
      const m = c ? "previousSibling" : "nextSibling", y = e.getRoot();
      if (rn(o) && !n_(o) && (c ? r > 0 : r < o.data.length))
        return o;
      for (; ; ) {
        if (!n[0].block_expand && e.isBlock(u))
          return u;
        for (let v = u[m]; v; v = v[m]) {
          const x = rn(v) && !N0(e, y, v, m);
          if (!Fm(v) && !WS(v) && !n_(v, x))
            return u;
        }
        if (u === y || u.parentNode === y) {
          o = u;
          break;
        }
        u = u.parentNode;
      }
      return o;
    }, c_ = (e) => Fm(e.parentNode) || Fm(e), Yo = (e, n, o, r = !1) => {
      let { startContainer: c, startOffset: u, endContainer: m, endOffset: y } = n;
      const v = e.dom, x = o[0];
      return Vn(c) && c.hasChildNodes() && (c = Dd(c, u), rn(c) && (u = 0)), Vn(m) && m.hasChildNodes() && (m = Dd(m, n.collapsed ? y : y - 1), rn(m) && (y = m.nodeValue.length)), c = ZS(v, c), m = ZS(v, m), c_(c) && (c = Fm(c) ? c : c.parentNode, n.collapsed ? c = c.previousSibling || c : c = c.nextSibling || c, rn(c) && (u = n.collapsed ? c.length : 0)), c_(m) && (m = Fm(m) ? m : m.parentNode, n.collapsed ? m = m.nextSibling || m : m = m.previousSibling || m, rn(m) && (y = n.collapsed ? 0 : m.length)), n.collapsed && (r_(v, e.getBody(), c, u, !0, r).each(({ container: W, offset: K }) => {
        c = W, u = K;
      }), r_(v, e.getBody(), m, y, !1, r).each(({ container: W, offset: K }) => {
        m = W, y = K;
      })), (za(x) || x.block_expand) && ((!za(x) || !rn(c) || u === 0) && (c = Ch(v, o, c, u, !0)), (!za(x) || !rn(m) || y === m.nodeValue.length) && (m = Ch(v, o, m, y, !1))), Fd(x) && (c = M0(v, o, n, c, "previousSibling"), m = M0(v, o, n, m, "nextSibling")), (Ql(x) || fl(x)) && (c = a_(e, o, c, "previousSibling"), m = a_(e, o, m, "nextSibling"), Ql(x) && (v.isBlock(c) || (c = Ch(v, o, c, u, !0)), v.isBlock(m) || (m = Ch(v, o, m, y, !1)))), Vn(c) && (u = v.nodeIndex(c), c = c.parentNode), Vn(m) && (y = v.nodeIndex(m) + 1, m = m.parentNode), {
        startContainer: c,
        startOffset: u,
        endContainer: m,
        endOffset: y
      };
    }, xi = (e, n, o) => {
      const r = n.startOffset, c = Dd(n.startContainer, r), u = n.endOffset, m = Dd(n.endContainer, u - 1), y = (J) => {
        const te = J[0];
        rn(te) && te === c && r >= te.data.length && J.splice(0, 1);
        const ve = J[J.length - 1];
        return u === 0 && J.length > 0 && ve === m && rn(ve) && J.splice(J.length - 1, 1), J;
      }, v = (J, te, ve) => {
        const De = [];
        for (; J && J !== ve; J = J[te])
          De.push(J);
        return De;
      }, x = (J, te) => e.getParent(J, (ve) => ve.parentNode === te, te), R = (J, te, ve) => {
        const De = ve ? "nextSibling" : "previousSibling";
        for (let Be = J, qe = Be.parentNode; Be && Be !== te; Be = qe) {
          qe = Be.parentNode;
          const pt = v(Be === J ? Be : Be[De], De);
          pt.length && (ve || pt.reverse(), o(y(pt)));
        }
      };
      if (c === m)
        return o(y([c]));
      const F = e.findCommonAncestor(c, m);
      if (e.isChildOf(c, m))
        return R(c, F, !0);
      if (e.isChildOf(m, c))
        return R(m, F);
      const W = x(c, F) || c, K = x(m, F) || m;
      R(c, W, !0);
      const ee = v(W === c ? W : W.nextSibling, "nextSibling", K === m ? K.nextSibling : K);
      ee.length && o(y(ee)), R(m, K);
    }, Id = (e) => {
      const n = [];
      if (e)
        for (let o = 0; o < e.rangeCount; o++)
          n.push(e.getRangeAt(o));
      return n;
    }, Tb = (e) => yn(e, (n) => {
      const o = Wy(n);
      return o ? [be.fromDom(o)] : [];
    }), GS = (e) => Id(e).length > 1, B0 = (e) => ue(Tb(e), pc), KS = (e) => ia(e, "td[data-mce-selected],th[data-mce-selected]"), Sh = (e, n) => {
      const o = KS(n);
      return o.length > 0 ? o : B0(e);
    }, Ld = (e) => Sh(Id(e.selection.getSel()), be.fromDom(e.getBody())), tp = (e, n) => vd(e, "table", n), JE = (e) => {
      const n = e.startContainer, o = e.startOffset;
      return rn(n) ? o === 0 ? O.some(be.fromDom(n)) : O.none() : O.from(n.childNodes[o]).map(be.fromDom);
    }, YS = (e) => {
      const n = e.endContainer, o = e.endOffset;
      return rn(n) ? o === n.data.length ? O.some(be.fromDom(n)) : O.none() : O.from(n.childNodes[o - 1]).map(be.fromDom);
    }, $0 = (e) => md(e).fold(Pe([e]), (n) => [e].concat($0(n))), P0 = (e) => rl(e).fold(Pe([e]), (n) => An(n) === "br" ? sl(n).map((o) => [e].concat(P0(o))).getOr([]) : [e].concat(P0(n))), xh = (e, n) => qs(JE(n), YS(n), (o, r) => {
      const c = Wn($0(e), Ct(Is, o)), u = Wn(P0(e), Ct(Is, r));
      return c.isSome() && u.isSome();
    }).getOr(!1), Eb = (e, n, o, r) => {
      const c = o, u = new rr(o, c), m = hr(e.schema.getMoveCaretBeforeOnEnterElements(), (y, v) => !Ae([
        "td",
        "th",
        "table"
      ], v.toLowerCase()));
      do {
        if (rn(o) && it.trim(o.nodeValue).length !== 0) {
          r ? n.setStart(o, 0) : n.setEnd(o, o.nodeValue.length);
          return;
        }
        if (m[o.nodeName]) {
          r ? n.setStartBefore(o) : o.nodeName === "BR" ? n.setEndBefore(o) : n.setEndAfter(o);
          return;
        }
      } while (o = r ? u.next() : u.prev());
      c.nodeName === "BODY" && (r ? n.setStart(c, 0) : n.setEnd(c, c.childNodes.length));
    }, Th = (e) => {
      const n = e.selection.getSel();
      return n && n.rangeCount > 0;
    }, Ab = (e, n) => {
      const o = Ld(e);
      o.length > 0 ? X(o, (r) => {
        const c = r.dom, u = e.dom.createRng();
        u.setStartBefore(c), u.setEndAfter(c), n(u, !0);
      }) : n(e.selection.getRng(), !1);
    }, Eh = (e, n, o) => {
      const r = fr(e, n);
      o(r), e.moveToBookmark(r);
    }, Ah = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], F0 = (e) => Ps(e) && Cd(e) === k, zh = (e, n, o, r) => ec(n).fold(() => "skipping", (c) => r === "br" || F0(n) ? "valid" : ah(n) ? "existing" : Xl(n.dom) ? "caret" : Oe(Ah, (u) => El(n, u)) ? "valid-block" : !Qg(e, o, r) || !Qg(e, An(c), o) ? "invalid-child" : "valid"), zb = (e, n) => {
      const o = Yo(e, n, [{ inline: "span" }]);
      n.setStart(o.startContainer, o.startOffset), n.setEnd(o.endContainer, o.endOffset), e.selection.setRng(n);
    }, l_ = (e, n, o, r, c, u) => {
      const { uid: m = n, ...y } = o;
      jl(e, xm()), ms(e, `${Tg()}`, m), ms(e, `${Tm()}`, r);
      const { attributes: v = {}, classes: x = [] } = c(m, y);
      if (ur(e, v), ZC(e, x), u) {
        x.length > 0 && ms(e, `${rh()}`, x.join(","));
        const R = $e(v);
        R.length > 0 && ms(e, `${Eg()}`, R.join(","));
      }
    }, XS = (e) => {
      Nu(e, xm()), $r(e, `${Tg()}`), $r(e, `${Tm()}`), $r(e, `${sh()}`);
      const n = _l(e, `${Eg()}`).map((r) => r.split(",")).getOr([]), o = _l(e, `${rh()}`).map((r) => r.split(",")).getOr([]);
      X(n, (r) => $r(e, r)), hi(e, o), $r(e, `${rh()}`), $r(e, `${Eg()}`);
    }, i_ = (e, n, o, r, c) => {
      const u = be.fromTag("span", e);
      return l_(u, n, o, r, c, !1), u;
    }, JS = (e, n, o, r, c, u) => {
      const m = [], y = i_(e.getDoc(), o, u, r, c), v = Od(), x = () => {
        v.clear();
      }, R = () => v.get().getOrThunk(() => {
        const ee = zg(y);
        return m.push(ee), v.set(ee), ee;
      }), F = (ee) => {
        X(ee, W);
      }, W = (ee) => {
        switch (zh(e, ee, "span", An(ee))) {
          case "invalid-child": {
            x();
            const te = Qr(ee);
            F(te), x();
            break;
          }
          case "valid-block": {
            x(), l_(ee, o, u, r, c, !0);
            break;
          }
          case "valid": {
            const te = R();
            Cy(ee, te);
            break;
          }
        }
      }, K = (ee) => {
        const J = ae(ee, be.fromDom);
        F(J);
      };
      return xi(e.dom, n, (ee) => {
        x(), K(ee);
      }), m;
    }, Ob = (e, n, o, r) => {
      e.undoManager.transact(() => {
        const c = e.selection, u = c.getRng(), m = Ld(e).length > 0, y = Xk("mce-annotation");
        if (u.collapsed && !m && zb(e, u), c.getRng().collapsed && !m) {
          const v = i_(e.getDoc(), y, r, n, o.decorate);
          mf(v, Te), c.getRng().insertNode(v.dom), c.select(v.dom);
        } else
          Eh(c, !1, () => {
            Ab(e, (v) => {
              JS(e, v, y, n, o.decorate, r);
            });
          });
      });
    }, u_ = (e) => {
      const n = WC();
      nc(e, n);
      const o = F1(e, n), r = su("span"), c = (u) => {
        X(u, (m) => {
          r(m) ? $a(m) : XS(m);
        });
      };
      return {
        register: (u, m) => {
          n.register(u, m);
        },
        annotate: (u, m) => {
          n.lookup(u).each((y) => {
            Ob(e, u, y, m);
          });
        },
        annotationChanged: (u, m) => {
          o.addListener(u, m);
        },
        remove: (u) => {
          const m = e.selection.getBookmark();
          Yk(e, O.some(u)).each(({ elements: y }) => {
            c(y);
          }), e.selection.moveToBookmark(m);
        },
        removeAll: (u) => {
          const m = e.selection.getBookmark();
          Jt(Vy(e, u), (y, v) => {
            c(y);
          }), e.selection.moveToBookmark(m);
        },
        getAll: (u) => {
          const m = Vy(e, u);
          return ht(m, (y) => ae(y, (v) => v.dom));
        }
      };
    }, Oh = (e) => ({
      getBookmark: Ct(PS, e),
      moveToBookmark: Ct(FS, e)
    });
    Oh.isBookmarkNode = Jl;
    const d_ = (e, n, o) => o.collapsed ? !1 : Oe(o.getClientRects(), (r) => GC(r, e, n)), QS = (e, n) => e.dispatch("PreProcess", n), ex = (e, n) => e.dispatch("PostProcess", n), tx = (e) => e.dispatch("remove"), nx = (e) => e.dispatch("detach"), np = (e, n) => e.dispatch("SwitchMode", { mode: n }), cn = (e, n, o, r, c) => {
      e.dispatch("ObjectResizeStart", {
        target: n,
        width: o,
        height: r,
        origin: c
      });
    }, Oa = (e, n, o, r, c) => {
      e.dispatch("ObjectResized", {
        target: n,
        width: o,
        height: r,
        origin: c
      });
    }, Db = (e) => e.dispatch("PreInit"), Ua = (e) => e.dispatch("PostRender"), Bl = (e) => e.dispatch("Init"), f_ = (e, n) => e.dispatch("PlaceholderToggle", { state: n }), Dh = (e, n, o) => e.dispatch(n, o), Rb = (e, n, o, r) => e.dispatch("FormatApply", {
      format: n,
      node: o,
      vars: r
    }), I0 = (e, n, o, r) => e.dispatch("FormatRemove", {
      format: n,
      node: o,
      vars: r
    }), Mb = (e, n) => e.dispatch("BeforeSetContent", n), Nb = (e, n) => e.dispatch("SetContent", n), L0 = (e, n) => e.dispatch("BeforeGetContent", n), m_ = (e, n) => e.dispatch("GetContent", n), g_ = (e, n) => e.dispatch("AutocompleterStart", n), H0 = (e, n) => e.dispatch("AutocompleterUpdate", n), p_ = (e) => e.dispatch("AutocompleterEnd"), V0 = (e, n, o) => e.dispatch("PastePreProcess", {
      content: n,
      internal: o
    }), Bb = (e, n, o) => e.dispatch("PastePostProcess", {
      node: n,
      internal: o
    }), op = (e, n) => e.dispatch("PastePlainTextToggle", { state: n }), Tn = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || Tn.metaKeyPressed(e),
      metaKeyPressed: (e) => Qt.os.isMacOS() || Qt.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, bu = "data-mce-selected", j0 = "table,img,figure.image,hr,video,span.mce-preview-object", h_ = Math.abs, Im = Math.round, If = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, sp = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, y_ = (e, n) => {
      const o = n.dom, r = n.getDoc(), c = document, u = n.getBody();
      let m, y, v, x, R, F, W, K, ee, J, te, ve, De, Be, qe, pt, pn;
      const vt = (nn) => Q(nn) && (Up(nn) || o.is(nn, "figure.image")), xt = (nn) => tc(nn) || o.hasClass(nn, "mce-preview-object"), Zt = (nn, is) => {
        if (sp(nn)) {
          const _s = nn.touches[0];
          return vt(nn.target) && !d_(_s.clientX, _s.clientY, is);
        } else
          return vt(nn.target) && !d_(nn.clientX, nn.clientY, is);
      }, Xt = (nn) => {
        const is = nn.target;
        Zt(nn, n.selection.getRng()) && !nn.isDefaultPrevented() && n.selection.select(is);
      }, Qn = (nn) => o.is(nn, "figure.image") ? [nn.querySelector("img")] : o.hasClass(nn, "mce-preview-object") && Q(nn.firstElementChild) ? [
        nn,
        nn.firstElementChild
      ] : [nn], En = (nn) => {
        const is = wi(n);
        return !is || nn.getAttribute("data-mce-resize") === "false" || nn === n.getBody() ? !1 : o.hasClass(nn, "mce-preview-object") ? El(be.fromDom(nn.firstElementChild), is) : El(be.fromDom(nn), is);
      }, fn = (nn) => xt(nn) ? o.create("img", { src: Qt.transparentSrc }) : nn.cloneNode(!0), As = (nn, is, _s) => {
        if (Q(_s)) {
          const po = Qn(nn);
          X(po, (eo) => {
            eo.style[is] || !n.schema.isValid(eo.nodeName.toLowerCase(), is) ? o.setStyle(eo, is, _s) : o.setAttrib(eo, is, "" + _s);
          });
        }
      }, Us = (nn, is, _s) => {
        As(nn, "width", is), As(nn, "height", _s);
      }, lr = (nn) => {
        let is, _s, po, eo, Vs;
        is = nn.screenX - F, _s = nn.screenY - W, Be = is * x[2] + J, qe = _s * x[3] + te, Be = Be < 5 ? 5 : Be, qe = qe < 5 ? 5 : qe, (vt(m) || xt(m)) && YE(n) !== !1 ? po = !Tn.modifierPressed(nn) : po = Tn.modifierPressed(nn), po && (h_(is) > h_(_s) ? (qe = Im(Be * ve), Be = Im(qe / ve)) : (Be = Im(qe / ve), qe = Im(Be * ve))), Us(y, Be, qe), eo = x.startPos.x + is, Vs = x.startPos.y + _s, eo = eo > 0 ? eo : 0, Vs = Vs > 0 ? Vs : 0, o.setStyles(v, {
          left: eo,
          top: Vs,
          display: "block"
        }), v.innerHTML = Be + " &times; " + qe, x[2] < 0 && y.clientWidth <= Be && o.setStyle(y, "left", K + (J - Be)), x[3] < 0 && y.clientHeight <= qe && o.setStyle(y, "top", ee + (te - qe)), is = u.scrollWidth - pt, _s = u.scrollHeight - pn, is + _s !== 0 && o.setStyles(v, {
          left: eo - is,
          top: Vs - _s
        }), De || (cn(n, m, J, te, "corner-" + x.name), De = !0);
      }, qa = () => {
        const nn = De;
        De = !1, nn && (As(m, "width", Be), As(m, "height", qe)), o.unbind(r, "mousemove", lr), o.unbind(r, "mouseup", qa), c !== r && (o.unbind(c, "mousemove", lr), o.unbind(c, "mouseup", qa)), o.remove(y), o.remove(v), o.remove(R), Gt(m), nn && (Oa(n, m, Be, qe, "corner-" + x.name), o.setAttrib(m, "style", o.getAttrib(m, "style"))), n.nodeChanged();
      }, Gt = (nn) => {
        ln();
        const is = o.getPos(nn, u), _s = is.x, po = is.y, eo = nn.getBoundingClientRect(), Vs = eo.width || eo.right - eo.left, Ws = eo.height || eo.bottom - eo.top;
        m !== nn && (ps(), m = nn, Be = qe = 0);
        const Ga = n.dispatch("ObjectSelected", { target: nn });
        En(nn) && !Ga.isDefaultPrevented() ? Jt(If, (mr, bs) => {
          let gr;
          const yl = (bl) => {
            const Tc = Qn(m)[0];
            F = bl.screenX, W = bl.screenY, J = Tc.clientWidth, te = Tc.clientHeight, ve = te / J, x = mr, x.name = bs, x.startPos = {
              x: Vs * mr[0] + _s,
              y: Ws * mr[1] + po
            }, pt = u.scrollWidth, pn = u.scrollHeight, R = o.add(u, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), o.setStyles(R, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), y = fn(m), o.addClass(y, "mce-clonedresizable"), o.setAttrib(y, "data-mce-bogus", "all"), y.contentEditable = "false", o.setStyles(y, {
              left: _s,
              top: po,
              margin: 0
            }), Us(y, Vs, Ws), y.removeAttribute(bu), u.appendChild(y), o.bind(r, "mousemove", lr), o.bind(r, "mouseup", qa), c !== r && (o.bind(c, "mousemove", lr), o.bind(c, "mouseup", qa)), v = o.add(u, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, J + " &times; " + te);
          };
          gr = o.get("mceResizeHandle" + bs), gr && o.remove(gr), gr = o.add(u, "div", {
            id: "mceResizeHandle" + bs,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + bs + "-resize; margin:0; padding:0"
          }), o.bind(gr, "mousedown", (bl) => {
            bl.stopImmediatePropagation(), bl.preventDefault(), yl(bl);
          }), mr.elm = gr, o.setStyles(gr, {
            left: Vs * mr[0] + _s - gr.offsetWidth / 2,
            top: Ws * mr[1] + po - gr.offsetHeight / 2
          });
        }) : ps(!1);
      }, Hn = zf(Gt, 0), ps = (nn = !0) => {
        Hn.cancel(), ln(), m && nn && m.removeAttribute(bu), Jt(If, (is, _s) => {
          const po = o.get("mceResizeHandle" + _s);
          po && (o.unbind(po), o.remove(po));
        });
      }, ss = (nn, is) => Q(nn) && o.isChildOf(nn, is), ac = (nn) => {
        if (De || n.removed || n.composing)
          return;
        const is = nn.type === "mousedown" ? nn.target : e.getNode(), _s = Js(be.fromDom(is), j0).map((eo) => eo.dom).getOrUndefined(), po = Q(_s) ? o.getAttrib(_s, bu, "1") : "1";
        if (X(o.select(`img[${bu}],hr[${bu}]`), (eo) => {
          eo.removeAttribute(bu);
        }), ss(_s, u)) {
          lo();
          const eo = e.getStart(!0);
          if (ss(eo, _s) && ss(e.getEnd(!0), _s)) {
            o.setAttrib(_s, bu, po), Hn.throttle(_s);
            return;
          }
        }
        ps();
      }, ln = () => {
        Jt(If, (nn) => {
          nn.elm && (o.unbind(nn.elm), delete nn.elm);
        });
      }, lo = () => {
        try {
          n.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return n.on("init", () => {
        lo(), n.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", ac), n.on("keyup compositionend", (nn) => {
          m && m.nodeName === "TABLE" && ac(nn);
        }), n.on("hide blur", ps), n.on("contextmenu longpress", Xt, !0);
      }), n.on("remove", ln), {
        isResizable: En,
        showResizeRect: Gt,
        hideResizeRect: ps,
        updateResizeRect: ac,
        destroy: () => {
          Hn.cancel(), m = y = R = null;
        }
      };
    }, ox = (e, n) => {
      n.fold((o) => {
        e.setStartBefore(o.dom);
      }, (o, r) => {
        e.setStart(o.dom, r);
      }, (o) => {
        e.setStartAfter(o.dom);
      });
    }, sx = (e, n) => {
      n.fold((o) => {
        e.setEndBefore(o.dom);
      }, (o, r) => {
        e.setEnd(o.dom, r);
      }, (o) => {
        e.setEndAfter(o.dom);
      });
    }, Rh = (e, n, o) => {
      const r = e.document.createRange();
      return ox(r, n), sx(r, o), r;
    }, $b = (e, n, o, r, c) => {
      const u = e.document.createRange();
      return u.setStart(n.dom, o), u.setEnd(r.dom, c), u;
    }, Mh = vi.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), Lf = (e, n, o) => n(be.fromDom(o.startContainer), o.startOffset, be.fromDom(o.endContainer), o.endOffset), Cc = (e, n) => n.match({
      domRange: (o) => ({
        ltr: Pe(o),
        rtl: O.none
      }),
      relative: (o, r) => ({
        ltr: Rn(() => Rh(e, o, r)),
        rtl: Rn(() => O.some(Rh(e, r, o)))
      }),
      exact: (o, r, c, u) => ({
        ltr: Rn(() => $b(e, o, r, c, u)),
        rtl: Rn(() => O.some($b(e, c, u, o, r)))
      })
    }), Ki = (e, n) => {
      const o = n.ltr();
      return o.collapsed ? n.rtl().filter((c) => c.collapsed === !1).map((c) => Mh.rtl(be.fromDom(c.endContainer), c.endOffset, be.fromDom(c.startContainer), c.startOffset)).getOrThunk(() => Lf(e, Mh.ltr, o)) : Lf(e, Mh.ltr, o);
    }, vu = (e, n) => {
      const o = Cc(e, n);
      return Ki(e, o);
    };
    Mh.ltr, Mh.rtl;
    const Pb = { create: (e, n, o, r) => ({
      start: e,
      soffset: n,
      finish: o,
      foffset: r
    }) }, rx = (e, n, o) => {
      var r, c;
      return O.from((c = (r = e.dom).caretPositionFromPoint) === null || c === void 0 ? void 0 : c.call(r, n, o)).bind((u) => {
        if (u.offsetNode === null)
          return O.none();
        const m = e.dom.createRange();
        return m.setStart(u.offsetNode, u.offset), m.collapse(), O.some(m);
      });
    }, Nh = (e, n, o) => {
      var r, c;
      return O.from((c = (r = e.dom).caretRangeFromPoint) === null || c === void 0 ? void 0 : c.call(r, n, o));
    }, ax = (() => document.caretPositionFromPoint ? rx : document.caretRangeFromPoint ? Nh : O.none)(), U0 = (e, n, o) => {
      const r = be.fromDom(e.document);
      return ax(r, n, o).map((c) => Pb.create(be.fromDom(c.startContainer), c.startOffset, be.fromDom(c.endContainer), c.endOffset));
    }, W0 = vi.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), b_ = (e, n, o, r) => e.fold(n, o, r), cx = (e) => e.fold(Rt, Rt, Rt), v_ = W0.before, Z0 = W0.on, q0 = W0.after, Ds = {
      before: v_,
      on: Z0,
      after: q0,
      cata: b_,
      getStart: cx
    }, Ti = vi.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), k_ = (e) => Ti.exact(e.start, e.soffset, e.finish, e.foffset), w_ = (e) => e.match({
      domRange: (n) => be.fromDom(n.startContainer),
      relative: (n, o) => Ds.getStart(n),
      exact: (n, o, r, c) => n
    }), __ = Ti.domRange, G0 = Ti.relative, C_ = Ti.exact, Fb = (e) => {
      const n = w_(e);
      return $i(n);
    }, lx = Pb.create, rp = {
      domRange: __,
      relative: G0,
      exact: C_,
      exactFromRange: k_,
      getWin: Fb,
      range: lx
    }, Bh = (e, n) => {
      const o = An(e);
      return o === "input" ? Ds.after(e) : Ae([
        "br",
        "img"
      ], o) ? n === 0 ? Ds.before(e) : Ds.after(e) : Ds.on(e, n);
    }, ix = (e, n) => {
      const o = e.fold(Ds.before, Bh, Ds.after), r = n.fold(Ds.before, Bh, Ds.after);
      return rp.relative(o, r);
    }, Ib = (e, n, o, r) => {
      const c = Bh(e, n), u = Bh(o, r);
      return rp.relative(c, u);
    }, ap = (e) => e.match({
      domRange: (n) => {
        const o = be.fromDom(n.startContainer), r = be.fromDom(n.endContainer);
        return Ib(o, n.startOffset, r, n.endOffset);
      },
      relative: ix,
      exact: Ib
    }), Hf = (e, n) => {
      const r = (n || document).createDocumentFragment();
      return X(e, (c) => {
        r.appendChild(c.dom);
      }), be.fromDom(r);
    }, K0 = (e) => {
      const n = rp.getWin(e).dom, o = (c, u, m, y) => $b(n, c, u, m, y), r = ap(e);
      return vu(n, r).match({
        ltr: o,
        rtl: o
      });
    }, ux = (e, n, o) => U0(e, n, o), Ei = (e, n, o) => ux(o.defaultView, e, n).map((r) => {
      const c = o.createRange();
      return c.setStart(r.start.dom, r.soffset), c.setEnd(r.finish.dom, r.foffset), c;
    }).getOrUndefined(), Wa = (e, n) => e && n && e.startContainer === n.startContainer && e.startOffset === n.startOffset && e.endContainer === n.endContainer && e.endOffset === n.endOffset, Jc = (e, n, o) => {
      for (; e && e !== n; ) {
        if (o(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, wu = (e, n, o) => Jc(e, n, o) !== null, QE = (e, n, o) => wu(e, n, (r) => r.nodeName === o), Y0 = (e) => e && e.nodeName === "TABLE", dx = (e) => e && /^(TD|TH|CAPTION)$/.test(e.nodeName), cs = (e, n) => jt(e) && wu(e, n, Xl) === !1, S_ = (e, n, o) => {
      const r = new rr(n, e.getParent(n.parentNode, e.isBlock) || e.getRoot());
      for (; n = r[o ? "prev" : "next"](); )
        if (Cr(n))
          return !0;
    }, x_ = (e, n) => e.previousSibling && e.previousSibling.nodeName === n, X0 = (e, n) => {
      for (; n && n !== e; ) {
        if (Dr(n))
          return !0;
        n = n.parentNode;
      }
      return !1;
    }, J0 = (e, n, o, r, c) => {
      let u;
      const m = e.getRoot();
      let y;
      const v = e.schema.getNonEmptyElements(), x = e.getParent(c.parentNode, e.isBlock) || m;
      if (r && Cr(c) && n && e.isEmpty(x))
        return O.some(Ke(c.parentNode, e.nodeIndex(c)));
      const R = new rr(c, x);
      for (; y = R[r ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(y) === "false" || cs(y, m))
          return O.none();
        if (rn(y) && y.nodeValue.length > 0)
          return QE(y, m, "A") === !1 ? O.some(Ke(y, r ? y.nodeValue.length : 0)) : O.none();
        if (e.isBlock(y) || v[y.nodeName.toLowerCase()])
          return O.none();
        u = y;
      }
      return hm(u) ? O.none() : o && u ? O.some(Ke(u, 0)) : O.none();
    }, Lb = (e, n, o, r) => {
      let c, u;
      const m = e.getRoot();
      let y, v, x = !1;
      c = r[(o ? "start" : "end") + "Container"], u = r[(o ? "start" : "end") + "Offset"];
      const R = Vn(c) && u === c.childNodes.length, F = e.schema.getNonEmptyElements();
      if (v = o, jt(c))
        return O.none();
      if (Vn(c) && u > c.childNodes.length - 1 && (v = !1), gc(c) && (c = m, u = 0), c === m) {
        if (v && (y = c.childNodes[u > 0 ? u - 1 : 0], y && (jt(y) || F[y.nodeName] || Y0(y))))
          return O.none();
        if (c.hasChildNodes()) {
          if (u = Math.min(!v && u > 0 ? u - 1 : u, c.childNodes.length - 1), c = c.childNodes[u], u = rn(c) && R ? c.data.length : 0, !n && c === m.lastChild && Y0(c) || X0(m, c) || jt(c))
            return O.none();
          if (c.hasChildNodes() && Y0(c) === !1) {
            y = c;
            const W = new rr(c, m);
            do {
              if (Dr(y) || jt(y)) {
                x = !1;
                break;
              }
              if (rn(y) && y.nodeValue.length > 0) {
                u = v ? 0 : y.nodeValue.length, c = y, x = !0;
                break;
              }
              if (F[y.nodeName.toLowerCase()] && !dx(y)) {
                u = e.nodeIndex(y), c = y.parentNode, v || u++, x = !0;
                break;
              }
            } while (y = v ? W.next() : W.prev());
          }
        }
      }
      return n && (rn(c) && u === 0 && J0(e, R, n, !0, c).each((W) => {
        c = W.container(), u = W.offset(), x = !0;
      }), Vn(c) && (y = c.childNodes[u], y || (y = c.childNodes[u - 1]), y && Cr(y) && !x_(y, "A") && !S_(e, y, !1) && !S_(e, y, !0) && J0(e, R, n, !0, y).each((W) => {
        c = W.container(), u = W.offset(), x = !0;
      }))), v && !n && rn(c) && u === c.nodeValue.length && J0(e, R, n, !1, c).each((W) => {
        c = W.container(), u = W.offset(), x = !0;
      }), x ? O.some(Ke(c, u)) : O.none();
    }, Hb = (e, n) => {
      const o = n.collapsed, r = n.cloneRange(), c = Ke.fromRangeStart(n);
      return Lb(e, o, !0, r).each((u) => {
        (!o || !Ke.isAbove(c, u)) && r.setStart(u.container(), u.offset());
      }), o || Lb(e, o, !1, r).each((u) => {
        r.setEnd(u.container(), u.offset());
      }), o && r.collapse(!0), Wa(n, r) ? O.none() : O.some(r);
    }, Vb = (e, n) => e.splitText(n), jb = (e) => {
      let n = e.startContainer, o = e.startOffset, r = e.endContainer, c = e.endOffset;
      return n === r && rn(n) ? o > 0 && o < n.nodeValue.length && (r = Vb(n, o), n = r.previousSibling, c > o ? (c = c - o, n = r = Vb(r, c).previousSibling, c = r.nodeValue.length, o = 0) : c = 0) : (rn(n) && o > 0 && o < n.nodeValue.length && (n = Vb(n, o), o = 0), rn(r) && c > 0 && c < r.nodeValue.length && (r = Vb(r, c).previousSibling, c = r.nodeValue.length)), {
        startContainer: n,
        startOffset: o,
        endContainer: r,
        endOffset: c
      };
    }, cp = (e) => ({
      walk: (c, u) => xi(e, c, u),
      split: jb,
      normalize: (c) => Hb(e, c).fold(Mn, (u) => (c.setStart(u.startContainer, u.startOffset), c.setEnd(u.endContainer, u.endOffset), !0))
    });
    cp.compareRanges = Wa, cp.getCaretRangeFromPoint = Ei, cp.getSelectedNode = Wy, cp.getNode = Dd;
    const Q0 = ((e, n) => {
      const o = (y, v) => {
        if (!ft(v) && !v.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + v);
        const x = y.dom;
        Tl(x) && (x.style[e] = v + "px");
      }, r = (y) => {
        const v = n(y);
        if (v <= 0 || v === null) {
          const x = Gr(y, e);
          return parseFloat(x) || 0;
        }
        return v;
      }, c = r, u = (y, v) => Ht(v, (x, R) => {
        const F = Gr(y, R), W = F === void 0 ? 0 : parseInt(F, 10);
        return isNaN(W) ? x : x + W;
      }, 0);
      return {
        set: o,
        get: r,
        getOuter: c,
        aggregate: u,
        max: (y, v, x) => {
          const R = u(y, x);
          return v > R ? v - R : 0;
        }
      };
    })("height", (e) => {
      const n = e.dom;
      return xo(e) ? n.getBoundingClientRect().height : n.offsetHeight;
    }), E_ = (e) => Q0.get(e), A_ = () => be.fromDom(document), fx = (e, n) => e.view(n).fold(Pe([]), (r) => {
      const c = e.owner(r), u = fx(e, c);
      return [r].concat(u);
    }), mx = (e, n) => {
      const o = n.owner(e);
      return fx(n, o);
    };
    var e5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var n;
        return (e.dom === document ? O.none() : O.from((n = e.dom.defaultView) === null || n === void 0 ? void 0 : n.frameElement)).map(be.fromDom);
      },
      owner: (e) => ii(e)
    });
    const ao = (e) => {
      const n = A_(), o = Po(n), r = mx(e, e5), c = pd(e), u = ct(r, (m, y) => {
        const v = pd(y);
        return {
          left: m.left + v.left,
          top: m.top + v.top
        };
      }, {
        left: 0,
        top: 0
      });
      return Lu(u.left + c.left + o.left, u.top + c.top + o.top);
    }, ev = (e) => An(e) === "textarea", gx = (e, n) => e.dispatch("ScrollIntoView", n).isDefaultPrevented(), px = (e, n) => {
      e.dispatch("AfterScrollIntoView", n);
    }, Ub = (e, n) => {
      const o = Qr(e);
      if (o.length === 0 || ev(e))
        return {
          element: e,
          offset: n
        };
      if (n < o.length && !ev(o[n]))
        return {
          element: o[n],
          offset: 0
        };
      {
        const r = o[o.length - 1];
        return ev(r) ? {
          element: e,
          offset: n
        } : An(r) === "img" ? {
          element: r,
          offset: 1
        } : Ps(r) ? {
          element: r,
          offset: Cd(r).length
        } : {
          element: r,
          offset: Qr(r).length
        };
      }
    }, $h = (e, n) => {
      const o = pf(e), r = E_(e);
      return {
        element: e,
        bottom: o.top + r,
        height: r,
        pos: o,
        cleanup: n
      };
    }, hx = (e, n) => {
      const o = Ub(e, n), r = be.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + k + "</span>");
      return Mr(o.element, r), $h(r, () => Gs(r));
    }, yx = (e) => $h(be.fromDom(e), Se), z_ = (e, n, o, r) => {
      ov(e, (c, u) => tv(e, n, o, r), o);
    }, Wb = (e, n, o, r, c) => {
      const u = {
        elm: r.element.dom,
        alignToTop: c
      };
      if (gx(e, u))
        return;
      const m = Po(n).top;
      o(n, m, r, c), px(e, u);
    }, tv = (e, n, o, r) => {
      const c = be.fromDom(e.getBody()), u = be.fromDom(e.getDoc());
      yo(c);
      const m = hx(be.fromDom(o.startContainer), o.startOffset);
      Wb(e, u, n, m, r), m.cleanup();
    }, nv = (e, n, o, r) => {
      const c = be.fromDom(e.getDoc());
      Wb(e, c, o, yx(n), r);
    }, ov = (e, n, o) => {
      const r = o.startContainer, c = o.startOffset, u = o.endContainer, m = o.endOffset;
      n(be.fromDom(r), be.fromDom(u));
      const y = e.dom.createRng();
      y.setStart(r, c), y.setEnd(u, m), e.selection.setRng(o);
    }, Ph = (e, n, o, r) => {
      const c = e.pos;
      if (o)
        hd(c.left, c.top, r);
      else {
        const u = c.top - n + e.height;
        hd(c.left, u, r);
      }
    }, sv = (e, n, o, r, c) => {
      const u = o + n, m = r.pos.top, y = r.bottom, v = y - m >= o;
      m < n ? Ph(r, o, c !== !1, e) : m > u ? Ph(r, o, v ? c !== !1 : c === !0, e) : y > u && !v && Ph(r, o, c === !0, e);
    }, O_ = (e, n, o, r) => {
      const c = e.dom.defaultView.innerHeight;
      sv(e, n, c, o, r);
    }, Zb = (e, n, o, r) => {
      const c = e.dom.defaultView.innerHeight;
      sv(e, n, c, o, r);
      const u = ao(o.element), m = Hp(window);
      u.top < m.y ? mm(o.element, r !== !1) : u.top > m.bottom && mm(o.element, r === !0);
    }, rv = (e, n, o) => z_(e, O_, n, o), bx = (e, n, o) => nv(e, n, O_, o), vx = (e, n, o) => z_(e, Zb, n, o), Hs = (e, n, o) => nv(e, n, Zb, o), av = (e, n, o) => {
      (e.inline ? bx : Hs)(e, n, o);
    }, Ai = (e, n, o) => {
      (e.inline ? rv : vx)(e, n, o);
    }, _u = (e) => e.dom.focus(), Fh = (e) => {
      const n = M(e).dom;
      return e.dom === n.activeElement;
    }, Qc = (e = A_()) => O.from(e.dom.activeElement).map(be.fromDom), qb = (e) => Qc(M(e)).filter((n) => e.dom.contains(n.dom)), lp = (e, n) => {
      const o = Ps(n) ? Cd(n).length : Qr(n).length + 1;
      return e > o ? o : e < 0 ? 0 : e;
    }, Gb = (e) => rp.range(e.start, lp(e.soffset, e.start), e.finish, lp(e.foffset, e.finish)), ip = (e, n) => !hf(n.dom) && (ya(e, n) || Is(e, n)), D_ = (e) => (n) => ip(e, n.start) && ip(e, n.finish), t5 = (e) => e.inline, n5 = (e) => rp.range(be.fromDom(e.startContainer), e.startOffset, be.fromDom(e.endContainer), e.endOffset), o5 = (e) => {
      const n = e.getSelection();
      return (!n || n.rangeCount === 0 ? O.none() : O.from(n.getRangeAt(0))).map(n5);
    }, ls = (e) => {
      const n = $i(e);
      return o5(n.dom).filter(D_(e));
    }, Cu = (e, n) => O.from(n).filter(D_(e)).map(Gb), up = (e) => {
      const n = document.createRange();
      try {
        return n.setStart(e.start.dom, e.soffset), n.setEnd(e.finish.dom, e.foffset), O.some(n);
      } catch {
        return O.none();
      }
    }, cv = (e) => {
      const n = t5(e) ? ls(be.fromDom(e.getBody())) : O.none();
      e.bookmark = n.isSome() ? n : e.bookmark;
    }, Vf = (e) => (e.bookmark ? e.bookmark : O.none()).bind((o) => Cu(be.fromDom(e.getBody()), o)).bind(up), gs = (e) => {
      Vf(e).each((n) => e.selection.setRng(n));
    }, lv = { isEditorUIElement: (e) => {
      const n = e.className.toString();
      return n.indexOf("tox-") !== -1 || n.indexOf("mce-") !== -1;
    } }, iv = (e, n) => (ft(n) || (n = 0), setTimeout(e, n)), kx = (e, n) => (ft(n) || (n = 0), setInterval(e, n)), ml = {
      setEditorTimeout: (e, n, o) => iv(() => {
        e.removed || n();
      }, o),
      setEditorInterval: (e, n, o) => {
        const r = kx(() => {
          e.removed ? clearInterval(r) : n();
        }, o);
        return r;
      }
    }, Lm = (e) => e.type === "nodechange" && e.selectionChange, i = (e, n) => {
      const o = () => {
        n.throttle();
      };
      Ks.DOM.bind(document, "mouseup", o), e.on("remove", () => {
        Ks.DOM.unbind(document, "mouseup", o);
      });
    }, d = (e, n) => {
      e.on("mouseup touchend", (o) => {
        n.throttle();
      });
    }, p = (e, n) => {
      d(e, n), e.on("keyup NodeChange AfterSetSelectionRange", (o) => {
        Lm(o) || cv(e);
      });
    }, b = (e) => {
      const n = zf(() => {
        cv(e);
      }, 0);
      e.on("init", () => {
        e.inline && i(e, n), p(e, n);
      }), e.on("remove", () => {
        n.cancel();
      });
    };
    let _;
    const A = Ks.DOM, N = (e) => lv.isEditorUIElement(e), L = (e) => {
      const n = e.classList;
      return n !== void 0 ? n.contains("tox-edit-area") || n.contains("tox-edit-area__iframe") || n.contains("mce-content-body") : !1;
    }, Y = (e, n) => {
      const o = c0(e);
      return A.getParent(n, (c) => N(c) || (o ? e.dom.is(c, o) : !1)) !== null;
    }, de = (e) => {
      try {
        const n = M(be.fromDom(e.getElement()));
        return Qc(n).fold(() => document.body, (o) => o.dom);
      } catch {
        return document.body;
      }
    }, Ee = (e, n) => {
      const o = n.editor;
      b(o), o.on("focusin", () => {
        const r = e.focusedEditor;
        r !== o && (r && r.dispatch("blur", { focusedEditor: o }), e.setActive(o), e.focusedEditor = o, o.dispatch("focus", { blurredEditor: r }), o.focus(!0));
      }), o.on("focusout", () => {
        ml.setEditorTimeout(o, () => {
          const r = e.focusedEditor;
          !Y(o, de(o)) && r === o && (o.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), _ || (_ = (r) => {
        const c = e.activeEditor;
        c && sn(r).each((u) => {
          u.ownerDocument === document && u !== document.body && !Y(c, u) && e.focusedEditor === c && (c.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, A.bind(document, "focusin", _));
    }, yt = (e, n) => {
      e.focusedEditor === n.editor && (e.focusedEditor = null), e.activeEditor || (A.unbind(document, "focusin", _), _ = null);
    }, Ut = (e) => {
      e.on("AddEditor", Ct(Ee, e)), e.on("RemoveEditor", Ct(yt, e));
    }, It = (e, n) => e.dom.getParent(n, (o) => e.dom.getContentEditable(o) === "true"), st = (e) => e.collapsed ? O.from(Dd(e.startContainer, e.startOffset)).map(be.fromDom) : O.none(), Wt = (e, n) => st(n).bind((o) => wf(o) ? O.some(o) : ya(e, o) === !1 ? O.some(e) : O.none()), ot = (e, n) => {
      Wt(be.fromDom(e.getBody()), n).bind((o) => Xc(o.dom)).fold(() => {
        e.selection.normalize();
      }, (o) => e.selection.setRng(o.toRange()));
    }, gn = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, co = (e) => Fh(e) || qb(e).isSome(), Mo = (e) => e.iframeElement && Fh(be.fromDom(e.iframeElement)), Sr = (e) => {
      const n = e.getBody();
      return n && co(be.fromDom(n));
    }, da = (e) => {
      const n = M(be.fromDom(e.getElement()));
      return Qc(n).filter((o) => !L(o.dom) && Y(e, o.dom)).isSome();
    }, xr = (e) => e.inline ? Sr(e) : Mo(e), gl = (e) => xr(e) || da(e), dp = (e) => {
      const n = e.selection, o = e.getBody();
      let r = n.getRng();
      e.quirks.refreshContentEditable(), e.bookmark !== void 0 && xr(e) === !1 && Vf(e).each((u) => {
        e.selection.setRng(u), r = u;
      });
      const c = It(e, n.getNode());
      if (e.dom.isChildOf(c, o)) {
        gn(c), ot(e, r), fp(e);
        return;
      }
      e.inline || (Qt.browser.isOpera() || gn(o), e.getWin().focus()), (Qt.browser.isFirefox() || e.inline) && (gn(o), ot(e, r)), fp(e);
    }, fp = (e) => e.editorManager.setActive(e), uv = (e, n) => {
      e.removed || (n ? fp(e) : dp(e));
    }, Ih = (e, n, o, r, c) => {
      const u = o ? n.startContainer : n.endContainer, m = o ? n.startOffset : n.endOffset;
      return O.from(u).map(be.fromDom).map((y) => !r || !n.collapsed ? au(y, c(y, m)).getOr(y) : y).bind((y) => Oo(y) ? O.some(y) : ec(y).filter(Oo)).map((y) => y.dom).getOr(e);
    }, Ys = (e, n, o) => Ih(e, n, !0, o, (r, c) => Math.min(al(r), c)), Sc = (e, n, o) => Ih(e, n, !1, o, (r, c) => c > 0 ? c - 1 : c), Nc = (e, n) => {
      const o = e;
      for (; e && rn(e) && e.length === 0; )
        e = n ? e.nextSibling : e.previousSibling;
      return e || o;
    }, Yi = (e, n) => {
      let o, r, c;
      if (!n)
        return e;
      r = n.startContainer, c = n.endContainer;
      const u = n.startOffset, m = n.endOffset;
      return o = n.commonAncestorContainer, !n.collapsed && (r === c && m - u < 2 && r.hasChildNodes() && (o = r.childNodes[u]), r.nodeType === 3 && c.nodeType === 3 && (r.length === u ? r = Nc(r.nextSibling, !0) : r = r.parentNode, m === 0 ? c = Nc(c.previousSibling, !1) : c = c.parentNode, r && r === c)) ? r : o && o.nodeType === 3 ? o.parentNode : o;
    }, zi = (e, n, o, r) => {
      let c;
      const u = [], m = e.getRoot();
      if (o = e.getParent(o || Ys(m, n, n.collapsed), e.isBlock), r = e.getParent(r || Sc(m, n, n.collapsed), e.isBlock), o && o !== m && u.push(o), o && r && o !== r) {
        c = o;
        const y = new rr(o, m);
        for (; (c = y.next()) && c !== r; )
          e.isBlock(c) && u.push(c);
      }
      return r && o !== r && r !== m && u.push(r), u;
    }, mp = (e, n, o) => O.from(n).map((r) => {
      const c = e.nodeIndex(r), u = e.createRng();
      return u.setStart(r.parentNode, c), u.setEnd(r.parentNode, c + 1), o && (Eb(e, u, r, !0), Eb(e, u, r, !1)), u;
    }), xc = (e, n) => ae(n, (o) => {
      const r = e.dispatch("GetSelectionRange", { range: o });
      return r.range !== o ? r.range : o;
    }), dv = (e) => An(e) === "img" ? 1 : ju(e).fold(() => Qr(e).length, (n) => n.length), Lh = (e) => ju(e).filter((n) => n.trim().length !== 0 || n.indexOf(Te) > -1).isSome(), od = [
      "img",
      "br"
    ], _a = (e) => Lh(e) || Ae(od, An(e)), R_ = (e) => kf(e, _a), wx = (e) => M_(e, _a), M_ = (e, n) => {
      const o = (r) => {
        const c = Qr(r);
        for (let u = c.length - 1; u >= 0; u--) {
          const m = c[u];
          if (n(m))
            return O.some(m);
          const y = o(m);
          if (y.isSome())
            return y;
        }
        return O.none();
      };
      return o(e);
    }, fv = "[data-mce-autocompleter]", _x = (e, n) => {
      if (N_(be.fromDom(e.getBody())).isNone()) {
        const o = be.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
        Kr(o, be.fromDom(n.extractContents())), n.insertNode(o.dom), ec(o).each((r) => r.dom.normalize()), wx(o).map((r) => {
          e.selection.setCursorLocation(r.dom, dv(r));
        });
      }
    }, mv = (e) => Js(e, fv), N_ = (e) => kd(e, fv), Hh = (e, n) => N_(n).each((o) => {
      const r = e.selection.getBookmark();
      $a(o), e.selection.moveToBookmark(r);
    }), w7 = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, Vh = (e, n, o) => {
      const r = o ? "lastChild" : "firstChild", c = o ? "prev" : "next";
      if (e[r])
        return e[r];
      if (e !== n) {
        let u = e[c];
        if (u)
          return u;
        for (let m = e.parent; m && m !== n; m = m.parent)
          if (u = m[c], u)
            return u;
      }
    }, _7 = (e) => {
      if (!Gl(e.value))
        return !1;
      const n = e.parent;
      return !(n && (n.name !== "span" || n.attr("style")) && /^[ ]+$/.test(e.value));
    }, r5 = (e) => {
      const n = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || n;
    };
    class pl {
      constructor(n, o) {
        this.name = n, this.type = o, o === 1 && (this.attributes = [], this.attributes.map = {});
      }
      static create(n, o) {
        const r = new pl(n, w7[n] || 1);
        return o && Jt(o, (c, u) => {
          r.attr(u, c);
        }), r;
      }
      replace(n) {
        const o = this;
        return n.parent && n.remove(), o.insert(n, o), o.remove(), o;
      }
      attr(n, o) {
        const r = this;
        let c;
        if (typeof n != "string")
          return n != null && Jt(n, (u, m) => {
            r.attr(m, u);
          }), r;
        if (c = r.attributes) {
          if (o !== void 0) {
            if (o === null) {
              if (n in c.map) {
                delete c.map[n];
                let u = c.length;
                for (; u--; )
                  if (c[u].name === n)
                    return c.splice(u, 1), r;
              }
              return r;
            }
            if (n in c.map) {
              let u = c.length;
              for (; u--; )
                if (c[u].name === n) {
                  c[u].value = o;
                  break;
                }
            } else
              c.push({
                name: n,
                value: o
              });
            return c.map[n] = o, r;
          }
          return c.map[n];
        }
      }
      clone() {
        const n = this, o = new pl(n.name, n.type);
        let r;
        if (r = n.attributes) {
          const c = [];
          c.map = {};
          for (let u = 0, m = r.length; u < m; u++) {
            const y = r[u];
            y.name !== "id" && (c[c.length] = {
              name: y.name,
              value: y.value
            }, c.map[y.name] = y.value);
          }
          o.attributes = c;
        }
        return o.value = n.value, o;
      }
      wrap(n) {
        const o = this;
        return o.parent.insert(n, o), n.append(o), o;
      }
      unwrap() {
        const n = this;
        for (let o = n.firstChild; o; ) {
          const r = o.next;
          n.insert(o, n, !0), o = r;
        }
        n.remove();
      }
      remove() {
        const n = this, o = n.parent, r = n.next, c = n.prev;
        return o && (o.firstChild === n ? (o.firstChild = r, r && (r.prev = null)) : c.next = r, o.lastChild === n ? (o.lastChild = c, c && (c.next = null)) : r.prev = c, n.parent = n.next = n.prev = null), n;
      }
      append(n) {
        const o = this;
        n.parent && n.remove();
        const r = o.lastChild;
        return r ? (r.next = n, n.prev = r, o.lastChild = n) : o.lastChild = o.firstChild = n, n.parent = o, n;
      }
      insert(n, o, r) {
        n.parent && n.remove();
        const c = o.parent || this;
        return r ? (o === c.firstChild ? c.firstChild = n : o.prev.next = n, n.prev = o.prev, n.next = o, o.prev = n) : (o === c.lastChild ? c.lastChild = n : o.next.prev = n, n.next = o.next, n.prev = o, o.next = n), n.parent = c, n;
      }
      getAll(n) {
        const o = this, r = [];
        for (let c = o.firstChild; c; c = Vh(c, o))
          c.name === n && r.push(c);
        return r;
      }
      children() {
        const n = this, o = [];
        for (let r = n.firstChild; r; r = r.next)
          o.push(r);
        return o;
      }
      empty() {
        const n = this;
        if (n.firstChild) {
          const o = [];
          for (let c = n.firstChild; c; c = Vh(c, n))
            o.push(c);
          let r = o.length;
          for (; r--; ) {
            const c = o[r];
            c.parent = c.firstChild = c.lastChild = c.next = c.prev = null;
          }
        }
        return n.firstChild = n.lastChild = null, n;
      }
      isEmpty(n, o = {}, r) {
        const c = this;
        let u = c.firstChild;
        if (r5(c))
          return !1;
        if (u)
          do {
            if (u.type === 1) {
              if (u.attr("data-mce-bogus"))
                continue;
              if (n[u.name] || r5(u))
                return !1;
            }
            if (u.type === 8 || u.type === 3 && !_7(u) || u.type === 3 && u.parent && o[u.parent.name] && Gl(u.value) || r && r(u))
              return !1;
          } while (u = Vh(u, c));
        return !0;
      }
      walk(n) {
        return Vh(this, null, n);
      }
    }
    const C7 = (e, n) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(e.substr(n)), Cx = (e, n, o = 0) => {
      const r = e.toLowerCase();
      if (r.indexOf("[if ", o) !== -1 && C7(r, o)) {
        const c = r.indexOf("[endif]", o);
        return r.indexOf(">", c);
      } else if (n) {
        const c = r.indexOf(">", o);
        return c !== -1 ? c : r.length;
      } else {
        const c = /--!?>/g;
        c.lastIndex = o;
        const u = c.exec(e);
        return u ? u.index + u[0].length : r.length;
      }
    }, a5 = (e, n, o) => {
      const r = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g, c = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g, u = e.getVoidElements();
      let m = 1, y = o;
      for (; m !== 0; )
        for (r.lastIndex = y; ; ) {
          const v = r.exec(n);
          if (v === null)
            return y;
          if (v[1] === "!") {
            On(v[2], "--") ? y = Cx(n, !1, v.index + 3) : y = Cx(n, !0, v.index + 1);
            break;
          } else {
            c.lastIndex = r.lastIndex;
            const x = c.exec(n);
            if (oe(x) || x.index !== r.lastIndex)
              continue;
            v[1] === "/" ? m -= 1 : Gn(u, v[2]) || (m += 1), y = r.lastIndex + x[0].length;
            break;
          }
        }
      return y;
    }, c5 = (e, n) => {
      const o = new RegExp(["\\s?(" + e.join("|") + ')="[^"]+"'].join("|"), "gi");
      return n.replace(o, "");
    }, l5 = (e, n) => {
      const o = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g, r = e.schema;
      let c = c5(e.getTempAttrs(), n);
      const u = r.getVoidElements();
      let m;
      for (; m = o.exec(c); ) {
        const y = o.lastIndex, v = m[0].length;
        let x;
        u[m[1]] ? x = y : x = a5(r, c, y), c = c.substring(0, y - v) + c.substring(x), o.lastIndex = y - v;
      }
      return P(c);
    }, S7 = l5, x7 = (e, n) => {
      const o = Ir(e), r = new RegExp(`^(<${o}[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/${o}>[\r
]*|<br \\/>[\r
]*)$`);
      return n.replace(r, "");
    }, T7 = (e, n, o) => {
      let r;
      return n.format === "raw" ? r = it.trim(S7(e.serializer, o.innerHTML)) : n.format === "text" ? (r = P(o.innerText), r = r === `
` ? "" : r) : n.format === "tree" ? r = e.serializer.serialize(o, n) : r = x7(e, e.serializer.serialize(o, n)), n.format !== "text" && !vm(be.fromDom(o)) && ie(r) ? it.trim(r) : r;
    }, B_ = (e, n) => O.from(e.getBody()).fold(Pe(n.format === "tree" ? new pl("body", 11) : ""), (o) => T7(e, n, o)), i5 = it.each, Sx = (e) => ({ compare: (o, r) => {
      if (o.nodeName !== r.nodeName)
        return !1;
      const c = (m) => {
        const y = {};
        return i5(e.getAttribs(m), (v) => {
          const x = v.nodeName.toLowerCase();
          x.indexOf("_") !== 0 && x !== "style" && x.indexOf("data-") !== 0 && (y[x] = e.getAttrib(m, x));
        }), y;
      }, u = (m, y) => {
        let v, x;
        for (x in m)
          if (Gn(m, x)) {
            if (v = y[x], typeof v > "u" || m[x] !== v)
              return !1;
            delete y[x];
          }
        for (x in y)
          if (Gn(y, x))
            return !1;
        return !0;
      };
      return !u(c(o), c(r)) || !u(e.parseStyle(e.getAttrib(o, "style")), e.parseStyle(e.getAttrib(r, "style"))) ? !1 : !Jl(o) && !Jl(r);
    } }), xx = it.makeMap, Tx = (e) => {
      const n = [];
      e = e || {};
      const o = e.indent, r = xx(e.indent_before || ""), c = xx(e.indent_after || ""), u = Ls.getEncodeFunc(e.entity_encoding || "raw", e.entities), m = e.element_format !== "xhtml";
      return {
        start: (y, v, x) => {
          let R, F, W, K;
          if (o && r[y] && n.length > 0 && (K = n[n.length - 1], K.length > 0 && K !== `
` && n.push(`
`)), n.push("<", y), v)
            for (R = 0, F = v.length; R < F; R++)
              W = v[R], n.push(" ", W.name, '="', u(W.value, !0), '"');
          !x || m ? n[n.length] = ">" : n[n.length] = " />", x && o && c[y] && n.length > 0 && (K = n[n.length - 1], K.length > 0 && K !== `
` && n.push(`
`));
        },
        end: (y) => {
          let v;
          n.push("</", y, ">"), o && c[y] && n.length > 0 && (v = n[n.length - 1], v.length > 0 && v !== `
` && n.push(`
`));
        },
        text: (y, v) => {
          y.length > 0 && (n[n.length] = v ? y : u(y));
        },
        cdata: (y) => {
          n.push("<![CDATA[", y, "]]>");
        },
        comment: (y) => {
          n.push("<!--", y, "-->");
        },
        pi: (y, v) => {
          v ? n.push("<?", y, " ", u(v), "?>") : n.push("<?", y, "?>"), o && n.push(`
`);
        },
        doctype: (y) => {
          n.push("<!DOCTYPE", y, ">", o ? `
` : "");
        },
        reset: () => {
          n.length = 0;
        },
        getContent: () => n.join("").replace(/\n$/, "")
      };
    }, gp = (e, n = pi()) => {
      const o = Tx(e);
      return e = e || {}, e.validate = "validate" in e ? e.validate : !0, { serialize: (c) => {
        const u = e.validate, m = {
          3: (v) => {
            o.text(v.value, v.raw);
          },
          8: (v) => {
            o.comment(v.value);
          },
          7: (v) => {
            o.pi(v.name, v.value);
          },
          10: (v) => {
            o.doctype(v.value);
          },
          4: (v) => {
            o.cdata(v.value);
          },
          11: (v) => {
            if (v = v.firstChild)
              do
                y(v);
              while (v = v.next);
          }
        };
        o.reset();
        const y = (v) => {
          const x = m[v.type];
          if (x)
            x(v);
          else {
            const R = v.name, F = R in n.getVoidElements();
            let W = v.attributes;
            if (u && W && W.length > 1) {
              const K = [];
              K.map = {};
              const ee = n.getElementRule(v.name);
              if (ee) {
                for (let J = 0, te = ee.attributesOrder.length; J < te; J++) {
                  const ve = ee.attributesOrder[J];
                  if (ve in W.map) {
                    const De = W.map[ve];
                    K.map[ve] = De, K.push({
                      name: ve,
                      value: De
                    });
                  }
                }
                for (let J = 0, te = W.length; J < te; J++) {
                  const ve = W[J].name;
                  if (!(ve in K.map)) {
                    const De = W.map[ve];
                    K.map[ve] = De, K.push({
                      name: ve,
                      value: De
                    });
                  }
                }
                W = K;
              }
            }
            if (o.start(R, W, F), !F) {
              let K = v.firstChild;
              if (K) {
                (R === "pre" || R === "textarea") && K.type === 3 && K.value[0] === `
` && o.text(`
`, !0);
                do
                  y(K);
                while (K = K.next);
              }
              o.end(R);
            }
          }
        };
        return c.type === 1 && !e.inner ? y(c) : c.type === 3 ? m[3](c) : m[11](c), o.getContent();
      } };
    }, u5 = /* @__PURE__ */ new Set();
    X([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (n) => {
      u5.add(n);
    });
    const d5 = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], Ex = (e, n) => $e(e.parseStyle(e.getAttrib(n, "style"))), E7 = (e) => u5.has(e), A7 = (e, n) => ds(Ex(e, n), (o) => !E7(o)), z7 = (e) => ue(e, (n) => Oe(d5, (o) => On(n, o))), O7 = (e, n, o) => {
      const r = Ex(e, n), c = Ex(e, o), u = (m) => {
        var y, v;
        const x = (y = e.getStyle(n, m)) !== null && y !== void 0 ? y : "", R = (v = e.getStyle(o, m)) !== null && v !== void 0 ? v : "";
        return Bo(x) && Bo(R) && x !== R;
      };
      return Oe(r, (m) => {
        const y = (v) => Oe(v, (x) => x === m);
        if (!y(c) && y(d5)) {
          const v = z7(c);
          return Oe(v, u);
        } else
          return u(m);
      });
    }, f5 = (e, n, o) => O.from(o.container()).filter(rn).exists((r) => {
      const c = e ? 0 : -1;
      return n(r.data.charAt(o.offset() + c));
    }), Ax = Ct(f5, !0, Yg), zx = Ct(f5, !1, Yg), D7 = (e) => {
      const n = e.container();
      return rn(n) && (n.data.length === 0 || S(n.data) && Oh.isBookmarkNode(n.parentNode));
    }, Hd = (e, n) => (o) => O.from(y0(e ? 0 : -1, o)).filter(n).isSome(), Ox = (e) => Up(e) && Gr(be.fromDom(e), "display") === "block", Dx = (e) => Dr(e) && !ug(e), R7 = Hd(!0, Ox), M7 = Hd(!1, Ox), gv = Hd(!0, tc), pv = Hd(!1, tc), m5 = Hd(!0, mi), g5 = Hd(!1, mi), Hm = Hd(!0, Dx), pp = Hd(!1, Dx), p5 = (e) => e.slice(0, -1), h5 = (e, n, o) => ya(n, e) ? p5(rg(e, (r) => o(r) || Is(r, n))) : [], y5 = (e, n) => h5(e, n, Mn), Vm = (e, n) => [e].concat(y5(e, n)), Rx = (e, n, o) => Rm(e, n, o, D7), b5 = (e, n) => Wn(Vm(be.fromDom(n.container()), e), xa), v5 = (e, n, o) => Rx(e, n.dom, o).forall((r) => b5(n, o).fold(() => td(r, o, n.dom) === !1, (c) => td(r, o, n.dom) === !1 && ya(c, be.fromDom(r.container())))), k5 = (e, n, o) => b5(n, o).fold(() => Rx(e, n.dom, o).forall((r) => td(r, o, n.dom) === !1), (r) => Rx(e, r.dom, o).isNone()), Mx = Ct(k5, !1), w5 = Ct(k5, !0), N7 = Ct(v5, !1), B7 = Ct(v5, !0), $7 = (e) => bh(e).exists(_d), $_ = (e, n, o) => {
      const r = ue(Vm(be.fromDom(o.container()), n), xa), c = Go(r).getOr(n);
      return Ci(e, c.dom, o).filter($7);
    }, Nx = (e, n) => bh(n).exists(_d) || $_(!0, e, n).isSome(), Bx = (e, n) => pb(n).exists(_d) || $_(!1, e, n).isSome(), P7 = Ct($_, !1), F7 = Ct($_, !0), _5 = (e) => Ke.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), C5 = (e, n) => {
      const o = ue(Vm(be.fromDom(n.container()), e), xa);
      return Go(o).getOr(e);
    }, S5 = (e, n) => _5(n) ? zx(n) : zx(n) || qi(C5(e, n).dom, n).exists(zx), Kn = (e, n) => _5(n) ? Ax(n) : Ax(n) || Si(C5(e, n).dom, n).exists(Ax), x5 = (e) => Ae([
      "pre",
      "pre-wrap"
    ], e), P_ = (e) => bh(e).bind((n) => bd(n, Oo)).exists((n) => x5(Gr(n, "white-space"))), I7 = (e, n) => qi(e.dom, n).isNone(), $x = (e, n) => Si(e.dom, n).isNone(), L7 = (e, n) => I7(e, n) || $x(e, n) || Mx(e, n) || w5(e, n) || Bx(e, n) || Nx(e, n), H7 = (e) => Q(e) && Dr(e) && g0(e), V7 = (e) => (n) => H7(new rr(n, e).next()), j7 = (e, n) => {
      const o = Si(e.dom, n).getOr(n), r = V7(e.dom);
      return n.isAtEnd() && (r(n.container()) || r(o.container()));
    }, U7 = (e, n) => P_(n) ? !1 : L7(e, n) || S5(e, n) || Kn(e, n), jh = (e, n) => P_(n) ? !1 : Mx(e, n) || N7(e, n) || Bx(e, n) || S5(e, n), T5 = (e) => {
      const n = e.container(), o = e.offset();
      return rn(n) && o < n.data.length ? Ke(n, o + 1) : e;
    }, Px = (e, n) => P_(n) ? !1 : w5(e, n) || B7(e, n) || Nx(e, n) || Kn(e, n) || j7(e, n), E5 = (e, n) => jh(e, n) || Px(e, T5(n)), Uo = (e, n) => $m(e.charAt(n)), W7 = (e) => {
      const n = e.container();
      return rn(n) && Yt(n.data, Te);
    }, ys = (e) => {
      const n = e.split("");
      return ae(n, (o, r) => $m(o) && r > 0 && r < n.length - 1 && _b(n[r - 1]) && _b(n[r + 1]) ? " " : o).join("");
    }, A5 = (e, n) => {
      const o = n.data, r = Ke(n, 0);
      return Uo(o, 0) && !E5(e, r) ? (n.data = " " + o.slice(1), !0) : !1;
    }, QI = (e) => {
      const n = e.data, o = ys(n);
      return o !== n ? (e.data = o, !0) : !1;
    }, eL = (e, n) => {
      const o = n.data, r = Ke(n, o.length - 1);
      return Uo(o, o.length - 1) && !E5(e, r) ? (n.data = o.slice(0, -1) + " ", !0) : !1;
    }, Z7 = (e, n) => O.some(n).filter(W7).bind((o) => {
      const r = o.container();
      return A5(e, r) || QI(r) || eL(e, r) ? O.some(o) : O.none();
    }), tL = (e) => {
      const n = be.fromDom(e.getBody());
      e.selection.isCollapsed() && Z7(n, Ke.fromRangeStart(e.selection.getRng())).each((o) => {
        e.selection.setRng(o.toRange());
      });
    }, q7 = (e, n, o) => {
      if (o === 0)
        return;
      const r = be.fromDom(e), c = vf(r, xa).getOr(r), u = e.data.slice(n, n + o), m = n + o >= e.data.length && Px(c, Ke(e, e.data.length)), y = n === 0 && jh(c, Ke(e, 0));
      e.replaceData(n, o, Hk(u, 4, y, m));
    }, F_ = (e, n) => {
      const o = e.data.slice(n), r = o.length - Ya(o).length;
      q7(e, n, r);
    }, Fx = (e, n) => {
      const o = e.data.slice(0, n), r = o.length - sa(o).length;
      q7(e, n - r, r);
    }, go = (e, n, o, r = !0) => {
      const c = sa(e.data).length, u = r ? e : n, m = r ? n : e;
      return r ? u.appendData(m.data) : u.insertData(0, m.data), Gs(be.fromDom(m)), o && F_(u, c), u;
    }, G7 = (e, n) => {
      const o = e.container(), r = e.offset();
      return Ke.isTextPosition(e) === !1 && o === n.parentNode && r > Ke.before(n).offset();
    }, K7 = (e, n) => G7(n, e) ? Ke(n.container(), n.offset() - 1) : n, Y7 = (e) => rn(e) ? Ke(e, 0) : Ke.before(e), hv = (e) => rn(e) ? Ke(e, e.data.length) : Ke.after(e), Ix = (e) => Do(e.previousSibling) ? O.some(hv(e.previousSibling)) : e.previousSibling ? hu(e.previousSibling) : O.none(), z5 = (e) => Do(e.nextSibling) ? O.some(Y7(e.nextSibling)) : e.nextSibling ? Xc(e.nextSibling) : O.none(), X7 = (e, n) => {
      const o = Ke.before(n.previousSibling ? n.previousSibling : n.parentNode);
      return qi(e, o).fold(() => Si(e, Ke.after(n)), O.some);
    }, J7 = (e, n) => Si(e, Ke.after(n)).fold(() => qi(e, Ke.before(n)), O.some), O5 = (e, n) => Ix(n).orThunk(() => z5(n)).orThunk(() => X7(e, n)), Q7 = (e, n) => z5(n).orThunk(() => Ix(n)).orThunk(() => J7(e, n)), nL = (e, n, o) => e ? Q7(n, o) : O5(n, o), oL = (e, n, o) => nL(e, n, o).map(Ct(K7, o)), D5 = (e, n, o) => {
      o.fold(() => {
        e.focus();
      }, (r) => {
        e.selection.setRng(r.toRange(), n);
      });
    }, eR = (e) => (n) => n.dom === e, tR = (e, n) => n && Gn(e.schema.getBlockElements(), An(n)), nR = (e) => {
      if (ta(e)) {
        const n = be.fromHtml('<br data-mce-bogus="1">');
        return ff(e), Kr(e, n), O.some(Ke.before(n.dom));
      } else
        return O.none();
    }, R5 = (e, n, o) => {
      const r = sl(e).filter(Ps), c = lf(e).filter(Ps);
      return Gs(e), Hc(r, c, n, (u, m, y) => {
        const v = u.dom, x = m.dom, R = v.data.length;
        return go(v, x, o), y.container() === x ? Ke(v, R) : y;
      }).orThunk(() => (o && (r.each((u) => Fx(u.dom, u.dom.length)), c.each((u) => F_(u.dom, 0))), n));
    }, oR = (e, n) => Gn(e.schema.getTextInlineElements(), An(n)), Qo = (e, n, o, r = !0) => {
      const c = oL(n, e.getBody(), o.dom), u = vf(o, Ct(tR, e), eR(e.getBody())), m = R5(o, c, oR(e, o));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : u.bind(nR).fold(() => {
        r && D5(e, n, m);
      }, (y) => {
        r && D5(e, n, O.some(y));
      });
    }, M5 = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, I_ = (e) => M5.test(e), hp = (e, n) => El(be.fromDom(n), uS(e)), N5 = (e) => Ks.DOM.getStyle(e, "direction", !0) === "rtl" || I_(e.textContent), B5 = (e, n, o) => ue(Ks.DOM.getParents(o.container(), "*", n), e), jm = (e, n, o) => {
      const r = B5(e, n, o);
      return O.from(r[r.length - 1]);
    }, $5 = (e, n, o) => {
      const r = Pf(n, e), c = Pf(o, e);
      return r && r === c;
    }, sR = (e) => Rr(e) || ks(e), Xi = (e, n) => {
      if (!n)
        return n;
      const o = n.container(), r = n.offset();
      return e ? St(o) ? rn(o.nextSibling) ? Ke(o.nextSibling, 0) : Ke.after(o) : Rr(n) ? Ke(o, r + 1) : n : St(o) ? rn(o.previousSibling) ? Ke(o.previousSibling, o.previousSibling.data.length) : Ke.before(o) : ks(n) ? Ke(o, r - 1) : n;
    }, P5 = Ct(Xi, !0), F5 = Ct(Xi, !1), I5 = (e, n) => {
      const o = (r) => r.stopImmediatePropagation();
      e.on("beforeinput input", o, !0), e.getDoc().execCommand(n), e.off("beforeinput input", o);
    }, Lx = (e) => I5(e, "Delete"), rR = (e) => I5(e, "ForwardDelete"), aR = (e) => (n) => Is(e, be.fromDom(n.dom.parentNode)), cR = (e) => jc(e) || zl(e), L_ = (e, n) => ya(e, n) ? bd(n, cR, aR(e)) : O.none(), yv = (e, n = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !n });
    }, Hx = (e, n, o) => qs(Xc(o), hu(o), (r, c) => {
      const u = Xi(!0, r), m = Xi(!1, c), y = Xi(!1, n);
      return e ? Si(o, y).exists((v) => v.isEqual(m) && n.isEqual(u)) : qi(o, y).exists((v) => v.isEqual(u) && n.isEqual(m));
    }).getOr(!0), L5 = (e) => (ic(e) ? sl(e) : rl(e)).bind(L5).orThunk(() => O.some(e)), H5 = (e, n, o, r = !0) => {
      var c;
      n.deleteContents();
      const u = L5(o).getOr(o), m = be.fromDom((c = e.dom.getParent(u.dom, e.dom.isBlock)) !== null && c !== void 0 ? c : o.dom);
      if (m.dom === e.getBody() ? yv(e, r) : ta(m) && (Pa(m), r && e.selection.setCursorLocation(m.dom, 0)), !Is(o, m)) {
        const y = hs(ec(m), o) ? [] : cm(m);
        X(y.concat(Qr(o)), (v) => {
          !Is(v, m) && !ya(v, m) && ta(v) && Gs(v);
        });
      }
    }, lR = (e) => (n) => Is(e, n), Vx = (e) => ia(e, "td,th"), iR = (e, n) => {
      const o = (x) => tp(be.fromDom(x), n), r = o(e.startContainer), c = o(e.endContainer), u = r.isSome(), m = c.isSome(), y = qs(r, c, Is).getOr(!1);
      return {
        startTable: r,
        endTable: c,
        isStartInTable: u,
        isEndInTable: m,
        isSameTable: y,
        isMultiTable: !y && u && m
      };
    }, jx = (e, n) => ({
      start: e,
      end: n
    }), uR = (e, n, o) => ({
      rng: e,
      table: n,
      cells: o
    }), bv = vi.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), vv = (e, n) => Js(be.fromDom(e), "td,th", n), V5 = (e) => !Is(e.start, e.end), j5 = (e, n) => tp(e.start, n).bind((o) => tp(e.end, n).bind((r) => as(Is(o, r), o))), Uh = (e, n) => !V5(e) && j5(e, n).exists((o) => {
      const r = o.dom.rows;
      return r.length === 1 && r[0].cells.length === 1;
    }), dR = (e, n) => {
      const o = vv(e.startContainer, n), r = vv(e.endContainer, n);
      return qs(o, r, jx);
    }, U5 = (e) => (n) => tp(n, e).bind((o) => Ro(Vx(o)).map((r) => jx(n, r))), fR = (e) => (n) => tp(n, e).bind((o) => Go(Vx(o)).map((r) => jx(r, n))), Ux = (e) => (n) => j5(n, e).map((o) => uR(n, o, Vx(o))), Wx = (e, n, o, r) => {
      if (o.collapsed || !e.forall(V5))
        return O.none();
      if (n.isSameTable) {
        const c = e.bind(Ux(r));
        return O.some({
          start: c,
          end: c
        });
      } else {
        const c = vv(o.startContainer, r), u = vv(o.endContainer, r), m = c.bind(U5(r)).bind(Ux(r)), y = u.bind(fR(r)).bind(Ux(r));
        return O.some({
          start: m,
          end: y
        });
      }
    }, Zx = (e, n) => ko(e, (o) => Is(o, n)), qx = (e) => qs(Zx(e.cells, e.rng.start), Zx(e.cells, e.rng.end), (n, o) => e.cells.slice(n, o + 1)), mR = (e, n, o) => e.exists((r) => Uh(r, o) && xh(r.start, n)), W5 = (e, n) => {
      const { startTable: o, endTable: r } = n, c = e.cloneRange();
      return o.each((u) => c.setStartAfter(u.dom)), r.each((u) => c.setEndBefore(u.dom)), c;
    }, gR = (e, n, o, r) => Wx(e, n, o, r).bind(({ start: c, end: u }) => c.or(u)).bind((c) => {
      const { isSameTable: u } = n, m = qx(c).getOr([]);
      if (u && c.cells.length === m.length)
        return O.some(bv.fullTable(c.table));
      if (m.length > 0) {
        if (u)
          return O.some(bv.partialTable(m, O.none()));
        {
          const y = W5(o, n);
          return O.some(bv.partialTable(m, O.some({
            ...n,
            rng: y
          })));
        }
      } else
        return O.none();
    }), pR = (e, n, o, r) => Wx(e, n, o, r).bind(({ start: c, end: u }) => {
      const m = c.bind(qx).getOr([]), y = u.bind(qx).getOr([]);
      if (m.length > 0 && y.length > 0) {
        const v = W5(o, n);
        return O.some(bv.multiTable(m, y, v));
      } else
        return O.none();
    }), Wh = (e, n) => {
      const o = lR(e), r = dR(n, o), c = iR(n, o);
      return mR(r, n, o) ? r.map((u) => bv.singleCellTable(n, u.start)) : c.isMultiTable ? pR(r, c, n, o) : gR(r, c, n, o);
    }, Z5 = (e) => X(e, (n) => {
      $r(n, "contenteditable"), Pa(n);
    }), hR = (e, n) => O.from(e.dom.getParent(n, e.dom.isBlock)).map(be.fromDom), na = (e, n, o) => {
      o.each((r) => {
        n ? Gs(r) : (Pa(r), e.selection.setCursorLocation(r.dom, 0));
      });
    }, Kb = (e, n, o, r) => {
      const c = o.cloneRange();
      r ? (c.setStart(o.startContainer, o.startOffset), c.setEndAfter(n.dom.lastChild)) : (c.setStartBefore(n.dom.firstChild), c.setEnd(o.endContainer, o.endOffset)), Su(e, c, n, !1).each((u) => u());
    }, yR = (e) => {
      const n = Ld(e), o = be.fromDom(e.selection.getNode());
      yd(o.dom) && ta(o) ? e.selection.setCursorLocation(o.dom, 0) : e.selection.collapse(!0), n.length > 1 && Oe(n, (r) => Is(r, o)) && ms(o, "data-mce-selected", "1");
    }, $l = (e, n, o) => O.some(() => {
      const r = e.selection.getRng(), c = o.bind(({ rng: u, isStartInTable: m }) => {
        const y = hR(e, m ? u.endContainer : u.startContainer);
        u.deleteContents(), na(e, m, y.filter(ta));
        const v = m ? n[0] : n[n.length - 1];
        return Kb(e, v, r, m), ta(v) ? O.none() : O.some(m ? n.slice(1) : n.slice(0, -1));
      }).getOr(n);
      Z5(c), yR(e);
    }), wr = (e, n, o, r) => O.some(() => {
      const c = e.selection.getRng(), u = n[0], m = o[o.length - 1];
      Kb(e, u, c, !0), Kb(e, m, c, !1);
      const y = ta(u) ? n : n.slice(1), v = ta(m) ? o : o.slice(0, -1);
      Z5(y.concat(v)), r.deleteContents(), yR(e);
    }), Su = (e, n, o, r = !0) => O.some(() => {
      H5(e, n, o, r);
    }), bR = (e, n) => O.some(() => Qo(e, !1, n)), q5 = (e, n, o) => Wh(n, o).bind((r) => r.fold(Ct(Su, e), Ct(bR, e), Ct($l, e), Ct(wr, e))), Gx = (e, n) => Yb(e, n), Kx = (e, n, o, r) => Xx(n, r).fold(() => q5(e, n, o), (c) => Gx(e, c)), G5 = (e, n, o) => {
      const r = be.fromDom(e.getBody()), c = e.selection.getRng();
      return o.length !== 0 ? $l(e, o, O.none()) : Kx(e, r, c, n);
    }, Yx = (e, n) => Wn(Vm(n, e), pc), Xx = (e, n) => Wn(Vm(n, e), su("caption")), vR = (e, n, o, r, c) => bb(o, e.getBody(), c).bind((u) => Yx(n, be.fromDom(u.getNode())).bind((m) => Is(m, r) ? O.none() : O.some(Se))), Yb = (e, n) => O.some(() => {
      Pa(n), e.selection.setCursorLocation(n.dom, 0);
    }), K5 = (e, n, o, r) => Xc(e.dom).bind((c) => hu(e.dom).map((u) => n ? o.isEqual(c) && r.isEqual(u) : o.isEqual(u) && r.isEqual(c))).getOr(!0), Vd = (e, n) => Yb(e, n), kR = (e, n, o) => Xx(e, be.fromDom(o.getNode())).fold(() => O.some(Se), (r) => as(!Is(r, n), Se)), wR = (e, n, o, r, c) => bb(o, e.getBody(), c).fold(() => O.some(Se), (u) => K5(r, o, c, u) ? Vd(e, r) : kR(n, r, u)), sL = (e, n, o, r) => {
      const c = Ke.fromRangeStart(e.selection.getRng());
      return Yx(o, r).bind((u) => ta(u) ? Yb(e, u) : vR(e, o, n, u, c));
    }, Jx = (e, n, o, r) => {
      const c = Ke.fromRangeStart(e.selection.getRng());
      return ta(r) ? Yb(e, r) : wR(e, o, n, r, c);
    }, Y5 = (e, n) => e ? m5(n) : g5(n), kv = (e, n) => {
      const o = Ke.fromRangeStart(e.selection.getRng());
      return Y5(n, o) || Ci(n, e.getBody(), o).exists((r) => Y5(n, r));
    }, _R = (e, n, o) => {
      const r = be.fromDom(e.getBody());
      return Xx(r, o).fold(() => sL(e, n, r, o).orThunk(() => as(kv(e, n), Se)), (c) => Jx(e, n, r, c));
    }, yp = (e, n) => {
      const o = be.fromDom(e.selection.getStart(!0)), r = Ld(e);
      return e.selection.isCollapsed() && r.length === 0 ? _R(e, n, o) : G5(e, o, r);
    }, hl = (e, n) => {
      for (; n && n !== e; ) {
        if (Zl(n) || Dr(n))
          return n;
        n = n.parentNode;
      }
      return null;
    }, Zh = (e, n) => {
      n(e), e.firstChild && Zh(e.firstChild, n), e.next && Zh(e.next, n);
    }, _r = (e, n, o, r) => {
      const c = o.name;
      for (let u = 0, m = e.length; u < m; u++) {
        const y = e[u];
        if (y.name === c) {
          const v = r.nodes[c];
          v ? v.nodes.push(o) : r.nodes[c] = {
            filter: y,
            nodes: [o]
          };
        }
      }
      if (o.attributes)
        for (let u = 0, m = n.length; u < m; u++) {
          const y = n[u], v = y.name;
          if (v in o.attributes.map) {
            const x = r.attributes[v];
            x ? x.nodes.push(o) : r.attributes[v] = {
              filter: y,
              nodes: [o]
            };
          }
        }
    }, wv = (e, n, o) => {
      const r = {
        nodes: {},
        attributes: {}
      };
      return o.firstChild && Zh(o.firstChild, (c) => {
        _r(e, n, c, r);
      }), r;
    }, Qx = (e, n) => {
      const o = (r) => {
        Jt(r, (c) => {
          const u = ue(c.nodes, (m) => Q(m.parent));
          X(c.filter.callbacks, (m) => {
            m(u, c.filter.name, n);
          });
        });
      };
      o(e.nodes), o(e.attributes);
    }, e3 = (e, n, o, r = {}) => {
      const c = wv(e, n, o);
      Qx(c, r);
    }, _v = (e, n, o, r) => {
      n.insert && o[r.name] ? r.empty().append(new pl("br", 1)) : r.empty().append(new pl("#text", 3)).value = Te;
    }, t3 = (e) => H_(e, "#text") && e.firstChild.value === Te, H_ = (e, n) => e && e.firstChild && e.firstChild === e.lastChild && e.firstChild.name === n, n3 = (e, n) => {
      const o = e.getElementRule(n.name);
      return o && o.paddEmpty;
    }, bp = (e, n, o, r) => r.isEmpty(n, o, (c) => n3(e, c)), o3 = (e, n) => e && (e.name in n || e.name === "br"), V_ = (e, n, o = e.parent) => {
      if (n.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const r = e.children();
        for (const c of r)
          n.isValidChild(o.name, c.name) || V_(c, n, o);
        e.unwrap();
      }
    }, j_ = (e, n, o = Se) => {
      const r = n.getTextBlockElements(), c = n.getNonEmptyElements(), u = n.getWhitespaceElements(), m = it.makeMap("tr,td,th,tbody,thead,tfoot,table"), y = /* @__PURE__ */ new Set();
      for (let v = 0; v < e.length; v++) {
        const x = e[v];
        let R, F, W;
        if (!x.parent || y.has(x))
          continue;
        if (r[x.name] && x.parent.name === "li") {
          let ee = x.next;
          for (; ee && r[ee.name]; ) {
            ee.name = "li", y.add(ee), x.parent.insert(ee, x.parent);
            ee = ee.next;
          }
          x.unwrap();
          continue;
        }
        const K = [x];
        for (R = x.parent; R && !n.isValidChild(R.name, x.name) && !m[R.name]; R = R.parent)
          K.push(R);
        if (R && K.length > 1)
          if (n.isValidChild(R.name, x.name)) {
            K.reverse(), F = K[0].clone(), o(F);
            let ee = F;
            for (let J = 0; J < K.length - 1; J++) {
              n.isValidChild(ee.name, K[J].name) ? (W = K[J].clone(), o(W), ee.append(W)) : W = ee;
              for (let te = K[J].firstChild; te && te !== K[J + 1]; ) {
                const ve = te.next;
                W.append(te), te = ve;
              }
              ee = W;
            }
            bp(n, c, u, F) ? R.insert(x, K[0], !0) : (R.insert(F, K[0], !0), R.insert(x, F)), R = K[0], (bp(n, c, u, R) || H_(R, "br")) && R.empty().remove();
          } else
            V_(x, n);
        else if (x.parent) {
          if (x.name === "li") {
            let ee = x.prev;
            if (ee && (ee.name === "ul" || ee.name === "ol")) {
              ee.append(x);
              continue;
            }
            if (ee = x.next, ee && (ee.name === "ul" || ee.name === "ol")) {
              ee.insert(x, ee.firstChild, !0);
              continue;
            }
            const J = new pl("ul", 1);
            o(J), x.wrap(J);
            continue;
          }
          if (n.isValidChild(x.parent.name, "div") && n.isValidChild("div", x.name)) {
            const ee = new pl("div", 1);
            o(ee), x.wrap(ee);
          } else
            V_(x, n);
        }
      }
    }, X5 = (e, n, o, r) => {
      const c = document.createRange();
      return c.setStart(e, n), c.setEnd(o, r), c;
    }, J5 = (e) => {
      const n = Ke.fromRangeStart(e), o = Ke.fromRangeEnd(e), r = e.commonAncestorContainer;
      return Ci(!1, r, o).map((c) => !td(n, o, r) && td(n, c, r) ? X5(n.container(), n.offset(), c.container(), c.offset()) : e).getOr(e);
    }, U_ = (e) => e.collapsed ? e : J5(e), Xb = (e) => e.firstChild && e.firstChild === e.lastChild, Q5 = (e) => e.name === "br" || e.value === Te, s3 = (e, n) => e.getBlockElements()[n.name] && Xb(n) && Q5(n.firstChild), CR = (e, n) => {
      const o = e.getNonEmptyElements();
      return n && (n.isEmpty(o) || s3(e, n));
    }, SR = (e, n) => {
      let o = n.firstChild, r = n.lastChild;
      return o && o.name === "meta" && (o = o.next), r && r.attr("id") === "mce_marker" && (r = r.prev), CR(e, r) && (r = r.prev), !o || o !== r ? !1 : o.name === "ul" || o.name === "ol";
    }, eA = (e) => {
      const n = e.firstChild, o = e.lastChild;
      return n && n.nodeName === "META" && n.parentNode.removeChild(n), o && o.id === "mce_marker" && o.parentNode.removeChild(o), e;
    }, tA = (e, n, o) => {
      const r = n.serialize(o), c = e.createFragment(r);
      return eA(c);
    }, nA = (e) => ue(e.childNodes, (n) => n.nodeName === "LI"), W_ = (e) => e.data === Te || Cr(e), oA = (e) => e && e.firstChild && e.firstChild === e.lastChild && W_(e.firstChild), sA = (e) => !e.firstChild || oA(e), rA = (e) => e.length > 0 && sA(e[e.length - 1]) ? e.slice(0, -1) : e, Z_ = (e, n) => {
      const o = e.getParent(n, e.isBlock);
      return o && o.nodeName === "LI" ? o : null;
    }, aA = (e, n) => !!Z_(e, n), cA = (e, n) => {
      const o = n.cloneRange(), r = n.cloneRange();
      return o.setStartBefore(e), r.setEndAfter(e), [
        o.cloneContents(),
        r.cloneContents()
      ];
    }, lA = (e, n) => {
      const o = Ke.before(e), c = _c(n).next(o);
      return c ? c.toRange() : null;
    }, r3 = (e, n) => {
      const o = Ke.after(e), c = _c(n).prev(o);
      return c ? c.toRange() : null;
    }, iA = (e, n, o, r) => {
      const c = cA(e, r), u = e.parentNode;
      return u.insertBefore(c[0], e), it.each(n, (m) => {
        u.insertBefore(m, e);
      }), u.insertBefore(c[1], e), u.removeChild(e), r3(n[n.length - 1], o);
    }, uA = (e, n, o) => {
      const r = e.parentNode;
      return it.each(n, (c) => {
        r.insertBefore(c, e);
      }), lA(e, o);
    }, dA = (e, n, o, r) => (r.insertAfter(n.reverse(), e), r3(n[0], o)), fA = (e, n, o, r) => {
      const c = tA(n, e, r), u = Z_(n, o.startContainer), m = rA(nA(c.firstChild)), y = 1, v = 2, x = n.getRoot(), R = (F) => {
        const W = Ke.fromRangeStart(o), K = _c(n.getRoot()), ee = F === y ? K.prev(W) : K.next(W);
        return ee ? Z_(n, ee.getNode()) !== u : !0;
      };
      return R(y) ? uA(u, m, x) : R(v) ? dA(u, m, x, n) : iA(u, m, x, o);
    }, mA = ["pre"], a3 = (e, n, o, r) => {
      var c;
      const u = n.firstChild, m = n.lastChild, y = m.attr("data-mce-type") === "bookmark" ? m.prev : m, v = u === y, x = Ae(mA, u.name);
      if (v && x) {
        const R = u.attr("contenteditable") !== "false", F = ((c = e.getParent(o, e.isBlock)) === null || c === void 0 ? void 0 : c.nodeName.toLowerCase()) === u.name, W = O.from(hl(r, o)).forall(Zl);
        return R && F && W;
      } else
        return !1;
    }, Jb = yd, gA = (e, n, o) => {
      if (o !== null) {
        const r = e.getParent(n.endContainer, Jb);
        return o === r && xh(be.fromDom(o), n);
      } else
        return !1;
    }, pA = (e, n, o) => {
      if (o.getAttribute("data-mce-bogus") === "all")
        o.parentNode.insertBefore(e.dom.createFragment(n), o);
      else {
        const r = o.firstChild, c = o.lastChild;
        !r || r === c && r.nodeName === "BR" ? e.dom.setHTML(o, n) : e.selection.setContent(n, { no_events: !0 });
      }
    }, q_ = (e, n) => {
      O.from(e.getParent(n, "td,th")).map(be.fromDom).each(A1);
    }, c3 = (e, n) => {
      const o = e.schema.getTextInlineElements(), r = e.dom;
      if (n) {
        const c = e.getBody(), u = Sx(r);
        it.each(r.select("*[data-mce-fragment]"), (m) => {
          if (Q(o[m.nodeName.toLowerCase()]) && A7(r, m)) {
            for (let v = m.parentNode; Q(v) && v !== c && !O7(r, m, v); v = v.parentNode)
              if (u.compare(v, m)) {
                r.remove(m, !0);
                break;
              }
          }
        });
      }
    }, Cv = (e) => {
      let n = e;
      for (; n = n.walk(); )
        n.type === 1 && n.attr("data-mce-fragment", "1");
    }, l3 = (e) => {
      it.each(e.getElementsByTagName("*"), (n) => {
        n.removeAttribute("data-mce-fragment");
      });
    }, hA = (e) => !!e.getAttribute("data-mce-fragment"), Sv = (e, n) => n && !e.schema.getVoidElements()[n.nodeName], i3 = (e, n) => {
      let o;
      const r = e.dom, c = e.selection;
      if (!n)
        return;
      c.scrollIntoView(n);
      const u = hl(e.getBody(), n);
      if (r.getContentEditable(u) === "false") {
        r.remove(n), c.select(u);
        return;
      }
      let m = r.createRng();
      const y = n.previousSibling;
      if (rn(y)) {
        m.setStart(y, y.nodeValue.length);
        const R = n.nextSibling;
        rn(R) && (y.appendData(R.data), R.parentNode.removeChild(R));
      } else
        m.setStartBefore(n), m.setEndBefore(n);
      const v = (R) => {
        let F = Ke.fromRangeStart(R);
        if (F = _c(e.getBody()).next(F), F)
          return F.toRange();
      }, x = r.getParent(n, r.isBlock);
      r.remove(n), x && r.isEmpty(x) && (ff(be.fromDom(x)), m.setStart(x, 0), m.setEnd(x, 0), !Jb(x) && !hA(x) && (o = v(m)) ? (m = o, r.remove(x)) : r.add(x, r.create("br", { "data-mce-bogus": "1" }))), c.setRng(m);
    }, u3 = (e) => {
      const n = e.dom, o = U_(e.selection.getRng());
      e.selection.setRng(o);
      const r = n.getParent(o.startContainer, Jb);
      gA(n, o, r) ? Su(e, o, be.fromDom(r)) : e.getDoc().execCommand("Delete", !1, null);
    }, xv = (e, n, o) => {
      var r;
      let c, u, m;
      const y = e.selection, v = e.dom, x = e.parser, R = o.merge, F = gp({ validate: !0 }, e.schema), W = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      n.indexOf("{$caret}") === -1 && (n += "{$caret}"), n = n.replace(/\{\$caret\}/, W), u = y.getRng();
      const K = u.startContainer || (u.parentElement ? u.parentElement() : null), ee = e.getBody();
      K === ee && y.isCollapsed() && v.isBlock(ee.firstChild) && Sv(e, ee.firstChild) && v.isEmpty(ee.firstChild) && (u = v.createRng(), u.setStart(ee.firstChild, 0), u.setEnd(ee.firstChild, 0), y.setRng(u)), y.isCollapsed() || u3(e), c = y.getNode();
      const J = {
        context: c.nodeName.toLowerCase(),
        data: o.data,
        insert: !0
      }, te = x.parse(n, J);
      if (o.paste === !0 && SR(e.schema, te) && aA(v, c))
        return u = fA(F, v, y.getRng(), te), y.setRng(u), n;
      if (o.paste === !0 && a3(v, te, c, e.getBody()) && ((r = te.firstChild) === null || r === void 0 || r.unwrap()), Cv(te), m = te.lastChild, m.attr("id") === "mce_marker") {
        const ve = m;
        for (m = m.prev; m; m = m.walk(!0))
          if (m.type === 3 || !v.isBlock(m.name)) {
            e.schema.isValidChild(m.parent.name, "span") && m.parent.insert(ve, m, m.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(c), !J.invalid)
        n = F.serialize(te), pA(e, n, c);
      else {
        e.selection.setContent(W), c = y.getNode();
        const ve = e.getBody();
        for (c.nodeType === 9 ? c = m = ve : m = c; m !== ve; )
          c = m, m = m.parentNode;
        n = c === ve ? ve.innerHTML : v.getOuterHTML(c);
        const De = x.parse(n);
        for (let pn = De; pn; pn = pn.walk())
          if (pn.attr("id") === "mce_marker") {
            pn.replace(te);
            break;
          }
        const Be = te.children(), qe = te.parent.name;
        te.unwrap();
        const pt = ue(Be, (pn) => !e.schema.isValidChild(qe, pn.name));
        j_(pt, e.schema), e3(x.getNodeFilters(), x.getAttributeFilters(), De), n = F.serialize(De), c === ve ? v.setHTML(ve, n) : v.setOuterHTML(c, n);
      }
      return c3(e, R), i3(e, v.get("mce_marker")), l3(e.getBody()), q_(v, y.getStart()), n;
    }, Tv = (e) => e instanceof pl, xR = (e) => {
      xr(e) && Xc(e.getBody()).each((n) => {
        const o = n.getNode(), r = mi(o) ? Xc(o).getOr(n) : n;
        e.selection.setRng(r.toRange());
      });
    }, G_ = (e, n, o) => {
      e.dom.setHTML(e.getBody(), n), o !== !0 && xR(e);
    }, yA = (e, n, o, r) => {
      if (o.length === 0 || /^\s+$/.test(o)) {
        const c = '<br data-mce-bogus="1">';
        n.nodeName === "TABLE" ? o = "<tr><td>" + c + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (o = "<li>" + c + "</li>");
        const u = Ir(e);
        return e.schema.isValidChild(n.nodeName.toLowerCase(), u.toLowerCase()) ? (o = c, o = e.dom.createHTML(u, ua(e), o)) : o || (o = c), G_(e, o, r.no_selection), {
          content: o,
          html: o
        };
      } else {
        r.format !== "raw" && (o = gp({ validate: !1 }, e.schema).serialize(e.parser.parse(o, {
          isRootContent: !0,
          insert: !0
        })));
        const c = vm(be.fromDom(n)) ? o : it.trim(o);
        return G_(e, c, r.no_selection), {
          content: c,
          html: c
        };
      }
    }, TR = (e, n, o, r) => {
      e3(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), o);
      const c = gp({ validate: !1 }, e.schema).serialize(o), u = vm(be.fromDom(n)) ? c : it.trim(c);
      return G_(e, u, r.no_selection), {
        content: o,
        html: u
      };
    }, rL = (e, n, o) => O.from(e.getBody()).map((r) => Tv(n) ? TR(e, r, n, o) : yA(e, r, n, o)).getOr({
      content: n,
      html: Tv(o.content) ? "" : o.content
    }), ER = (e, n) => fg(e, n).isSome(), K_ = (e) => wn(e) ? e : Mn, jd = (e, n, o) => {
      let r = e.dom;
      const c = K_(o);
      for (; r.parentNode; ) {
        r = r.parentNode;
        const u = be.fromDom(r), m = n(u);
        if (m.isSome())
          return m;
        if (c(u))
          break;
      }
      return O.none();
    }, Ev = (e, n, o) => {
      const r = n(e), c = K_(o);
      return r.orThunk(() => c(e) ? O.none() : jd(e, n, c));
    }, Av = Sb, Y_ = (e, n, o) => {
      const r = e.formatter.get(o);
      if (r)
        for (let c = 0; c < r.length; c++) {
          const u = r[c];
          if (fl(u) && u.inherit === !1 && e.dom.is(n, u.selector))
            return !0;
        }
      return !1;
    }, d3 = (e, n, o, r, c) => {
      const u = e.dom.getRoot();
      return n === u ? !1 : (n = e.dom.getParent(n, (m) => Y_(e, m, o) ? !0 : m.parentNode === u || !!Ud(e, m, o, r, !0)), !!Ud(e, n, o, r, c));
    }, zv = (e, n, o) => za(o) && Av(n, o.inline) || Ql(o) && Av(n, o.block) ? !0 : fl(o) ? Vn(n) && e.is(n, o.selector) : !1, bA = (e, n, o, r, c, u) => {
      const m = o[r];
      if (wn(o.onmatch))
        return o.onmatch(n, o, r);
      if (m) {
        if (rt(m.length)) {
          for (const y in m)
            if (Gn(m, y)) {
              const v = r === "attributes" ? e.getAttrib(n, y) : Nl(e, n, y), x = Ml(m[y], u), R = lt(v) || fs(v);
              if (R && lt(x))
                continue;
              if (c && R && !o.exact || (!c || o.exact) && !Av(v, Pm(x, y)))
                return !1;
            }
        } else
          for (let y = 0; y < m.length; y++)
            if (r === "attributes" ? e.getAttrib(n, m[y]) : Nl(e, n, m[y]))
              return !0;
      }
      return !0;
    }, Ud = (e, n, o, r, c) => {
      const u = e.formatter.get(o), m = e.dom;
      if (u && n)
        for (let y = 0; y < u.length; y++) {
          const v = u[y];
          if (zv(e.dom, n, v) && bA(m, n, v, "attributes", c, r) && bA(m, n, v, "styles", c, r)) {
            const x = v.classes;
            if (x) {
              for (let R = 0; R < x.length; R++)
                if (!e.dom.hasClass(n, Ml(x[R], r)))
                  return;
            }
            return v;
          }
        }
    }, Ov = (e, n, o, r, c) => {
      if (r)
        return d3(e, r, n, o, c);
      if (r = e.selection.getNode(), d3(e, r, n, o, c))
        return !0;
      const u = e.selection.getStart();
      return !!(u !== r && d3(e, u, n, o, c));
    }, AR = (e, n, o) => {
      const r = [], c = {}, u = e.selection.getStart();
      return e.dom.getParent(u, (m) => {
        for (let y = 0; y < n.length; y++) {
          const v = n[y];
          !c[v] && Ud(e, m, v, o) && (c[v] = !0, r.push(v));
        }
      }, e.dom.getRoot()), r;
    }, vA = (e, n) => {
      const o = (c) => Is(c, be.fromDom(e.getBody())), r = (c, u) => Ud(e, c.dom, u) ? O.some(u) : O.none();
      return O.from(e.selection.getStart(!0)).bind((c) => Ev(be.fromDom(c), (u) => Qs(n, (m) => r(u, m)), o)).getOrNull();
    }, zR = (e, n) => {
      const o = e.formatter.get(n), r = e.dom;
      if (o) {
        const c = e.selection.getStart(), u = ep(r, c);
        for (let m = o.length - 1; m >= 0; m--) {
          const y = o[m];
          if (!fl(y))
            return !0;
          for (let v = u.length - 1; v >= 0; v--)
            if (r.is(u[v], y.selector))
              return !0;
        }
      }
      return !1;
    }, Dv = (e, n, o) => Ht(o, (r, c) => {
      const u = US(e, c);
      return e.formatter.matchNode(n, c, {}, u) ? r.concat([c]) : r;
    }, []), qh = k, kA = "_mce_caret", wA = (e, n) => e.importNode(n, !0), OR = (e) => {
      const n = [];
      for (; e; ) {
        if (e.nodeType === 3 && e.nodeValue !== qh || e.childNodes.length > 1)
          return [];
        e.nodeType === 1 && n.push(e), e = e.firstChild;
      }
      return n;
    }, _A = (e) => OR(e).length > 0, CA = (e) => {
      if (e) {
        const n = new rr(e, e);
        for (e = n.current(); e; e = n.next())
          if (rn(e))
            return e;
      }
      return null;
    }, f3 = (e) => {
      const n = be.fromTag("span");
      return ur(n, {
        id: kA,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && Kr(n, be.fromText(qh)), n;
    }, DR = (e) => {
      const n = CA(e);
      return n && n.nodeValue.charAt(0) === qh && n.deleteData(0, 1), n;
    }, X_ = (e, n, o = !0) => {
      const r = e.dom, c = e.selection;
      if (_A(n))
        Qo(e, !1, be.fromDom(n), o);
      else {
        const u = c.getRng(), m = r.getParent(n, r.isBlock), y = u.startContainer, v = u.startOffset, x = u.endContainer, R = u.endOffset, F = DR(n);
        r.remove(n, !0), y === F && v > 0 && u.setStart(F, v - 1), x === F && R > 0 && u.setEnd(F, R - 1), m && r.isEmpty(m) && Pa(be.fromDom(m)), c.setRng(u);
      }
    }, m3 = (e, n, o = !0) => {
      const r = e.dom, c = e.selection;
      if (n)
        X_(e, n, o);
      else if (n = Pd(e.getBody(), c.getStart()), !n)
        for (; n = r.get(kA); )
          X_(e, n, !1);
    }, g3 = (e, n, o) => {
      const r = e.dom, c = r.getParent(o, Ct(Jg, e));
      c && r.isEmpty(c) ? o.parentNode.replaceChild(n, o) : (Xn(be.fromDom(o)), r.isEmpty(o) ? o.parentNode.replaceChild(n, o) : r.insertAfter(n, o));
    }, vp = (e, n) => (e.appendChild(n), n), SA = (e, n) => {
      const o = ct(e, (r, c) => vp(r, c.cloneNode(!1)), n);
      return vp(o, o.ownerDocument.createTextNode(qh));
    }, RR = (e, n, o, r, c, u) => {
      const m = e.formatter, y = e.dom, v = ue($e(m.get()), (F) => F !== r && !Yt(F, "removeformat")), x = Dv(e, o, v);
      if (ue(x, (F) => !e_(e, F, r)).length > 0) {
        const F = o.cloneNode(!1);
        return y.add(n, F), m.remove(r, c, F, u), y.remove(F), O.some(F);
      } else
        return O.none();
    }, J_ = (e, n, o) => {
      let r, c;
      const u = e.selection, m = u.getRng();
      let y = m.startOffset;
      const x = m.startContainer.nodeValue;
      r = Pd(e.getBody(), u.getStart()), r && (c = CA(r));
      const R = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (x && y > 0 && y < x.length && R.test(x.charAt(y)) && R.test(x.charAt(y - 1))) {
        const F = u.getBookmark();
        m.collapse(!0);
        let W = Yo(e, m, e.formatter.get(n));
        W = jb(W), e.formatter.apply(n, o, W), u.moveToBookmark(F);
      } else
        (!r || c.nodeValue !== qh) && (r = wA(e.getDoc(), f3(!0).dom), c = r.firstChild, m.insertNode(r), y = 1), e.formatter.apply(n, o, r), u.setCursorLocation(c, y);
    }, p3 = (e, n, o, r) => {
      const c = e.dom, u = e.selection;
      let m, y, v;
      const x = [], R = u.getRng(), F = R.startContainer, W = R.startOffset;
      for (y = F, F.nodeType === 3 && (W !== F.nodeValue.length && (m = !0), y = y.parentNode); y; ) {
        if (Ud(e, y, n, o, r)) {
          v = y;
          break;
        }
        y.nextSibling && (m = !0), x.push(y), y = y.parentNode;
      }
      if (!!v)
        if (m) {
          const K = u.getBookmark();
          R.collapse(!0);
          let ee = Yo(e, R, e.formatter.get(n), !0);
          ee = jb(ee), e.formatter.remove(n, o, ee, r), u.moveToBookmark(K);
        } else {
          const K = Pd(e.getBody(), v), ee = f3(!1).dom;
          g3(e, ee, K !== null ? K : v);
          const J = RR(e, ee, v, n, o, r), te = SA(x.concat(J.toArray()), ee);
          X_(e, K, !1), u.setCursorLocation(te, 1), c.isEmpty(v) && c.remove(v);
        }
    }, MR = (e, n) => {
      const o = e.selection, r = e.getBody();
      m3(e, null, !1), (n === 8 || n === 46) && o.isCollapsed() && o.getStart().innerHTML === qh && m3(e, Pd(r, o.getStart())), (n === 37 || n === 39) && m3(e, Pd(r, o.getStart()));
    }, NR = (e) => {
      e.on("mouseup keydown", (n) => {
        MR(e, n.keyCode);
      });
    }, xA = (e, n) => {
      const o = f3(!1), r = SA(n, o.dom);
      return Mr(be.fromDom(e), o), Gs(be.fromDom(e)), Ke(r, 0);
    }, h3 = (e, n) => {
      const o = e.schema.getTextInlineElements();
      return Gn(o, An(n)) && !Xl(n.dom) && !Hu(n.dom);
    }, BR = (e) => Xl(e.dom) && _A(e.dom), Gh = {}, jf = cc, TA = Ur, y3 = (e, n) => {
      Gh[e] || (Gh[e] = []), Gh[e].push(n);
    }, fa = (e, n) => {
      TA(Gh[e], (o) => {
        o(n);
      });
    };
    y3("pre", (e) => {
      const n = e.selection.getRng();
      let o;
      const r = (m) => u(m.previousSibling) && Z(o, m.previousSibling) !== -1, c = (m, y) => {
        const v = be.fromDom(y), x = ii(v).dom;
        Gs(v), Fu(be.fromDom(m), [
          be.fromTag("br", x),
          be.fromTag("br", x),
          ...Qr(v)
        ]);
      }, u = Wl(["pre"]);
      n.collapsed || (o = e.selection.getSelectedBlocks(), TA(jf(jf(o, u), r), (m) => {
        c(m.previousSibling, m);
      }));
    });
    const Rv = it.each, Mv = (e) => Vn(e) && !Jl(e) && !Xl(e) && !Hu(e), Um = (e, n) => {
      for (let o = e; o; o = o[n]) {
        if (rn(o) && Bo(o.data))
          return e;
        if (Vn(o) && !Jl(o))
          return o;
      }
      return e;
    }, EA = (e, n, o) => {
      const r = Sx(e);
      if (n && o && (n = Um(n, "previousSibling"), o = Um(o, "nextSibling"), r.compare(n, o))) {
        for (let c = n.nextSibling; c && c !== o; ) {
          const u = c;
          c = c.nextSibling, n.appendChild(u);
        }
        return e.remove(o), it.each(it.grep(o.childNodes), (c) => {
          n.appendChild(c);
        }), n;
      }
      return o;
    }, b3 = (e, n, o, r) => {
      if (r && n.merge_siblings !== !1) {
        const c = EA(e, Xg(r), r);
        EA(e, c, Xg(c, !0));
      }
    }, Nv = (e, n, o) => {
      if (n.clear_child_styles) {
        const r = n.links ? "*:not(a)" : "*";
        Rv(e.select(r, o), (c) => {
          Mv(c) && Rv(n.styles, (u, m) => {
            e.setStyle(c, m, "");
          });
        });
      }
    }, v3 = (e, n, o) => {
      Rv(e.childNodes, (r) => {
        Mv(r) && (n(r) && o(r), r.hasChildNodes() && v3(r, n, o));
      });
    }, $R = (e, n) => {
      n.nodeName === "SPAN" && e.getAttribs(n).length === 0 && e.remove(n, !0);
    }, Kh = (e, n) => (o) => !!(o && Nl(e, o, n)), AA = (e, n, o) => (r) => {
      e.setStyle(r, n, o), r.getAttribute("style") === "" && r.removeAttribute("style"), $R(e, r);
    }, Wd = vi.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), PR = /^(src|href|style)$/, kp = it.each, Ji = Sb, Q_ = (e) => /^(TR|TH|TD)$/.test(e.nodeName), e2 = (e, n, o) => e.isChildOf(n, o) && n !== o && !e.isBlock(o), zA = (e, n, o) => {
      let r = n[o ? "startContainer" : "endContainer"], c = n[o ? "startOffset" : "endOffset"];
      if (Vn(r)) {
        const u = r.childNodes.length - 1;
        !o && c && c--, r = r.childNodes[c > u ? u : c];
      }
      return rn(r) && o && c >= r.nodeValue.length && (r = new rr(r, e.getBody()).next() || r), rn(r) && !o && c === 0 && (r = new rr(r, e.getBody()).prev() || r), r;
    }, OA = (e, n) => {
      const o = n ? "firstChild" : "lastChild";
      if (Q_(e) && e[o]) {
        const r = e[o];
        return e.nodeName === "TR" && r[o] || r;
      }
      return e;
    }, Qb = (e, n, o, r) => {
      const c = e.create(o, r);
      return n.parentNode.insertBefore(c, n), c.appendChild(n), c;
    }, DA = (e, n, o, r, c) => {
      const u = be.fromDom(n), m = be.fromDom(e.create(r, c)), y = o ? Ec(u) : uf(u);
      return Fu(m, y), o ? (Mr(u, m), _y(m, u)) : (cl(u, m), Kr(m, u)), m.dom;
    }, sd = (e, n) => n.links && e.nodeName === "A", t2 = (e, n, o) => {
      const r = n.parentNode;
      let c;
      const u = e.dom, m = Ir(e);
      Ql(o) && r === u.getRoot() && (!o.list_block || !Ji(n, o.list_block)) && X(Os(n.childNodes), (y) => {
        Qg(e, m, y.nodeName.toLowerCase()) ? c ? c.appendChild(y) : (c = Qb(u, y, m), u.setAttribs(c, ua(e))) : c = null;
      }), !(t_(o) && !Ji(o.inline, n)) && u.remove(n, !0);
    }, k3 = (e, n, o, r, c) => {
      let u;
      const m = e.dom;
      if (!zv(m, r, n) && !sd(r, n))
        return Wd.keep();
      const y = r;
      if (za(n) && n.remove === "all" && Re(n.preserve_attributes)) {
        const v = ue(m.getAttribs(y), (x) => Ae(n.preserve_attributes, x.name.toLowerCase()));
        if (m.removeAllAttribs(y), X(v, (x) => m.setAttrib(y, x.name, x.value)), v.length > 0)
          return Wd.rename("span");
      }
      if (n.remove !== "all") {
        kp(n.styles, (x, R) => {
          x = Pm(Ml(x, o), R + ""), ft(R) && (R = x, c = null), (n.remove_similar || !c || Ji(Nl(m, c, R), x)) && m.setStyle(y, R, ""), u = !0;
        }), u && m.getAttrib(y, "style") === "" && (y.removeAttribute("style"), y.removeAttribute("data-mce-style")), kp(n.attributes, (x, R) => {
          let F;
          if (x = Ml(x, o), ft(R) && (R = x, c = null), n.remove_similar || !c || Ji(m.getAttrib(c, R), x)) {
            if (R === "class" && (x = m.getAttrib(y, R), x && (F = "", X(x.split(/\s+/), (W) => {
              /mce\-\w+/.test(W) && (F += (F ? " " : "") + W);
            }), F))) {
              m.setAttrib(y, R, F);
              return;
            }
            if (PR.test(R) && y.removeAttribute("data-mce-" + R), R === "style" && Wl(["li"])(y) && m.getStyle(y, "list-style-type") === "none") {
              y.removeAttribute(R), m.setStyle(y, "list-style-type", "none");
              return;
            }
            R === "class" && y.removeAttribute("className"), y.removeAttribute(R);
          }
        }), kp(n.classes, (x) => {
          x = Ml(x, o), (!c || m.hasClass(c, x)) && m.removeClass(y, x);
        });
        const v = m.getAttribs(y);
        for (let x = 0; x < v.length; x++) {
          const R = v[x].nodeName;
          if (R.indexOf("_") !== 0 && R.indexOf("data-") !== 0)
            return Wd.keep();
        }
      }
      return n.remove !== "none" ? (t2(e, y, n), Wd.removed()) : Wd.keep();
    }, wp = (e, n, o, r, c) => k3(e, n, o, r, c).fold(Mn, (u) => (e.dom.rename(r, u), !0), Xe), w3 = (e, n, o, r, c) => {
      let u;
      return X(ep(e.dom, n.parentNode).reverse(), (m) => {
        if (!u && m.id !== "_start" && m.id !== "_end") {
          const y = Ud(e, m, o, r, c);
          y && y.split !== !1 && (u = m);
        }
      }), u;
    }, Yh = (e, n, o, r) => k3(e, n, o, r, r).fold(Pe(r), (c) => (e.dom.createFragment().appendChild(r), e.dom.rename(r, c)), Pe(null)), _3 = (e, n, o, r, c, u, m, y) => {
      let v, x, R;
      const F = e.dom;
      if (o) {
        const W = o.parentNode;
        for (let K = r.parentNode; K && K !== W; K = K.parentNode) {
          v = F.clone(K, !1);
          for (let ee = 0; ee < n.length && (v = Yh(e, n[ee], y, v), v !== null); ee++)
            ;
          v && (x && v.appendChild(x), R || (R = v), x = v);
        }
        u && (!m.mixed || !F.isBlock(o)) && (r = F.split(o, r)), x && (c.parentNode.insertBefore(x, c), R.appendChild(c), za(m) && b3(F, m, y, x));
      }
      return r;
    }, RA = (e, n, o, r, c) => {
      const u = e.formatter.get(n), m = u[0];
      let y = !0;
      const v = e.dom, x = e.selection, R = (te) => {
        const ve = w3(e, te, n, o, c);
        return _3(e, u, ve, te, te, !0, m, o);
      }, F = (te) => Jl(te) && Vn(te) && (te.id === "_start" || te.id === "_end"), W = (te) => Oe(u, (ve) => wp(e, ve, o, te, te)), K = (te) => {
        let ve = !0, De = !1;
        Vn(te) && v.getContentEditable(te) && (ve = y, y = v.getContentEditable(te) === "true", De = !0);
        const Be = Os(te.childNodes);
        if (y && !De) {
          const pn = W(te) || Oe(u, (xt) => zv(v, te, xt)), vt = te.parentNode;
          !pn && Q(vt) && Fd(m) && W(vt);
        }
        if (m.deep && Be.length) {
          for (let pt = 0; pt < Be.length; pt++)
            K(Be[pt]);
          De && (y = ve);
        }
        X([
          "underline",
          "line-through",
          "overline"
        ], (pt) => {
          Vn(te) && e.dom.getStyle(te, "text-decoration") === pt && te.parentNode && xb(v, te.parentNode) === pt && wp(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: pt }
          }, null, te);
        });
      }, ee = (te) => {
        const ve = v.get(te ? "_start" : "_end");
        let De = ve[te ? "firstChild" : "lastChild"];
        return F(De) && (De = De[te ? "firstChild" : "lastChild"]), rn(De) && De.data.length === 0 && (De = te ? ve.previousSibling || ve.nextSibling : ve.nextSibling || ve.previousSibling), v.remove(ve, !0), De;
      }, J = (te) => {
        let ve, De, Be = Yo(e, te, u, te.collapsed);
        if (m.split) {
          if (Be = jb(Be), ve = zA(e, Be, !0), De = zA(e, Be), ve !== De) {
            if (ve = OA(ve, !0), De = OA(De, !1), e2(v, ve, De)) {
              const pt = O.from(ve.firstChild).getOr(ve);
              R(DA(v, pt, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), ee(!0);
              return;
            }
            if (e2(v, De, ve)) {
              const pt = O.from(De.lastChild).getOr(De);
              R(DA(v, pt, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), ee(!1);
              return;
            }
            ve = Qb(v, ve, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), De = Qb(v, De, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const qe = v.createRng();
            qe.setStartAfter(ve), qe.setEndBefore(De), xi(v, qe, (pt) => {
              X(pt, (pn) => {
                !Jl(pn) && !Jl(pn.parentNode) && R(pn);
              });
            }), R(ve), R(De), ve = ee(!0), De = ee();
          } else
            ve = De = R(ve);
          Be.startContainer = ve.parentNode ? ve.parentNode : ve, Be.startOffset = v.nodeIndex(ve), Be.endContainer = De.parentNode ? De.parentNode : De, Be.endOffset = v.nodeIndex(De) + 1;
        }
        xi(v, Be, (qe) => {
          X(qe, K);
        });
      };
      if (r) {
        if (Ff(r)) {
          const te = v.createRng();
          te.setStartBefore(r), te.setEndAfter(r), J(te);
        } else
          J(r);
        I0(e, n, r, o);
        return;
      }
      if (v.getContentEditable(x.getNode()) === "false") {
        r = x.getNode();
        for (let te = 0; te < u.length && !(u[te].ceFalseOverride && wp(e, u[te], o, r, r)); te++)
          ;
        I0(e, n, r, o);
        return;
      }
      !x.isCollapsed() || !za(m) || Ld(e).length ? (Eh(x, !0, () => {
        Ab(e, J);
      }), za(m) && Ov(e, n, o, x.getStart()) && O0(v, x, x.getRng()), e.nodeChanged()) : p3(e, n, o, c), I0(e, n, r, o);
    }, C3 = it.each, FR = (e, n, o, r) => {
      const c = (u) => {
        if (u.nodeType === 1 && u.parentNode && u.parentNode.nodeType === 1) {
          const m = xb(e, u.parentNode);
          e.getStyle(u, "color") && m ? e.setStyle(u, "text-decoration", m) : e.getStyle(u, "text-decoration") === m && e.setStyle(u, "text-decoration", null);
        }
      };
      n.styles && (n.styles.color || n.styles.textDecoration) && (it.walk(r, c, "childNodes"), c(r));
    }, IR = (e, n, o, r) => {
      n.styles && n.styles.backgroundColor && v3(r, Kh(e, "fontSize"), AA(e, "backgroundColor", Ml(n.styles.backgroundColor, o)));
    }, LR = (e, n, o, r) => {
      za(n) && (n.inline === "sub" || n.inline === "sup") && (v3(r, Kh(e, "fontSize"), AA(e, "fontSize", "")), e.remove(e.select(n.inline === "sup" ? "sub" : "sup", r), !0));
    }, HR = (e, n, o, r) => {
      C3(n, (c) => {
        za(c) && C3(e.dom.select(c.inline, r), (u) => {
          !Mv(u) || wp(e, c, o, u, c.exact ? u : null);
        }), Nv(e.dom, c, r);
      });
    }, Bv = (e, n, o, r, c) => {
      Ud(e, c.parentNode, o, r) && wp(e, n, r, c) || n.merge_with_parents && e.dom.getParent(c.parentNode, (u) => {
        if (Ud(e, u, o, r))
          return wp(e, n, r, c), !0;
      });
    }, n2 = it.each, MA = (e) => Vn(e) && !Jl(e) && !Xl(e) && !Hu(e), S3 = (e, n, o, r) => {
      if (a0(e) && za(n)) {
        const c = Ny(e.schema), u = ER(be.fromDom(o), (m) => Xl(m.dom));
        return er(c, r) && ta(be.fromDom(o.parentNode), !1) && !u;
      } else
        return !1;
    }, NA = (e, n, o, r) => {
      const c = e.formatter.get(n), u = c[0], m = !r && e.selection.isCollapsed(), y = e.dom, v = e.selection, x = (K, ee = u) => {
        if (wn(ee.onformat) && ee.onformat(K, ee, o, r), n2(ee.styles, (J, te) => {
          y.setStyle(K, te, Ml(J, o));
        }), ee.styles) {
          const J = y.getAttrib(K, "style");
          J && y.setAttrib(K, "data-mce-style", J);
        }
        n2(ee.attributes, (J, te) => {
          y.setAttrib(K, te, Ml(J, o));
        }), n2(ee.classes, (J) => {
          J = Ml(J, o), y.hasClass(K, J) || y.addClass(K, J);
        });
      }, R = (K, ee) => {
        let J = !1;
        return n2(K, (te) => {
          if (!fl(te))
            return !1;
          if (!(Q(te.collapsed) && te.collapsed !== m) && y.is(ee, te.selector) && !Xl(ee))
            return x(ee, te), J = !0, !1;
        }), J;
      }, F = (K) => {
        if (ie(K)) {
          const ee = y.create(K);
          return x(ee), ee;
        } else
          return null;
      }, W = (K, ee, J) => {
        const te = [];
        let ve = !0;
        const De = u.inline || u.block, Be = F(De);
        xi(K, ee, (qe) => {
          let pt;
          const pn = (vt) => {
            let xt = !1, Zt = ve;
            const Xt = vt.nodeName.toLowerCase(), Qn = vt.parentNode, En = Qn.nodeName.toLowerCase();
            if (Vn(vt) && K.getContentEditable(vt) && (Zt = ve, ve = K.getContentEditable(vt) === "true", xt = !0), Cr(vt) && !S3(e, u, vt, En)) {
              pt = null, Ql(u) && K.remove(vt);
              return;
            }
            if (Ql(u) && u.wrapper && Ud(e, vt, n, o)) {
              pt = null;
              return;
            }
            if (ve && !xt && Ql(u) && !u.wrapper && Jg(e, Xt) && Qg(e, En, De)) {
              const fn = K.rename(vt, De);
              x(fn), te.push(fn), pt = null;
              return;
            }
            if (fl(u)) {
              let fn = R(c, vt);
              if (!fn && Q(Qn) && Fd(u) && (fn = R(c, Qn)), !za(u) || fn) {
                pt = null;
                return;
              }
            }
            ve && !xt && Qg(e, De, Xt) && Qg(e, En, De) && !(!J && rn(vt) && S(vt.data)) && !Xl(vt) && (!za(u) || !K.isBlock(vt)) ? (pt || (pt = K.clone(Be, !1), vt.parentNode.insertBefore(pt, vt), te.push(pt)), pt.appendChild(vt)) : (pt = null, X(Os(vt.childNodes), pn), xt && (ve = Zt), pt = null);
          };
          X(qe, pn);
        }), u.links === !0 && X(te, (qe) => {
          const pt = (pn) => {
            pn.nodeName === "A" && x(pn, u), X(Os(pn.childNodes), pt);
          };
          pt(qe);
        }), X(te, (qe) => {
          const pt = (xt) => {
            let Zt = 0;
            return X(xt.childNodes, (Xt) => {
              !jS(Xt) && !Jl(Xt) && Zt++;
            }), Zt;
          }, pn = (xt) => Wn(xt.childNodes, MA).filter((Xt) => zv(K, Xt, u)).map((Xt) => {
            const Qn = K.clone(Xt, !1);
            return x(Qn), K.replace(Qn, xt, !0), K.remove(Xt, !0), Qn;
          }).getOr(xt), vt = pt(qe);
          if ((te.length > 1 || !K.isBlock(qe)) && vt === 0) {
            K.remove(qe, !0);
            return;
          }
          (za(u) || Ql(u) && u.wrapper) && (!u.exact && vt === 1 && (qe = pn(qe)), HR(e, c, o, qe), Bv(e, u, n, o, qe), IR(K, u, o, qe), FR(K, u, o, qe), LR(K, u, o, qe), b3(K, u, o, qe));
        });
      };
      if (y.getContentEditable(v.getNode()) === "false") {
        r = v.getNode();
        for (let K = 0, ee = c.length; K < ee; K++) {
          const J = c[K];
          if (J.ceFalseOverride && fl(J) && y.is(r, J.selector)) {
            x(r, J);
            break;
          }
        }
        Rb(e, n, r, o);
        return;
      }
      if (u) {
        if (r)
          if (Ff(r)) {
            if (!R(c, r)) {
              const K = y.createRng();
              K.setStartBefore(r), K.setEndAfter(r), W(y, Yo(e, K, c), !0);
            }
          } else
            W(y, r, !0);
        else
          !m || !za(u) || Ld(e).length ? (v.setRng(U_(v.getRng())), Eh(v, !0, () => {
            Ab(e, (K, ee) => {
              const J = ee ? K : Yo(e, K, c);
              W(y, J, !1);
            });
          }), O0(y, v, v.getRng()), e.nodeChanged()) : J_(e, n, o);
        fa(n, e);
      }
      Rb(e, n, r, o);
    }, x3 = (e) => Gn(e, "vars"), BA = (e, n) => {
      e.set({}), n.on("NodeChange", (o) => {
        IA(n, o.element, e.get());
      }), n.on("FormatApply FormatRemove", (o) => {
        const r = O.from(o.node).map((c) => Ff(c) ? c : c.startContainer).bind((c) => Vn(c) ? O.some(c) : O.from(c.parentElement)).getOrThunk(() => $A(n));
        IA(n, r, e.get());
      });
    }, $A = (e) => e.selection.getStart(), PA = (e, n, o, r, c) => vo(n, (y) => {
      const v = e.formatter.matchNode(y, o, c != null ? c : {}, r);
      return !rt(v);
    }, (y) => Y_(e, y, o) ? !0 : r ? !1 : Q(e.formatter.matchNode(y, o, c, !0))), FA = (e, n) => {
      const o = n != null ? n : $A(e);
      return ue(ep(e.dom, o), (r) => Vn(r) && !Hu(r));
    }, IA = (e, n, o) => {
      const r = FA(e, n);
      Jt(o, (c, u) => {
        const m = (y) => {
          const v = PA(e, r, u, y.similar, x3(y) ? y.vars : void 0), x = v.isSome();
          if (y.state.get() !== x) {
            y.state.set(x);
            const R = v.getOr(n);
            x3(y) ? y.callback(x, {
              node: R,
              format: u,
              parents: r
            }) : X(y.callbacks, (F) => F(x, {
              node: R,
              format: u,
              parents: r
            }));
          }
        };
        X([
          c.withSimilar,
          c.withoutSimilar
        ], m), X(c.withVars, m);
      });
    }, VR = (e, n, o, r, c, u) => {
      const m = n.get();
      X(o.split(","), (y) => {
        const v = Xo(m, y).getOrThunk(() => {
          const R = {
            withSimilar: {
              state: ka(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: ka(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return m[y] = R, R;
        }), x = () => {
          const R = FA(e);
          return PA(e, R, y, c, u).isSome();
        };
        if (rt(u)) {
          const R = c ? v.withSimilar : v.withoutSimilar;
          R.callbacks.push(r), R.callbacks.length === 1 && R.state.set(x());
        } else
          v.withVars.push({
            state: ka(x()),
            similar: c,
            vars: u,
            callback: r
          });
      }), n.set(m);
    }, jR = (e, n, o) => {
      const r = e.get();
      X(n.split(","), (c) => Xo(r, c).each((u) => {
        r[c] = {
          withSimilar: {
            ...u.withSimilar,
            callbacks: ue(u.withSimilar.callbacks, (m) => m !== o)
          },
          withoutSimilar: {
            ...u.withoutSimilar,
            callbacks: ue(u.withoutSimilar.callbacks, (m) => m !== o)
          },
          withVars: ue(u.withVars, (m) => m.callback !== o)
        };
      })), e.set(r);
    }, UR = (e, n, o, r, c, u) => (n.get() === null && BA(n, e), VR(e, n, o, r, c, u), { unbind: () => jR(n, o, r) }), WR = (e, n, o, r) => {
      const c = e.formatter.get(n);
      Ov(e, n, o, r) && (!("toggle" in c[0]) || c[0].toggle) ? RA(e, n, o, r) : NA(e, n, o, r);
    };
    function Xh(e) {
      return Xh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
        return typeof n;
      } : function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
      }, Xh(e);
    }
    function T3(e, n) {
      return T3 = Object.setPrototypeOf || function(r, c) {
        return r.__proto__ = c, r;
      }, T3(e, n);
    }
    function ZR() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function o2(e, n, o) {
      return ZR() ? o2 = Reflect.construct : o2 = function(c, u, m) {
        var y = [null];
        y.push.apply(y, u);
        var v = Function.bind.apply(c, y), x = new v();
        return m && T3(x, m.prototype), x;
      }, o2.apply(null, arguments);
    }
    function Zd(e) {
      return LA(e) || qR(e) || e1(e) || GR();
    }
    function LA(e) {
      if (Array.isArray(e))
        return E3(e);
    }
    function qR(e) {
      if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
        return Array.from(e);
    }
    function e1(e, n) {
      if (!!e) {
        if (typeof e == "string")
          return E3(e, n);
        var o = Object.prototype.toString.call(e).slice(8, -1);
        if (o === "Object" && e.constructor && (o = e.constructor.name), o === "Map" || o === "Set")
          return Array.from(e);
        if (o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))
          return E3(e, n);
      }
    }
    function E3(e, n) {
      (n == null || n > e.length) && (n = e.length);
      for (var o = 0, r = new Array(n); o < n; o++)
        r[o] = e[o];
      return r;
    }
    function GR() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var KR = Object.hasOwnProperty, HA = Object.setPrototypeOf, VA = Object.isFrozen, YR = Object.getPrototypeOf, XR = Object.getOwnPropertyDescriptor, Oi = Object.freeze, Uf = Object.seal, JR = Object.create, jA = typeof Reflect < "u" && Reflect, s2 = jA.apply, A3 = jA.construct;
    s2 || (s2 = function(n, o, r) {
      return n.apply(o, r);
    }), Oi || (Oi = function(n) {
      return n;
    }), Uf || (Uf = function(n) {
      return n;
    }), A3 || (A3 = function(n, o) {
      return o2(n, Zd(o));
    });
    var QR = Wf(Array.prototype.forEach), eM = Wf(Array.prototype.pop), Jh = Wf(Array.prototype.push), $v = Wf(String.prototype.toLowerCase), aL = Wf(String.prototype.match), qd = Wf(String.prototype.replace), UA = Wf(String.prototype.indexOf), Pv = Wf(String.prototype.trim), el = Wf(RegExp.prototype.test), r2 = tM(TypeError);
    function Wf(e) {
      return function(n) {
        for (var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), c = 1; c < o; c++)
          r[c - 1] = arguments[c];
        return s2(e, n, r);
      };
    }
    function tM(e) {
      return function() {
        for (var n = arguments.length, o = new Array(n), r = 0; r < n; r++)
          o[r] = arguments[r];
        return A3(e, o);
      };
    }
    function cr(e, n) {
      HA && HA(e, null);
      for (var o = n.length; o--; ) {
        var r = n[o];
        if (typeof r == "string") {
          var c = $v(r);
          c !== r && (VA(n) || (n[o] = c), r = c);
        }
        e[r] = !0;
      }
      return e;
    }
    function Qh(e) {
      var n = JR(null), o;
      for (o in e)
        s2(KR, e, [o]) && (n[o] = e[o]);
      return n;
    }
    function a2(e, n) {
      for (; e !== null; ) {
        var o = XR(e, n);
        if (o) {
          if (o.get)
            return Wf(o.get);
          if (typeof o.value == "function")
            return Wf(o.value);
        }
        e = YR(e);
      }
      function r(c) {
        return console.warn("fallback value for", c), null;
      }
      return r;
    }
    var nM = Oi([
      "a",
      "abbr",
      "acronym",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "decorator",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "element",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meter",
      "nav",
      "nobr",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "select",
      "shadow",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]), z3 = Oi([
      "svg",
      "a",
      "altglyph",
      "altglyphdef",
      "altglyphitem",
      "animatecolor",
      "animatemotion",
      "animatetransform",
      "circle",
      "clippath",
      "defs",
      "desc",
      "ellipse",
      "filter",
      "font",
      "g",
      "glyph",
      "glyphref",
      "hkern",
      "image",
      "line",
      "lineargradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialgradient",
      "rect",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textpath",
      "title",
      "tref",
      "tspan",
      "view",
      "vkern"
    ]), c2 = Oi([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence"
    ]), oM = Oi([
      "animate",
      "color-profile",
      "cursor",
      "discard",
      "fedropshadow",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignobject",
      "hatch",
      "hatchpath",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "missing-glyph",
      "script",
      "set",
      "solidcolor",
      "unknown",
      "use"
    ]), Fv = Oi([
      "math",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mglyph",
      "mi",
      "mlabeledtr",
      "mmultiscripts",
      "mn",
      "mo",
      "mover",
      "mpadded",
      "mphantom",
      "mroot",
      "mrow",
      "ms",
      "mspace",
      "msqrt",
      "mstyle",
      "msub",
      "msup",
      "msubsup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover"
    ]), sM = Oi([
      "maction",
      "maligngroup",
      "malignmark",
      "mlongdiv",
      "mscarries",
      "mscarry",
      "msgroup",
      "mstack",
      "msline",
      "msrow",
      "semantics",
      "annotation",
      "annotation-xml",
      "mprescripts",
      "none"
    ]), Iv = Oi(["#text"]), O3 = Oi([
      "accept",
      "action",
      "align",
      "alt",
      "autocapitalize",
      "autocomplete",
      "autopictureinpicture",
      "autoplay",
      "background",
      "bgcolor",
      "border",
      "capture",
      "cellpadding",
      "cellspacing",
      "checked",
      "cite",
      "class",
      "clear",
      "color",
      "cols",
      "colspan",
      "controls",
      "controlslist",
      "coords",
      "crossorigin",
      "datetime",
      "decoding",
      "default",
      "dir",
      "disabled",
      "disablepictureinpicture",
      "disableremoteplayback",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "face",
      "for",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "id",
      "inputmode",
      "integrity",
      "ismap",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "loop",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "multiple",
      "muted",
      "name",
      "nonce",
      "noshade",
      "novalidate",
      "nowrap",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "playsinline",
      "poster",
      "preload",
      "pubdate",
      "radiogroup",
      "readonly",
      "rel",
      "required",
      "rev",
      "reversed",
      "role",
      "rows",
      "rowspan",
      "spellcheck",
      "scope",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "srclang",
      "start",
      "src",
      "srcset",
      "step",
      "style",
      "summary",
      "tabindex",
      "title",
      "translate",
      "type",
      "usemap",
      "valign",
      "value",
      "width",
      "xmlns",
      "slot"
    ]), ma = Oi([
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "ascent",
      "attributename",
      "attributetype",
      "azimuth",
      "basefrequency",
      "baseline-shift",
      "begin",
      "bias",
      "by",
      "class",
      "clip",
      "clippathunits",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "diffuseconstant",
      "direction",
      "display",
      "divisor",
      "dur",
      "edgemode",
      "elevation",
      "end",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterunits",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyphref",
      "gradientunits",
      "gradienttransform",
      "height",
      "href",
      "id",
      "image-rendering",
      "in",
      "in2",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "keypoints",
      "keysplines",
      "keytimes",
      "lang",
      "lengthadjust",
      "letter-spacing",
      "kernelmatrix",
      "kernelunitlength",
      "lighting-color",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerheight",
      "markerunits",
      "markerwidth",
      "maskcontentunits",
      "maskunits",
      "max",
      "mask",
      "media",
      "method",
      "mode",
      "min",
      "name",
      "numoctaves",
      "offset",
      "operator",
      "opacity",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "paint-order",
      "path",
      "pathlength",
      "patterncontentunits",
      "patterntransform",
      "patternunits",
      "points",
      "preservealpha",
      "preserveaspectratio",
      "primitiveunits",
      "r",
      "rx",
      "ry",
      "radius",
      "refx",
      "refy",
      "repeatcount",
      "repeatdur",
      "restart",
      "result",
      "rotate",
      "scale",
      "seed",
      "shape-rendering",
      "specularconstant",
      "specularexponent",
      "spreadmethod",
      "startoffset",
      "stddeviation",
      "stitchtiles",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke",
      "stroke-width",
      "style",
      "surfacescale",
      "systemlanguage",
      "tabindex",
      "targetx",
      "targety",
      "transform",
      "transform-origin",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textlength",
      "type",
      "u1",
      "u2",
      "unicode",
      "values",
      "viewbox",
      "visibility",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "width",
      "word-spacing",
      "wrap",
      "writing-mode",
      "xchannelselector",
      "ychannelselector",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      "zoomandpan"
    ]), rM = Oi([
      "accent",
      "accentunder",
      "align",
      "bevelled",
      "close",
      "columnsalign",
      "columnlines",
      "columnspan",
      "denomalign",
      "depth",
      "dir",
      "display",
      "displaystyle",
      "encoding",
      "fence",
      "frame",
      "height",
      "href",
      "id",
      "largeop",
      "length",
      "linethickness",
      "lspace",
      "lquote",
      "mathbackground",
      "mathcolor",
      "mathsize",
      "mathvariant",
      "maxsize",
      "minsize",
      "movablelimits",
      "notation",
      "numalign",
      "open",
      "rowalign",
      "rowlines",
      "rowspacing",
      "rowspan",
      "rspace",
      "rquote",
      "scriptlevel",
      "scriptminsize",
      "scriptsizemultiplier",
      "selection",
      "separator",
      "separators",
      "stretchy",
      "subscriptshift",
      "supscriptshift",
      "symmetric",
      "voffset",
      "width",
      "xmlns"
    ]), D3 = Oi([
      "xlink:href",
      "xml:id",
      "xlink:title",
      "xml:space",
      "xmlns:xlink"
    ]), cL = Uf(/\{\{[\w\W]*|[\w\W]*\}\}/gm), lL = Uf(/<%[\w\W]*|[\w\W]*%>/gm), rd = Uf(/^data-[\-\w.\u00B7-\uFFFF]/), l2 = Uf(/^aria-[\-\w]+$/), Lv = Uf(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Hv = Uf(/^(?:\w+script|data):/i), aM = Uf(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), cM = Uf(/^html$/i), Vv = function() {
      return typeof window > "u" ? null : window;
    }, t1 = function(n, o) {
      if (Xh(n) !== "object" || typeof n.createPolicy != "function")
        return null;
      var r = null, c = "data-tt-policy-suffix";
      o.currentScript && o.currentScript.hasAttribute(c) && (r = o.currentScript.getAttribute(c));
      var u = "dompurify" + (r ? "#" + r : "");
      try {
        return n.createPolicy(u, {
          createHTML: function(y) {
            return y;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + u + " could not be created."), null;
      }
    };
    function ey() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Vv(), n = function(Ve) {
        return ey(Ve);
      };
      if (n.version = "2.3.8", n.removed = [], !e || !e.document || e.document.nodeType !== 9)
        return n.isSupported = !1, n;
      var o = e.document, r = e.document, c = e.DocumentFragment, u = e.HTMLTemplateElement, m = e.Node, y = e.Element, v = e.NodeFilter, x = e.NamedNodeMap, R = x === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : x, F = e.HTMLFormElement, W = e.DOMParser, K = e.trustedTypes, ee = y.prototype, J = a2(ee, "cloneNode"), te = a2(ee, "nextSibling"), ve = a2(ee, "childNodes"), De = a2(ee, "parentNode");
      if (typeof u == "function") {
        var Be = r.createElement("template");
        Be.content && Be.content.ownerDocument && (r = Be.content.ownerDocument);
      }
      var qe = t1(K, o), pt = qe ? qe.createHTML("") : "", pn = r, vt = pn.implementation, xt = pn.createNodeIterator, Zt = pn.createDocumentFragment, Xt = pn.getElementsByTagName, Qn = o.importNode, En = {};
      try {
        En = Qh(r).documentMode ? r.documentMode : {};
      } catch {
      }
      var fn = {};
      n.isSupported = typeof De == "function" && vt && typeof vt.createHTMLDocument < "u" && En !== 9;
      var As = cL, Us = lL, lr = rd, qa = l2, Gt = Hv, Hn = aM, ps = Lv, ss = null, ac = cr({}, [].concat(Zd(nM), Zd(z3), Zd(c2), Zd(Fv), Zd(Iv))), ln = null, lo = cr({}, [].concat(Zd(O3), Zd(ma), Zd(rM), Zd(D3))), zn = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), nn = null, is = null, _s = !0, po = !0, eo = !1, Vs = !1, Ws = !1, Ga = !1, mr = !1, bs = !1, gr = !1, yl = !1, bl = !0, Tc = !0, tf = !1, oi = {}, Il = null, Ou = cr({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
      ]), $p = null, Jf = cr({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
      ]), Qf = null, si = cr({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
      ]), ky = "http://www.w3.org/1998/Math/MathML", Pp = "http://www.w3.org/2000/svg", Du = "http://www.w3.org/1999/xhtml", nf = Du, Fp = !1, ou, S1 = [
        "application/xhtml+xml",
        "text/html"
      ], VE = "text/html", em, tm = null, h7 = r.createElement("form"), Pk = function(Ve) {
        return Ve instanceof RegExp || Ve instanceof Function;
      }, Fk = function(Ve) {
        tm && tm === Ve || ((!Ve || Xh(Ve) !== "object") && (Ve = {}), Ve = Qh(Ve), ss = "ALLOWED_TAGS" in Ve ? cr({}, Ve.ALLOWED_TAGS) : ac, ln = "ALLOWED_ATTR" in Ve ? cr({}, Ve.ALLOWED_ATTR) : lo, Qf = "ADD_URI_SAFE_ATTR" in Ve ? cr(Qh(si), Ve.ADD_URI_SAFE_ATTR) : si, $p = "ADD_DATA_URI_TAGS" in Ve ? cr(Qh(Jf), Ve.ADD_DATA_URI_TAGS) : Jf, Il = "FORBID_CONTENTS" in Ve ? cr({}, Ve.FORBID_CONTENTS) : Ou, nn = "FORBID_TAGS" in Ve ? cr({}, Ve.FORBID_TAGS) : {}, is = "FORBID_ATTR" in Ve ? cr({}, Ve.FORBID_ATTR) : {}, oi = "USE_PROFILES" in Ve ? Ve.USE_PROFILES : !1, _s = Ve.ALLOW_ARIA_ATTR !== !1, po = Ve.ALLOW_DATA_ATTR !== !1, eo = Ve.ALLOW_UNKNOWN_PROTOCOLS || !1, Vs = Ve.SAFE_FOR_TEMPLATES || !1, Ws = Ve.WHOLE_DOCUMENT || !1, bs = Ve.RETURN_DOM || !1, gr = Ve.RETURN_DOM_FRAGMENT || !1, yl = Ve.RETURN_TRUSTED_TYPE || !1, mr = Ve.FORCE_BODY || !1, bl = Ve.SANITIZE_DOM !== !1, Tc = Ve.KEEP_CONTENT !== !1, tf = Ve.IN_PLACE || !1, ps = Ve.ALLOWED_URI_REGEXP || ps, nf = Ve.NAMESPACE || Du, Ve.CUSTOM_ELEMENT_HANDLING && Pk(Ve.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (zn.tagNameCheck = Ve.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ve.CUSTOM_ELEMENT_HANDLING && Pk(Ve.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (zn.attributeNameCheck = Ve.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ve.CUSTOM_ELEMENT_HANDLING && typeof Ve.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (zn.allowCustomizedBuiltInElements = Ve.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ou = S1.indexOf(Ve.PARSER_MEDIA_TYPE) === -1 ? ou = VE : ou = Ve.PARSER_MEDIA_TYPE, em = ou === "application/xhtml+xml" ? function(vn) {
          return vn;
        } : $v, Vs && (po = !1), gr && (bs = !0), oi && (ss = cr({}, Zd(Iv)), ln = [], oi.html === !0 && (cr(ss, nM), cr(ln, O3)), oi.svg === !0 && (cr(ss, z3), cr(ln, ma), cr(ln, D3)), oi.svgFilters === !0 && (cr(ss, c2), cr(ln, ma), cr(ln, D3)), oi.mathMl === !0 && (cr(ss, Fv), cr(ln, rM), cr(ln, D3))), Ve.ADD_TAGS && (ss === ac && (ss = Qh(ss)), cr(ss, Ve.ADD_TAGS)), Ve.ADD_ATTR && (ln === lo && (ln = Qh(ln)), cr(ln, Ve.ADD_ATTR)), Ve.ADD_URI_SAFE_ATTR && cr(Qf, Ve.ADD_URI_SAFE_ATTR), Ve.FORBID_CONTENTS && (Il === Ou && (Il = Qh(Il)), cr(Il, Ve.FORBID_CONTENTS)), Tc && (ss["#text"] = !0), Ws && cr(ss, [
          "html",
          "head",
          "body"
        ]), ss.table && (cr(ss, ["tbody"]), delete nn.tbody), Oi && Oi(Ve), tm = Ve);
      }, DC = cr({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
      ]), nm = cr({}, [
        "foreignobject",
        "desc",
        "title",
        "annotation-xml"
      ]), Ik = cr({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
      ]), xe = cr({}, z3);
      cr(xe, c2), cr(xe, oM);
      var Ie = cr({}, Fv);
      cr(Ie, sM);
      var Tt = function(Ve) {
        var vn = De(Ve);
        (!vn || !vn.tagName) && (vn = {
          namespaceURI: Du,
          tagName: "template"
        });
        var bo = $v(Ve.tagName), Vr = $v(vn.tagName);
        return Ve.namespaceURI === Pp ? vn.namespaceURI === Du ? bo === "svg" : vn.namespaceURI === ky ? bo === "svg" && (Vr === "annotation-xml" || DC[Vr]) : Boolean(xe[bo]) : Ve.namespaceURI === ky ? vn.namespaceURI === Du ? bo === "math" : vn.namespaceURI === Pp ? bo === "math" && nm[Vr] : Boolean(Ie[bo]) : Ve.namespaceURI === Du ? vn.namespaceURI === Pp && !nm[Vr] || vn.namespaceURI === ky && !DC[Vr] ? !1 : !Ie[bo] && (Ik[bo] || !xe[bo]) : !1;
      }, kt = function(Ve) {
        Jh(n.removed, { element: Ve });
        try {
          Ve.parentNode.removeChild(Ve);
        } catch {
          try {
            Ve.outerHTML = pt;
          } catch {
            Ve.remove();
          }
        }
      }, Zn = function(Ve, vn) {
        try {
          Jh(n.removed, {
            attribute: vn.getAttributeNode(Ve),
            from: vn
          });
        } catch {
          Jh(n.removed, {
            attribute: null,
            from: vn
          });
        }
        if (vn.removeAttribute(Ve), Ve === "is" && !ln[Ve])
          if (bs || gr)
            try {
              kt(vn);
            } catch {
            }
          else
            try {
              vn.setAttribute(Ve, "");
            } catch {
            }
      }, Rs = function(Ve) {
        var vn, bo;
        if (mr)
          Ve = "<remove></remove>" + Ve;
        else {
          var Vr = aL(Ve, /^[\r\n\t ]+/);
          bo = Vr && Vr[0];
        }
        ou === "application/xhtml+xml" && (Ve = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ve + "</body></html>");
        var Mi = qe ? qe.createHTML(Ve) : Ve;
        if (nf === Du)
          try {
            vn = new W().parseFromString(Mi, ou);
          } catch {
          }
        if (!vn || !vn.documentElement) {
          vn = vt.createDocument(nf, "template", null);
          try {
            vn.documentElement.innerHTML = Fp ? "" : Mi;
          } catch {
          }
        }
        var Ll = vn.body || vn.documentElement;
        return Ve && bo && Ll.insertBefore(r.createTextNode(bo), Ll.childNodes[0] || null), nf === Du ? Xt.call(vn, Ws ? "html" : "body")[0] : Ws ? vn.documentElement : Ll;
      }, Cs = function(Ve) {
        return xt.call(Ve.ownerDocument || Ve, Ve, v.SHOW_ELEMENT | v.SHOW_COMMENT | v.SHOW_TEXT, null, !1);
      }, ri = function(Ve) {
        return Ve instanceof F && (typeof Ve.nodeName != "string" || typeof Ve.textContent != "string" || typeof Ve.removeChild != "function" || !(Ve.attributes instanceof R) || typeof Ve.removeAttribute != "function" || typeof Ve.setAttribute != "function" || typeof Ve.namespaceURI != "string" || typeof Ve.insertBefore != "function");
      }, ud = function(Ve) {
        return Xh(m) === "object" ? Ve instanceof m : Ve && Xh(Ve) === "object" && typeof Ve.nodeType == "number" && typeof Ve.nodeName == "string";
      }, om = function(Ve, vn, bo) {
        !fn[Ve] || QR(fn[Ve], function(Vr) {
          Vr.call(n, vn, bo, tm);
        });
      }, jE = function(Ve) {
        var vn;
        if (om("beforeSanitizeElements", Ve, null), ri(Ve) || el(/[\u0080-\uFFFF]/, Ve.nodeName))
          return kt(Ve), !0;
        var bo = em(Ve.nodeName);
        if (om("uponSanitizeElement", Ve, {
          tagName: bo,
          allowedTags: ss
        }), Ve.hasChildNodes() && !ud(Ve.firstElementChild) && (!ud(Ve.content) || !ud(Ve.content.firstElementChild)) && el(/<[/\w]/g, Ve.innerHTML) && el(/<[/\w]/g, Ve.textContent) || bo === "select" && el(/<template/i, Ve.innerHTML))
          return kt(Ve), !0;
        if (!ss[bo] || nn[bo]) {
          if (!nn[bo] && UE(bo) && (zn.tagNameCheck instanceof RegExp && el(zn.tagNameCheck, bo) || zn.tagNameCheck instanceof Function && zn.tagNameCheck(bo)))
            return !1;
          if (Tc && !Il[bo]) {
            var Vr = De(Ve) || Ve.parentNode, Mi = ve(Ve) || Ve.childNodes;
            if (Mi && Vr)
              for (var Ll = Mi.length, vl = Ll - 1; vl >= 0; --vl)
                Vr.insertBefore(J(Mi[vl], !0), te(Ve));
          }
          return kt(Ve), !0;
        }
        return Ve instanceof y && !Tt(Ve) || (bo === "noscript" || bo === "noembed") && el(/<\/no(script|embed)/i, Ve.innerHTML) ? (kt(Ve), !0) : (Vs && Ve.nodeType === 3 && (vn = Ve.textContent, vn = qd(vn, As, " "), vn = qd(vn, Us, " "), Ve.textContent !== vn && (Jh(n.removed, { element: Ve.cloneNode() }), Ve.textContent = vn)), om("afterSanitizeElements", Ve, null), !1);
      }, RC = function(Ve, vn, bo) {
        if (bl && (vn === "id" || vn === "name") && (bo in r || bo in h7))
          return !1;
        if (!(po && !is[vn] && el(lr, vn))) {
          if (!(_s && el(qa, vn))) {
            if (!ln[vn] || is[vn]) {
              if (!(UE(Ve) && (zn.tagNameCheck instanceof RegExp && el(zn.tagNameCheck, Ve) || zn.tagNameCheck instanceof Function && zn.tagNameCheck(Ve)) && (zn.attributeNameCheck instanceof RegExp && el(zn.attributeNameCheck, vn) || zn.attributeNameCheck instanceof Function && zn.attributeNameCheck(vn)) || vn === "is" && zn.allowCustomizedBuiltInElements && (zn.tagNameCheck instanceof RegExp && el(zn.tagNameCheck, bo) || zn.tagNameCheck instanceof Function && zn.tagNameCheck(bo))))
                return !1;
            } else if (!Qf[vn]) {
              if (!el(ps, qd(bo, Hn, ""))) {
                if (!((vn === "src" || vn === "xlink:href" || vn === "href") && Ve !== "script" && UA(bo, "data:") === 0 && $p[Ve])) {
                  if (!(eo && !el(Gt, qd(bo, Hn, "")))) {
                    if (bo)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, UE = function(Ve) {
        return Ve.indexOf("-") > 0;
      }, WE = function(Ve) {
        var vn, bo, Vr, Mi;
        om("beforeSanitizeAttributes", Ve, null);
        var Ll = Ve.attributes;
        if (!!Ll) {
          var vl = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: ln
          };
          for (Mi = Ll.length; Mi--; ) {
            vn = Ll[Mi];
            var Lk = vn, ai = Lk.name, KI = Lk.namespaceURI;
            bo = ai === "value" ? vn.value : Pv(vn.value), Vr = em(ai);
            var ZE = bo;
            if (vl.attrName = Vr, vl.attrValue = bo, vl.keepAttr = !0, vl.forceKeepAttr = void 0, om("uponSanitizeAttribute", Ve, vl), bo = vl.attrValue, !vl.forceKeepAttr) {
              if (!vl.keepAttr) {
                Zn(ai, Ve);
                continue;
              }
              if (el(/\/>/i, bo)) {
                Zn(ai, Ve);
                continue;
              }
              Vs && (bo = qd(bo, As, " "), bo = qd(bo, Us, " "));
              var YI = em(Ve.nodeName);
              if (!RC(YI, Vr, bo)) {
                Zn(ai, Ve);
                continue;
              }
              if (bo !== ZE)
                try {
                  KI ? Ve.setAttributeNS(KI, ai, bo) : Ve.setAttribute(ai, bo);
                } catch {
                  Zn(ai, Ve);
                }
            }
          }
          om("afterSanitizeAttributes", Ve, null);
        }
      }, y7 = function qo(Ve) {
        var vn, bo = Cs(Ve);
        for (om("beforeSanitizeShadowDOM", Ve, null); vn = bo.nextNode(); )
          om("uponSanitizeShadowNode", vn, null), !jE(vn) && (vn.content instanceof c && qo(vn.content), WE(vn));
        om("afterSanitizeShadowDOM", Ve, null);
      };
      return n.sanitize = function(qo, Ve) {
        var vn, bo, Vr, Mi, Ll;
        if (Fp = !qo, Fp && (qo = "<!-->"), typeof qo != "string" && !ud(qo)) {
          if (typeof qo.toString != "function")
            throw r2("toString is not a function");
          if (qo = qo.toString(), typeof qo != "string")
            throw r2("dirty is not a string, aborting");
        }
        if (!n.isSupported) {
          if (Xh(e.toStaticHTML) === "object" || typeof e.toStaticHTML == "function") {
            if (typeof qo == "string")
              return e.toStaticHTML(qo);
            if (ud(qo))
              return e.toStaticHTML(qo.outerHTML);
          }
          return qo;
        }
        if (Ga || Fk(Ve), n.removed = [], typeof qo == "string" && (tf = !1), tf) {
          if (qo.nodeName) {
            var vl = em(qo.nodeName);
            if (!ss[vl] || nn[vl])
              throw r2("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (qo instanceof m)
          vn = Rs("<!---->"), bo = vn.ownerDocument.importNode(qo, !0), bo.nodeType === 1 && bo.nodeName === "BODY" || bo.nodeName === "HTML" ? vn = bo : vn.appendChild(bo);
        else {
          if (!bs && !Vs && !Ws && qo.indexOf("<") === -1)
            return qe && yl ? qe.createHTML(qo) : qo;
          if (vn = Rs(qo), !vn)
            return bs ? null : yl ? pt : "";
        }
        vn && mr && kt(vn.firstChild);
        for (var Lk = Cs(tf ? qo : vn); Vr = Lk.nextNode(); )
          Vr.nodeType === 3 && Vr === Mi || jE(Vr) || (Vr.content instanceof c && y7(Vr.content), WE(Vr), Mi = Vr);
        if (Mi = null, tf)
          return qo;
        if (bs) {
          if (gr)
            for (Ll = Zt.call(vn.ownerDocument); vn.firstChild; )
              Ll.appendChild(vn.firstChild);
          else
            Ll = vn;
          return ln.shadowroot && (Ll = Qn.call(o, Ll, !0)), Ll;
        }
        var ai = Ws ? vn.outerHTML : vn.innerHTML;
        return Ws && ss["!doctype"] && vn.ownerDocument && vn.ownerDocument.doctype && vn.ownerDocument.doctype.name && el(cM, vn.ownerDocument.doctype.name) && (ai = "<!DOCTYPE " + vn.ownerDocument.doctype.name + `>
` + ai), Vs && (ai = qd(ai, As, " "), ai = qd(ai, Us, " ")), qe && yl ? qe.createHTML(ai) : ai;
      }, n.setConfig = function(qo) {
        Fk(qo), Ga = !0;
      }, n.clearConfig = function() {
        tm = null, Ga = !1;
      }, n.isValidAttribute = function(qo, Ve, vn) {
        tm || Fk({});
        var bo = em(qo), Vr = em(Ve);
        return RC(bo, Vr, vn);
      }, n.addHook = function(qo, Ve) {
        typeof Ve == "function" && (fn[qo] = fn[qo] || [], Jh(fn[qo], Ve));
      }, n.removeHook = function(qo) {
        if (fn[qo])
          return eM(fn[qo]);
      }, n.removeHooks = function(qo) {
        fn[qo] && (fn[qo] = []);
      }, n.removeAllHooks = function() {
        fn = {};
      }, n;
    }
    var lM = ey();
    const i2 = it.explode, R3 = () => {
      const e = {};
      return {
        addFilter: (c, u) => {
          X(i2(c), (m) => {
            Gn(e, m) || (e[m] = {
              name: m,
              callbacks: []
            }), e[m].callbacks.push(u);
          });
        },
        getFilters: () => Tr(e),
        removeFilter: (c, u) => {
          X(i2(c), (m) => {
            if (Gn(e, m))
              if (Q(u)) {
                const y = e[m], v = ue(y.callbacks, (x) => x !== u);
                v.length > 0 ? y.callbacks = v : delete e[m];
              } else
                delete e[m];
          });
        }
      };
    }, WA = (e, n) => {
      X(n, (o) => {
        e.attr(o, null);
      });
    }, iM = (e, n, o) => {
      e.addNodeFilter("font", (r) => {
        X(r, (c) => {
          const u = n.parse(c.attr("style")), m = c.attr("color"), y = c.attr("face"), v = c.attr("size");
          m && (u.color = m), y && (u["font-family"] = y), v && (u["font-size"] = o[parseInt(c.attr("size"), 10) - 1]), c.name = "span", c.attr("style", n.serialize(u)), WA(c, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, uM = (e, n, o) => {
      e.addNodeFilter("strike", (r) => {
        const c = n.type !== "html4";
        X(r, (u) => {
          if (c)
            u.name = "s";
          else {
            const m = o.parse(u.attr("style"));
            m["text-decoration"] = "line-through", u.name = "span", u.attr("style", o.serialize(m));
          }
        });
      });
    }, ZA = (e, n, o) => {
      const r = kr();
      n.convert_fonts_to_spans && iM(e, r, it.explode(n.font_size_legacy_values)), uM(e, o, r);
    }, dM = (e, n, o) => {
      n.inline_styles && ZA(e, n, o);
    }, fM = (e) => fetch(e).then((n) => n.ok ? n.blob() : Promise.reject()).catch(() => Promise.reject(`Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`)), mM = (e) => {
      const n = /([a-z0-9+\/=\s]+)/i.exec(e);
      return n ? n[1] : "";
    }, M3 = (e) => {
      const [n, ...o] = e.split(","), r = o.join(","), c = /data:([^/]+\/[^;]+)(;.+)?/.exec(n);
      if (c) {
        const u = c[2] === ";base64", m = u ? mM(r) : decodeURIComponent(r);
        return O.some({
          type: c[1],
          data: m,
          base64Encoded: u
        });
      } else
        return O.none();
    }, qA = (e, n, o = !0) => {
      let r = n;
      if (o)
        try {
          r = atob(n);
        } catch {
          return O.none();
        }
      const c = new Uint8Array(r.length);
      for (let u = 0; u < c.length; u++)
        c[u] = r.charCodeAt(u);
      return O.some(new Blob([c], { type: e }));
    }, GA = (e) => new Promise((n, o) => {
      M3(e).bind(({ type: r, data: c, base64Encoded: u }) => qA(r, c, u)).fold(() => o("Invalid data URI"), n);
    }), gM = (e) => On(e, "blob:") ? fM(e) : On(e, "data:") ? GA(e) : Promise.reject("Unknown URI format"), n1 = (e) => new Promise((n, o) => {
      const r = new FileReader();
      r.onloadend = () => {
        n(r.result);
      }, r.onerror = () => {
        o(r.error.message);
      }, r.readAsDataURL(e);
    });
    let KA = 0;
    const pM = (e) => (e || "blobid") + KA++, N3 = (e, n, o) => M3(e).bind(({ data: r, type: c, base64Encoded: u }) => {
      if (n && !u)
        return O.none();
      {
        const m = u ? r : btoa(r);
        return o(m, c);
      }
    }), YA = (e, n, o) => {
      const r = e.create(pM(), n, o);
      return e.add(r), r;
    }, B3 = (e, n, o = !1) => N3(n, o, (r, c) => O.from(e.getByData(r, c)).orThunk(() => qA(c, r).map((u) => YA(e, u, r)))), hM = (e, n) => {
      const o = () => Promise.reject("Invalid data URI");
      if (On(n, "blob:")) {
        const r = e.getByUri(n);
        return Q(r) ? Promise.resolve(r) : gM(n).then((c) => n1(c).then((u) => N3(u, !1, (m) => O.some(YA(e, c, m))).getOrThunk(o)));
      } else
        return On(n, "data:") ? B3(e, n).fold(o, (r) => Promise.resolve(r)) : Promise.reject("Unknown image data format");
    }, yM = (e) => Q(e.attr("data-mce-bogus")), XA = (e) => e.attr("src") === Qt.transparentSrc || Q(e.attr("data-mce-placeholder")), JA = (e, n) => {
      const { blob_cache: o } = n, r = (c) => {
        const u = c.attr("src");
        XA(c) || yM(c) || B3(o, u, !0).each((m) => {
          c.attr("src", m.blobUri());
        });
      };
      o && e.addAttributeFilter("src", (c) => X(c, r));
    }, QA = (e, n) => {
      const o = e.schema;
      n.remove_trailing_brs && e.addNodeFilter("br", (r, c, u) => {
        const m = it.extend({}, o.getBlockElements()), y = o.getNonEmptyElements(), v = o.getWhitespaceElements();
        m.body = 1;
        for (let x = 0, R = r.length; x < R; x++) {
          let F = r[x], W = F.parent;
          if (m[F.parent.name] && F === W.lastChild) {
            let K = F.prev;
            for (; K; ) {
              const ee = K.name;
              if (ee !== "span" || K.attr("data-mce-type") !== "bookmark") {
                ee === "br" && (F = null);
                break;
              }
              K = K.prev;
            }
            if (F && (F.remove(), bp(o, y, v, W))) {
              const ee = o.getElementRule(W.name);
              ee && (ee.removeEmpty ? W.remove() : ee.paddEmpty && _v(n, u, m, W));
            }
          } else {
            let K = F;
            for (; W && W.firstChild === K && W.lastChild === K && (K = W, !m[W.name]); )
              W = W.parent;
            if (K === W) {
              const ee = new pl("#text", 3);
              ee.value = Te, F.replace(ee);
            }
          }
        }
      }), e.addAttributeFilter("href", (r) => {
        let c = r.length;
        const u = (y) => y.split(" ").filter((x) => x.length > 0).concat(["noopener"]).sort().join(" "), m = (y) => {
          const v = y ? it.trim(y) : "";
          return /\b(noopener)\b/g.test(v) ? v : u(v);
        };
        if (!n.allow_unsafe_link_target)
          for (; c--; ) {
            const y = r[c];
            y.name === "a" && y.attr("target") === "_blank" && y.attr("rel", m(y.attr("rel")));
          }
      }), n.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (r) => {
        let c = r.length, u, m, y, v;
        for (; c--; )
          if (v = r[c], v.name === "a" && v.firstChild && !v.attr("href")) {
            y = v.parent, u = v.lastChild;
            do
              m = u.prev, y.insert(u, v), u = m;
            while (u);
          }
      }), n.fix_list_elements && e.addNodeFilter("ul,ol", (r) => {
        let c = r.length, u, m;
        for (; c--; )
          if (u = r[c], m = u.parent, m.name === "ul" || m.name === "ol")
            if (u.prev && u.prev.name === "li")
              u.prev.append(u);
            else {
              const y = new pl("li", 1);
              y.attr("style", "list-style-type: none"), u.wrap(y);
            }
      }), n.validate && o.getValidClasses() && e.addAttributeFilter("class", (r) => {
        const c = o.getValidClasses();
        let u = r.length;
        for (; u--; ) {
          const m = r[u], y = m.attr("class").split(" ");
          let v = "";
          for (let x = 0; x < y.length; x++) {
            const R = y[x];
            let F = !1, W = c["*"];
            W && W[R] && (F = !0), W = c[m.name], !F && W && W[R] && (F = !0), F && (v && (v += " "), v += R);
          }
          v.length || (v = null), m.attr("class", v);
        }
      }), JA(e, n);
    }, $3 = it.each, ez = it.trim, bM = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" "), vM = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, kM = [
      "img",
      "video"
    ], wM = (e, n) => Q(e) ? !e : Q(n) ? !Ae(kM, n) : !0, P3 = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, o1 = (e, n, o) => {
      const r = P3(n);
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(r) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(r) ? wM(e.allow_svg_data_urls, o) && /^data:image\/svg\+xml/i.test(r) : /^data:/i.test(r);
    };
    class ad {
      constructor(n, o) {
        n = ez(n), this.settings = o || {};
        const r = this.settings.base_uri, c = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(n) || /^\s*#/.test(n)) {
          c.source = n;
          return;
        }
        const u = n.indexOf("//") === 0;
        if (n.indexOf("/") === 0 && !u && (n = (r && r.protocol || "http") + "://mce_host" + n), !/^[\w\-]*:?\/\//.test(n)) {
          const y = this.settings.base_uri ? this.settings.base_uri.path : new ad(document.location.href).directory;
          if (this.settings.base_uri && this.settings.base_uri.protocol == "")
            n = "//mce_host" + c.toAbsPath(y, n);
          else {
            const v = /([^#?]*)([#?]?.*)/.exec(n);
            n = (r && r.protocol || "http") + "://mce_host" + c.toAbsPath(y, v[1]) + v[2];
          }
        }
        n = n.replace(/@@/g, "(mce_at)");
        const m = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(n);
        $3(bM, (y, v) => {
          let x = m[v];
          x && (x = x.replace(/\(mce_at\)/g, "@@")), c[y] = x;
        }), r && (c.protocol || (c.protocol = r.protocol), c.userInfo || (c.userInfo = r.userInfo), !c.port && c.host === "mce_host" && (c.port = r.port), (!c.host || c.host === "mce_host") && (c.host = r.host), c.source = ""), u && (c.protocol = "");
      }
      static parseDataUri(n) {
        let o;
        const r = decodeURIComponent(n).split(","), c = /data:([^;]+)/.exec(r[0]);
        return c && (o = c[1]), {
          type: o,
          data: r[1]
        };
      }
      static isDomSafe(n, o, r = {}) {
        if (r.allow_script_urls)
          return !0;
        {
          const c = Ls.decode(n).replace(/[\s\u0000-\u001F]+/g, "");
          return !o1(r, c, o);
        }
      }
      static getDocumentBaseUrl(n) {
        let o;
        return n.protocol.indexOf("http") !== 0 && n.protocol !== "file:" ? o = n.href : o = n.protocol + "//" + n.host + n.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(o) && (o = o.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(o) || (o += "/")), o;
      }
      setPath(n) {
        const o = /^(.*?)\/?(\w+)?$/.exec(n);
        this.path = o[0], this.directory = o[1], this.file = o[2], this.source = "", this.getURI();
      }
      toRelative(n) {
        let o;
        if (n === "./")
          return n;
        const r = new ad(n, { base_uri: this });
        if (r.host !== "mce_host" && this.host !== r.host && r.host || this.port !== r.port || this.protocol !== r.protocol && r.protocol !== "")
          return r.getURI();
        const c = this.getURI(), u = r.getURI();
        return c === u || c.charAt(c.length - 1) === "/" && c.substr(0, c.length - 1) === u ? c : (o = this.toRelPath(this.path, r.path), r.query && (o += "?" + r.query), r.anchor && (o += "#" + r.anchor), o);
      }
      toAbsolute(n, o) {
        const r = new ad(n, { base_uri: this });
        return r.getURI(o && this.isSameOrigin(r));
      }
      isSameOrigin(n) {
        if (this.host == n.host && this.protocol == n.protocol) {
          if (this.port == n.port)
            return !0;
          const o = vM[this.protocol];
          if (o && (this.port || o) == (n.port || o))
            return !0;
        }
        return !1;
      }
      toRelPath(n, o) {
        let r = 0, c = "", u, m;
        const y = n.substring(0, n.lastIndexOf("/")).split("/"), v = o.split("/");
        if (y.length >= v.length) {
          for (u = 0, m = y.length; u < m; u++)
            if (u >= v.length || y[u] !== v[u]) {
              r = u + 1;
              break;
            }
        }
        if (y.length < v.length) {
          for (u = 0, m = v.length; u < m; u++)
            if (u >= y.length || y[u] !== v[u]) {
              r = u + 1;
              break;
            }
        }
        if (r === 1)
          return o;
        for (u = 0, m = y.length - (r - 1); u < m; u++)
          c += "../";
        for (u = r - 1, m = v.length; u < m; u++)
          u !== r - 1 ? c += "/" + v[u] : c += v[u];
        return c;
      }
      toAbsPath(n, o) {
        let r, c = 0, u = [], m;
        const y = /\/$/.test(o) ? "/" : "";
        let v = n.split("/");
        const x = o.split("/");
        for ($3(v, (R) => {
          R && u.push(R);
        }), v = u, r = x.length - 1, u = []; r >= 0; r--)
          if (!(x[r].length === 0 || x[r] === ".")) {
            if (x[r] === "..") {
              c++;
              continue;
            }
            if (c > 0) {
              c--;
              continue;
            }
            u.push(x[r]);
          }
        return r = v.length - c, r <= 0 ? m = Ho(u).join("/") : m = v.slice(0, r).join("/") + "/" + Ho(u).join("/"), m.indexOf("/") !== 0 && (m = "/" + m), y && m.lastIndexOf("/") !== m.length - 1 && (m += y), m;
      }
      getURI(n = !1) {
        let o;
        return (!this.source || n) && (o = "", n || (this.protocol ? o += this.protocol + "://" : o += "//", this.userInfo && (o += this.userInfo + "@"), this.host && (o += this.host), this.port && (o += ":" + this.port)), this.path && (o += this.path), this.query && (o += "?" + this.query), this.anchor && (o += "#" + this.anchor), this.source = o), this.source;
      }
    }
    const F3 = it.makeMap, jv = it.extend, _M = {
      IN_PLACE: !0,
      ALLOW_UNKNOWN_PROTOCOLS: !0,
      ALLOWED_TAGS: [
        "#comment",
        "#cdata-section",
        "body"
      ],
      ALLOWED_ATTR: []
    }, CM = it.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), Zf = "data-mce-type", I3 = (e, n) => {
      const o = { ..._M };
      return o.PARSER_MEDIA_TYPE = n, e.allow_script_urls ? o.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (o.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), o;
    }, tz = (e, n) => {
      const o = lM(), r = n.getSpecialElements(), c = e.validate;
      let u = 0;
      return o.addHook("uponSanitizeElement", (m, y) => {
        var v, x;
        m.nodeType === G && !e.allow_conditional_comments && /^\[if/i.test(m.nodeValue) && (m.nodeValue = " " + m.nodeValue);
        const R = y.tagName;
        if (m.nodeType !== Ye || R === "body")
          return;
        const F = be.fromDom(m), W = R.toLowerCase(), K = Ni(F, Zf), ee = Na(F, "data-mce-bogus");
        if (!K && ie(ee)) {
          ee === "all" ? Gs(F) : $a(F);
          return;
        }
        const J = n.getElementRule(W);
        if (c && !J) {
          Gn(r, W) ? Gs(F) : $a(F);
          return;
        } else
          y.allowedTags[R] = !0;
        if (c && !K) {
          if (X((v = J.attributesForced) !== null && v !== void 0 ? v : [], (te) => {
            ms(F, te.name, te.value === "{$uid}" ? `mce_${u++}` : te.value);
          }), X((x = J.attributesDefault) !== null && x !== void 0 ? x : [], (te) => {
            Ni(F, te.name) || ms(F, te.name, te.value === "{$uid}" ? `mce_${u++}` : te.value);
          }), J.attributesRequired && !Oe(J.attributesRequired, (te) => Ni(F, te))) {
            $a(F);
            return;
          }
          if (J.removeEmptyAttrs && Cl(F)) {
            $a(F);
            return;
          }
          J.outputName && J.outputName !== W && qC(F, J.outputName);
        }
      }), o.addHook("uponSanitizeAttribute", (m, y) => {
        const v = m.tagName.toLowerCase(), { attrName: x, attrValue: R } = y;
        y.keepAttr = !c || n.isValid(v, x) || On(x, "data-") || On(x, "aria-"), x in CM && o1(e, R, v) && (y.keepAttr = !1), y.keepAttr ? (y.allowedAttributes[x] = !0, x in n.getBoolAttrs() && (y.attrValue = x), e.allow_svg_data_urls && On(R, "data:image/svg+xml") && (y.forceKeepAttr = !0)) : m.hasAttribute(Zf) && (x === "id" || x === "class" || x === "style") && (y.forceKeepAttr = !0);
      }), o;
    }, s1 = (e, n, o) => {
      const r = e.name, c = r in o && r !== "title" && r !== "textarea", u = n.childNodes;
      for (let m = 0, y = u.length; m < y; m++) {
        const v = u[m], x = new pl(v.nodeName.toLowerCase(), v.nodeType);
        if (Vn(v)) {
          const R = v.attributes;
          for (let F = 0, W = R.length; F < W; F++) {
            const K = R[F];
            x.attr(K.name, K.value);
          }
        } else
          rn(v) ? (x.value = v.data, c && (x.raw = !0)) : (hm(v) || Ty(v) || jp(v)) && (x.value = v.data);
        s1(x, v, o), e.append(x);
      }
    }, nz = (e, n, o) => {
      const r = [];
      for (let c = e, u = c; Q(c); u = c, c = c.walk())
        X(n, (m) => m(c)), lt(c.parent) && c !== e ? c = u : r.push(c);
      for (let c = r.length - 1; c >= 0; c--) {
        const u = r[c];
        X(o, (m) => m(u));
      }
    }, oz = (e, n, o, r) => {
      const c = o.validate, u = n.getNonEmptyElements(), m = n.getWhitespaceElements(), y = jv(F3("script,style,head,html,body,title,meta,param"), n.getBlockElements()), v = Ny(n), x = /[ \t\r\n]+/g, R = /^[ \t\r\n]+/, F = /[ \t\r\n]+$/, W = (ve) => {
        for (ve = ve.parent; Q(ve); ) {
          if (ve.name in m)
            return !0;
          ve = ve.parent;
        }
        return !1;
      }, K = (ve) => {
        let De = ve;
        for (; Q(De); ) {
          if (De.name in v)
            return bp(n, u, m, De);
          De = De.parent;
        }
        return !1;
      }, ee = (ve, De) => {
        const Be = De ? ve.prev : ve.next;
        return Q(Be) ? !1 : ve.parent.name in y && (ve.parent !== e || r.isRootContent);
      };
      return [
        (ve) => {
          if (ve.type === 3 && !W(ve)) {
            let De = ve.value;
            De = De.replace(x, " "), (o3(ve.prev, y) || ee(ve, !0)) && (De = De.replace(R, "")), De.length === 0 ? ve.remove() : ve.value = De;
          }
        },
        (ve) => {
          var De;
          if (ve.type === 1) {
            const Be = n.getElementRule(ve.name);
            if (c && Be) {
              const qe = bp(n, u, m, ve);
              Be.paddInEmptyBlock && qe && K(ve) ? _v(o, r, y, ve) : Be.removeEmpty && qe ? y[ve.name] ? ve.remove() : ve.unwrap() : Be.paddEmpty && (qe || t3(ve)) && _v(o, r, y, ve);
            }
          } else if (ve.type === 3 && !W(ve)) {
            let Be = ve.value;
            (y[(De = ve.next) === null || De === void 0 ? void 0 : De.name] || ee(ve, !1)) && (Be = Be.replace(F, "")), Be.length === 0 ? ve.remove() : ve.value = Be;
          }
        }
      ];
    }, sz = (e, n) => {
      var o;
      const r = (o = n.forced_root_block) !== null && o !== void 0 ? o : e.forced_root_block;
      return r === !1 ? "" : r === !0 ? "p" : r;
    }, ty = (e = {}, n = pi()) => {
      const o = R3(), r = R3(), c = {
        validate: !0,
        root_name: "body",
        ...e
      }, u = new DOMParser(), m = tz(c, n), y = (De, Be, qe = "html") => {
        const pt = qe === "xhtml" ? "application/xhtml+xml" : "text/html", pn = Gn(n.getSpecialElements(), Be.toLowerCase()), vt = pn ? `<${Be}>${De}</${Be}>` : De, xt = qe === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${vt}</body></html>` : `<body>${vt}</body>`, Zt = u.parseFromString(xt, pt).body;
        return m.sanitize(Zt, I3(c, pt)), m.removed = [], pn ? Zt.firstChild : Zt;
      }, v = o.addFilter, x = o.getFilters, R = o.removeFilter, F = r.addFilter, W = r.getFilters, K = r.removeFilter, ee = (De, Be) => {
        const qe = De.parent;
        qe && n.children[De.name] && !n.isValidChild(qe.name, De.name) && Be.push(De);
      }, J = (De, Be) => {
        const qe = jv(F3("script,style,head,html,body,title,meta,param"), n.getBlockElements()), pt = /^[ \t\r\n]+/, pn = /[ \t\r\n]+$/;
        let vt = De.firstChild, xt = null;
        const Zt = (Xt) => {
          Xt && (vt = Xt.firstChild, vt && vt.type === 3 && (vt.value = vt.value.replace(pt, "")), vt = Xt.lastChild, vt && vt.type === 3 && (vt.value = vt.value.replace(pn, "")));
        };
        if (!!n.isValidChild(De.name, Be.toLowerCase())) {
          for (; vt; ) {
            const Xt = vt.next;
            vt.type === 3 || vt.type === 1 && vt.name !== "p" && !qe[vt.name] && !vt.attr(Zf) ? (xt || (xt = new pl(Be, 1), xt.attr(c.forced_root_block_attrs), De.insert(xt, vt)), xt.append(vt)) : (Zt(xt), xt = null), vt = Xt;
          }
          Zt(xt);
        }
      }, ve = {
        schema: n,
        addAttributeFilter: F,
        getAttributeFilters: W,
        removeAttributeFilter: K,
        addNodeFilter: v,
        getNodeFilters: x,
        removeNodeFilter: R,
        parse: (De, Be = {}) => {
          var qe;
          const pt = c.validate, pn = (qe = Be.context) !== null && qe !== void 0 ? qe : c.root_name, vt = y(De, pn, Be.format), xt = new pl(pn, 11);
          s1(xt, vt, n.getSpecialElements());
          const [Zt, Xt] = oz(xt, n, c, Be), Qn = [], En = pt ? (lr) => ee(lr, Qn) : Se, fn = {
            nodes: {},
            attributes: {}
          }, As = (lr) => _r(x(), W(), lr, fn);
          if (nz(xt, [
            Zt,
            As
          ], [
            Xt,
            En
          ]), Qn.reverse(), pt && Qn.length > 0)
            if (Be.context) {
              const {
                pass: lr,
                fail: qa
              } = ke(Qn, (Gt) => Gt.parent === xt);
              j_(qa, n, As), Be.invalid = lr.length > 0;
            } else
              j_(Qn, n, As);
          const Us = sz(c, Be);
          return Us && (xt.name === "body" || Be.isRootContent) && J(xt, Us), Be.invalid || Qx(fn, Be), xt;
        }
      };
      return QA(ve, c), dM(ve, c, n), ve;
    }, SM = (e) => Tv(e) ? gp({ validate: !1 }).serialize(e) : e, rz = (e, n) => {
      const o = SM(e), r = n(o);
      if (r.isDefaultPrevented())
        return r;
      if (Tv(e))
        if (r.content !== o) {
          const c = ty({
            validate: !1,
            forced_root_block: !1
          }).parse(r.content, { context: e.name });
          return {
            ...r,
            content: c
          };
        } else
          return {
            ...r,
            content: e
          };
      else
        return r;
    }, az = (e, n) => {
      if (n.no_events)
        return ul.value(n);
      {
        const o = L0(e, n);
        return o.isDefaultPrevented() ? ul.error(m_(e, {
          content: "",
          ...o
        }).content) : ul.value(o);
      }
    }, u2 = (e, n, o) => o.no_events ? n : rz(n, (c) => m_(e, {
      ...o,
      content: c
    })).content, L3 = (e, n) => {
      if (n.no_events)
        return ul.value(n);
      {
        const o = rz(n.content, (r) => Mb(e, {
          ...n,
          content: r
        }));
        return o.isDefaultPrevented() ? (Nb(e, o), ul.error(void 0)) : ul.value(o);
      }
    }, H3 = (e, n, o) => {
      o.no_events || Nb(e, {
        ...o,
        content: n
      });
    }, ny = (e, n, o) => ({
      element: e,
      width: n,
      rows: o
    }), d2 = (e, n) => ({
      element: e,
      cells: n
    }), xM = (e, n) => ({
      x: e,
      y: n
    }), V3 = (e, n) => {
      const o = parseInt(Na(e, n), 10);
      return isNaN(o) ? 1 : o;
    }, TM = (e, n, o, r, c) => {
      const u = V3(c, "rowspan"), m = V3(c, "colspan"), y = e.rows;
      for (let v = o; v < o + u; v++) {
        y[v] || (y[v] = d2(I1(r), []));
        for (let x = n; x < n + m; x++) {
          const R = y[v].cells;
          R[x] = v === o && x === n ? c : zg(c);
        }
      }
    }, f2 = (e, n, o) => {
      const r = e.rows;
      return !!(r[o] ? r[o].cells : [])[n];
    }, cz = (e, n, o) => {
      for (; f2(e, n, o); )
        n++;
      return n;
    }, lz = (e) => Ht(e, (n, o) => o.cells.length > n ? o.cells.length : n, 0), j3 = (e, n) => {
      const o = e.rows;
      for (let r = 0; r < o.length; r++) {
        const c = o[r].cells;
        for (let u = 0; u < c.length; u++)
          if (Is(c[u], n))
            return O.some(xM(u, r));
      }
      return O.none();
    }, iz = (e, n, o, r, c) => {
      const u = [], m = e.rows;
      for (let y = o; y <= c; y++) {
        const v = m[y].cells, x = n < r ? v.slice(n, r + 1) : v.slice(r, n + 1);
        u.push(d2(m[y].element, x));
      }
      return u;
    }, EM = (e, n, o) => {
      const r = n.x, c = n.y, u = o.x, m = o.y, y = c < m ? iz(e, r, c, u, m) : iz(e, r, m, u, c);
      return ny(e.element, lz(y), y);
    }, U3 = (e, n) => {
      const o = zg(e.element), r = be.fromTag("tbody");
      return Fu(r, n), Kr(o, r), o;
    }, AM = (e) => ae(e.rows, (n) => {
      const o = ae(n.cells, (c) => {
        const u = I1(c);
        return $r(u, "colspan"), $r(u, "rowspan"), u;
      }), r = zg(n.element);
      return Fu(r, o), r;
    }), uz = (e) => {
      const n = ny(zg(e), 0, []);
      return X(ia(e, "tr"), (o, r) => {
        X(ia(o, "td,th"), (c, u) => {
          TM(n, cz(n, u, r), r, o, c);
        });
      }), ny(n.element, lz(n.rows), n.rows);
    }, dz = (e) => U3(e, AM(e)), W3 = (e, n, o) => j3(e, n).bind((r) => j3(e, o).map((c) => EM(e, r, c))), zM = (e) => Wn(e, (n) => An(n) === "ul" || An(n) === "ol"), fz = (e, n) => Wn(e, (o) => An(o) === "li" && xh(o, n)).fold(Pe([]), (o) => zM(e).map((r) => {
      const c = be.fromTag(An(r)), u = hr(Ip(r), (m, y) => On(y, "list-style"));
      return Or(c, u), [
        be.fromTag("li"),
        c
      ];
    }).getOr([])), Z3 = (e, n) => {
      const o = Ht(n, (r, c) => (Kr(c, r), c), e);
      return n.length > 0 ? Hf([o]) : o;
    }, OM = (e) => zl(e) ? ec(e).filter(xs).fold(Pe([]), (n) => [
      e,
      n
    ]) : xs(e) ? [e] : [], DM = (e, n) => {
      const o = be.fromDom(n.commonAncestorContainer), r = Vm(o, e), c = ue(r, mg), u = fz(r, n), m = c.concat(u.length ? u : OM(o));
      return ae(m, zg);
    }, mz = () => Hf([]), RM = (e, n) => Z3(be.fromDom(n.cloneContents()), DM(e, n)), gz = (e, n) => vd(n, "table", Ct(Is, e)), q3 = (e, n) => gz(e, n[0]).bind((o) => {
      const r = n[0], c = n[n.length - 1], u = uz(o);
      return W3(u, r, c).map((m) => Hf([dz(m)]));
    }).getOrThunk(mz), pz = (e, n) => n.length > 0 && n[0].collapsed ? mz() : RM(e, n[0]), hz = (e, n) => {
      const o = Sh(n, e);
      return o.length > 0 ? q3(e, o) : pz(e, n);
    }, Uv = (e, n) => n >= 0 && n < e.length && Yg(e.charAt(n)), G3 = (e) => P(e.innerText), yz = (e) => e.map((n) => n.nodeName).getOr("div").toLowerCase(), bz = (e) => O.from(e.selection.getRng()).map((n) => {
      const o = O.from(e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock)), r = e.getBody(), c = yz(o), u = e.dom.add(r, c, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, n.cloneContents()), m = G3(u), y = P(u.textContent);
      if (e.dom.remove(u), Uv(y, 0) || Uv(y, y.length - 1)) {
        const v = o.getOr(r), x = G3(v), R = x.indexOf(m);
        if (R === -1)
          return m;
        {
          const F = Uv(x, R - 1), W = Uv(x, R + m.length);
          return (F ? " " : "") + m + (W ? " " : "");
        }
      } else
        return m;
    }).getOr(""), MM = (e, n) => {
      const o = e.selection.getRng(), r = e.dom.create("body"), c = e.selection.getSel(), u = xc(e, Id(c)), m = n.contextual ? hz(be.fromDom(e.getBody()), u).dom : o.cloneContents();
      return m && r.appendChild(m), e.selection.serializer.serialize(r, n);
    }, K3 = (e, n) => {
      if (n.format === "text")
        return bz(e);
      {
        const o = MM(e, n);
        return n.format === "tree" ? o : e.selection.isCollapsed() ? "" : o;
      }
    }, NM = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      selection: !0,
      getInner: !0
    }), m2 = (e, n, o = {}) => {
      const r = NM(o, n);
      return az(e, r).fold(Rt, (c) => {
        const u = K3(e, c);
        return u2(e, u, c);
      });
    }, Y3 = 0, vz = 1, kz = 2, wz = (e, n) => {
      const o = e.length + n.length + 2, r = new Array(o), c = new Array(o), u = (R, F, W) => ({
        start: R,
        end: F,
        diag: W
      }), m = (R, F, W, K, ee) => {
        const J = v(R, F, W, K);
        if (J === null || J.start === F && J.diag === F - K || J.end === R && J.diag === R - W) {
          let te = R, ve = W;
          for (; te < F || ve < K; )
            te < F && ve < K && e[te] === n[ve] ? (ee.push([
              Y3,
              e[te]
            ]), ++te, ++ve) : F - R > K - W ? (ee.push([
              kz,
              e[te]
            ]), ++te) : (ee.push([
              vz,
              n[ve]
            ]), ++ve);
        } else {
          m(R, J.start, W, J.start - J.diag, ee);
          for (let te = J.start; te < J.end; ++te)
            ee.push([
              Y3,
              e[te]
            ]);
          m(J.end, F, J.end - J.diag, K, ee);
        }
      }, y = (R, F, W, K) => {
        let ee = R;
        for (; ee - F < K && ee < W && e[ee] === n[ee - F]; )
          ++ee;
        return u(R, ee, F);
      }, v = (R, F, W, K) => {
        const ee = F - R, J = K - W;
        if (ee === 0 || J === 0)
          return null;
        const te = ee - J, ve = J + ee, De = (ve % 2 === 0 ? ve : ve + 1) / 2;
        r[1 + De] = R, c[1 + De] = F + 1;
        let Be, qe, pt, pn, vt;
        for (Be = 0; Be <= De; ++Be) {
          for (qe = -Be; qe <= Be; qe += 2) {
            for (pt = qe + De, qe === -Be || qe !== Be && r[pt - 1] < r[pt + 1] ? r[pt] = r[pt + 1] : r[pt] = r[pt - 1] + 1, pn = r[pt], vt = pn - R + W - qe; pn < F && vt < K && e[pn] === n[vt]; )
              r[pt] = ++pn, ++vt;
            if (te % 2 !== 0 && te - Be <= qe && qe <= te + Be && c[pt - te] <= r[pt])
              return y(c[pt - te], qe + R - W, F, K);
          }
          for (qe = te - Be; qe <= te + Be; qe += 2) {
            for (pt = qe + De - te, qe === te - Be || qe !== te + Be && c[pt + 1] <= c[pt - 1] ? c[pt] = c[pt + 1] - 1 : c[pt] = c[pt - 1], pn = c[pt] - 1, vt = pn - R + W - qe; pn >= R && vt >= W && e[pn] === n[vt]; )
              c[pt] = pn--, vt--;
            if (te % 2 === 0 && -Be <= qe && qe <= Be && c[pt] <= r[pt + te])
              return y(c[pt], qe + R - W, F, K);
          }
        }
      }, x = [];
      return m(0, e.length, 0, n.length, x), x;
    }, X3 = (e) => Vn(e) ? e.outerHTML : rn(e) ? Ls.encodeRaw(e.data, !1) : hm(e) ? "<!--" + e.data + "-->" : "", BM = (e) => {
      let n;
      const o = document.createElement("div"), r = document.createDocumentFragment();
      for (e && (o.innerHTML = e); n = o.firstChild; )
        r.appendChild(n);
      return r;
    }, $M = (e, n, o) => {
      const r = BM(n);
      if (e.hasChildNodes() && o < e.childNodes.length) {
        const c = e.childNodes[o];
        c.parentNode.insertBefore(r, c);
      } else
        e.appendChild(r);
    }, PM = (e, n) => {
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const o = e.childNodes[n];
        o.parentNode.removeChild(o);
      }
    }, FM = (e, n) => {
      let o = 0;
      X(e, (r) => {
        r[0] === Y3 ? o++ : r[0] === vz ? ($M(n, r[1], o), o++) : r[0] === kz && PM(n, o);
      });
    }, _z = (e) => ue(ae(Os(e.childNodes), X3), (n) => n.length > 0), iL = (e, n) => {
      const o = ae(Os(n.childNodes), X3);
      return FM(wz(o, e), n), n;
    }, IM = Rn(() => document.implementation.createHTMLDocument("undo")), LM = (e) => e.indexOf("</iframe>") !== -1, HM = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), VM = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), g2 = (e) => {
      const n = _z(e.getBody()), o = yn(n, (c) => {
        const u = l5(e.serializer, c);
        return u.length > 0 ? [u] : [];
      }), r = o.join("");
      return LM(r) ? HM(o) : VM(r);
    }, J3 = (e, n, o) => {
      const r = o ? n.beforeBookmark : n.bookmark;
      n.type === "fragmented" ? iL(n.fragments, e.getBody()) : e.setContent(n.content, {
        format: "raw",
        no_selection: Q(r) && T0(r) ? !r.isFakeCaret : !0
      }), e.selection.moveToBookmark(r);
    }, Q3 = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, eT = (e) => {
      const n = be.fromTag("body", IM());
      return mf(n, Q3(e)), X(ia(n, "*[data-mce-bogus]"), $a), ag(n);
    }, jM = (e, n) => Q3(e) === Q3(n), UM = (e, n) => eT(e) === eT(n), tT = (e, n) => !e || !n ? !1 : jM(e, n) ? !0 : UM(e, n), nT = (e) => e.get() === 0, p2 = (e, n, o) => {
      nT(o) && (e.typing = n);
    }, Wv = (e, n) => {
      e.typing && (p2(e, !1, n), e.add());
    }, WM = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, ZM = (e, n, o) => {
      nT(n) && o.set(Y1(e.selection));
    }, Cz = (e, n, o, r, c, u, m) => {
      const y = g2(e);
      if (u = u || {}, u = it.extend(u, y), nT(r) === !1 || e.removed)
        return null;
      const v = n.data[o.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: u,
        lastLevel: v,
        originalEvent: m
      }).isDefaultPrevented() || v && tT(v, u))
        return null;
      n.data[o.get()] && c.get().each((F) => {
        n.data[o.get()].beforeBookmark = F;
      });
      const x = hS(e);
      if (x && n.data.length > x) {
        for (let F = 0; F < n.data.length - 1; F++)
          n.data[F] = n.data[F + 1];
        n.data.length--, o.set(n.data.length);
      }
      u.bookmark = Y1(e.selection), o.get() < n.data.length - 1 && (n.data.length = o.get() + 1), n.data.push(u), o.set(n.data.length - 1);
      const R = {
        level: u,
        lastLevel: v,
        originalEvent: m
      };
      return o.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", R), e.dispatch("change", R)) : e.dispatch("AddUndo", R), u;
    }, oT = (e, n, o) => {
      n.data = [], o.set(0), n.typing = !1, e.dispatch("ClearUndos");
    }, qM = (e, n, o, r, c) => {
      if (n.transact(r)) {
        const u = n.data[o.get()].bookmark, m = n.data[o.get() - 1];
        J3(e, m, !0), n.transact(c) && (n.data[o.get() - 1].beforeBookmark = u);
      }
    }, GM = (e, n, o) => {
      let r;
      return n.get() < o.length - 1 && (n.set(n.get() + 1), r = o[n.get()], J3(e, r, !1), e.setDirty(!0), e.dispatch("Redo", { level: r })), r;
    }, uL = (e, n, o, r) => {
      let c;
      return n.typing && (n.add(), n.typing = !1, p2(n, !1, o)), r.get() > 0 && (r.set(r.get() - 1), c = n.data[r.get()], J3(e, c, !0), e.setDirty(!0), e.dispatch("Undo", { level: c })), c;
    }, KM = (e) => {
      e.clear(), e.add();
    }, Zv = (e, n, o) => o.get() > 0 || n.typing && n.data[0] && !tT(g2(e), n.data[0]), Sz = (e, n) => n.get() < e.data.length - 1 && !e.typing, xz = (e, n, o) => (Wv(e, n), e.beforeChange(), e.ignore(o), e.add()), YM = (e, n) => {
      try {
        e.set(e.get() + 1), n();
      } finally {
        e.set(e.get() - 1);
      }
    }, Tz = (e, n) => {
      const o = e.dom, r = Q(n) ? n : e.getBody();
      rt(e.hasVisual) && (e.hasVisual = bS(e)), X(o.select("table,a", r), (c) => {
        switch (c.nodeName) {
          case "TABLE":
            const u = sb(e), m = o.getAttrib(c, "border");
            (!m || m === "0") && e.hasVisual ? o.addClass(c, u) : o.removeClass(c, u);
            break;
          case "A":
            if (!o.getAttrib(c, "href")) {
              const y = o.getAttrib(c, "name") || c.id, v = Ew(e);
              y && e.hasVisual ? o.addClass(c, v) : o.removeClass(c, v);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: n,
        hasVisual: e.hasVisual
      });
    }, Ez = (e) => ({
      init: { bindEvents: Se },
      undoManager: {
        beforeChange: (n, o) => ZM(e, n, o),
        add: (n, o, r, c, u, m) => Cz(e, n, o, r, c, u, m),
        undo: (n, o, r) => uL(e, n, o, r),
        redo: (n, o) => GM(e, n, o),
        clear: (n, o) => oT(e, n, o),
        reset: (n) => KM(n),
        hasUndo: (n, o) => Zv(e, n, o),
        hasRedo: (n, o) => Sz(n, o),
        transact: (n, o, r) => xz(n, o, r),
        ignore: (n, o) => YM(n, o),
        extra: (n, o, r, c) => qM(e, n, o, r, c)
      },
      formatter: {
        match: (n, o, r, c) => Ov(e, n, o, r, c),
        matchAll: (n, o) => AR(e, n, o),
        matchNode: (n, o, r, c) => Ud(e, n, o, r, c),
        canApply: (n) => zR(e, n),
        closest: (n) => vA(e, n),
        apply: (n, o, r) => NA(e, n, o, r),
        remove: (n, o, r, c) => RA(e, n, o, r, c),
        toggle: (n, o, r) => WR(e, n, o, r),
        formatChanged: (n, o, r, c, u) => UR(e, n, o, r, c, u)
      },
      editor: {
        getContent: (n) => B_(e, n),
        setContent: (n, o) => rL(e, n, o),
        insertContent: (n, o) => xv(e, n, o),
        addVisual: (n) => Tz(e, n)
      },
      selection: { getContent: (n, o) => m2(e, n, o) },
      autocompleter: {
        addDecoration: (n) => _x(e, n),
        removeDecoration: () => Hh(e, be.fromDom(e.getBody()))
      },
      raw: { getModel: () => O.none() }
    }), XM = (e) => {
      const n = (x) => dn(x) ? x : {}, { init: o, undoManager: r, formatter: c, editor: u, selection: m, autocompleter: y, raw: v } = e;
      return {
        init: { bindEvents: o.bindEvents },
        undoManager: {
          beforeChange: r.beforeChange,
          add: r.add,
          undo: r.undo,
          redo: r.redo,
          clear: r.clear,
          reset: r.reset,
          hasUndo: r.hasUndo,
          hasRedo: r.hasRedo,
          transact: (x, R, F) => r.transact(F),
          ignore: (x, R) => r.ignore(R),
          extra: (x, R, F, W) => r.extra(F, W)
        },
        formatter: {
          match: (x, R, F, W) => c.match(x, n(R), W),
          matchAll: c.matchAll,
          matchNode: c.matchNode,
          canApply: (x) => c.canApply(x),
          closest: (x) => c.closest(x),
          apply: (x, R, F) => c.apply(x, n(R)),
          remove: (x, R, F, W) => c.remove(x, n(R)),
          toggle: (x, R, F) => c.toggle(x, n(R)),
          formatChanged: (x, R, F, W, K) => c.formatChanged(R, F, W, K)
        },
        editor: {
          getContent: (x) => u.getContent(x),
          setContent: (x, R) => ({
            content: u.setContent(x, R),
            html: ""
          }),
          insertContent: (x, R) => (u.insertContent(x), ""),
          addVisual: u.addVisual
        },
        selection: { getContent: (x, R) => m.getContent(R) },
        autocompleter: {
          addDecoration: y.addDecoration,
          removeDecoration: y.removeDecoration
        },
        raw: { getModel: () => O.some(v.getRawModel()) }
      };
    }, JM = () => {
      const e = Pe(null), n = Pe("");
      return {
        init: { bindEvents: Se },
        undoManager: {
          beforeChange: Se,
          add: e,
          undo: e,
          redo: e,
          clear: Se,
          reset: Se,
          hasUndo: Mn,
          hasRedo: Mn,
          transact: e,
          ignore: Se,
          extra: Se
        },
        formatter: {
          match: Mn,
          matchAll: Pe([]),
          matchNode: Pe(void 0),
          canApply: Mn,
          closest: n,
          apply: Se,
          remove: Se,
          toggle: Se,
          formatChanged: Pe({ unbind: Se })
        },
        editor: {
          getContent: n,
          setContent: Pe({
            content: "",
            html: ""
          }),
          insertContent: Pe(""),
          addVisual: Se
        },
        selection: { getContent: n },
        autocompleter: {
          addDecoration: Se,
          removeDecoration: Se
        },
        raw: { getModel: Pe(O.none()) }
      };
    }, Wm = (e) => Gn(e.plugins, "rtc"), Az = (e) => Xo(e.plugins, "rtc").bind((n) => O.from(n.setup)), QM = (e) => {
      const n = e;
      return Az(e).fold(() => (n.rtcInstance = Ez(e), O.none()), (o) => (n.rtcInstance = JM(), O.some(() => o().then((r) => (n.rtcInstance = XM(r), r.rtc.isRemote)))));
    }, sT = (e) => e.rtcInstance ? e.rtcInstance : Ez(e), Lr = (e) => {
      const n = e.rtcInstance;
      if (n)
        return n;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, zz = (e, n, o) => {
      Lr(e).undoManager.beforeChange(n, o);
    }, Oz = (e, n, o, r, c, u, m) => Lr(e).undoManager.add(n, o, r, c, u, m), eN = (e, n, o, r) => Lr(e).undoManager.undo(n, o, r), tN = (e, n, o) => Lr(e).undoManager.redo(n, o), nN = (e, n, o) => {
      Lr(e).undoManager.clear(n, o);
    }, Dz = (e, n) => {
      Lr(e).undoManager.reset(n);
    }, oN = (e, n, o) => Lr(e).undoManager.hasUndo(n, o), sN = (e, n, o) => Lr(e).undoManager.hasRedo(n, o), rN = (e, n, o, r) => Lr(e).undoManager.transact(n, o, r), aN = (e, n, o) => {
      Lr(e).undoManager.ignore(n, o);
    }, dL = (e, n, o, r, c) => {
      Lr(e).undoManager.extra(n, o, r, c);
    }, Zm = (e, n, o, r, c) => Lr(e).formatter.match(n, o, r, c), Rz = (e, n, o) => Lr(e).formatter.matchAll(n, o), cN = (e, n, o, r, c) => Lr(e).formatter.matchNode(n, o, r, c), lN = (e, n) => Lr(e).formatter.canApply(n), iN = (e, n) => Lr(e).formatter.closest(n), uN = (e, n, o, r) => {
      Lr(e).formatter.apply(n, o, r);
    }, Bs = (e, n, o, r, c) => {
      Lr(e).formatter.remove(n, o, r, c);
    }, fL = (e, n, o, r) => {
      Lr(e).formatter.toggle(n, o, r);
    }, dN = (e, n, o, r, c, u) => Lr(e).formatter.formatChanged(n, o, r, c, u), fN = (e, n) => sT(e).editor.getContent(n), oa = (e, n, o) => sT(e).editor.setContent(n, o), mN = (e, n, o) => sT(e).editor.insertContent(n, o), qv = (e, n, o) => Lr(e).selection.getContent(n, o), gN = (e, n) => Lr(e).editor.addVisual(n), Mz = (e) => Lr(e).init.bindEvents(), pN = (e, n) => Lr(e).autocompleter.addDecoration(n), Nz = (e) => Lr(e).autocompleter.removeDecoration(), _p = (e, n = {}) => {
      const o = n.format ? n.format : "html";
      return qv(e, o, n);
    }, ei = (e) => e.dom.length === 0 ? (Gs(e), O.none()) : O.some(e), Gv = (e, n) => e.filter((o) => Oh.isBookmarkNode(o.dom)).bind(n ? lf : sl), oy = (e, n, o, r) => {
      const c = e.dom, u = n.dom, m = r ? c.length : u.length;
      r ? (go(c, u, !1, !r), o.setStart(u, m)) : (go(u, c, !1, !r), o.setEnd(u, m));
    }, qm = (e, n) => {
      ec(e).each((o) => {
        const r = e.dom;
        n && jh(o, Ke(r, 0)) ? F_(r, 0) : !n && Px(o, Ke(r, r.length)) && Fx(r, r.length);
      });
    }, r1 = (e, n, o, r) => {
      e.bind((c) => ((r ? Fx : F_)(c.dom, r ? c.dom.length : 0), n.filter(Ps).map((m) => oy(c, m, o, r)))).orThunk(() => Gv(n, r).or(n).filter(Ps).map((u) => qm(u, r)));
    }, rT = (e, n) => {
      const o = O.from(n.firstChild).map(be.fromDom), r = O.from(n.lastChild).map(be.fromDom);
      e.deleteContents(), e.insertNode(n);
      const c = o.bind(sl).filter(Ps).bind(ei), u = r.bind(lf).filter(Ps).bind(ei);
      r1(c, o, e, !0), r1(u, r, e, !1), e.collapse(!1);
    }, aT = (e, n) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: n
    }), Bz = (e, n) => {
      if (n.format !== "raw") {
        const o = e.selection.getRng(), r = e.dom.getParent(o.commonAncestorContainer, e.dom.isBlock), c = r ? { context: r.nodeName.toLowerCase() } : {}, u = e.parser.parse(n.content, {
          forced_root_block: !1,
          ...c,
          ...n
        });
        return gp({ validate: !1 }, e.schema).serialize(u);
      } else
        return n.content;
    }, $z = (e, n, o = {}) => {
      const r = aT(o, n);
      L3(e, r).each((c) => {
        const u = Bz(e, c), m = e.selection.getRng();
        rT(m, m.createContextualFragment(u)), e.selection.setRng(m), Ai(e, m), H3(e, u, c);
      });
    }, Pz = (e, n, o) => {
      if (e && Gn(e, n)) {
        const r = ue(e[n], (c) => c !== o);
        r.length === 0 ? delete e[n] : e[n] = r;
      }
    };
    var Fz = (e, n) => {
      let o, r;
      const c = (m, y) => Wn(y, (v) => e.is(v, m)), u = (m) => e.getParents(m, null, e.getRoot());
      return {
        selectorChangedWithUnbind: (m, y) => (o || (o = {}, r = {}, n.on("NodeChange", (v) => {
          const x = v.element, R = u(x), F = {};
          it.each(o, (W, K) => {
            c(K, R).each((ee) => {
              r[K] || (X(W, (J) => {
                J(!0, {
                  node: ee,
                  selector: K,
                  parents: R
                });
              }), r[K] = W), F[K] = W;
            });
          }), it.each(r, (W, K) => {
            F[K] || (delete r[K], it.each(W, (ee) => {
              ee(!1, {
                node: x,
                selector: K,
                parents: R
              });
            }));
          });
        })), o[m] || (o[m] = []), o[m].push(y), c(m, u(n.selection.getStart())).each(() => {
          r[m] = o[m];
        }), {
          unbind: () => {
            Pz(o, m, y), Pz(r, m, y);
          }
        })
      };
    };
    const cT = (e) => !!(e && e.ownerDocument) && ya(be.fromDom(e.ownerDocument), be.fromDom(e)), hN = (e) => e ? cT(e.startContainer) && cT(e.endContainer) : !1, lT = (e, n, o, r) => {
      let c, u;
      const { selectorChangedWithUnbind: m } = Fz(e, r), y = (Gt, Hn) => {
        const ps = e.createRng();
        Q(Gt) && Q(Hn) ? (ps.setStart(Gt, Hn), ps.setEnd(Gt, Hn), Be(ps), te(!1)) : (Eb(e, ps, r.getBody(), !0), Be(ps));
      }, v = (Gt) => _p(r, Gt), x = (Gt, Hn) => $z(r, Gt, Hn), R = (Gt) => Ys(r.getBody(), De(), Gt), F = (Gt) => Sc(r.getBody(), De(), Gt), W = (Gt, Hn) => lr.getBookmark(Gt, Hn), K = (Gt) => lr.moveToBookmark(Gt), ee = (Gt, Hn) => (mp(e, Gt, Hn).each(Be), Gt), J = () => {
        const Gt = De(), Hn = ve();
        return !Gt || Gt.item ? !1 : Gt.compareEndPoints ? Gt.compareEndPoints("StartToEnd", Gt) === 0 : !Hn || Gt.collapsed;
      }, te = (Gt) => {
        const Hn = De();
        Hn.collapse(!!Gt), Be(Hn);
      }, ve = () => n.getSelection ? n.getSelection() : n.document.selection, De = () => {
        let Gt, Hn, ps;
        const ss = (ln, lo, zn) => {
          try {
            return lo.compareBoundaryPoints(ln, zn);
          } catch {
            return -1;
          }
        }, ac = n.document;
        if (r.bookmark !== void 0 && xr(r) === !1) {
          const ln = Vf(r);
          if (ln.isSome())
            return ln.map((lo) => xc(r, [lo])[0]).getOr(ac.createRange());
        }
        try {
          (Gt = ve()) && !hf(Gt.anchorNode) && (Gt.rangeCount > 0 ? Hn = Gt.getRangeAt(0) : Hn = Gt.createRange ? Gt.createRange() : ac.createRange(), Hn = xc(r, [Hn])[0]);
        } catch {
        }
        return Hn || (Hn = ac.createRange()), Hn.setStart && Hn.startContainer.nodeType === 9 && Hn.collapsed && (ps = e.getRoot(), Hn.setStart(ps, 0), Hn.setEnd(ps, 0)), c && u && (ss(Hn.START_TO_START, Hn, c) === 0 && ss(Hn.END_TO_END, Hn, c) === 0 ? Hn = u : (c = null, u = null)), Hn;
      }, Be = (Gt, Hn) => {
        let ps;
        if (!hN(Gt))
          return;
        const ss = ve();
        if (Gt = r.dispatch("SetSelectionRange", {
          range: Gt,
          forward: Hn
        }).range, ss) {
          u = Gt;
          try {
            ss.removeAllRanges(), ss.addRange(Gt);
          } catch {
          }
          Hn === !1 && ss.extend && (ss.collapse(Gt.endContainer, Gt.endOffset), ss.extend(Gt.startContainer, Gt.startOffset)), c = ss.rangeCount > 0 ? ss.getRangeAt(0) : null;
        }
        !Gt.collapsed && Gt.startContainer === Gt.endContainer && ss.setBaseAndExtent && Gt.endOffset - Gt.startOffset < 2 && Gt.startContainer.hasChildNodes() && (ps = Gt.startContainer.childNodes[Gt.startOffset], ps && ps.tagName === "IMG" && (ss.setBaseAndExtent(Gt.startContainer, Gt.startOffset, Gt.endContainer, Gt.endOffset), (ss.anchorNode !== Gt.startContainer || ss.focusNode !== Gt.endContainer) && ss.setBaseAndExtent(ps, 0, ps, 1))), r.dispatch("AfterSetSelectionRange", {
          range: Gt,
          forward: Hn
        });
      }, qe = (Gt) => (x(e.getOuterHTML(Gt)), Gt), pt = () => Yi(r.getBody(), De()), pn = (Gt, Hn) => zi(e, De(), Gt, Hn), vt = () => {
        const Gt = ve(), Hn = Gt == null ? void 0 : Gt.anchorNode, ps = Gt == null ? void 0 : Gt.focusNode;
        if (!Gt || !Hn || !ps || hf(Hn) || hf(ps))
          return !0;
        const ss = e.createRng(), ac = e.createRng();
        try {
          ss.setStart(Hn, Gt.anchorOffset), ss.collapse(!0), ac.setStart(ps, Gt.focusOffset), ac.collapse(!0);
        } catch {
          return !0;
        }
        return ss.compareBoundaryPoints(ss.START_TO_START, ac) <= 0;
      }, Us = {
        bookmarkManager: null,
        controlSelection: null,
        dom: e,
        win: n,
        serializer: o,
        editor: r,
        collapse: te,
        setCursorLocation: y,
        getContent: v,
        setContent: x,
        getBookmark: W,
        moveToBookmark: K,
        select: ee,
        isCollapsed: J,
        isForward: vt,
        setNode: qe,
        getNode: pt,
        getSel: ve,
        setRng: Be,
        getRng: De,
        getStart: R,
        getEnd: F,
        getSelectedBlocks: pn,
        normalize: () => {
          const Gt = De(), Hn = ve();
          if (!GS(Hn) && Th(r)) {
            const ps = Hb(e, Gt);
            return ps.each((ss) => {
              Be(ss, vt());
            }), ps.getOr(Gt);
          }
          return Gt;
        },
        selectorChanged: (Gt, Hn) => (m(Gt, Hn), Us),
        selectorChangedWithUnbind: m,
        getScrollContainer: () => {
          let Gt, Hn = e.getRoot();
          for (; Hn && Hn.nodeName !== "BODY"; ) {
            if (Hn.scrollHeight > Hn.clientHeight) {
              Gt = Hn;
              break;
            }
            Hn = Hn.parentNode;
          }
          return Gt;
        },
        scrollIntoView: (Gt, Hn) => {
          Q(Gt) ? av(r, Gt, Hn) : Ai(r, De(), Hn);
        },
        placeCaretAt: (Gt, Hn) => Be(Ei(Gt, Hn, r.getDoc())),
        getBoundingClientRect: () => {
          const Gt = De();
          return Gt.collapsed ? Ke.fromRangeStart(Gt).getClientRects()[0] : Gt.getBoundingClientRect();
        },
        destroy: () => {
          n = c = u = null, qa.destroy();
        }
      }, lr = Oh(Us), qa = y_(Us, r);
      return Us.bookmarkManager = lr, Us.controlSelection = qa, Us;
    }, yN = (e, n, o) => {
      e.addAttributeFilter("data-mce-tabindex", (r, c) => {
        let u = r.length;
        for (; u--; ) {
          const m = r[u];
          m.attr("tabindex", m.attr("data-mce-tabindex")), m.attr(c, null);
        }
      }), e.addAttributeFilter("src,href,style", (r, c) => {
        const u = "data-mce-" + c, m = n.url_converter, y = n.url_converter_scope;
        let v = r.length;
        for (; v--; ) {
          const x = r[v];
          let R = x.attr(u);
          R !== void 0 ? (x.attr(c, R.length > 0 ? R : null), x.attr(u, null)) : (R = x.attr(c), c === "style" ? R = o.serializeStyle(o.parseStyle(R), x.name) : m && (R = m.call(y, R, c, x.name)), x.attr(c, R.length > 0 ? R : null));
        }
      }), e.addAttributeFilter("class", (r) => {
        let c = r.length;
        for (; c--; ) {
          const u = r[c];
          let m = u.attr("class");
          m && (m = u.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), u.attr("class", m.length > 0 ? m : null));
        }
      }), e.addAttributeFilter("data-mce-type", (r, c, u) => {
        let m = r.length;
        for (; m--; ) {
          const y = r[m];
          y.attr("data-mce-type") === "bookmark" && !u.cleanup && (O.from(y.firstChild).exists((x) => !S(x.value)) ? y.unwrap() : y.remove());
        }
      }), e.addNodeFilter("noscript", (r) => {
        let c = r.length;
        for (; c--; ) {
          const u = r[c].firstChild;
          u && (u.value = Ls.decode(u.value));
        }
      }), e.addNodeFilter("script,style", (r, c) => {
        const u = (y) => y.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let m = r.length;
        for (; m--; ) {
          const y = r[m], v = y.firstChild ? y.firstChild.value : "";
          if (c === "script") {
            const x = y.attr("type");
            x && y.attr("type", x === "mce-no/type" ? null : x.replace(/^mce\-/, "")), n.element_format === "xhtml" && v.length > 0 && (y.firstChild.value = `// <![CDATA[
` + u(v) + `
// ]]>`);
          } else
            n.element_format === "xhtml" && v.length > 0 && (y.firstChild.value = `<!--
` + u(v) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (r) => {
        let c = r.length;
        for (; c--; ) {
          const u = r[c];
          n.preserve_cdata && u.value.indexOf("[CDATA[") === 0 ? (u.name = "#cdata", u.type = 4, u.value = o.decode(u.value.replace(/^\[CDATA\[|\]\]$/g, ""))) : u.value.indexOf("mce:protected ") === 0 && (u.name = "#text", u.type = 3, u.raw = !0, u.value = unescape(u.value).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (r, c) => {
        let u = r.length;
        for (; u--; ) {
          const m = r[u];
          m.type === 7 ? m.remove() : m.type === 1 && c === "input" && !m.attr("type") && m.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (r) => {
        X(r, (c) => {
          c.attr("data-mce-type") === "format-caret" && (c.isEmpty(e.schema.getNonEmptyElements()) ? c.remove() : c.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", (r, c) => {
        let u = r.length;
        for (; u--; )
          r[u].attr(c, null);
      });
    }, Kv = (e) => {
      const n = (r) => r && r.name === "br", o = e.lastChild;
      if (n(o)) {
        const r = o.prev;
        n(r) && (o.remove(), r.remove());
      }
    }, iT = (e, n, o) => {
      let r;
      const c = e.dom;
      let u = n.cloneNode(!0);
      const m = document.implementation;
      if (m.createHTMLDocument) {
        const y = m.createHTMLDocument("");
        it.each(u.nodeName === "BODY" ? u.childNodes : [u], (v) => {
          y.body.appendChild(y.importNode(v, !0));
        }), u.nodeName !== "BODY" ? u = y.body.firstChild : u = y.body, r = c.doc, c.doc = y;
      }
      return QS(e, {
        ...o,
        node: u
      }), r && (c.doc = r), u;
    }, mL = (e, n) => e && e.hasEventListeners("PreProcess") && !n.no_events, bN = (e, n, o) => mL(e, o) ? iT(e, n, o) : n, vN = (e, n, o) => {
      it.inArray(n, o) === -1 && (e.addAttributeFilter(o, (r, c) => {
        let u = r.length;
        for (; u--; )
          r[u].attr(c, null);
      }), n.push(o));
    }, a1 = (e, n, o) => !n.no_events && e ? ex(e, {
      ...n,
      content: o
    }).content : o, gL = (e, n, o) => {
      const r = P(o.getInner ? n.innerHTML : e.getOuterHTML(n));
      return o.selection || vm(be.fromDom(n)) ? r : it.trim(r);
    }, pL = (e, n, o) => {
      const r = o.selection ? {
        forced_root_block: !1,
        ...o
      } : o, c = e.parse(n, r);
      return Kv(c), c;
    }, Bc = (e, n, o) => gp(e, n).serialize(o), kN = (e, n, o, r, c) => {
      const u = Bc(n, o, r);
      return a1(e, c, u);
    }, Iz = (e, n) => {
      const o = ["data-mce-selected"], r = n && n.dom ? n.dom : Ks.DOM, c = n && n.schema ? n.schema : pi(e);
      e.entity_encoding = e.entity_encoding || "named", e.remove_trailing_brs = "remove_trailing_brs" in e ? e.remove_trailing_brs : !0;
      const u = ty(e, c);
      yN(u, e, r);
      const m = (y, v = {}) => {
        const x = {
          format: "html",
          ...v
        }, R = bN(n, y, x), F = gL(r, R, x), W = pL(u, F, x);
        return x.format === "tree" ? W : kN(n, e, c, W, x);
      };
      return {
        schema: c,
        addNodeFilter: u.addNodeFilter,
        addAttributeFilter: u.addAttributeFilter,
        serialize: m,
        addRules: c.addValidElements,
        setRules: c.setValidElements,
        addTempAttr: Ct(vN, u, o),
        getTempAttrs: Pe(o),
        getNodeFilters: u.getNodeFilters,
        getAttributeFilters: u.getAttributeFilters,
        removeNodeFilter: u.removeNodeFilter,
        removeAttributeFilter: u.removeAttributeFilter
      };
    }, uT = (e, n) => {
      const o = Iz(e, n);
      return {
        schema: o.schema,
        addNodeFilter: o.addNodeFilter,
        addAttributeFilter: o.addAttributeFilter,
        serialize: o.serialize,
        addRules: o.addRules,
        setRules: o.setRules,
        addTempAttr: o.addTempAttr,
        getTempAttrs: o.getTempAttrs,
        getNodeFilters: o.getNodeFilters,
        getAttributeFilters: o.getAttributeFilters,
        removeNodeFilter: o.removeNodeFilter,
        removeAttributeFilter: o.removeAttributeFilter
      };
    }, Lz = "html", Hz = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      getInner: !0
    }), dT = (e, n = {}) => {
      const o = n.format ? n.format : Lz, r = Hz(n, o);
      return az(e, r).fold(Rt, (c) => {
        const u = fN(e, c);
        return u2(e, u, c);
      });
    }, hL = "html", wN = (e, n) => ({
      format: hL,
      ...e,
      set: !0,
      content: n
    }), Vz = (e, n, o = {}) => {
      const r = wN(o, n);
      return L3(e, r).map((c) => {
        const u = oa(e, c.content, c);
        return H3(e, u.html, c), u.content;
      }).getOr(n);
    }, _N = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), CN = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), qf = (e) => {
      const n = ue(_N, (r) => Gn(e, r)), o = e.forced_root_block;
      return (o === !1 || o === "") && n.push("forced_root_block (false only)"), ro(n);
    }, yL = (e) => {
      const n = it.makeMap(e.plugins, " "), r = ue(CN, (c) => Gn(n, c));
      return ro(r);
    }, SN = (e, n) => {
      const o = qf(e), r = yL(n), c = r.length > 0, u = o.length > 0, m = n.theme === "mobile";
      if (c || u || m) {
        const y = `
- `, v = m ? `

Themes:${y}mobile` : "", x = c ? `

Plugins:${y}${r.join(y)}` : "", R = u ? `

Options:${y}${o.join(y)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + v + x + R);
      }
    }, xN = (e, n) => {
      SN(e, n);
    }, fT = Ks.DOM, TN = (e) => {
      fT.setStyle(e.id, "display", e.orgDisplay);
    }, Hr = (e) => O.from(e).each((n) => n.destroy()), jz = (e) => {
      e.contentAreaContainer = e.formElement = e.container = e.editorContainer = null, e.bodyElement = e.contentDocument = e.contentWindow = null, e.iframeElement = e.targetElm = null, e.selection && (e.selection = e.selection.win = e.selection.dom = e.selection.dom.doc = null);
    }, Uz = (e) => {
      const n = e.formElement;
      n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, n._mceOldSubmit = null), fT.unbind(n, "submit reset", e.formEventDelegate));
    }, Gd = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: n, editorUpload: o } = e, r = e.getBody(), c = e.getElement();
        r && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && c && fT.remove(c.nextSibling), tx(e), e.editorManager.remove(e), !e.inline && r && TN(e), nx(e), fT.remove(e.getContainer()), Hr(n), Hr(o), e.destroy();
      }
    }, Wz = (e, n) => {
      const { selection: o, dom: r } = e;
      if (!e.destroyed) {
        if (!n && !e.removed) {
          e.remove();
          return;
        }
        n || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), Hr(o), Hr(r)), Uz(e), jz(e), e.destroyed = !0;
      }
    }, h2 = (() => {
      const e = {};
      return {
        add: (c, u) => {
          e[c] = u;
        },
        get: (c) => e[c] ? e[c] : { icons: {} },
        has: (c) => Gn(e, c)
      };
    })(), Cp = Dc.ModelManager, Zz = (e, n) => n.dom[e], sy = (e, n) => parseInt(Gr(n, e), 10), EN = Ct(Zz, "clientWidth"), qz = Ct(Zz, "clientHeight"), Gz = Ct(sy, "margin-top"), mT = Ct(sy, "margin-left"), Kz = (e) => e.dom.getBoundingClientRect(), gT = (e, n, o) => {
      const r = EN(e), c = qz(e);
      return n >= 0 && o >= 0 && n <= r && o <= c;
    }, AN = (e, n, o, r) => {
      const c = Kz(n), u = e ? c.left + n.dom.clientLeft + mT(n) : 0, m = e ? c.top + n.dom.clientTop + Gz(n) : 0, y = o - u, v = r - m;
      return {
        x: y,
        y: v
      };
    }, zN = (e, n, o) => {
      const r = be.fromDom(e.getBody()), c = e.inline ? r : rm(r), u = AN(e.inline, c, n, o);
      return gT(c, u.x, u.y);
    }, ON = (e) => O.from(e).map(be.fromDom), cd = (e) => {
      const n = e.inline ? e.getBody() : e.getContentAreaContainer();
      return ON(n).map(xo).getOr(!1);
    }, vL = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    }, DN = (e) => {
      const n = [], o = () => {
        const W = e.theme;
        return W && W.getNotificationManagerImpl ? W.getNotificationManagerImpl() : vL();
      }, r = () => O.from(n[0]), c = (W, K) => W.type === K.type && W.text === K.text && !W.progressBar && !W.timeout && !K.progressBar && !K.timeout, u = () => {
        X(n, (W) => {
          W.reposition();
        });
      }, m = (W) => {
        n.push(W);
      }, y = (W) => {
        ko(n, (K) => K === W).each((K) => {
          n.splice(K, 1);
        });
      }, v = (W, K = !0) => {
        if (!(e.removed || !cd(e)))
          return K && e.dispatch("BeforeOpenNotification", { notification: W }), Wn(n, (ee) => c(o().getArgs(ee), W)).getOrThunk(() => {
            e.editorManager.setActive(e);
            const ee = o().open(W, () => {
              y(ee), u(), r().fold(() => e.focus(), (J) => _u(be.fromDom(J.getEl())));
            });
            return m(ee), u(), e.dispatch("OpenNotification", { notification: { ...ee } }), ee;
          });
      }, x = () => {
        r().each((W) => {
          o().close(W), y(W), u();
        });
      }, R = Pe(n);
      return ((W) => {
        W.on("SkinLoaded", () => {
          const K = fS(W);
          K && v({
            text: K,
            type: "warning",
            timeout: 0
          }, !1), u();
        }), W.on("show ResizeEditor ResizeWindow NodeChange", () => {
          requestAnimationFrame(u);
        }), W.on("remove", () => {
          X(n.slice(), (K) => {
            o().close(K);
          });
        });
      })(e), {
        open: v,
        close: x,
        getNotifications: R
      };
    }, c1 = Dc.PluginManager, Kd = Dc.ThemeManager;
    var RN = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e,
        getParams: e,
        setParams: e
      };
    };
    const pT = (e) => {
      let n = [];
      const o = () => {
        const J = e.theme;
        return J && J.getWindowManagerImpl ? J.getWindowManagerImpl() : RN();
      }, r = (J, te) => (...ve) => te ? te.apply(J, ve) : void 0, c = (J) => {
        e.dispatch("OpenWindow", { dialog: J });
      }, u = (J) => {
        e.dispatch("CloseWindow", { dialog: J });
      }, m = (J) => {
        n.push(J), c(J);
      }, y = (J) => {
        u(J), n = ue(n, (te) => te !== J), n.length === 0 && e.focus();
      }, v = () => O.from(n[n.length - 1]), x = (J) => {
        e.editorManager.setActive(e), cv(e), e.ui.show();
        const te = J();
        return m(te), te;
      }, R = (J, te) => x(() => o().open(J, te, y)), F = (J) => x(() => o().openUrl(J, y)), W = (J, te, ve) => {
        const De = o();
        De.alert(J, r(ve || De, te));
      }, K = (J, te, ve) => {
        const De = o();
        De.confirm(J, r(ve || De, te));
      }, ee = () => {
        v().each((J) => {
          o().close(J), y(J);
        });
      };
      return e.on("remove", () => {
        X(n, (J) => {
          o().close(J);
        });
      }), {
        open: R,
        openUrl: F,
        alert: W,
        confirm: K,
        close: ee
      };
    }, hT = (e, n) => {
      e.notificationManager.open({
        type: "error",
        text: n
      });
    }, Yv = (e, n) => {
      e._skinLoaded ? hT(e, n) : e.on("SkinLoaded", () => {
        hT(e, n);
      });
    }, MN = (e, n) => {
      Yv(e, Dl.translate([
        "Failed to upload image: {0}",
        n
      ]));
    }, Xv = (e, n, o) => {
      Dh(e, n, { message: o }), console.error(o);
    }, ld = (e, n, o) => o ? `Failed to load ${e}: ${o} from url ${n}` : `Failed to load ${e} url: ${n}`, NN = (e, n, o) => {
      Xv(e, "PluginLoadError", ld("plugin", n, o));
    }, BN = (e, n, o) => {
      Xv(e, "IconsLoadError", ld("icons", n, o));
    }, $N = (e, n, o) => {
      Xv(e, "LanguageLoadError", ld("language", n, o));
    }, PN = (e, n, o) => {
      Xv(e, "ThemeLoadError", ld("theme", n, o));
    }, FN = (e, n, o) => {
      Xv(e, "ModelLoadError", ld("model", n, o));
    }, IN = (e, n, o) => {
      const r = Dl.translate([
        "Failed to initialize plugin: {0}",
        n
      ]);
      Dh(e, "PluginLoadError", { message: r }), y2(r, o), Yv(e, r);
    }, y2 = (e, ...n) => {
      const o = window.console;
      o && (o.error ? o.error(e, ...n) : o.log(e, ...n));
    }, LN = (e) => /^[a-z0-9\-]+$/i.test(e), HN = (e) => Yz(e, iS(e)), VN = (e) => Yz(e, _w(e)), Yz = (e, n) => {
      const o = e.editorManager.baseURL + "/skins/content", c = `content${e.editorManager.suffix}.css`, u = e.inline === !0;
      return ae(n, (m) => LN(m) && !u ? `${o}/${m}/${c}` : e.documentBaseURI.toAbsolute(m));
    }, kL = (e) => {
      e.contentCSS = e.contentCSS.concat(HN(e), VN(e));
    }, Jv = Xe, jN = (e, n, o) => fm(e, n, Jv, o), yT = (e) => e ? Os(e.getElementsByTagName("img")) : [], UN = (e, n) => {
      const o = {};
      return { findAll: (c, u = Xe) => {
        const m = ue(yT(c), (v) => {
          const x = v.src;
          return v.hasAttribute("data-mce-bogus") || v.hasAttribute("data-mce-placeholder") || !x || x === Qt.transparentSrc ? !1 : On(x, "blob:") ? !e.isUploaded(x) && u(v) : On(x, "data:") ? u(v) : !1;
        }), y = ae(m, (v) => {
          const x = v.src;
          if (Gn(o, x))
            return o[x].then((R) => ie(R) ? R : {
              image: v,
              blobInfo: R.blobInfo
            });
          {
            const R = hM(n, x).then((F) => (delete o[x], {
              image: v,
              blobInfo: F
            })).catch((F) => (delete o[x], F));
            return o[x] = R, R;
          }
        });
        return Promise.all(y);
      } };
    }, Xz = () => {
      let o = {};
      const r = (W, K) => ({
        status: W,
        resultUri: K
      }), c = (W) => W in o;
      return {
        hasBlobUri: c,
        getResultUri: (W) => {
          const K = o[W];
          return K ? K.resultUri : null;
        },
        isPending: (W) => c(W) ? o[W].status === 1 : !1,
        isUploaded: (W) => c(W) ? o[W].status === 2 : !1,
        markPending: (W) => {
          o[W] = r(1, null);
        },
        markUploaded: (W, K) => {
          o[W] = r(2, K);
        },
        removeFailed: (W) => {
          delete o[W];
        },
        destroy: () => {
          o = {};
        }
      };
    };
    let WN = 0;
    const ZN = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36), n = new Date().getTime();
      return "s" + n.toString(36) + e() + e() + e();
    }, ry = (e) => e + WN++ + ZN(), ay = () => {
      let e = [];
      const n = (F) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[F.toLowerCase()] || "dat", o = (F, W, K, ee, J) => {
        if (ie(F))
          return r({
            id: F,
            name: ee,
            filename: J,
            blob: W,
            base64: K
          });
        if (dn(F))
          return r(F);
        throw new Error("Unknown input type");
      }, r = (F) => {
        if (!F.blob || !F.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const W = F.id || ry("blobid"), K = F.name || W, ee = F.blob;
        return {
          id: Pe(W),
          name: Pe(K),
          filename: Pe(F.filename || K + "." + n(ee.type)),
          blob: Pe(ee),
          base64: Pe(F.base64),
          blobUri: Pe(F.blobUri || URL.createObjectURL(ee)),
          uri: Pe(F.uri)
        };
      }, c = (F) => {
        m(F.id()) || e.push(F);
      }, u = (F) => Wn(e, F).getOrUndefined(), m = (F) => u((W) => W.id() === F);
      return {
        create: o,
        add: c,
        get: m,
        getByUri: (F) => u((W) => W.blobUri() === F),
        getByData: (F, W) => u((K) => K.base64() === F && K.blob().type === W),
        findFirst: u,
        removeByUri: (F) => {
          e = ue(e, (W) => W.blobUri() === F ? (URL.revokeObjectURL(W.blobUri()), !1) : !0);
        },
        destroy: () => {
          X(e, (F) => {
            URL.revokeObjectURL(F.blobUri());
          }), e = [];
        }
      };
    }, b2 = (e, n) => {
      const o = {}, r = (ee, J) => ee ? ee.replace(/\/$/, "") + "/" + J.replace(/^\//, "") : J, c = (ee, J) => new Promise((te, ve) => {
        const De = new XMLHttpRequest();
        De.open("POST", n.url), De.withCredentials = n.credentials, De.upload.onprogress = (qe) => {
          J(qe.loaded / qe.total * 100);
        }, De.onerror = () => {
          ve("Image upload failed due to a XHR Transport error. Code: " + De.status);
        }, De.onload = () => {
          if (De.status < 200 || De.status >= 300) {
            ve("HTTP Error: " + De.status);
            return;
          }
          const qe = JSON.parse(De.responseText);
          if (!qe || !ie(qe.location)) {
            ve("Invalid JSON: " + De.responseText);
            return;
          }
          te(r(n.basePath, qe.location));
        };
        const Be = new FormData();
        Be.append("file", ee.blob(), ee.filename()), De.send(Be);
      }), u = () => new Promise((ee) => {
        ee([]);
      }), m = (ee, J) => ({
        url: J,
        blobInfo: ee,
        status: !0
      }), y = (ee, J) => ({
        url: "",
        blobInfo: ee,
        status: !1,
        error: J
      }), v = (ee, J) => {
        it.each(o[ee], (te) => {
          te(J);
        }), delete o[ee];
      }, x = (ee, J, te) => (e.markPending(ee.blobUri()), new Promise((ve) => {
        let De, Be;
        try {
          const qe = () => {
            De && (De.close(), Be = Se);
          }, pt = (vt) => {
            qe(), e.markUploaded(ee.blobUri(), vt), v(ee.blobUri(), m(ee, vt)), ve(m(ee, vt));
          }, pn = (vt) => {
            qe(), e.removeFailed(ee.blobUri()), v(ee.blobUri(), y(ee, vt)), ve(y(ee, vt));
          };
          Be = (vt) => {
            vt < 0 || vt > 100 || O.from(De).orThunk(() => O.from(te).map(Sn)).each((xt) => {
              De = xt, xt.progressBar.value(vt);
            });
          }, J(ee, Be).then(pt, (vt) => {
            pn(ie(vt) ? { message: vt } : vt);
          });
        } catch (qe) {
          ve(y(ee, qe));
        }
      })), R = (ee) => ee === c, F = (ee) => {
        const J = ee.blobUri();
        return new Promise((te) => {
          o[J] = o[J] || [], o[J].push(te);
        });
      }, W = (ee, J) => (ee = it.grep(ee, (te) => !e.isUploaded(te.blobUri())), Promise.all(it.map(ee, (te) => e.isPending(te.blobUri()) ? F(te) : x(te, n.handler, J)))), K = (ee, J) => !n.url && R(n.handler) ? u() : W(ee, J);
      return wn(n.handler) === !1 && (n.handler = c), { upload: K };
    }, Qv = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), Sp = (e, n) => b2(n, {
      url: vw(e),
      basePath: cS(e),
      credentials: kw(e),
      handler: fh(e)
    }), cy = (e) => {
      const n = Xz(), o = Sp(e, n);
      return { upload: (r, c = !0) => o.upload(r, c ? Qv(e) : void 0) };
    }, v2 = (e) => {
      const n = ay();
      let o, r;
      const c = Xz(), u = [], m = (Be) => (qe) => e.selection ? Be(qe) : [], y = (Be) => Be + (Be.indexOf("?") === -1 ? "?" : "&") + new Date().getTime(), v = (Be, qe, pt) => {
        let pn = 0;
        do
          pn = Be.indexOf(qe, pn), pn !== -1 && (Be = Be.substring(0, pn) + pt + Be.substr(pn + qe.length), pn += pt.length - qe.length + 1);
        while (pn !== -1);
        return Be;
      }, x = (Be, qe, pt) => {
        const pn = `src="${pt}"${pt === Qt.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return Be = v(Be, `src="${qe}"`, pn), Be = v(Be, 'data-mce-src="' + qe + '"', 'data-mce-src="' + pt + '"'), Be;
      }, R = (Be, qe) => {
        X(e.undoManager.data, (pt) => {
          pt.type === "fragmented" ? pt.fragments = ae(pt.fragments, (pn) => x(pn, Be, qe)) : pt.content = x(pt.content, Be, qe);
        });
      }, F = (Be, qe) => {
        const pt = e.convertURL(qe, "src");
        R(Be.src, qe), ur(be.fromDom(Be), {
          src: Ig(e) ? y(qe) : qe,
          "data-mce-src": pt
        });
      }, W = () => (o || (o = Sp(e, c)), te().then(m((Be) => {
        const qe = ae(Be, (pt) => pt.blobInfo);
        return o.upload(qe, Qv(e)).then(m((pt) => {
          const pn = [];
          let vt = !1;
          const xt = ae(pt, (Zt, Xt) => {
            const Qn = Be[Xt].blobInfo, En = Be[Xt].image;
            let fn = !1;
            return Zt.status && tb(e) ? (Zt.url && !Yt(En.src, Zt.url) && (vt = !0), n.removeByUri(En.src), Wm(e) || F(En, Zt.url)) : Zt.error && (Zt.error.remove && (R(En.getAttribute("src"), Qt.transparentSrc), pn.push(En), fn = !0), MN(e, Zt.error.message)), {
              element: En,
              status: Zt.status,
              uploadUri: Zt.url,
              blobInfo: Qn,
              removed: fn
            };
          });
          return pn.length > 0 && !Wm(e) ? e.undoManager.transact(() => {
            X(pn, (Zt) => {
              e.dom.remove(Zt), n.removeByUri(Zt.src);
            });
          }) : vt && e.undoManager.dispatchChange(), xt;
        }));
      }))), K = () => dh(e) ? W() : Promise.resolve([]), ee = (Be) => ds(u, (qe) => qe(Be)), J = (Be) => {
        u.push(Be);
      }, te = () => (r || (r = UN(c, n)), r.findAll(e.getBody(), ee).then(m((Be) => {
        const qe = ue(Be, (pt) => ie(pt) ? (Yv(e, pt), !1) : !0);
        return Wm(e) || X(qe, (pt) => {
          R(pt.image.src, pt.blobInfo.blobUri()), pt.image.src = pt.blobInfo.blobUri(), pt.image.removeAttribute("data-mce-src");
        }), qe;
      }))), ve = () => {
        n.destroy(), c.destroy(), r = o = null;
      }, De = (Be) => Be.replace(/src="(blob:[^"]+)"/g, (qe, pt) => {
        const pn = c.getResultUri(pt);
        if (pn)
          return 'src="' + pn + '"';
        let vt = n.getByUri(pt);
        if (vt || (vt = Ht(e.editorManager.get(), (xt, Zt) => xt || Zt.editorUpload && Zt.editorUpload.blobCache.getByUri(pt), null)), vt) {
          const xt = vt.blob();
          return 'src="data:' + xt.type + ";base64," + vt.base64() + '"';
        }
        return qe;
      });
      return e.on("SetContent", () => {
        dh(e) ? K() : te();
      }), e.on("RawSaveContent", (Be) => {
        Be.content = De(Be.content);
      }), e.on("GetContent", (Be) => {
        Be.source_view || Be.format === "raw" || Be.format === "tree" || (Be.content = De(Be.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (Be) => {
          X(Be, (qe) => {
            const pt = qe.attr("src");
            if (n.getByUri(pt))
              return;
            const pn = c.getResultUri(pt);
            pn && qe.attr("src", pn);
          });
        });
      }), {
        blobCache: n,
        addFilter: J,
        uploadImages: W,
        uploadImagesAuto: K,
        scanForImages: te,
        destroy: ve
      };
    }, k2 = (e) => {
      const n = e.dom, o = e.schema.type, r = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (c) => {
              n.setStyle(c, "float", null);
            },
            preview: "font-family font-size"
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (c) => {
              n.setStyle(c, "float", null);
            },
            preview: "font-family font-size"
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: (() => {
          const c = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, u = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, m = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return o !== "html4" ? [
            m,
            c,
            u
          ] : [
            c,
            m,
            u
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (c, u, m) => Vn(c) && c.hasAttribute("href"),
          onformat: (c, u, m) => {
            it.each(m, (y, v) => {
              n.setAttrib(c, v, y);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (c) => {
              var u;
              return (u = c == null ? void 0 : c.customValue) !== null && u !== void 0 ? u : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return it.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (c) => {
        r[c] = {
          block: c,
          remove: "all"
        };
      }), r;
    }, bT = {
      remove_similar: !0,
      inherit: !1
    }, xp = {
      selector: "td,th",
      ...bT
    }, vT = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...xp
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...xp
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...xp
      },
      tablecellclass: {
        classes: ["%value"],
        ...xp
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...bT
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...xp
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...xp
      }
    }, Jz = Pe(vT), Qz = (e) => {
      const n = {}, o = (m) => Q(m) ? n[m] : n, r = (m) => Gn(n, m), c = (m, y) => {
        m && (ie(m) ? (Re(y) || (y = [y]), X(y, (v) => {
          rt(v.deep) && (v.deep = !fl(v)), rt(v.split) && (v.split = !fl(v) || za(v)), rt(v.remove) && fl(v) && !za(v) && (v.remove = "none"), fl(v) && za(v) && (v.mixed = !0, v.block_expand = !0), ie(v.classes) && (v.classes = v.classes.split(/\s+/));
        }), n[m] = y) : Jt(m, (v, x) => {
          c(x, v);
        }));
      }, u = (m) => (m && n[m] && delete n[m], n);
      return c(k2(e)), c(Jz()), c(mS(e)), {
        get: o,
        has: r,
        register: c,
        unregister: u
      };
    }, Gm = it.each, ti = Ks.DOM, kT = (e, n) => {
      let o, r, c;
      const u = n && n.schema || pi({}), m = (R, F) => {
        F.classes.length && ti.addClass(R, F.classes.join(" ")), ti.setAttribs(R, F.attrs);
      }, y = (R) => {
        r = typeof R == "string" ? {
          name: R,
          classes: [],
          attrs: {}
        } : R;
        const F = ti.create(r.name);
        return m(F, r), F;
      }, v = (R, F) => {
        const W = typeof R != "string" ? R.nodeName.toLowerCase() : R, K = u.getElementRule(W), ee = K && K.parentsRequired;
        return ee && ee.length ? F && it.inArray(ee, F) !== -1 ? F : ee[0] : !1;
      }, x = (R, F, W) => {
        let K, ee;
        const J = F.length > 0 && F[0], te = J && J.name, ve = v(R, te);
        if (ve)
          te === ve ? (ee = F[0], F = F.slice(1)) : ee = ve;
        else if (J)
          ee = F[0], F = F.slice(1);
        else if (!W)
          return R;
        return ee && (K = y(ee), K.appendChild(R)), W && (K || (K = ti.create("div"), K.appendChild(R)), it.each(W, (De) => {
          const Be = y(De);
          K.insertBefore(Be, R);
        })), x(K, F, ee && ee.siblings);
      };
      return e && e.length ? (r = e[0], o = y(r), c = ti.create("div"), c.appendChild(x(o, e.slice(1), r.siblings)), c) : "";
    }, e6 = (e) => {
      let n;
      const o = {
        classes: [],
        attrs: {}
      };
      return e = o.selector = it.trim(e), e !== "*" && (n = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (r, c, u, m, y) => {
        switch (c) {
          case "#":
            o.attrs.id = u;
            break;
          case ".":
            o.classes.push(u);
            break;
          case ":":
            it.inArray("checked disabled enabled read-only required".split(" "), u) !== -1 && (o.attrs[u] = u);
            break;
        }
        if (m === "[") {
          const v = y.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          v && (o.attrs[v[1]] = v[2]);
        }
        return "";
      })), o.name = n || "div", o;
    }, w2 = (e) => !e || typeof e != "string" ? [] : (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), it.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (n) => {
      const o = it.map(n.split(/(?:~\+|~|\+)/), e6), r = o.pop();
      return o.length && (r.siblings = o), r;
    }).reverse()), t6 = (e, n) => {
      let o, r, c = "", u, m = Sw(e);
      if (m === "")
        return "";
      const y = (R) => R.replace(/%(\w+)/g, "");
      if (typeof n == "string") {
        if (n = e.formatter.get(n), !n)
          return;
        n = n[0];
      }
      if ("preview" in n) {
        const R = Xo(n, "preview");
        if (hs(R, !1))
          return "";
        m = R.getOr(m);
      }
      o = n.block || n.inline || "span";
      const v = w2(n.selector);
      v.length ? (v[0].name || (v[0].name = o), o = n.selector, r = kT(v, e)) : r = kT([o], e);
      const x = ti.select(o, r)[0] || r.firstChild;
      return Gm(n.styles, (R, F) => {
        const W = y(R);
        W && ti.setStyle(x, F, W);
      }), Gm(n.attributes, (R, F) => {
        const W = y(R);
        W && ti.setAttrib(x, F, W);
      }), Gm(n.classes, (R) => {
        const F = y(R);
        ti.hasClass(x, F) || ti.addClass(x, F);
      }), e.dispatch("PreviewFormats"), ti.setStyles(r, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(r), u = ti.getStyle(e.getBody(), "fontSize", !0), u = /px$/.test(u) ? parseInt(u, 10) : 0, Gm(m.split(" "), (R) => {
        let F = ti.getStyle(x, R, !0);
        if (!(R === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(F) && (F = ti.getStyle(e.getBody(), R, !0), yu(F).toLowerCase() === "#ffffff")) && !(R === "color" && yu(F).toLowerCase() === "#000000")) {
          if (R === "font-size" && /em|%$/.test(F)) {
            if (u === 0)
              return;
            F = parseFloat(F) / (/%$/.test(F) ? 100 : 1) * u + "px";
          }
          R === "border" && F && (c += "padding:0 2px;"), c += R + ":" + F + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), ti.remove(r), c;
    }, n6 = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let n = 1; n <= 6; n++)
        e.addShortcut("access+" + n, "", [
          "FormatBlock",
          !1,
          "h" + n
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, wT = (e) => {
      const n = Qz(e), o = ka(null);
      return n6(e), NR(e), {
        get: n.get,
        has: n.has,
        register: n.register,
        unregister: n.unregister,
        apply: (r, c, u) => {
          uN(e, r, c, u);
        },
        remove: (r, c, u, m) => {
          Bs(e, r, c, u, m);
        },
        toggle: (r, c, u) => {
          fL(e, r, c, u);
        },
        match: (r, c, u, m) => Zm(e, r, c, u, m),
        closest: (r) => iN(e, r),
        matchAll: (r, c) => Rz(e, r, c),
        matchNode: (r, c, u, m) => cN(e, r, c, u, m),
        canApply: (r) => lN(e, r),
        formatChanged: (r, c, u, m) => dN(e, o, r, c, u, m),
        getCssText: Ct(t6, e)
      };
    }, _T = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, Km = (e, n, o) => {
      const r = ka(!1), c = (v) => {
        p2(n, !1, o), n.add({}, v);
      };
      e.on("init", () => {
        n.add();
      }), e.on("BeforeExecCommand", (v) => {
        const x = v.command;
        _T(x) || (Wv(n, o), n.beforeChange());
      }), e.on("ExecCommand", (v) => {
        const x = v.command;
        _T(x) || c(v);
      }), e.on("ObjectResizeStart cut", () => {
        n.beforeChange();
      }), e.on("SaveContent ObjectResized blur", c), e.on("dragend", c), e.on("keyup", (v) => {
        const x = v.keyCode;
        v.isDefaultPrevented() || ((x >= 33 && x <= 36 || x >= 37 && x <= 40 || x === 45 || v.ctrlKey) && (c(), e.nodeChanged()), (x === 46 || x === 8) && e.nodeChanged(), r.get() && n.typing && tT(g2(e), n.data[0]) === !1 && (e.isDirty() === !1 && e.setDirty(!0), e.dispatch("TypingUndo"), r.set(!1), e.nodeChanged()));
      }), e.on("keydown", (v) => {
        const x = v.keyCode;
        if (v.isDefaultPrevented())
          return;
        if (x >= 33 && x <= 36 || x >= 37 && x <= 40 || x === 45) {
          n.typing && c(v);
          return;
        }
        const R = v.ctrlKey && !v.altKey || v.metaKey;
        (x < 16 || x > 20) && x !== 224 && x !== 91 && !n.typing && !R && (n.beforeChange(), p2(n, !0, o), n.add({}, v), r.set(!0));
      }), e.on("mousedown", (v) => {
        n.typing && c(v);
      });
      const u = (v) => v.inputType === "insertReplacementText", m = (v) => v.inputType === "insertText" && v.data === null, y = (v) => v.inputType === "insertFromPaste" || v.inputType === "insertFromDrop";
      e.on("input", (v) => {
        v.inputType && (u(v) || m(v) || y(v)) && c(v);
      }), e.on("AddUndo Undo Redo ClearUndos", (v) => {
        v.isDefaultPrevented() || e.nodeChanged();
      });
    }, Tp = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, xu = (e) => {
      const n = Od(), o = ka(0), r = ka(0), c = {
        data: [],
        typing: !1,
        beforeChange: () => {
          zz(e, o, n);
        },
        add: (u, m) => Oz(e, c, r, o, n, u, m),
        dispatchChange: () => {
          e.setDirty(!0), e.dispatch("change", {
            level: g2(e),
            lastLevel: Ln(c.data, r.get()).getOrUndefined()
          });
        },
        undo: () => eN(e, c, o, r),
        redo: () => tN(e, r, c.data),
        clear: () => {
          nN(e, c, r);
        },
        reset: () => {
          Dz(e, c);
        },
        hasUndo: () => oN(e, c, r),
        hasRedo: () => sN(e, c, r),
        transact: (u) => rN(e, c, o, u),
        ignore: (u) => {
          aN(e, o, u);
        },
        extra: (u, m) => {
          dL(e, c, r, u, m);
        }
      };
      return Wm(e) || Km(e, c, o), Tp(e), c;
    }, qN = [
      9,
      27,
      Tn.HOME,
      Tn.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      Tn.DOWN,
      Tn.UP,
      Tn.LEFT,
      Tn.RIGHT
    ].concat(Qt.browser.isFirefox() ? [224] : []), o6 = "data-mce-placeholder", s6 = (e) => e.type === "keydown" || e.type === "keyup", r6 = (e) => {
      const n = e.keyCode;
      return n === Tn.BACKSPACE || n === Tn.DELETE;
    }, GN = (e) => {
      if (s6(e)) {
        const n = e.keyCode;
        return !r6(e) && (Tn.metaKeyPressed(e) || e.altKey || n >= 112 && n <= 123 || Ae(qN, n));
      } else
        return !1;
    }, KN = (e) => s6(e) && !(r6(e) || e.type === "keyup" && e.keyCode === 229), YN = (e, n, o) => {
      if (ta(be.fromDom(n), !1)) {
        const r = n.firstElementChild;
        return r ? e.getStyle(n.firstElementChild, "padding-left") || e.getStyle(n.firstElementChild, "padding-right") ? !1 : o === r.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, XN = (e) => {
      const n = e.dom, o = Ir(e), r = dS(e), c = (u, m) => {
        if (GN(u))
          return;
        const y = e.getBody(), v = KN(u) ? !1 : YN(n, y, o);
        (n.getAttrib(y, o6) !== "" !== v || m) && (n.setAttrib(y, o6, v ? r : null), n.setAttrib(y, "aria-placeholder", v ? r : null), f_(e, v), e.on(v ? "keydown" : "keyup", c), e.off(v ? "keyup" : "keydown", c));
      };
      r && e.on("init", (u) => {
        c(u, !0), e.on("change SetContent ExecCommand", c), e.on("paste", (m) => ml.setEditorTimeout(e, () => c(m)));
      });
    }, JN = (e, n) => ({
      block: e,
      position: n
    }), QN = (e, n) => ({
      from: e,
      to: n
    }), CT = (e, n) => {
      const o = be.fromDom(e), r = be.fromDom(n.container());
      return L_(o, r).map((c) => JN(c, n));
    }, eB = (e) => Is(e.from.block, e.to.block) === !1, ST = (e) => ec(e.from.block).bind((n) => ec(e.to.block).filter((o) => Is(n, o))).isSome(), xT = (e) => Dr(e.from.block.dom) === !1 && Dr(e.to.block.dom) === !1, a6 = (e, n, o) => Cr(o.position.getNode()) && ta(o.block) === !1 ? Mm(!1, o.block.dom).bind((r) => r.isEqual(o.position) ? Ci(n, e, r).bind((c) => CT(e, c)) : O.some(o)).getOr(o) : o, tB = (e, n, o) => {
      const r = CT(e, Ke.fromRangeStart(o)), c = r.bind((u) => Ci(n, e, u.position).bind((m) => CT(e, m).map((y) => a6(e, n, y))));
      return qs(r, c, QN).filter((u) => eB(u) && ST(u) && xT(u));
    }, nB = (e, n, o) => o.collapsed ? tB(e, n, o) : O.none(), c6 = (e) => {
      const n = Qr(e);
      return ko(n, xa).fold(Pe(n), (o) => n.slice(0, o));
    }, TT = (e) => {
      const n = c6(e);
      return X(n, Gs), n;
    }, _2 = (e, n) => {
      const o = Vm(n, e);
      return Wn(o.reverse(), (r) => ta(r)).each(Gs);
    }, l6 = (e) => ue(uf(e), (n) => !ta(n)).length === 0, i6 = (e, n, o, r) => {
      if (ta(o))
        return Pa(o), Xc(o.dom);
      l6(r) && ta(n) && Mr(r, be.fromTag("br"));
      const c = qi(o.dom, Ke.before(r.dom));
      return X(TT(n), (u) => {
        Mr(r, u);
      }), _2(e, n), c;
    }, ET = (e, n, o) => {
      if (ta(o))
        return Gs(o), ta(n) && Pa(n), Xc(n.dom);
      const r = hu(o.dom);
      return X(TT(n), (c) => {
        Kr(o, c);
      }), _2(e, n), r;
    }, oB = (e, n) => {
      const o = Vm(n, e);
      return O.from(o[o.length - 1]);
    }, sB = (e, n) => ya(n, e) ? oB(n, e) : O.none(), Yd = (e, n) => {
      Mm(e, n.dom).map((o) => o.getNode()).map(be.fromDom).filter(_d).each(Gs);
    }, Tu = (e, n, o) => (Yd(!0, n), Yd(!1, o), sB(n, o).fold(Ct(ET, e, n, o), Ct(i6, e, n, o))), ek = (e, n, o, r) => n ? Tu(e, r, o) : Tu(e, o, r), C2 = (e, n) => {
      const o = be.fromDom(e.getBody());
      return nB(o.dom, n, e.selection.getRng()).map((c) => () => {
        ek(o, n, c.from.block, c.to.block).each((u) => {
          e.selection.setRng(u.toRange());
        });
      });
    }, S2 = (e, n) => {
      const o = n.getRng();
      return qs(L_(e, be.fromDom(o.startContainer)), L_(e, be.fromDom(o.endContainer)), (r, c) => Is(r, c) === !1 ? O.some(() => {
        o.deleteContents(), ek(e, !0, r, c).each((u) => {
          n.setRng(u.toRange());
        });
      }) : O.none()).getOr(O.none());
    }, AT = (e, n) => {
      const o = be.fromDom(n), r = Ct(Is, e);
      return vf(o, pc, r).isSome();
    }, u6 = (e, n) => AT(e, n.startContainer) || AT(e, n.endContainer), d6 = (e, n) => {
      const o = qi(e.dom, Ke.fromRangeStart(n)).isNone(), r = Si(e.dom, Ke.fromRangeEnd(n)).isNone();
      return !u6(e, n) && o && r;
    }, f6 = (e) => O.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), m6 = (e) => {
      const n = be.fromDom(e.getBody()), o = e.selection.getRng();
      return d6(n, o) ? f6(e) : S2(n, e.selection);
    }, x2 = (e, n) => e.selection.isCollapsed() ? O.none() : m6(e), T2 = Zl, zT = Dr, Ym = (e, n, o, r, c) => O.from(n._selectionOverrides.showCaret(e, o, r, c)), rB = (e) => {
      const n = e.ownerDocument.createRange();
      return n.selectNode(e), n;
    }, tk = (e, n) => e.dispatch("BeforeObjectSelected", { target: n }).isDefaultPrevented() ? O.none() : O.some(rB(n)), aB = (e, n, o) => {
      const r = yh(1, e.getBody(), n), c = Ke.fromRangeStart(r), u = c.getNode();
      if (Om(u))
        return Ym(1, e, u, !c.isAtEnd(), !1);
      const m = c.getNode(!0);
      if (Om(m))
        return Ym(1, e, m, !1, !1);
      const y = e.dom.getParent(c.getNode(), (v) => zT(v) || T2(v));
      return Om(y) ? Ym(1, e, y, !1, o) : O.none();
    }, E2 = (e, n, o) => n.collapsed ? aB(e, n, o).getOr(n) : n, cB = (e) => Hm(e) || gv(e), lB = (e) => pp(e) || pv(e), OT = (e, n) => {
      rn(n) && n.data.length === 0 && e.remove(n);
    }, g6 = (e, n, o, r, c, u) => {
      Ym(r, e, u.getNode(!c), c, !0).each((m) => {
        if (n.collapsed) {
          const y = n.cloneRange();
          c ? y.setEnd(m.startContainer, m.startOffset) : y.setStart(m.endContainer, m.endOffset), y.deleteContents();
        } else
          n.deleteContents();
        e.selection.setRng(m);
      }), OT(e.dom, o);
    }, iB = (e, n) => {
      const o = e.selection.getRng();
      if (!rn(o.commonAncestorContainer))
        return O.none();
      const r = n ? ja.Forwards : ja.Backwards, c = _c(e.getBody()), u = Ct(hb, n ? c.next : c.prev), m = n ? cB : lB, y = Gg(r, e.getBody(), o), v = Xi(n, u(y));
      if (!v || !vh(y, v))
        return O.none();
      if (m(v))
        return O.some(() => g6(e, o, y.getNode(), r, n, v));
      const x = u(v);
      return x && m(x) && vh(v, x) ? O.some(() => g6(e, o, y.getNode(), r, n, x)) : O.none();
    }, DT = (e, n) => iB(e, n), RT = (e, n) => {
      const o = e.getBody();
      return n ? Xc(o).filter(Hm) : hu(o).filter(pp);
    }, MT = (e) => {
      const n = e.selection.getRng();
      return !n.collapsed && (RT(e, !0).exists((o) => o.isEqual(Ke.fromRangeStart(n))) || RT(e, !1).exists((o) => o.isEqual(Ke.fromRangeEnd(n))));
    }, uB = (e) => pc(be.fromDom(e)) || zl(be.fromDom(e)), Qi = vi.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), A2 = (e, n) => {
      const o = n.getNode(e === !1), r = e ? "after" : "before";
      return Vn(o) && o.getAttribute("data-mce-caret") === r;
    }, NT = (e, n, o, r) => {
      const c = (u) => Fi(be.fromDom(u)) && !td(o, r, e);
      return b0(!n, o).fold(() => b0(n, r).fold(Mn, c), c);
    }, p6 = (e, n, o, r) => {
      const c = r.getNode(n === !1);
      return L_(be.fromDom(e), be.fromDom(o.getNode())).map((u) => ta(u) ? Qi.remove(u.dom) : Qi.moveToElement(c)).orThunk(() => O.some(Qi.moveToElement(c)));
    }, h6 = (e, n, o) => Ci(n, e, o).bind((r) => uB(r.getNode()) || NT(e, n, o, r) ? O.none() : n && Dr(r.getNode()) || n === !1 && Dr(r.getNode(!0)) ? p6(e, n, o, r) : n && pp(o) || n === !1 && Hm(o) ? O.some(Qi.moveToPosition(r)) : O.none()), dB = (e, n) => e && Dr(n.nextSibling) ? O.some(Qi.moveToElement(n.nextSibling)) : e === !1 && Dr(n.previousSibling) ? O.some(Qi.moveToElement(n.previousSibling)) : O.none(), fB = (e, n, o) => o.fold((r) => O.some(Qi.remove(r)), (r) => O.some(Qi.moveToElement(r)), (r) => td(n, r, e) ? O.none() : O.some(Qi.moveToPosition(r))), y6 = (e, n, o) => A2(n, o) ? dB(n, o.getNode(n === !1)).fold(() => h6(e, n, o), O.some) : h6(e, n, o).bind((r) => fB(e, o, r)), mB = (e, n, o) => {
      const r = yh(n ? 1 : -1, e, o), c = Ke.fromRangeStart(r), u = be.fromDom(e);
      return n === !1 && pp(c) ? O.some(Qi.remove(c.getNode(!0))) : n && Hm(c) ? O.some(Qi.remove(c.getNode())) : n === !1 && Hm(c) && Bx(u, c) ? P7(u, c).map((m) => Qi.remove(m.getNode())) : n && pp(c) && Nx(u, c) ? F7(u, c).map((m) => Qi.remove(m.getNode())) : y6(e, n, c);
    }, gB = (e, n) => (o) => (e._selectionOverrides.hideFakeCaret(), Qo(e, n, be.fromDom(o)), !0), BT = (e, n) => (o) => {
      const r = n ? Ke.before(o) : Ke.after(o);
      return e.selection.setRng(r.toRange()), !0;
    }, pB = (e) => (n) => (e.selection.setRng(n.toRange()), !0), b6 = (e, n) => O.from(hl(e.getBody(), n)), hB = (e, n) => {
      const o = e.selection.getNode();
      return b6(e, o).filter(Dr).fold(() => mB(e.getBody(), n, e.selection.getRng()).map((r) => () => r.fold(gB(e, n), BT(e, n), pB(e))), () => O.some(Se));
    }, yB = (e) => {
      X(ia(e, ".mce-offscreen-selection"), Gs);
    }, bB = (e, n) => {
      const o = e.selection.getNode();
      return Dr(o) && !yd(o) ? b6(e, o.parentNode).filter(Dr).fold(() => O.some(() => {
        yB(be.fromDom(e.getBody())), Qo(e, n, be.fromDom(e.selection.getNode())), yv(e);
      }), () => O.some(Se)) : MT(e) ? O.some(() => {
        H5(e, e.selection.getRng(), be.fromDom(e.getBody()));
      }) : O.none();
    }, v6 = (e) => {
      const n = e.dom, o = e.selection, r = hl(e.getBody(), o.getNode());
      if (Zl(r) && n.isBlock(r) && n.isEmpty(r)) {
        const c = n.create("br", { "data-mce-bogus": "1" });
        n.setHTML(r, ""), r.appendChild(c), o.setRng(Ke.before(c).toRange());
      }
      return !0;
    }, $T = (e, n) => e.selection.isCollapsed() ? hB(e, n) : bB(e, n), z2 = (e, n) => {
      const o = Ke.fromRangeStart(e.selection.getRng());
      return Ci(n, e.getBody(), o).filter((r) => n ? R7(r) : M7(r)).bind((r) => O.from(y0(n ? 0 : -1, r))).map((r) => () => e.selection.select(r));
    }, l1 = (e, n) => e.selection.isCollapsed() ? z2(e, n) : O.none(), i1 = rn, k6 = (e) => i1(e) && e.data[0] === k, nk = (e) => i1(e) && e.data[e.data.length - 1] === k, w6 = (e) => e.ownerDocument.createTextNode(k), vB = (e) => {
      if (i1(e.previousSibling))
        return nk(e.previousSibling) || e.previousSibling.appendData(k), e.previousSibling;
      if (i1(e))
        return k6(e) || e.insertData(0, k), e;
      {
        const n = w6(e);
        return e.parentNode.insertBefore(n, e), n;
      }
    }, kB = (e) => {
      if (i1(e.nextSibling))
        return k6(e.nextSibling) || e.nextSibling.insertData(0, k), e.nextSibling;
      if (i1(e))
        return nk(e) || e.appendData(k), e;
      {
        const n = w6(e);
        return e.nextSibling ? e.parentNode.insertBefore(n, e.nextSibling) : e.parentNode.appendChild(n), n;
      }
    }, O2 = (e, n) => e ? vB(n) : kB(n), wB = Ct(O2, !0), _B = Ct(O2, !1), _6 = (e, n) => rn(e.container()) ? O2(n, e.container()) : O2(n, e.getNode()), C6 = (e, n) => {
      const o = n.get();
      return o && e.container() === o && St(o);
    }, PT = (e, n) => n.fold((o) => {
      $d(e.get());
      const r = wB(o);
      return e.set(r), O.some(Ke(r, r.length - 1));
    }, (o) => Xc(o).map((r) => {
      if (C6(r, e))
        return Ke(e.get(), 1);
      {
        $d(e.get());
        const c = _6(r, !0);
        return e.set(c), Ke(c, 1);
      }
    }), (o) => hu(o).map((r) => {
      if (C6(r, e))
        return Ke(e.get(), e.get().length - 1);
      {
        $d(e.get());
        const c = _6(r, !1);
        return e.set(c), Ke(c, c.length - 1);
      }
    }), (o) => {
      $d(e.get());
      const r = _B(o);
      return e.set(r), O.some(Ke(r, 1));
    }), S6 = (e, n) => {
      for (let o = 0; o < e.length; o++) {
        const r = e[o].apply(null, n);
        if (r.isSome())
          return r;
      }
      return O.none();
    }, Pl = vi.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), CB = (e, n) => {
      const o = Pf(n, e);
      return o || e;
    }, id = (e, n, o) => {
      const r = P5(o), c = CB(n, r.container());
      return jm(e, c, r).fold(() => Si(c, r).bind(Ct(jm, e, c)).map((u) => Pl.before(u)), O.none);
    }, FT = (e, n) => Pd(e, n) === null, IT = (e, n, o) => jm(e, n, o).filter(Ct(FT, n)), x6 = (e, n, o) => {
      const r = F5(o);
      return IT(e, n, r).bind((c) => qi(c, r).isNone() ? O.some(Pl.start(c)) : O.none());
    }, SB = (e, n, o) => {
      const r = P5(o);
      return IT(e, n, r).bind((c) => Si(c, r).isNone() ? O.some(Pl.end(c)) : O.none());
    }, T6 = (e, n, o) => {
      const r = F5(o), c = CB(n, r.container());
      return jm(e, c, r).fold(() => qi(c, r).bind(Ct(jm, e, c)).map((u) => Pl.after(u)), O.none);
    }, E6 = (e) => N5(LT(e)) === !1, Xd = (e, n, o) => S6([
      id,
      x6,
      SB,
      T6
    ], [
      e,
      n,
      o
    ]).filter(E6), LT = (e) => e.fold(Rt, Rt, Rt, Rt), A6 = (e) => e.fold(Pe("before"), Pe("start"), Pe("end"), Pe("after")), D2 = (e) => e.fold(Pl.before, Pl.before, Pl.after, Pl.after), Ep = (e) => e.fold(Pl.start, Pl.start, Pl.end, Pl.end), z6 = (e, n) => A6(e) === A6(n) && LT(e) === LT(n), O6 = (e, n, o, r, c, u) => qs(jm(n, o, r), jm(n, o, c), (m, y) => m !== y && $5(o, m, y) ? Pl.after(e ? m : y) : u).getOr(u), D6 = (e, n) => e.fold(Xe, (o) => !z6(o, n)), HT = (e, n, o, r, c) => {
      const u = Xi(e, c);
      return Ci(e, o, u).map(Ct(Xi, e)).fold(() => r.map(D2), (v) => Xd(n, o, v).map(Ct(O6, e, n, o, u, v)).filter(Ct(D6, r))).filter(E6);
    }, xB = (e, n) => e ? n.fold(Qe(O.some, Pl.start), O.none, Qe(O.some, Pl.after), O.none) : n.fold(O.none, Qe(O.some, Pl.before), O.none, Qe(O.some, Pl.end)), TB = (e, n, o, r) => {
      const c = Xi(e, r), u = Xd(n, o, c);
      return Xd(n, o, c).bind(Ct(xB, e)).orThunk(() => HT(e, n, o, u, r));
    }, EB = (e) => wn(e.selection.getSel().modify), AB = (e, n, o) => {
      const r = e ? 1 : -1;
      return n.setRng(Ke(o.container(), o.offset() + r).toRange()), n.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, wL = (e, n) => {
      const o = n.selection.getRng(), r = e ? Ke.fromRangeEnd(o) : Ke.fromRangeStart(o);
      return EB(n) ? e && Rr(r) ? AB(!0, n.selection, r) : !e && ks(r) ? AB(!1, n.selection, r) : !1 : !1;
    };
    var Xm;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(Xm || (Xm = {}));
    const Di = (e, n) => e === ja.Backwards ? Ho(n) : n, zB = (e, n, o) => e === ja.Forwards ? n.next(o) : n.prev(o), OB = (e, n, o, r) => Cr(r.getNode(n === ja.Forwards)) ? Xm.Br : td(o, r) === !1 ? Xm.Block : Xm.Wrap, VT = (e, n, o, r) => {
      const c = _c(o);
      let u = r;
      const m = [];
      for (; u; ) {
        const y = zB(n, c, u);
        if (!y)
          break;
        if (Cr(y.getNode(!1)))
          return n === ja.Forwards ? {
            positions: Di(n, m).concat([y]),
            breakType: Xm.Br,
            breakAt: O.some(y)
          } : {
            positions: Di(n, m),
            breakType: Xm.Br,
            breakAt: O.some(y)
          };
        if (!y.isVisible()) {
          u = y;
          continue;
        }
        if (e(u, y)) {
          const v = OB(o, n, u, y);
          return {
            positions: Di(n, m),
            breakType: v,
            breakAt: O.some(y)
          };
        }
        m.push(y), u = y;
      }
      return {
        positions: Di(n, m),
        breakType: Xm.Eol,
        breakAt: O.none()
      };
    }, R2 = (e, n, o, r) => n(o, r).breakAt.map((c) => {
      const u = n(o, c).positions;
      return e === ja.Backwards ? u.concat(c) : [c].concat(u);
    }).getOr([]), R6 = (e, n) => Ht(e, (o, r) => o.fold(() => O.some(r), (c) => qs(Go(c.getClientRects()), Go(r.getClientRects()), (u, m) => {
      const y = Math.abs(n - u.left);
      return Math.abs(n - m.left) <= y ? r : c;
    }).or(o)), O.none()), jT = (e, n) => Go(n.getClientRects()).bind((o) => R6(e, o.left)), M2 = Ct(VT, Ke.isAbove, -1), Fl = Ct(VT, Ke.isBelow, 1), M6 = Ct(R2, -1, M2), N6 = Ct(R2, 1, Fl), DB = (e, n) => M2(e, n).breakAt.isNone(), RB = (e, n) => Fl(e, n).breakAt.isNone(), MB = (e) => Xc(e).map((n) => [n].concat(Fl(e, n).positions)).getOr([]), NB = (e) => hu(e).map((n) => M2(e, n).positions.concat(n)).getOr([]), ly = (e, n) => jT(M6(e, n), n), BB = (e, n) => jT(N6(e, n), n), $B = Dr, B6 = (e, n) => Math.abs(e.left - n), N2 = (e, n) => Math.abs(e.right - n), UT = (e) => er(e, "node"), WT = (e, n) => le(e, (o, r) => {
      const c = Math.min(B6(o, n), N2(o, n)), u = Math.min(B6(r, n), N2(r, n));
      return u === c && UT(r) && $B(r.node) || u < c ? r : o;
    }), $6 = (e) => {
      const n = (o) => ae(o, (r) => {
        const c = qc(r);
        return c.node = e, c;
      });
      if (Vn(e))
        return n(e.getClientRects());
      if (rn(e)) {
        const o = e.ownerDocument.createRange();
        return o.setStart(e, 0), o.setEnd(e, e.data.length), n(o.getClientRects());
      } else
        return [];
    }, ZT = (e) => yn(e, $6);
    var ok;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(ok || (ok = {}));
    const sk = (e, n, o, r) => {
      for (; r = Wg(r, e, Li, n); )
        if (o(r))
          return;
    }, P6 = (e, n, o, r, c, u) => {
      let m = 0;
      const y = [], v = (F) => {
        let W = ZT([F]);
        e === -1 && (W = W.reverse());
        for (let K = 0; K < W.length; K++) {
          const ee = W[K];
          if (!o(ee, x)) {
            if (y.length > 0 && n(ee, wt(y)) && m++, ee.line = m, c(ee))
              return !0;
            y.push(ee);
          }
        }
      }, x = wt(u.getClientRects());
      if (!x)
        return y;
      const R = u.getNode();
      return v(R), sk(e, r, v, R), y;
    }, PB = (e, n) => n.line > e, FB = (e, n) => n.line === e, IB = Ct(P6, ok.Up, Ui, yi), LB = Ct(P6, ok.Down, yi, Ui), HB = (e, n, o, r) => {
      const c = _c(n);
      let u, m, y, v;
      const x = [];
      let R = 0;
      const F = (K) => wt(K.getClientRects());
      e === 1 ? (u = c.next, m = yi, y = Ui, v = Ke.after(r)) : (u = c.prev, m = Ui, y = yi, v = Ke.before(r));
      const W = F(v);
      do {
        if (!v.isVisible())
          continue;
        const K = F(v);
        if (y(K, W))
          continue;
        x.length > 0 && m(K, wt(x)) && R++;
        const ee = qc(K);
        if (ee.position = v, ee.line = R, o(ee))
          return x;
        x.push(ee);
      } while (v = u(v));
      return x;
    }, F6 = (e) => (n) => PB(e, n), B2 = (e) => (n) => FB(e, n), Jm = (e, n) => {
      e.selection.setRng(n), Ai(e, e.selection.getRng());
    }, $2 = (e, n, o) => O.some(E2(e, n, o)), qT = (e, n, o, r, c, u) => {
      const m = n === ja.Forwards, y = _c(e.getBody()), v = Ct(hb, m ? y.next : y.prev), x = m ? r : c;
      if (!o.collapsed) {
        const ee = Wy(o);
        if (u(ee))
          return Ym(n, e, ee, n === ja.Backwards, !1);
        if (MT(e)) {
          const J = o.cloneRange();
          return J.collapse(n === ja.Backwards), O.from(J);
        }
      }
      const R = Gg(n, e.getBody(), o);
      if (x(R))
        return tk(e, R.getNode(!m));
      const F = Xi(m, v(R)), W = pg(o);
      if (!F)
        return W ? O.some(o) : O.none();
      if (x(F))
        return Ym(n, e, F.getNode(!m), m, !1);
      const K = v(F);
      return K && x(K) && vh(F, K) ? Ym(n, e, K.getNode(!m), m, !1) : W ? $2(e, F.toRange(), !1) : O.none();
    }, rk = (e, n, o, r, c, u) => {
      const m = Gg(n, e.getBody(), o), y = wt(m.getClientRects()), v = n === ok.Down, x = e.getBody();
      if (!y)
        return O.none();
      if (MT(e)) {
        const te = v ? Ke.fromRangeEnd(o) : Ke.fromRangeStart(o);
        return (v ? BB : ly)(x, te).orThunk(() => O.from(te)).map((De) => De.toRange());
      }
      const F = (v ? LB : IB)(x, F6(1), m), W = ue(F, B2(1)), K = y.left, ee = WT(W, K);
      if (ee && u(ee.node)) {
        const te = Math.abs(K - ee.left), ve = Math.abs(K - ee.right);
        return Ym(n, e, ee.node, te < ve, !1);
      }
      let J;
      if (r(m) ? J = m.getNode() : c(m) ? J = m.getNode(!0) : J = Wy(o), J) {
        const te = HB(n, x, F6(1), J);
        let ve = WT(ue(te, B2(1)), K);
        if (ve || (ve = wt(ue(te, B2(0))), ve))
          return $2(e, ve.position.toRange(), !1);
      }
      return W.length === 0 ? P2(e, v).filter(v ? c : r).map((te) => E2(e, te.toRange(), !1)) : O.none();
    }, P2 = (e, n) => {
      const o = e.selection.getRng(), r = n ? Ke.fromRangeEnd(o) : Ke.fromRangeStart(o), c = RS(r.container(), e.getBody());
      if (n) {
        const u = Fl(c, r);
        return Ro(u.positions);
      } else {
        const u = M2(c, r);
        return Go(u.positions);
      }
    }, F2 = (e, n, o) => P2(e, n).filter(o).exists((r) => (e.selection.setRng(r.toRange()), !0)), Qm = (e, n) => {
      const o = e.dom.createRng();
      o.setStart(n.container(), n.offset()), o.setEnd(n.container(), n.offset()), e.selection.setRng(o);
    }, GT = (e, n) => {
      e ? n.setAttribute("data-mce-selected", "inline-boundary") : n.removeAttribute("data-mce-selected");
    }, I2 = (e, n, o) => PT(n, o).map((r) => (Qm(e, r), o)), VB = (e, n, o) => {
      const r = Ke.fromRangeStart(e);
      if (e.collapsed)
        return r;
      {
        const c = Ke.fromRangeEnd(e);
        return o ? qi(n, c).getOr(c) : Si(n, r).getOr(r);
      }
    }, KT = (e, n, o) => {
      const r = e.getBody(), c = VB(e.selection.getRng(), r, o), u = Ct(hp, e);
      return TB(o, u, r, c).bind((y) => I2(e, n, y));
    }, jB = (e, n, o) => {
      const r = ae(ia(be.fromDom(n.getRoot()), '*[data-mce-selected="inline-boundary"]'), (m) => m.dom), c = ue(r, e), u = ue(o, e);
      X(mn(c, u), Ct(GT, !1)), X(mn(u, c), Ct(GT, !0));
    }, UB = (e, n) => {
      if (e.selection.isCollapsed() && e.composing !== !0 && n.get()) {
        const o = Ke.fromRangeStart(e.selection.getRng());
        Ke.isTextPosition(o) && sR(o) === !1 && (Qm(e, ub(n.get(), o)), n.set(null));
      }
    }, WB = (e, n, o, r) => {
      if (n.selection.isCollapsed()) {
        const c = ue(r, e);
        X(c, (u) => {
          const m = Ke.fromRangeStart(n.selection.getRng());
          Xd(e, n.getBody(), m).bind((y) => I2(n, o, y));
        });
      }
    }, I6 = (e, n, o) => Rl(e) ? KT(e, n, o).isSome() : !1, L6 = (e, n, o) => Rl(n) ? wL(e, n) : !1, ZB = (e) => {
      const n = ka(null), o = Ct(hp, e);
      return e.on("NodeChange", (r) => {
        Rl(e) && (jB(o, e.dom, r.parents), UB(e, n), WB(o, e, n, r.parents));
      }), n;
    }, H6 = Ct(L6, !0), u1 = Ct(L6, !1), d1 = (e, n, o) => {
      if (Rl(e)) {
        const r = P2(e, n).getOrThunk(() => {
          const c = e.selection.getRng();
          return n ? Ke.fromRangeEnd(c) : Ke.fromRangeStart(c);
        });
        return Xd(Ct(hp, e), e.getBody(), r).exists((c) => {
          const u = D2(c);
          return PT(o, u).exists((m) => (Qm(e, m), !0));
        });
      } else
        return !1;
    }, V6 = (e, n) => {
      const o = document.createRange();
      return o.setStart(e.container(), e.offset()), o.setEnd(n.container(), n.offset()), o;
    }, j6 = (e) => qs(Xc(e), hu(e), (n, o) => {
      const r = Xi(!0, n), c = Xi(!1, o);
      return Si(e, r).forall((u) => u.isEqual(c));
    }).getOr(!0), L2 = (e, n) => (o) => PT(n, o).map((r) => () => Qm(e, r)), U6 = (e, n, o, r) => {
      const c = e.getBody(), u = Ct(hp, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(V6(o, r)), Lx(e), Xd(u, c, Ke.fromRangeStart(e.selection.getRng())).map(Ep).bind(L2(e, n)).each(Dn);
      }), e.nodeChanged();
    }, qB = (e, n) => {
      const o = Pf(n, e);
      return o || e;
    }, GB = (e, n, o, r) => {
      const c = qB(e.getBody(), r.container()), u = Ct(hp, e), m = Xd(u, c, r);
      return m.bind((v) => o ? v.fold(Pe(O.some(Ep(v))), O.none, Pe(O.some(D2(v))), O.none) : v.fold(O.none, Pe(O.some(D2(v))), O.none, Pe(O.some(Ep(v))))).map(L2(e, n)).getOrThunk(() => {
        const v = bb(o, c, r), x = v.bind((R) => Xd(u, c, R));
        return qs(m, x, () => jm(u, c, r).bind((R) => j6(R) ? O.some(() => {
          Qo(e, o, be.fromDom(R));
        }) : O.none())).getOrThunk(() => x.bind(() => v.map((R) => () => {
          o ? U6(e, n, r, R) : U6(e, n, R, r);
        })));
      });
    }, YT = (e, n, o) => {
      if (e.selection.isCollapsed() && Rl(e)) {
        const r = Ke.fromRangeStart(e.selection.getRng());
        return GB(e, n, o, r);
      }
      return O.none();
    }, KB = (e, n) => {
      const o = Vm(n, e);
      return ko(o, xa).fold(Pe(o), (r) => o.slice(0, r));
    }, YB = (e) => al(e) === 1, XB = (e, n, o, r) => {
      const c = Ct(h3, n), u = ae(ue(r, c), (m) => m.dom);
      if (u.length === 0)
        Qo(n, e, o);
      else {
        const m = xA(o.dom, u);
        n.selection.setRng(m.toRange());
      }
    }, W6 = (e, n) => {
      const o = be.fromDom(e.getBody()), r = be.fromDom(e.selection.getStart()), c = ue(KB(o, r), YB);
      return Ro(c).bind((u) => {
        const m = Ke.fromRangeStart(e.selection.getRng());
        return Hx(n, m, u.dom) && !BR(u) ? O.some(() => XB(n, e, u, c)) : O.none();
      });
    }, XT = (e, n) => e.selection.isCollapsed() ? W6(e, n) : O.none(), JT = (e, n, o) => O.some(() => {
      e._selectionOverrides.hideFakeCaret(), Qo(e, n, be.fromDom(o));
    }), eu = (e, n) => {
      const o = n ? gv : pv, r = n ? ja.Forwards : ja.Backwards, c = Gg(r, e.getBody(), e.selection.getRng());
      return o(c) ? JT(e, n, c.getNode(!n)) : O.from(Xi(n, c)).filter((u) => o(u) && vh(c, u)).map((u) => () => JT(e, n, u.getNode(!n)));
    }, JB = (e, n) => {
      const o = e.selection.getNode();
      return tc(o) ? JT(e, n, o) : O.none();
    }, ak = (e, n) => e.selection.isCollapsed() ? eu(e, n) : JB(e, n), Z6 = (e) => bd(e, (n) => Zl(n.dom) || Dr(n.dom)).exists((n) => Zl(n.dom)), ck = (e) => {
      const n = parseInt(e, 10);
      return isNaN(n) ? 0 : n;
    }, q6 = (e, n) => {
      const o = e || E1(n) ? "margin" : "padding", r = Gr(n, "direction") === "rtl" ? "-right" : "-left";
      return o + r;
    }, QB = (e, n, o, r, c, u) => {
      const m = q6(o, be.fromDom(u));
      if (n === "outdent") {
        const y = Math.max(0, ck(u.style[m]) - r);
        e.setStyle(u, m, y ? y + c : "");
      } else {
        const y = ck(u.style[m]) + r + c;
        e.setStyle(u, m, y);
      }
    }, e$ = (e, n) => ds(n, (o) => {
      const r = q6(s0(e), o), c = gd(o, r).map(ck).getOr(0);
      return e.dom.getContentEditable(o.dom) !== "false" && c > 0;
    }), G6 = (e) => {
      const n = X6(e);
      return !e.mode.isReadOnly() && (n.length > 1 || e$(e, n));
    }, K6 = (e) => xs(e) || zl(e), Y6 = (e) => ec(e).exists(K6), X6 = (e) => ue(vs(e.selection.getSelectedBlocks()), (n) => !K6(n) && !Y6(n) && Z6(n)), J6 = (e, n) => {
      const { dom: o } = e, r = qt(e), c = /[a-z%]+$/i.exec(r)[0], u = parseInt(r, 10), m = s0(e);
      X(X6(e), (y) => {
        QB(o, n, m, u, c, y.dom);
      });
    }, _L = (e) => J6(e, "indent"), Q6 = (e) => J6(e, "outdent"), eO = (e) => {
      if (e.selection.isCollapsed() && G6(e)) {
        const n = e.dom, o = e.selection.getRng(), r = Ke.fromRangeStart(o), c = n.getParent(o.startContainer, n.isBlock);
        if (c !== null && Mx(be.fromDom(c), r))
          return O.some(() => Q6(e));
      }
      return O.none();
    }, QT = (e, n, o) => Qs([
      eO,
      $T,
      DT,
      (r, c) => YT(r, n, c),
      C2,
      yp,
      l1,
      ak,
      x2,
      XT
    ], (r) => r(e, o)), tO = (e, n) => {
      QT(e, n, !1).fold(() => {
        Lx(e), yv(e);
      }, Dn);
    }, CL = (e, n) => {
      QT(e, n, !0).fold(() => rR(e), Dn);
    }, t$ = (e, n) => {
      e.addCommand("delete", () => {
        tO(e, n);
      }), e.addCommand("forwardDelete", () => {
        CL(e, n);
      });
    }, nO = 5, n$ = 400, e4 = (e) => e.touches === void 0 || e.touches.length !== 1 ? O.none() : O.some(e.touches[0]), H2 = (e, n) => {
      const o = Math.abs(e.clientX - n.x), r = Math.abs(e.clientY - n.y);
      return o > nO || r > nO;
    }, oO = (e) => {
      const n = Od(), o = ka(!1), r = Hy((c) => {
        e.dispatch("longpress", {
          ...c,
          type: "longpress"
        }), o.set(!0);
      }, n$);
      e.on("touchstart", (c) => {
        e4(c).each((u) => {
          r.cancel();
          const m = {
            x: u.clientX,
            y: u.clientY,
            target: c.target
          };
          r.throttle(c), o.set(!1), n.set(m);
        });
      }, !0), e.on("touchmove", (c) => {
        r.cancel(), e4(c).each((u) => {
          n.on((m) => {
            H2(u, m) && (n.clear(), o.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (c) => {
        r.cancel(), c.type !== "touchcancel" && n.get().filter((u) => u.target.isEqualNode(c.target)).each(() => {
          o.get() ? c.preventDefault() : e.dispatch("tap", {
            ...c,
            type: "tap"
          });
        });
      }, !0);
    }, V2 = (e, n) => Gn(e, n.nodeName), o$ = (e, n) => rn(n) ? !0 : Vn(n) ? !V2(e, n) && !Jl(n) : !1, s$ = (e, n, o) => Oe(y5(be.fromDom(o), be.fromDom(n)), (r) => V2(e, r.dom)), t4 = (e, n) => {
      if (rn(n)) {
        if (n.nodeValue.length === 0)
          return !0;
        if (/^\s+$/.test(n.nodeValue) && (!n.nextSibling || V2(e, n.nextSibling)))
          return !0;
      }
      return !1;
    }, sO = (e) => e.dom.create(Ir(e), ua(e)), r$ = (e) => {
      const n = e.dom, o = e.selection, r = e.schema, c = r.getBlockElements();
      let u = o.getStart();
      const m = e.getBody();
      let y, v, x;
      const R = Ir(e);
      if (!u || !Vn(u))
        return;
      const F = m.nodeName.toLowerCase();
      if (!r.isValidChild(F, R.toLowerCase()) || s$(c, m, u))
        return;
      const W = o.getRng(), K = W.startContainer, ee = W.startOffset, J = W.endContainer, te = W.endOffset, ve = xr(e);
      for (u = m.firstChild; u; )
        if (o$(c, u)) {
          if (t4(c, u)) {
            v = u, u = u.nextSibling, n.remove(v);
            continue;
          }
          y || (y = sO(e), u.parentNode.insertBefore(y, u), x = !0), v = u, u = u.nextSibling, y.appendChild(v);
        } else
          y = null, u = u.nextSibling;
      x && ve && (W.setStart(K, ee), W.setEnd(J, te), o.setRng(W), e.nodeChanged());
    }, rO = (e, n, o) => {
      const r = be.fromDom(sO(e)), c = Sd();
      Kr(r, c), o(n, r);
      const u = document.createRange();
      return u.setStartBefore(c.dom), u.setEndBefore(c.dom), u;
    }, a$ = (e) => {
      e.on("NodeChange", Ct(r$, e));
    }, Eu = (e) => (n) => (" " + n.attr("class") + " ").indexOf(e) !== -1, aO = (e, n, o) => function(r) {
      const c = arguments, u = c[c.length - 2], m = u > 0 ? n.charAt(u - 1) : "";
      if (m === '"')
        return r;
      if (m === ">") {
        const y = n.lastIndexOf("<", u);
        if (y !== -1 && n.substring(y, u).indexOf('contenteditable="false"') !== -1)
          return r;
      }
      return '<span class="' + o + '" data-mce-content="' + e.dom.encode(c[0]) + '">' + e.dom.encode(typeof c[1] == "string" ? c[1] : c[0]) + "</span>";
    }, cO = (e, n, o) => {
      let r = n.length, c = o.content;
      if (o.format !== "raw") {
        for (; r--; )
          c = c.replace(n[r], aO(e, c, Bw(e)));
        o.content = c;
      }
    }, SL = (e) => {
      const n = "contenteditable", o = " " + it.trim(_S(e)) + " ", r = " " + it.trim(Bw(e)) + " ", c = Eu(o), u = Eu(r), m = CS(e);
      m.length > 0 && e.on("BeforeSetContent", (y) => {
        cO(e, m, y);
      }), e.parser.addAttributeFilter("class", (y) => {
        let v = y.length;
        for (; v--; ) {
          const x = y[v];
          c(x) ? x.attr(n, "true") : u(x) && x.attr(n, "false");
        }
      }), e.serializer.addAttributeFilter(n, (y) => {
        let v = y.length;
        for (; v--; ) {
          const x = y[v];
          !c(x) && !u(x) || (m.length > 0 && x.attr("data-mce-content") ? (x.name = "#text", x.type = 3, x.raw = !0, x.value = x.attr("data-mce-content")) : x.attr(n, null));
        }
      });
    }, xL = (e) => kd(be.fromDom(e.getBody()), "*[data-mce-caret]").map((n) => n.dom).getOrNull(), c$ = (e, n) => {
      n.hasAttribute("data-mce-caret") && (Ii(n), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(n));
    }, TL = (e, n) => {
      const o = xL(e);
      if (!!o) {
        if (n.type === "compositionstart") {
          n.preventDefault(), n.stopPropagation(), c$(e, o);
          return;
        }
        mo(o) && (c$(e, o), e.undoManager.add());
      }
    }, l$ = (e) => {
      e.on("keyup compositionstart", Ct(TL, e));
    }, lO = Dr, n4 = (e, n, o) => qT(n, e, o, Hm, pp, lO), i$ = (e, n, o) => rk(n, e, o, (u) => Hm(u) || m5(u), (u) => pp(u) || g5(u), lO), iO = (e) => {
      const n = e.dom.create(Ir(e));
      return n.innerHTML = '<br data-mce-bogus="1">', n;
    }, uO = (e, n, o) => {
      const r = _c(e.getBody()), c = Ct(hb, n === 1 ? r.next : r.prev);
      if (o.collapsed) {
        const u = e.dom.getParent(o.startContainer, "PRE");
        if (!u)
          return;
        if (!c(Ke.fromRangeStart(o))) {
          const y = be.fromDom(iO(e));
          n === 1 ? cl(be.fromDom(u), y) : Mr(be.fromDom(u), y), e.selection.select(y.dom, !0), e.selection.collapse();
        }
      }
    }, u$ = (e, n) => {
      const o = n ? ja.Forwards : ja.Backwards, r = e.selection.getRng();
      return n4(o, e, r).orThunk(() => (uO(e, o, r), O.none()));
    }, dO = (e, n) => {
      const o = n ? 1 : -1, r = e.selection.getRng();
      return i$(o, e, r).orThunk(() => (uO(e, o, r), O.none()));
    }, o4 = (e, n) => u$(e, n).exists((o) => (Jm(e, o), !0)), s4 = (e, n) => dO(e, n).exists((o) => (Jm(e, o), !0)), fO = (e, n) => F2(e, n, n ? pp : Hm), j2 = (e, n) => RT(e, !n).map((o) => {
      const r = o.toRange(), c = e.selection.getRng();
      return n ? r.setStart(c.startContainer, c.startOffset) : r.setEnd(c.endContainer, c.endOffset), r;
    }).exists((o) => (Jm(e, o), !0)), U2 = (e) => Ae(["figcaption"], An(e)), d$ = (e, n) => {
      const o = Ct(Is, n);
      return bd(be.fromDom(e.container()), xa, o).filter(U2);
    }, f$ = (e, n, o) => n ? RB(e.dom, o) : DB(e.dom, o), m$ = (e, n) => {
      const o = be.fromDom(e.getBody()), r = Ke.fromRangeStart(e.selection.getRng());
      return d$(r, o).exists(() => {
        if (f$(o, n, r)) {
          const u = rO(e, o, n ? Kr : _y);
          return e.selection.setRng(u), !0;
        } else
          return !1;
      });
    }, W2 = (e, n) => e.selection.isCollapsed() ? m$(e, n) : !1, mO = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, g$ = (e) => ae(e, (n) => ({
      ...mO,
      action: Se,
      ...n
    })), gO = (e) => ae(e, (n) => ({
      ...mO,
      action: () => O.none(),
      ...n
    })), pO = (e, n) => n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey, p$ = (e, n) => yn(g$(e), (o) => pO(o, n) ? [o] : []), h$ = (e, n) => yn(gO(e), (o) => pO(o, n) ? [o] : []), es = (e, ...n) => () => e.apply(null, n), lk = (e, n) => Wn(p$(e, n), (o) => o.action()), hO = (e, n) => Qs(h$(e, n), (o) => o.action()), Z2 = (e, n) => {
      const o = n ? ja.Forwards : ja.Backwards, r = e.selection.getRng();
      return qT(e, o, r, gv, pv, tc).exists((c) => (Jm(e, c), !0));
    }, yO = (e, n) => {
      const o = n ? 1 : -1, r = e.selection.getRng();
      return rk(e, o, r, gv, pv, tc).exists((c) => (Jm(e, c), !0));
    }, r4 = (e, n) => F2(e, n, n ? pv : gv), bO = vi.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), ik = {
      ...bO,
      none: (e) => bO.none(e)
    }, y$ = (e, n) => vO(e, n, Xe), vO = (e, n, o) => yn(Qr(e), (r) => El(r, n) ? o(r) ? [r] : [] : vO(r, n, o)), b$ = (e, n, o = Mn) => {
      if (o(n))
        return O.none();
      if (Ae(e, An(n)))
        return O.some(n);
      const r = (c) => El(c, "table") || o(c);
      return vd(n, e.join(","), r);
    }, Za = (e, n) => b$([
      "td",
      "th"
    ], e, n), v$ = (e) => y$(e, "th,td"), kO = (e, n) => Js(e, "table", n), a4 = (e, n, o, r, c = Xe) => {
      const u = r === 1;
      if (!u && o <= 0)
        return ik.first(e[0]);
      if (u && o >= e.length - 1)
        return ik.last(e[e.length - 1]);
      {
        const m = o + r, y = e[m];
        return c(y) ? ik.middle(n, y) : a4(e, n, m, r, c);
      }
    }, c4 = (e, n) => kO(e, n).bind((o) => {
      const r = v$(o);
      return ko(r, (u) => Is(e, u)).map((u) => ({
        index: u,
        all: r
      }));
    }), l4 = (e, n, o) => c4(e, o).fold(() => ik.none(e), (c) => a4(c.all, e, c.index, 1, n)), k$ = (e, n, o) => c4(e, o).fold(() => ik.none(), (c) => a4(c.all, e, c.index, -1, n)), Ap = (e) => Js(e, "[contenteditable]"), q2 = (e, n = !1) => xo(e) ? e.dom.isContentEditable : Ap(e).fold(Pe(n), (o) => wO(o) === "true"), wO = (e) => e.dom.contentEditable, i4 = (e, n) => ({
      left: e.left - n,
      top: e.top - n,
      right: e.right + n * 2,
      bottom: e.bottom + n * 2,
      width: e.width + n,
      height: e.height + n
    }), u4 = (e, n) => yn(n, (o) => {
      const r = i4(qc(o.getBoundingClientRect()), -1);
      return [
        {
          x: r.left,
          y: e(r),
          cell: o
        },
        {
          x: r.right,
          y: e(r),
          cell: o
        }
      ];
    }), d4 = (e, n, o) => Ht(e, (r, c) => r.fold(() => O.some(c), (u) => {
      const m = Math.sqrt(Math.abs(u.x - n) + Math.abs(u.y - o)), y = Math.sqrt(Math.abs(c.x - n) + Math.abs(c.y - o));
      return O.some(y < m ? c : u);
    }), O.none()), f4 = (e, n, o, r, c) => {
      const u = ia(be.fromDom(o), "td,th,caption").map((y) => y.dom), m = ue(u4(e, u), (y) => n(y, c));
      return d4(m, r, c).map((y) => y.cell);
    }, G2 = (e) => e.bottom, K2 = (e) => e.top, uk = (e, n) => e.y < n, dk = (e, n) => e.y > n, Gf = Ct(f4, G2, uk), fk = Ct(f4, K2, dk), _O = (e, n) => Go(n.getClientRects()).bind((o) => Gf(e, o.left, o.top)).bind((o) => jT(NB(o), n)), CO = (e, n) => Ro(n.getClientRects()).bind((o) => fk(e, o.left, o.top)).bind((o) => jT(MB(o), n)), w$ = (e, n, o) => o.breakAt.exists((r) => e(n, r).breakAt.isSome()), SO = (e) => e.breakType === Xm.Wrap && e.positions.length === 0, _$ = (e) => e.breakType === Xm.Br && e.positions.length === 1, xO = (e, n, o) => {
      const r = e(n, o);
      return SO(r) || !Cr(o.getNode()) && _$(r) ? !w$(e, n, r) : r.breakAt.isNone();
    }, TO = Ct(xO, M2), C$ = Ct(xO, Fl), S$ = (e, n, o) => {
      const r = Ke.fromRangeStart(n);
      return Mm(!e, o).exists((c) => c.isEqual(r));
    }, x$ = (e, n, o, r) => {
      const c = e.selection.getRng(), u = n ? 1 : -1;
      return Vg() && S$(n, c, o) ? (Ym(u, e, o, !n, !1).each((m) => {
        Jm(e, m);
      }), !0) : !1;
    }, T$ = (e, n, o) => _O(n, o).orThunk(() => Go(o.getClientRects()).bind((r) => R6(M6(e, Ke.before(n)), r.left))).getOr(Ke.before(n)), E$ = (e, n, o) => CO(n, o).orThunk(() => Go(o.getClientRects()).bind((r) => R6(N6(e, Ke.after(n)), r.left))).getOr(Ke.after(n)), EO = (e, n) => {
      const o = n.getNode(e);
      return mi(o) ? O.some(o) : O.none();
    }, A$ = (e, n, o) => {
      n.undoManager.transact(() => {
        const r = e ? cl : Mr, c = rO(n, be.fromDom(o), r);
        Jm(n, c);
      });
    }, AO = (e, n, o) => {
      const r = EO(!!n, o), c = n === !1;
      r.fold(() => Jm(e, o.toRange()), (u) => Mm(c, e.getBody()).filter((m) => m.isEqual(o)).fold(() => Jm(e, o.toRange()), (m) => A$(n, e, u)));
    }, z$ = (e, n, o, r) => {
      const c = e.selection.getRng(), u = Ke.fromRangeStart(c), m = e.getBody();
      if (!n && TO(r, u)) {
        const y = T$(m, o, u);
        return AO(e, n, y), !0;
      } else if (n && C$(r, u)) {
        const y = E$(m, o, u);
        return AO(e, n, y), !0;
      } else
        return !1;
    }, zO = (e, n, o) => O.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((r) => O.from(e.dom.getParent(r, "table")).map((c) => o(e, n, c, r))).getOr(!1), OO = (e, n) => zO(e, n, x$), DO = (e, n) => zO(e, n, z$), O$ = (e) => {
      const n = rp.exact(e, 0, e, 0);
      return K0(n);
    }, m4 = (e, n, o) => o.fold(O.none, O.none, (r, c) => R_(c).map((u) => O$(u)), (r) => (e.execCommand("mceTableInsertRowAfter"), RO(e, n, r))), RO = (e, n, o) => m4(e, n, l4(o, q2)), D$ = (e, n, o) => m4(e, n, k$(o, q2)), MO = (e, n) => {
      const o = [
        "table",
        "li",
        "dl"
      ], r = be.fromDom(e.getBody()), c = (y) => {
        const v = An(y);
        return Is(y, r) || Ae(o, v);
      }, u = e.selection.getRng(), m = be.fromDom(n ? u.endContainer : u.startContainer);
      return Za(m, c).map((y) => (kO(y, c).each((R) => {
        e.model.table.clearSelectedCells(R.dom);
      }), e.selection.collapse(!n), (n ? RO : D$)(e, c, y).each((R) => {
        e.selection.setRng(R);
      }), !0)).getOr(!1);
    }, R$ = (e, n, o) => {
      const r = Qt.os.isMacOS() || Qt.os.isiOS();
      lk([
        {
          keyCode: Tn.RIGHT,
          action: es(o4, e, !0)
        },
        {
          keyCode: Tn.LEFT,
          action: es(o4, e, !1)
        },
        {
          keyCode: Tn.UP,
          action: es(s4, e, !1)
        },
        {
          keyCode: Tn.DOWN,
          action: es(s4, e, !0)
        },
        ...r ? [
          {
            keyCode: Tn.UP,
            action: es(j2, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Tn.DOWN,
            action: es(j2, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: Tn.RIGHT,
          action: es(OO, e, !0)
        },
        {
          keyCode: Tn.LEFT,
          action: es(OO, e, !1)
        },
        {
          keyCode: Tn.UP,
          action: es(DO, e, !1)
        },
        {
          keyCode: Tn.DOWN,
          action: es(DO, e, !0)
        },
        {
          keyCode: Tn.RIGHT,
          action: es(Z2, e, !0)
        },
        {
          keyCode: Tn.LEFT,
          action: es(Z2, e, !1)
        },
        {
          keyCode: Tn.UP,
          action: es(yO, e, !1)
        },
        {
          keyCode: Tn.DOWN,
          action: es(yO, e, !0)
        },
        {
          keyCode: Tn.RIGHT,
          action: es(I6, e, n, !0)
        },
        {
          keyCode: Tn.LEFT,
          action: es(I6, e, n, !1)
        },
        {
          keyCode: Tn.RIGHT,
          ctrlKey: !r,
          altKey: r,
          action: es(H6, e, n)
        },
        {
          keyCode: Tn.LEFT,
          ctrlKey: !r,
          altKey: r,
          action: es(u1, e, n)
        },
        {
          keyCode: Tn.UP,
          action: es(W2, e, !1)
        },
        {
          keyCode: Tn.DOWN,
          action: es(W2, e, !0)
        }
      ], o).each((c) => {
        o.preventDefault();
      });
    }, NO = (e, n) => {
      e.on("keydown", (o) => {
        o.isDefaultPrevented() === !1 && R$(e, n, o);
      });
    }, Jd = (e, n) => ({
      container: e,
      offset: n
    }), mk = Ks.DOM, gk = (e) => (n) => e === n ? -1 : 0, BO = (e) => (n) => e.isBlock(n) || Ae([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], n.nodeName) || e.getContentEditable(n) === "false", g4 = (e, n, o) => {
      if (rn(e) && n >= 0)
        return O.some(Jd(e, n));
      {
        const r = oc(mk);
        return O.from(r.backwards(e, n, gk(e), o)).map((c) => Jd(c.container, c.container.data.length));
      }
    }, M$ = (e, n, o) => {
      if (rn(e) && n >= e.length)
        return O.some(Jd(e, n));
      {
        const r = oc(mk);
        return O.from(r.forwards(e, n, gk(e), o)).map((c) => Jd(c.container, 0));
      }
    }, p4 = (e, n, o) => {
      if (!rn(e))
        return O.none();
      const r = e.textContent;
      if (n >= 0 && n <= r.length)
        return O.some(Jd(e, n));
      {
        const c = oc(mk);
        return O.from(c.backwards(e, n, gk(e), o)).bind((u) => {
          const m = u.container.data;
          return p4(u.container, n + m.length, o);
        });
      }
    }, h4 = (e, n, o) => {
      if (!rn(e))
        return O.none();
      const r = e.textContent;
      if (n <= r.length)
        return O.some(Jd(e, n));
      {
        const c = oc(mk);
        return O.from(c.forwards(e, n, gk(e), o)).bind((u) => h4(u.container, n - r.length, o));
      }
    }, y4 = (e, n, o, r, c) => {
      const u = oc(e, BO(e));
      return O.from(u.backwards(n, o, r, c));
    }, N$ = (e) => e.collapsed && e.startContainer.nodeType === 3, b4 = (e) => e.toString().replace(/\u00A0/g, " ").replace(/\uFEFF/g, ""), $O = (e) => e !== "" && ` \xA0\f
\r	\v`.indexOf(e) !== -1, v4 = (e, n) => e.substring(n.length), PO = (e, n, o) => {
      let r;
      for (r = n - 1; r >= 0; r--) {
        const c = e.charAt(r);
        if ($O(c))
          return O.none();
        if (c === o)
          break;
      }
      return O.some(r);
    }, B$ = (e, n, o, r = 0) => {
      if (!N$(n))
        return O.none();
      const c = (m, y, v) => PO(v, y, o).getOr(y), u = e.getParent(n.startContainer, e.isBlock) || e.getRoot();
      return y4(e, n.startContainer, n.startOffset, c, u).bind((m) => {
        const y = n.cloneRange();
        if (y.setStart(m.container, m.offset), y.setEnd(n.endContainer, n.endOffset), y.collapsed)
          return O.none();
        const v = b4(y);
        return v.lastIndexOf(o) !== 0 || v4(v, o).length < r ? O.none() : O.some({
          text: v4(v, o),
          range: y,
          triggerChar: o
        });
      });
    }, FO = (e, n, o, r = 0) => mv(be.fromDom(n.startContainer)).fold(() => B$(e, n, o, r), (c) => {
      const u = e.createRng();
      u.selectNode(c.dom);
      const m = b4(u);
      return O.some({
        range: u,
        text: v4(m, o),
        triggerChar: o
      });
    }), $$ = (e) => e.nodeType === bn, IO = (e) => e.nodeType === Ye, k4 = (e) => {
      if ($$(e))
        return Jd(e, e.data.length);
      {
        const n = e.childNodes;
        return n.length > 0 ? k4(n[n.length - 1]) : Jd(e, n.length);
      }
    }, LO = (e, n) => {
      const o = e.childNodes;
      return o.length > 0 && n < o.length ? LO(o[n], 0) : o.length > 0 && IO(e) && o.length === n ? k4(o[o.length - 1]) : Jd(e, n);
    }, P$ = (e, n) => {
      const o = e.getParent(n.container, e.isBlock);
      return y4(e, n.container, n.offset, (r, c) => c === 0 ? -1 : c, o).filter((r) => {
        const c = r.container.data.charAt(r.offset - 1);
        return !$O(c);
      }).isSome();
    }, F$ = (e) => (n) => {
      const o = LO(n.startContainer, n.startOffset);
      return !P$(e, o);
    }, I$ = (e, n, o) => Qs(o.triggerChars, (r) => FO(e, n, r)), L$ = (e, n) => {
      const o = n(), r = e.selection.getRng();
      return I$(e.dom, r, o).bind((c) => HO(e, n, c));
    }, HO = (e, n, o, r = {}) => {
      const c = n(), m = e.selection.getRng().startContainer.nodeValue, y = ue(c.lookupByChar(o.triggerChar), (x) => o.text.length >= x.minChars && x.matches.getOrThunk(() => F$(e.dom))(o.range, m, o.text));
      if (y.length === 0)
        return O.none();
      const v = Promise.all(ae(y, (x) => x.fetch(o.text, x.maxResults, r).then((F) => ({
        matchText: o.text,
        items: F,
        columns: x.columns,
        onAction: x.onAction,
        highlightOn: x.highlightOn
      }))));
      return O.some({
        lookupData: v,
        context: o
      });
    };
    var Qd;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(Qd || (Qd = {}));
    const w4 = (e, n, o) => e.stype === Qd.Error ? n(e.serror) : o(e.svalue), AL = (e) => {
      const n = [], o = [];
      return X(e, (r) => {
        w4(r, (c) => o.push(c), (c) => n.push(c));
      }), {
        values: n,
        errors: o
      };
    }, H$ = (e, n) => e.stype === Qd.Error ? {
      stype: Qd.Error,
      serror: n(e.serror)
    } : e, Y2 = (e, n) => e.stype === Qd.Value ? {
      stype: Qd.Value,
      svalue: n(e.svalue)
    } : e, VO = (e, n) => e.stype === Qd.Value ? n(e.svalue) : e, jO = (e, n) => e.stype === Qd.Error ? n(e.serror) : e, UO = (e) => ({
      stype: Qd.Value,
      svalue: e
    }), _4 = (e) => ({
      stype: Qd.Error,
      serror: e
    }), $c = {
      fromResult: (e) => e.fold(_4, UO),
      toResult: (e) => w4(e, ul.error, ul.value),
      svalue: UO,
      partition: AL,
      serror: _4,
      bind: VO,
      bindError: jO,
      map: Y2,
      mapError: H$,
      fold: w4
    }, C4 = (e) => dn(e) && $e(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), WO = (e) => {
      const n = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: Pe("... (only showing first ten failures)")
      }]) : e;
      return ae(n, (o) => "Failed path: (" + o.path.join(" > ") + `)
` + o.getErrorInfo());
    }, X2 = (e, n) => $c.serror([{
      path: e,
      getErrorInfo: n
    }]), S4 = (e, n, o) => X2(e, () => 'Could not find valid *required* value for "' + n + '" in ' + C4(o)), j$ = (e, n) => X2(e, () => 'Choice schema did not contain choice key: "' + n + '"'), U$ = (e, n, o) => X2(e, () => 'The chosen schema: "' + o + '" did not exist in branches: ' + C4(n)), W$ = (e, n) => X2(e, Pe(n)), ZO = (e, n, o, r) => Xo(o, r).fold(() => U$(e, o, r), (u) => u.extract(e.concat(["branch: " + r]), n)), Z$ = (e, n) => ({
      extract: (c, u) => Xo(u, e).fold(() => j$(c, e), (y) => ZO(c, u, n, y)),
      toString: () => "chooseOn(" + e + "). Possible values: " + $e(n)
    }), q$ = (e, n) => n, G$ = (e, n) => _t(e) && _t(n) ? J2(e, n) : n, qO = (e) => (...n) => {
      if (n.length === 0)
        throw new Error("Can't merge zero objects");
      const o = {};
      for (let r = 0; r < n.length; r++) {
        const c = n[r];
        for (const u in c)
          Gn(c, u) && (o[u] = e(o[u], c[u]));
      }
      return o;
    }, J2 = qO(G$), ni = qO(q$), zp = () => ({
      tag: "required",
      process: {}
    }), K$ = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), Y$ = (e) => K$(Pe(e)), X$ = () => ({
      tag: "option",
      process: {}
    }), J$ = (e, n) => e.length > 0 ? $c.svalue(J2(n, ni.apply(void 0, e))) : $c.svalue(n), GO = (e) => Qe($c.serror, fo)(e), f1 = {
      consolidateObj: (e, n) => {
        const o = $c.partition(e);
        return o.errors.length > 0 ? GO(o.errors) : J$(o.values, n);
      },
      consolidateArr: (e) => {
        const n = $c.partition(e);
        return n.errors.length > 0 ? GO(n.errors) : $c.svalue(n.values);
      }
    }, DL = (e, n, o, r) => ({
      tag: "field",
      key: e,
      newKey: n,
      presence: o,
      prop: r
    }), eP = (e, n) => ({
      tag: "custom",
      newKey: e,
      instantiator: n
    }), KO = (e, n, o) => {
      switch (e.tag) {
        case "field":
          return n(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return o(e.newKey, e.instantiator);
      }
    }, Au = (e) => {
      const n = (r, c) => $c.bindError(e(c), (u) => W$(r, u)), o = Pe("val");
      return {
        extract: n,
        toString: o
      };
    }, tP = Au($c.svalue), nP = (e, n, o, r) => Xo(n, o).fold(() => S4(e, o, n), r), x4 = (e, n, o, r) => {
      const c = Xo(e, n).getOrThunk(() => o(e));
      return r(c);
    }, oP = (e, n, o) => o(Xo(e, n)), YO = (e, n, o, r) => {
      const c = Xo(e, n).map((u) => u === !0 ? o(e) : u);
      return r(c);
    }, XO = (e, n, o, r, c) => {
      const u = (y) => c.extract(n.concat([r]), y), m = (y) => y.fold(() => $c.svalue(O.none()), (v) => {
        const x = c.extract(n.concat([r]), v);
        return $c.map(x, O.some);
      });
      switch (e.tag) {
        case "required":
          return nP(n, o, r, u);
        case "defaultedThunk":
          return x4(o, r, e.process, u);
        case "option":
          return oP(o, r, m);
        case "defaultedOptionThunk":
          return YO(o, r, e.process, m);
        case "mergeWithThunk":
          return x4(o, r, Pe({}), (y) => {
            const v = J2(e.process(o), y);
            return u(v);
          });
      }
    }, T4 = (e, n, o) => {
      const r = {}, c = [];
      for (const u of o)
        KO(u, (m, y, v, x) => {
          const R = XO(v, e, n, m, x);
          $c.fold(R, (F) => {
            c.push(...F);
          }, (F) => {
            r[y] = F;
          });
        }, (m, y) => {
          r[m] = y(n);
        });
      return c.length > 0 ? $c.serror(c) : $c.svalue(r);
    }, E4 = (e) => ({
      extract: (r, c) => T4(r, c, e),
      toString: () => {
        const r = ae(e, (c) => KO(c, (u, m, y, v) => u + " -> " + v.toString(), (u, m) => "state(" + u + ")"));
        return `obj{
` + r.join(`
`) + "}";
      }
    }), JO = (e) => ({
      extract: (r, c) => {
        const u = ae(c, (m, y) => e.extract(r.concat(["[" + y + "]"]), m));
        return f1.consolidateArr(u);
      },
      toString: () => "array(" + e.toString() + ")"
    }), sP = (e) => Au((n) => e(n).fold($c.serror, $c.svalue)), rP = (e, n, o) => {
      const r = n.extract([e], o);
      return $c.mapError(r, (c) => ({
        input: o,
        errors: c
      }));
    }, aP = (e, n, o) => $c.toResult(rP(e, n, o)), QO = (e) => `Errors: 
` + WO(e.errors).join(`
`) + `

Input object: ` + C4(e.input), A4 = (e, n) => Z$(e, ht(n, E4)), cP = Pe(tP), pk = (e, n) => Au((o) => {
      const r = typeof o;
      return e(o) ? $c.svalue(o) : $c.serror(`Expected type: ${n} but got: ${r}`);
    }), lP = pk(ft, "number"), Q2 = pk(ie, "string"), iP = pk(Je, "boolean"), z4 = pk(wn, "function"), m1 = DL, eC = eP, eD = (e) => sP((n) => Ae(e, n) ? ul.value(n) : ul.error(`Unsupported value: "${n}", choose one of "${e.join(", ")}".`)), tD = (e, n) => m1(e, e, zp(), n), nD = (e) => tD(e, Q2), tC = (e) => tD(e, z4), oD = (e, n) => m1(e, e, zp(), JO(n)), sD = (e, n) => m1(e, e, X$(), n), O4 = (e) => sD(e, Q2), RL = (e) => sD(e, z4), uP = (e, n) => m1(e, e, Y$(n), cP()), hk = (e, n, o) => m1(e, e, Y$(n), o), rD = (e, n) => hk(e, n, lP), dP = (e, n) => hk(e, n, Q2), fP = (e, n, o) => hk(e, n, eD(o)), D4 = (e, n) => hk(e, n, iP), Pc = (e, n) => hk(e, n, z4), R4 = (e, n, o) => hk(e, n, JO(o)), Kf = nD("type"), aD = tC("fetch"), nC = tC("onAction"), mP = Pc("onSetup", () => Se), M4 = O4("text"), N4 = O4("icon"), cD = O4("tooltip"), lD = O4("label"), gP = D4("active", !1), pP = D4("enabled", !0), iD = D4("primary", !1), hP = (e) => uP("columns", e), yk = (e) => dP("type", e), uD = E4([
      Kf,
      nD("ch"),
      rD("minChars", 1),
      hP(1),
      rD("maxResults", 10),
      RL("matches"),
      aD,
      nC,
      R4("highlightOn", [], Q2)
    ]), yP = (e) => aP("Autocompleter", uD, e), B4 = [
      pP,
      cD,
      N4,
      M4,
      mP
    ], dD = [gP].concat(B4), bP = [
      Pc("predicate", Mn),
      fP("scope", "node", [
        "node",
        "editor"
      ]),
      fP("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], vP = B4.concat([
      yk("contextformbutton"),
      iD,
      nC,
      eC("original", Rt)
    ]), kP = dD.concat([
      yk("contextformbutton"),
      iD,
      nC,
      eC("original", Rt)
    ]), fD = B4.concat([yk("contextformbutton")]), wP = dD.concat([yk("contextformtogglebutton")]), _P = A4("type", {
      contextformbutton: vP,
      contextformtogglebutton: kP
    });
    E4([
      yk("contextform"),
      Pc("initValue", Pe("")),
      lD,
      oD("commands", _P),
      sD("launch", A4("type", {
        contextformbutton: fD,
        contextformtogglebutton: wP
      }))
    ].concat(bP));
    const ML = (e) => {
      const n = e.ui.registry.getAll().popups, o = ht(n, (m) => yP(m).fold((y) => {
        throw new Error(QO(y));
      }, Rt)), r = ir(Fs(o, (m) => m.ch)), c = Tr(o);
      return {
        dataset: o,
        triggerChars: r,
        lookupByChar: (m) => ue(c, (y) => y.ch === m)
      };
    }, $4 = (e, n) => {
      const o = Hy(n.load, 50);
      e.on("keypress compositionend", (r) => {
        r.which !== 27 && o.throttle();
      }), e.on("keydown", (r) => {
        const c = r.which;
        c === 8 ? o.throttle() : c === 27 && n.cancelIfNecessary();
      }), e.on("remove", o.cancel);
    }, bk = (e) => {
      const n = Od(), o = ka(!1), r = n.isSet, c = () => {
        r() && (Nz(e), p_(e), o.set(!1), n.clear());
      }, u = (x) => {
        r() || (pN(e, x.range), n.set({
          triggerChar: x.triggerChar,
          matchLength: x.text.length
        }));
      }, m = Rn(() => ML(e)), y = (x) => n.get().map((R) => FO(e.dom, e.selection.getRng(), R.triggerChar).bind((F) => HO(e, m, F, x))).getOrThunk(() => L$(e, m)), v = (x) => {
        y(x).fold(c, (R) => {
          u(R.context), R.lookupData.then((F) => {
            n.get().map((W) => {
              const K = R.context;
              W.triggerChar === K.triggerChar && (K.text.length - W.matchLength >= 10 ? c() : (n.set({
                ...W,
                matchLength: K.text.length
              }), o.get() ? H0(e, { lookupData: F }) : (o.set(!0), g_(e, { lookupData: F }))));
            });
          });
        });
      };
      e.addCommand("mceAutocompleterReload", (x, R) => {
        const F = dn(R) ? R.fetchOptions : {};
        v(F);
      }), e.addCommand("mceAutocompleterClose", c), $4(e, {
        cancelIfNecessary: c,
        load: v
      });
    }, Yf = (e) => (n, o, r = {}) => {
      const c = n.getBody(), u = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: c,
        currentTarget: c,
        eventPhase: Event.AT_TARGET,
        originalTarget: c,
        explicitOriginalTarget: c,
        isTrusted: !1,
        srcElement: c,
        cancelable: !1,
        preventDefault: Se,
        inputType: o
      }, m = eh(new InputEvent(e));
      return n.dispatch(e, {
        ...m,
        ...u,
        ...r
      });
    }, eg = Yf("input"), g1 = Yf("beforeinput"), P4 = (e, n, o) => {
      const r = o.keyCode === Tn.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
      hO([
        {
          keyCode: Tn.BACKSPACE,
          action: es(eO, e)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es($T, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es($T, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(DT, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(DT, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(YT, e, n, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(YT, e, n, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(yp, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(yp, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(l1, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(l1, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(ak, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(ak, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(x2, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(x2, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(C2, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(C2, e, !0)
        },
        {
          keyCode: Tn.BACKSPACE,
          action: es(XT, e, !1)
        },
        {
          keyCode: Tn.DELETE,
          action: es(XT, e, !0)
        }
      ], o).each((c) => {
        o.preventDefault(), g1(e, r).isDefaultPrevented() || (c(), eg(e, r));
      });
    }, F4 = (e, n) => {
      lk([
        {
          keyCode: Tn.BACKSPACE,
          action: es(v6, e)
        },
        {
          keyCode: Tn.DELETE,
          action: es(v6, e)
        }
      ], n);
    }, mD = (e, n) => {
      e.on("keydown", (o) => {
        o.isDefaultPrevented() === !1 && P4(e, n, o);
      }), e.on("keyup", (o) => {
        o.isDefaultPrevented() === !1 && F4(e, o);
      });
    }, CP = (e) => {
      for (; e; ) {
        if (e.nodeType === 1 || e.nodeType === 3 && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
    }, p1 = (e, n) => {
      let o, r = n;
      const c = e.dom, u = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!n)
        return;
      if (/^(LI|DT|DD)$/.test(n.nodeName)) {
        const y = CP(n.firstChild);
        y && /^(UL|OL|DL)$/.test(y.nodeName) && n.insertBefore(c.doc.createTextNode(Te), n.firstChild);
      }
      const m = c.createRng();
      if (n.normalize(), n.hasChildNodes()) {
        const y = new rr(n, n);
        for (; o = y.current(); ) {
          if (rn(o)) {
            m.setStart(o, 0), m.setEnd(o, 0);
            break;
          }
          if (u[o.nodeName.toLowerCase()]) {
            m.setStartBefore(o), m.setEndBefore(o);
            break;
          }
          r = o, o = y.next();
        }
        o || (m.setStart(r, 0), m.setEnd(r, 0));
      } else
        Cr(n) ? n.nextSibling && c.isBlock(n.nextSibling) ? (m.setStartBefore(n), m.setEndBefore(n)) : (m.setStartAfter(n), m.setEndAfter(n)) : (m.setStart(n, 0), m.setEnd(n, 0));
      e.selection.setRng(m), Ai(e, m);
    }, gD = (e, n) => {
      const o = e.getRoot();
      let r, c;
      for (r = n; r !== o && e.getContentEditable(r) !== "false"; )
        e.getContentEditable(r) === "true" && (c = r), r = r.parentNode;
      return r !== o ? c : o;
    }, I4 = (e) => O.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), SP = (e) => I4(e).fold(Pe(""), (n) => n.nodeName.toUpperCase()), xP = (e) => I4(e).filter((n) => zl(be.fromDom(n))).isSome(), TP = (e, n) => e.firstChild && e.firstChild.nodeName === n, EP = (e) => {
      var n;
      return ((n = e.parentNode) === null || n === void 0 ? void 0 : n.firstChild) === e;
    }, pD = (e, n) => e && e.parentNode && e.parentNode.nodeName === n, L4 = (e) => e && /^(OL|UL|LI)$/.test(e.nodeName), hD = (e) => L4(e) && L4(e.parentNode), H4 = (e) => {
      const n = e.parentNode;
      return /^(LI|DT|DD)$/.test(n.nodeName) ? n : e;
    }, V4 = (e, n, o) => {
      let r = e[o ? "firstChild" : "lastChild"];
      for (; r && !Vn(r); )
        r = r[o ? "nextSibling" : "previousSibling"];
      return r === n;
    }, NL = (e, n, o, r, c) => {
      const u = e.dom, m = e.selection.getRng();
      if (o === e.getBody())
        return;
      hD(o) && (c = "LI");
      let y = n(c);
      if (V4(o, r, !0) && V4(o, r, !1))
        if (pD(o, "LI")) {
          const v = H4(o);
          u.insertAfter(y, v), EP(o) ? u.remove(v) : u.remove(o);
        } else
          u.replace(y, o);
      else if (V4(o, r, !0))
        pD(o, "LI") ? (u.insertAfter(y, H4(o)), y.appendChild(u.doc.createTextNode(" ")), y.appendChild(o)) : o.parentNode.insertBefore(y, o), u.remove(r);
      else if (V4(o, r, !1))
        u.insertAfter(y, H4(o)), u.remove(r);
      else {
        o = H4(o);
        const v = m.cloneRange();
        v.setStartAfter(r), v.setEndAfter(o);
        const x = v.extractContents();
        c === "LI" && TP(x, "LI") ? (y = x.firstChild, u.insertAfter(x, o)) : (u.insertAfter(x, o), u.insertAfter(y, o)), u.remove(r);
      }
      p1(e, y);
    }, AP = (e) => {
      X(lu(be.fromDom(e), Ps), (n) => {
        const o = n.dom;
        o.nodeValue = P(o.nodeValue);
      });
    }, BL = (e, n) => n && n.nodeName === "A" && e.isEmpty(n), $L = (e) => e && /^(TD|TH|CAPTION)$/.test(e.nodeName), j4 = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, U4 = (e, n) => e.nodeName === n || e.previousSibling && e.previousSibling.nodeName === n, zP = (e, n) => n && e.isBlock(n) && !/^(TD|TH|CAPTION|FORM)$/.test(n.nodeName) && !/^(fixed|absolute)/i.test(n.style.position) && e.getContentEditable(n) !== "true", OP = (e, n, o) => {
      let r = o;
      const c = [];
      let u;
      if (!!r) {
        for (; r = r.firstChild; ) {
          if (e.isBlock(r))
            return;
          Vn(r) && !n[r.nodeName.toLowerCase()] && c.push(r);
        }
        for (u = c.length; u--; )
          r = c[u], (!r.hasChildNodes() || r.firstChild === r.lastChild && r.firstChild.nodeValue === "" || BL(e, r)) && e.remove(r);
      }
    }, tu = (e, n, o) => rn(n) === !1 ? o : e ? o === 1 && n.data.charAt(o - 1) === k ? 0 : o : o === n.data.length - 1 && n.data.charAt(o) === k ? n.data.length : o, yD = (e) => {
      const n = e.cloneRange();
      return n.setStart(e.startContainer, tu(!0, e.startContainer, e.startOffset)), n.setEnd(e.endContainer, tu(!1, e.endContainer, e.endOffset)), n;
    }, DP = (e) => {
      do
        rn(e) && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, "")), e = e.firstChild;
      while (e);
    }, W4 = (e, n) => {
      const o = e.getRoot();
      let r, c;
      for (r = n; r !== o && e.getContentEditable(r) !== "false"; )
        e.getContentEditable(r) === "true" && (c = r), r = r.parentNode;
      return r !== o ? c : o;
    }, RP = (e, n, o) => {
      const r = e.dom;
      O.from(o.style).map(r.parseStyle).each((v) => {
        const R = {
          ...Ip(be.fromDom(n)),
          ...v
        };
        r.setStyles(n, R);
      });
      const c = O.from(o.class).map((v) => v.split(/\s+/)), u = O.from(n.className).map((v) => ue(v.split(/\s+/), (x) => x !== ""));
      qs(c, u, (v, x) => {
        const R = ue(x, (W) => !Ae(v, W)), F = [
          ...v,
          ...R
        ];
        r.setAttrib(n, "class", F.join(" "));
      });
      const m = [
        "style",
        "class"
      ], y = hr(o, (v, x) => !Ae(m, x));
      r.setAttribs(n, y);
    }, vk = (e, n) => {
      if (Ir(e).toLowerCase() === n.tagName.toLowerCase()) {
        const r = ua(e);
        RP(e, n, r);
      }
    }, PL = (e, n, o, r, c) => {
      let u, m, y, v, x, R;
      const F = e.dom, W = W4(F, r);
      if (m = F.getParent(r, F.isBlock), !m || !zP(F, m)) {
        if (m = m || W, m === e.getBody() || $L(m) ? R = m.nodeName.toLowerCase() : R = m.parentNode.nodeName.toLowerCase(), !m.hasChildNodes())
          return u = F.create(n), vk(e, u), m.appendChild(u), o.setStart(u, 0), o.setEnd(u, 0), u;
        for (v = r; v.parentNode !== m; )
          v = v.parentNode;
        for (; v && !F.isBlock(v); )
          y = v, v = v.previousSibling;
        if (y && e.schema.isValidChild(R, n.toLowerCase())) {
          for (u = F.create(n), vk(e, u), y.parentNode.insertBefore(u, y), v = y; v && !F.isBlock(v); )
            x = v.nextSibling, u.appendChild(v), v = x;
          o.setStart(r, c), o.setEnd(r, c);
        }
      }
      return r;
    }, ef = (e, n) => {
      n.normalize();
      const o = n.lastChild;
      (!o || /^(left|right)$/gi.test(e.getStyle(o, "float", !0))) && e.add(n, "br");
    }, MP = (e, n) => {
      const o = bw(e);
      return lt(n) ? !1 : ie(o) ? Ae(it.explode(o), n.nodeName.toLowerCase()) : o;
    }, bD = {
      insert: (e, n) => {
        let o, r, c, u, m, y, v, x, R;
        const F = e.dom, W = e.schema, K = W.getNonEmptyElements(), ee = e.selection.getRng(), J = Ir(e), te = (vt) => {
          let xt = r, Zt, Xt, Qn;
          const En = W.getTextInlineElements();
          if (vt || x === "TABLE" || x === "HR" ? Zt = F.create(vt || J) : Zt = u.cloneNode(!1), Qn = Zt, yw(e) === !1)
            F.setAttrib(Zt, "style", null), F.setAttrib(Zt, "class", null);
          else
            do
              if (En[xt.nodeName]) {
                if (Xl(xt) || Jl(xt))
                  continue;
                Xt = xt.cloneNode(!1), F.setAttrib(Xt, "id", ""), Zt.hasChildNodes() ? (Xt.appendChild(Zt.firstChild), Zt.appendChild(Xt)) : (Qn = Xt, Zt.appendChild(Xt));
              }
            while ((xt = xt.parentNode) && xt !== pt);
          return vk(e, Zt), j4(Qn), Zt;
        }, ve = (vt) => {
          let xt, Zt;
          const Xt = tu(vt, r, c);
          if (rn(r) && (vt ? Xt > 0 : Xt < r.nodeValue.length))
            return !1;
          if (r.parentNode === u && R && !vt || vt && Vn(r) && r === u.firstChild)
            return !0;
          if (U4(r, "TABLE") || U4(r, "HR"))
            return R && !vt || !R && vt;
          const Qn = new rr(r, u);
          for (rn(r) && (vt && Xt === 0 ? Qn.prev() : !vt && Xt === r.nodeValue.length && Qn.next()); xt = Qn.current(); ) {
            if (Vn(xt)) {
              if (!xt.getAttribute("data-mce-bogus") && (Zt = xt.nodeName.toLowerCase(), K[Zt] && Zt !== "br"))
                return !1;
            } else if (rn(xt) && !Gl(xt.nodeValue))
              return !1;
            vt ? Qn.prev() : Qn.next();
          }
          return !0;
        }, De = () => {
          /^(H[1-6]|PRE|FIGURE)$/.test(x) && pn !== "HGROUP" ? m = te(J) : m = te(), MP(e, v) && zP(F, v) && F.isEmpty(u) ? m = F.split(v, u) : F.insertAfter(m, u), p1(e, m);
        };
        Hb(F, ee).each((vt) => {
          ee.setStart(vt.startContainer, vt.startOffset), ee.setEnd(vt.endContainer, vt.endOffset);
        }), r = ee.startContainer, c = ee.startOffset;
        const Be = !!(n && n.shiftKey), qe = !!(n && n.ctrlKey);
        Vn(r) && r.hasChildNodes() && (R = c > r.childNodes.length - 1, r = r.childNodes[Math.min(c, r.childNodes.length - 1)] || r, R && rn(r) ? c = r.nodeValue.length : c = 0);
        const pt = W4(F, r);
        if (!pt)
          return;
        Be || (r = PL(e, J, ee, r, c)), u = F.getParent(r, F.isBlock), v = u ? F.getParent(u.parentNode, F.isBlock) : null, x = u ? u.nodeName.toUpperCase() : "";
        const pn = v ? v.nodeName.toUpperCase() : "";
        if (pn === "LI" && !qe && (u = v, v = v.parentNode, x = pn), /^(LI|DT|DD)$/.test(x) && F.isEmpty(u)) {
          NL(e, te, v, u, J);
          return;
        }
        u !== e.getBody() && (Ze(u) ? (m = Ii(u), F.isEmpty(u) && j4(u), vk(e, m), p1(e, m)) : ve() ? De() : ve(!0) ? (m = u.parentNode.insertBefore(te(), u), p1(e, U4(u, "HR") ? m : u)) : (o = yD(ee).cloneRange(), o.setEndAfter(u), y = o.extractContents(), AP(y), DP(y), m = y.firstChild, F.insertAfter(y, u), OP(F, K, m), ef(F, u), F.isEmpty(u) && j4(u), m.normalize(), F.isEmpty(m) ? (F.remove(m), De()) : (vk(e, m), p1(e, m))), F.setAttrib(m, "id", ""), e.dispatch("NewBlock", { newBlock: m }));
      },
      fakeEventName: "insertParagraph"
    }, NP = (e, n, o) => {
      const r = new rr(n, o);
      let c;
      const u = e.getNonEmptyElements();
      for (; c = r.next(); )
        if (u[c.nodeName.toLowerCase()] || c.length > 0)
          return !0;
    }, vD = (e, n, o) => {
      const r = e.dom.createRng();
      o ? (r.setStartBefore(n), r.setEndBefore(n)) : (r.setStartAfter(n), r.setEndAfter(n)), e.selection.setRng(r), Ai(e, r);
    }, BP = (e, n) => {
      const o = e.selection, r = e.dom, c = o.getRng();
      let u, m;
      Hb(r, c).each((K) => {
        c.setStart(K.startContainer, K.startOffset), c.setEnd(K.endContainer, K.endOffset);
      });
      let y = c.startOffset, v = c.startContainer;
      if (v.nodeType === 1 && v.hasChildNodes()) {
        const K = y > v.childNodes.length - 1;
        v = v.childNodes[Math.min(y, v.childNodes.length - 1)] || v, K && v.nodeType === 3 ? y = v.nodeValue.length : y = 0;
      }
      let x = r.getParent(v, r.isBlock);
      const R = x ? r.getParent(x.parentNode, r.isBlock) : null, F = R ? R.nodeName.toUpperCase() : "", W = !!(n && n.ctrlKey);
      F === "LI" && !W && (x = R), v && v.nodeType === 3 && y >= v.nodeValue.length && (NP(e.schema, v, x) || (u = r.create("br"), c.insertNode(u), c.setStartAfter(u), c.setEndAfter(u), m = !0)), u = r.create("br"), Wi(r, c, u), vD(e, u, m), e.undoManager.add();
    }, $P = (e, n) => {
      const o = be.fromTag("br");
      Mr(be.fromDom(n), o), e.undoManager.add();
    }, PP = (e, n) => {
      q4(e.getBody(), n) || cl(be.fromDom(n), be.fromTag("br"));
      const o = be.fromTag("br");
      cl(be.fromDom(n), o), vD(e, o.dom, !1), e.undoManager.add();
    }, Z4 = (e) => Cr(e.getNode()), q4 = (e, n) => Z4(Ke.after(n)) ? !0 : Si(e, Ke.after(n)).map((o) => Cr(o.getNode())).getOr(!1), kD = (e) => e && e.nodeName === "A" && "href" in e, LL = (e) => e.fold(Mn, kD, kD, Mn), HL = (e) => {
      const n = Ct(hp, e), o = Ke.fromRangeStart(e.selection.getRng());
      return Xd(n, e.getBody(), o).filter(LL);
    }, FP = (e, n) => {
      n.fold(Se, Ct($P, e), Ct(PP, e), Se);
    }, wD = {
      insert: (e, n) => {
        const o = HL(e);
        o.isSome() ? o.each(Ct(FP, e)) : BP(e, n);
      },
      fakeEventName: "insertLineBreak"
    }, Xf = (e, n) => I4(e).filter((o) => n.length > 0 && El(be.fromDom(o), n)).isSome(), IP = (e) => Xf(e, t0(e)), LP = (e) => Xf(e, hw(e)), tl = vi.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), HP = (e, n) => LP(e), G4 = (e) => (n, o) => xP(n) === e, _D = (e, n) => (o, r) => SP(o) === e.toUpperCase() === n, oC = (e) => _D("pre", e), VP = () => _D("summary", !0), sC = (e) => (n, o) => wc(n) === e, jP = (e, n) => IP(e), rC = (e, n) => n, UP = (e) => {
      const n = Ir(e), o = gD(e.dom, e.selection.getStart());
      return o && e.schema.isValidChild(o.nodeName, n);
    }, zu = (e, n) => (o, r) => Ht(e, (u, m) => u && m(o, r), !0) ? O.some(n) : O.none(), CD = (e, n) => S6([
      zu([HP], tl.none()),
      zu([VP()], tl.br()),
      zu([
        oC(!0),
        sC(!1),
        rC
      ], tl.br()),
      zu([
        oC(!0),
        sC(!1)
      ], tl.block()),
      zu([
        oC(!0),
        sC(!0),
        rC
      ], tl.block()),
      zu([
        oC(!0),
        sC(!0)
      ], tl.br()),
      zu([
        G4(!0),
        rC
      ], tl.br()),
      zu([G4(!0)], tl.block()),
      zu([jP], tl.br()),
      zu([rC], tl.br()),
      zu([UP], tl.block())
    ], [
      e,
      !!(n && n.shiftKey)
    ]).getOr(tl.none()), iy = (e, n, o) => {
      n.selection.isCollapsed() || Lx(n), !(Q(o) && g1(n, e.fakeEventName).isDefaultPrevented()) && (e.insert(n, o), Q(o) && eg(n, e.fakeEventName));
    }, SD = (e, n) => {
      const o = () => iy(wD, e, n), r = () => iy(bD, e, n), c = CD(e, n);
      switch (e0(e)) {
        case "linebreak":
          c.fold(o, o, Se);
          break;
        case "block":
          c.fold(r, r, Se);
          break;
        case "invert":
          c.fold(r, o, Se);
          break;
        default:
          c.fold(o, r, Se);
          break;
      }
    }, WP = (e, n) => {
      n.isDefaultPrevented() || (n.preventDefault(), WM(e.undoManager), e.undoManager.transact(() => {
        SD(e, n);
      }));
    }, ZP = (e) => {
      e.on("keydown", (n) => {
        n.keyCode === Tn.ENTER && WP(e, n);
      });
    }, qP = (e, n, o) => {
      const r = Qt.os.isMacOS() || Qt.os.isiOS();
      lk([
        {
          keyCode: Tn.END,
          action: es(fO, e, !0)
        },
        {
          keyCode: Tn.HOME,
          action: es(fO, e, !1)
        },
        ...r ? [] : [
          {
            keyCode: Tn.HOME,
            action: es(j2, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Tn.END,
            action: es(j2, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: Tn.END,
          action: es(r4, e, !0)
        },
        {
          keyCode: Tn.HOME,
          action: es(r4, e, !1)
        },
        {
          keyCode: Tn.END,
          action: es(d1, e, !0, n)
        },
        {
          keyCode: Tn.HOME,
          action: es(d1, e, !1, n)
        }
      ], o).each((c) => {
        o.preventDefault();
      });
    }, GP = (e, n) => {
      e.on("keydown", (o) => {
        o.isDefaultPrevented() === !1 && qP(e, n, o);
      });
    }, xD = (e) => {
      e.on("input", (n) => {
        n.isComposing === !1 && tL(e);
      });
    }, KP = Vo(), TD = (e, n, o) => {
      lk([
        {
          keyCode: Tn.PAGE_UP,
          action: es(d1, e, !1, n)
        },
        {
          keyCode: Tn.PAGE_DOWN,
          action: es(d1, e, !0, n)
        }
      ], o);
    }, K4 = (e) => e.stopImmediatePropagation(), ED = (e) => e.keyCode === Tn.PAGE_UP || e.keyCode === Tn.PAGE_DOWN, AD = (e, n, o) => {
      o && !e.get() ? n.on("NodeChange", K4, !0) : !o && e.get() && n.off("NodeChange", K4), e.set(o);
    }, Y4 = (e, n) => {
      if (KP.os.isMacOS())
        return;
      const o = ka(!1);
      e.on("keydown", (r) => {
        ED(r) && AD(o, e, !0);
      }), e.on("keyup", (r) => {
        r.isDefaultPrevented() === !1 && TD(e, n, r), ED(r) && o.get() && (AD(o, e, !1), e.nodeChanged());
      });
    }, zD = (e, n) => {
      const o = n.container(), r = n.offset();
      return rn(o) ? (o.insertData(r, e), O.some(Ke(o, r + e.length))) : bh(n).map((c) => {
        const u = be.fromText(e);
        return n.isAtEnd() ? cl(c, u) : Mr(c, u), Ke(u.dom, e.length);
      });
    }, YP = Ct(zD, Te), OD = Ct(zD, " "), X4 = (e) => (n) => n.fold((o) => qi(e.dom, Ke.before(o)), (o) => Xc(o), (o) => hu(o), (o) => Si(e.dom, Ke.after(o))), DD = (e, n) => (o) => U7(e, o) ? YP(n) : OD(n), XP = (e) => (n) => (e.selection.setRng(n.toRange()), e.nodeChanged(), !0), jL = (e) => {
      const n = Ke.fromRangeStart(e.selection.getRng()), o = be.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const r = Ct(hp, e), c = Ke.fromRangeStart(e.selection.getRng());
        return Xd(r, e.getBody(), c).bind(X4(o)).map((u) => () => DD(o, n)(u).each(XP(e)));
      } else
        return O.none();
    }, uy = (e, n) => {
      hO([{
        keyCode: Tn.SPACEBAR,
        action: es(jL, e)
      }], n).each((o) => {
        n.preventDefault(), g1(e, "insertText", { data: " " }).isDefaultPrevented() || (o(), eg(e, "insertText", { data: " " }));
      });
    }, JP = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() === !1 && uy(e, n);
      });
    }, QP = (e) => zm(e) ? [
      {
        keyCode: Tn.TAB,
        action: es(MO, e, !0)
      },
      {
        keyCode: Tn.TAB,
        shiftKey: !0,
        action: es(MO, e, !1)
      }
    ] : [], eF = (e, n) => {
      lk([...QP(e)], n).each((o) => {
        n.preventDefault();
      });
    }, aC = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() === !1 && eF(e, n);
      });
    }, RD = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), bk(e), Wm(e))
        return ka(null);
      {
        const n = ZB(e);
        return l$(e), NO(e, n), mD(e, n), ZP(e), JP(e), xD(e), aC(e), GP(e, n), Y4(e, n), n;
      }
    };
    class MD {
      constructor(n) {
        this.lastPath = [], this.editor = n;
        let o;
        const r = this;
        "onselectionchange" in n.getDoc() || n.on("NodeChange click mouseup keyup focus", (c) => {
          const u = n.selection.getRng(), m = {
            startContainer: u.startContainer,
            startOffset: u.startOffset,
            endContainer: u.endContainer,
            endOffset: u.endOffset
          };
          (c.type === "nodechange" || !Wa(m, o)) && n.dispatch("SelectionChange"), o = m;
        }), n.on("contextmenu", () => {
          n.dispatch("SelectionChange");
        }), n.on("SelectionChange", () => {
          const c = n.selection.getStart(!0);
          !c || Th(n) && !r.isSameElementPath(c) && n.dom.isChildOf(c, n.getBody()) && n.nodeChanged({ selectionChange: !0 });
        }), n.on("mouseup", (c) => {
          !c.isDefaultPrevented() && Th(n) && (n.selection.getNode().nodeName === "IMG" ? ml.setEditorTimeout(n, () => {
            n.nodeChanged();
          }) : n.nodeChanged());
        });
      }
      nodeChanged(n) {
        const o = this.editor.selection;
        let r, c, u;
        this.editor.initialized && o && !ob(this.editor) && !this.editor.mode.isReadOnly() && (u = this.editor.getBody(), r = o.getStart(!0) || u, (r.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(r, u)) && (r = u), c = [], this.editor.dom.getParent(r, (m) => {
          if (m === u)
            return !0;
          c.push(m);
        }), n = n || {}, n.element = r, n.parents = c, this.editor.dispatch("NodeChange", n));
      }
      isSameElementPath(n) {
        let o;
        const r = this.editor, c = Ho(r.dom.getParents(n, Xe, r.getBody()));
        if (c.length === this.lastPath.length) {
          for (o = c.length; o >= 0 && c[o] === this.lastPath[o]; o--)
            ;
          if (o === -1)
            return this.lastPath = c, !0;
        }
        return this.lastPath = c, !1;
      }
    }
    const ND = "x-tinymce/html", kk = Pe(ND), J4 = "<!-- " + ND + " -->", tF = (e) => J4 + e, nF = (e) => e.replace(J4, ""), Q4 = (e) => e.indexOf(J4) !== -1, eE = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), oF = (e, n) => {
      let o = "<" + e;
      const r = Fs(n, (c, u) => u + '="' + Ls.encodeAllRaw(c) + '"');
      return r.length && (o += " " + r.join(" ")), o + ">";
    }, tE = (e, n, o) => {
      const r = e.split(/\n\n/), c = oF(n, o), u = "</" + n + ">", m = ae(r, (v) => v.split(/\n/).join("<br />")), y = (v) => c + v + u;
      return m.length === 1 ? m[0] : ae(m, y).join("");
    }, nE = "%MCEPASTEBIN%", cC = (e, n) => {
      const { dom: o, selection: r } = e, c = e.getBody();
      n.set(r.getRng());
      const u = o.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, nE);
      Qt.browser.isFirefox() && o.setStyle(u, "left", o.getStyle(c, "direction", !0) === "rtl" ? 65535 : -65535), o.bind(u, "beforedeactivate focusin focusout", (m) => {
        m.stopPropagation();
      }), u.focus(), r.select(u, !0);
    }, BD = (e, n) => {
      const o = e.dom;
      if (lC(e)) {
        let r;
        const c = n.get();
        for (; r = lC(e); )
          o.remove(r), o.unbind(r);
        c && e.selection.setRng(c);
      }
      n.set(null);
    }, lC = (e) => e.dom.get("mcepastebin"), sF = (e) => e && e.id === "mcepastebin", rF = (e) => {
      const n = e.dom, o = (m, y) => {
        m.appendChild(y), n.remove(y, !0);
      }, [r, ...c] = ue(e.getBody().childNodes, sF);
      X(c, (m) => {
        o(r, m);
      });
      const u = n.select("div[id=mcepastebin]", r);
      for (let m = u.length - 1; m >= 0; m--) {
        const y = n.create("div");
        r.insertBefore(y, u[m]), o(y, u[m]);
      }
      return r ? r.innerHTML : "";
    }, wk = (e) => e === nE, aF = (e) => {
      const n = ka(null);
      return {
        create: () => cC(e, n),
        remove: () => BD(e, n),
        getEl: () => lC(e),
        getHtml: () => rF(e),
        getLastRng: n.get
      };
    }, $D = (e, n) => (it.each(n, (o) => {
      Ue(o, RegExp) ? e = e.replace(o, "") : e = e.replace(o[0], o[1]);
    }), e), cF = (e) => {
      const n = pi(), o = ty({}, n);
      let r = "";
      const c = n.getVoidElements(), u = it.makeMap("script noscript style textarea video audio iframe object", " "), m = n.getBlockElements(), y = (v) => {
        const x = v.name, R = v;
        if (x === "br") {
          r += `
`;
          return;
        }
        if (x !== "wbr") {
          if (c[x] && (r += " "), u[x]) {
            r += " ";
            return;
          }
          if (v.type === 3 && (r += v.value), !(v.name in n.getVoidElements()) && (v = v.firstChild))
            do
              y(v);
            while (v = v.next);
          m[x] && R.next && (r += `
`, x === "p" && (r += `
`));
        }
      };
      return e = $D(e, [/<!\[[^\]]+\]>/g]), y(o.parse(e)), r;
    }, PD = (e) => (e = $D(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (o, r, c) => !r && !c ? " " : Te
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), lF = (e) => {
      let n = 0;
      return () => e + n++;
    }, iF = (e) => {
      const n = e.toLowerCase(), o = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return it.hasOwn(o, n) ? "image/" + o[n] : "image/" + n;
    }, uF = (e, n) => {
      const o = ty({}, e.schema);
      o.addNodeFilter("meta", (c) => {
        it.each(c, (u) => {
          u.remove();
        });
      });
      const r = o.parse(n, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return gp({ validate: !0 }, e.schema).serialize(r);
    }, FD = (e, n) => ({
      content: e,
      cancelled: n
    }), dF = (e, n, o) => {
      const r = e.dom.create("div", { style: "display:none" }, n), c = Bb(e, r, o);
      return FD(c.node.innerHTML, c.isDefaultPrevented());
    }, Xr = (e, n, o) => {
      const r = V0(e, n, o), c = uF(e, r.content);
      return e.hasEventListeners("PastePostProcess") && !r.isDefaultPrevented() ? dF(e, c, o) : FD(c, r.isDefaultPrevented());
    }, fF = (e, n, o) => Xr(e, n, o), iC = (e, n) => (e.insertContent(n, {
      merge: ab(e),
      paste: !0
    }), !0), oE = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), sE = (e, n) => oE(n) && Oe(xS(e), (o) => os(n.toLowerCase(), `.${o.toLowerCase()}`)), ID = (e, n, o) => (e.undoManager.extra(() => {
      o(e, n);
    }, () => {
      e.insertContent('<img src="' + n + '">');
    }), !0), LD = (e, n, o) => (e.undoManager.extra(() => {
      o(e, n);
    }, () => {
      e.execCommand("mceInsertLink", !1, n);
    }), !0), mF = (e, n, o) => !e.selection.isCollapsed() && oE(n) ? LD(e, n, o) : !1, HD = (e, n, o) => sE(e, n) ? ID(e, n, o) : !1, gF = (e, n) => {
      it.each([
        mF,
        HD,
        iC
      ], (o) => o(e, n, iC) !== !0);
    }, pF = (e, n, o) => {
      o || !kS(e) ? iC(e, n) : gF(e, n);
    }, VD = lF("mceclip"), jD = (e, n, o, r) => {
      const c = fF(e, n, o);
      c.cancelled === !1 && pF(e, c.content, r);
    }, uC = (e, n, o) => {
      const r = o || Q4(n);
      jD(e, nF(n), r, !1);
    }, h1 = (e, n) => {
      const o = e.dom.encode(n).replace(/\r\n/g, `
`), r = Hk(o, wS(e)), c = tE(r, Ir(e), ua(e));
      jD(e, c, !1, !0);
    }, _k = (e) => {
      const n = {};
      if (e && e.types)
        for (let o = 0; o < e.types.length; o++) {
          const r = e.types[o];
          try {
            n[r] = e.getData(r);
          } catch {
            n[r] = "";
          }
        }
      return n;
    }, dy = (e, n) => n in e && e[n].length > 0, nu = (e) => dy(e, "text/html") || dy(e, "text/plain"), hF = (e, n) => {
      const o = n.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return Q(o) ? e.dom.encode(o[1]) : null;
    }, y1 = (e, n, o, r) => {
      const c = VD(), u = Ig(e) && Q(o.name), m = u ? hF(e, o.name) : c, y = u ? o.name : void 0, v = n.create(c, o, r, m, y);
      return n.add(v), v;
    }, Ck = (e, n) => {
      M3(n.uri).each(({ data: o, type: r, base64Encoded: c }) => {
        const u = c ? o : btoa(o), m = n.file, y = e.editorUpload.blobCache, v = y.getByData(u, r), x = v != null ? v : y1(e, y, m, u);
        uC(e, `<img src="${x.blobUri()}">`, !1);
      });
    }, yF = (e) => e.type === "paste", bF = (e) => Promise.all(ae(e, (n) => n1(n).then((o) => ({
      file: n,
      uri: o
    })))), b1 = (e) => {
      const n = xS(e);
      return (o) => On(o.type, "image/") && Oe(n, (r) => iF(r) === o.type);
    }, vF = (e, n) => {
      const o = n.items ? yn(Os(n.items), (c) => c.kind === "file" ? [c.getAsFile()] : []) : [], r = n.files ? Os(n.files) : [];
      return ue(o.length > 0 ? o : r, b1(e));
    }, dC = (e, n, o) => {
      const r = yF(n) ? n.clipboardData : n.dataTransfer;
      if (Ju(e) && r) {
        const c = vF(e, r);
        if (c.length > 0)
          return n.preventDefault(), bF(c).then((u) => {
            o && e.selection.setRng(o), X(u, (m) => {
              Ck(e, m);
            });
          }), !0;
      }
      return !1;
    }, rE = (e) => {
      var n, o;
      return Qt.os.isAndroid() && ((o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.items) === null || o === void 0 ? void 0 : o.length) === 0;
    }, UD = (e) => Tn.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, WD = (e, n, o, r) => {
      let c = PD(o);
      const u = dy(n, kk()) || Q4(o), m = !u && eE(c), y = oE(c);
      (wk(c) || !c.length || m && !y) && (r = !0), (r || y) && (dy(n, "text/plain") && m ? c = n["text/plain"] : c = cF(c)), !wk(c) && (r ? h1(e, c) : uC(e, c, u));
    }, kF = (e, n, o) => {
      let r;
      const c = () => n.getLastRng() || e.selection.getRng();
      e.on("keydown", (u) => {
        UD(u) && !u.isDefaultPrevented() && (r = u.shiftKey && u.keyCode === 86);
      }), e.on("paste", (u) => {
        if (u.isDefaultPrevented() || rE(u))
          return;
        const m = o.get() === "text" || r;
        r = !1;
        const y = _k(u.clipboardData);
        !nu(y) && dC(e, u, c()) || (dy(y, "text/html") ? (u.preventDefault(), WD(e, y, y["text/html"], m)) : (n.create(), ml.setEditorTimeout(e, () => {
          const v = n.getHtml();
          n.remove(), WD(e, y, v, m);
        }, 0)));
      });
    }, ZD = (e) => {
      const n = (c) => On(c, "webkit-fake-url"), o = (c) => On(c, "data:"), r = (c) => {
        var u;
        return ((u = c.data) === null || u === void 0 ? void 0 : u.paste) === !0;
      };
      e.parser.addNodeFilter("img", (c, u, m) => {
        if (!Ju(e) && r(m))
          for (const y of c) {
            const v = y.attr("src");
            ie(v) && !y.attr("data-mce-object") && v !== Qt.transparentSrc && (n(v) || !Nw(e) && o(v)) && y.remove();
          }
      });
    }, qD = (e, n, o) => {
      kF(e, n, o), ZD(e);
    }, wF = (e, n) => {
      n.get() === "text" ? (n.set("html"), op(e, !1)) : (n.set("text"), op(e, !0)), e.focus();
    }, _F = (e, n) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        wF(e, n);
      }), e.addCommand("mceInsertClipboardContent", (o, r) => {
        r.html && uC(e, r.html, r.internal), r.text && h1(e, r.text);
      });
    }, CF = (e, n, o) => {
      try {
        return e.clearData(), e.setData("text/html", n), e.setData("text/plain", o), e.setData(kk(), n), !0;
      } catch {
        return !1;
      }
    }, aE = (e, n, o, r) => {
      CF(e.clipboardData, n.html, n.text) ? (e.preventDefault(), r()) : o(n.html, r);
    }, GD = (e) => (n, o) => {
      const { dom: r, selection: c } = e, u = r.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), m = r.create("div", { contenteditable: "true" }, n);
      r.setStyles(u, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), u.appendChild(m), r.add(e.getBody(), u);
      const y = c.getRng();
      m.focus();
      const v = r.createRng();
      v.selectNodeContents(m), c.setRng(v), ml.setEditorTimeout(e, () => {
        c.setRng(y), r.remove(u), o();
      }, 0);
    }, cE = (e) => ({
      html: tF(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), SF = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), KD = (e) => !e.selection.isCollapsed() || SF(e), xF = (e) => (n) => {
      !n.isDefaultPrevented() && KD(e) && aE(n, cE(e), GD(e), () => {
        if (Qt.browser.isChromium() || Qt.browser.isFirefox()) {
          const o = e.selection.getRng();
          ml.setEditorTimeout(e, () => {
            e.selection.setRng(o), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, TF = (e) => (n) => {
      !n.isDefaultPrevented() && KD(e) && aE(n, cE(e), GD(e), Se);
    }, EF = (e) => {
      e.on("cut", xF(e)), e.on("copy", TF(e));
    }, YD = (e, n) => {
      var o, r;
      return cp.getCaretRangeFromPoint((o = n.clientX) !== null && o !== void 0 ? o : 0, (r = n.clientY) !== null && r !== void 0 ? r : 0, e.getDoc());
    }, AF = (e) => {
      const n = e["text/plain"];
      return n ? n.indexOf("file://") === 0 : !1;
    }, lE = (e, n) => {
      e.focus(), n && e.selection.setRng(n);
    }, zF = (e) => Oe(e.files, (n) => /^image\//.test(n.type)), OF = (e, n) => {
      Ar(e) && e.on("dragend dragover draggesture dragdrop drop drag", (o) => {
        o.preventDefault(), o.stopPropagation();
      }), Ju(e) || e.on("drop", (o) => {
        const r = o.dataTransfer;
        r && zF(r) && o.preventDefault();
      }), e.on("drop", (o) => {
        if (o.isDefaultPrevented() || n.get())
          return;
        const r = YD(e, o);
        if (lt(r))
          return;
        const c = _k(o.dataTransfer), u = dy(c, kk());
        if ((!nu(c) || AF(c)) && dC(e, o, r))
          return;
        const m = c[kk()], y = m || c["text/html"] || c["text/plain"];
        y && (o.preventDefault(), ml.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            m && e.execCommand("Delete"), lE(e, r);
            const v = PD(y);
            c["text/html"] ? uC(e, v, u) : h1(e, v);
          });
        }));
      }), e.on("dragstart", (o) => {
        n.set(!0);
      }), e.on("dragover dragend", (o) => {
        Ju(e) && n.get() === !1 && (o.preventDefault(), lE(e, YD(e, o))), o.type === "dragend" && n.set(!1);
      });
    }, XD = (e) => {
      const n = (c) => (u) => {
        c(e, u);
      }, o = Va(e);
      wn(o) && e.on("PastePreProcess", n(o));
      const r = Dw(e);
      wn(r) && e.on("PastePostProcess", n(r));
    }, DF = (e, n) => {
      e.on("PastePreProcess", (o) => {
        o.content = n(e, o.content, o.internal);
      });
    }, RF = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, MF = (e) => it.trim(e).replace(RF, yu).toLowerCase(), NF = (e, n, o) => {
      const r = u0(e);
      if (o || r === "all" || !Rw(e))
        return n;
      const c = r ? r.split(/[, ]/) : [];
      if (c && r !== "none") {
        const u = e.dom, m = e.selection.getNode();
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (y, v, x, R) => {
          const F = u.parseStyle(u.decode(x)), W = {};
          for (let ee = 0; ee < c.length; ee++) {
            const J = F[c[ee]];
            let te = J, ve = u.getStyle(m, c[ee], !0);
            /color/.test(c[ee]) && (te = MF(te), ve = MF(ve)), ve !== te && (W[c[ee]] = J);
          }
          const K = u.serializeStyle(W, "span");
          return K ? v + ' style="' + K + '"' + R : v + R;
        });
      } else
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return n = n.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (u, m, y, v) => m + ' style="' + y + '"' + v), n;
    }, UL = (e) => {
      (Qt.browser.isChromium() || Qt.browser.isSafari()) && DF(e, NF);
    }, BF = (e) => {
      const n = ka(!1), o = ka(Mw(e) ? "text" : "html"), r = aF(e);
      UL(e), _F(e, o), XD(e), e.on("PreInit", () => {
        EF(e), OF(e, n), qD(e, r, o);
      });
    }, $F = (e) => {
      e.on("click", (n) => {
        e.dom.getParent(n.target, "details") && n.preventDefault();
      });
    }, WL = (e) => {
      e.parser.addNodeFilter("details", (n) => {
        X(n, (o) => {
          o.attr("data-mce-open", o.attr("open")), o.attr("open", "open");
        });
      }), e.serializer.addNodeFilter("details", (n) => {
        X(n, (o) => {
          const r = o.attr("data-mce-open");
          o.attr("open", ie(r) ? r : null), o.attr("data-mce-open", null);
        });
      });
    }, PF = (e) => {
      $F(e), WL(e);
    }, Ri = Cr, JD = rn, FF = (e) => Dr(e.dom), IF = (e) => Zl(e.dom), QD = (e) => (n) => Is(be.fromDom(e), n), LF = (e, n) => bd(be.fromDom(e), (o) => IF(o) || xa(o), QD(n)).getOr(be.fromDom(n)).dom, Sk = (e, n) => bd(be.fromDom(e), FF, QD(n)), e8 = (e, n, o) => {
      const r = new rr(e, n), c = o ? r.next.bind(r) : r.prev.bind(r);
      let u = e;
      for (let m = o ? e : c(); m && !Ri(m); m = c())
        Do(m) && (u = m);
      return u;
    }, HF = (e, n) => {
      const r = Ke.fromRangeStart(e).getNode(), c = LF(r, n), u = e8(r, c, !1), m = e8(r, c, !0), y = document.createRange();
      return Sk(u, c).fold(() => {
        JD(u) ? y.setStart(u, 0) : y.setStartBefore(u);
      }, (v) => y.setStartBefore(v.dom)), Sk(m, c).fold(() => {
        JD(m) ? y.setEnd(m, m.data.length) : y.setEndAfter(m);
      }, (v) => y.setEndAfter(v.dom)), y;
    }, t8 = (e) => {
      const n = HF(e.selection.getRng(), e.getBody());
      e.selection.setRng(U_(n));
    }, n8 = (e) => {
      e.on("mousedown", (n) => {
        n.detail >= 3 && (n.preventDefault(), t8(e));
      });
    };
    var fy;
    (function(e) {
      e.Before = "before", e.After = "after";
    })(fy || (fy = {}));
    const VF = (e, n) => Math.abs(e.left - n), o8 = (e, n) => Math.abs(e.right - n), jF = (e, n) => e >= n.top && e <= n.bottom, s8 = (e, n) => e.top < n.bottom && e.bottom > n.top, UF = (e, n) => {
      const o = Uy(e, n) / Math.min(e.height, n.height);
      return s8(e, n) && o > 0.5;
    }, r8 = (e, n) => {
      const o = ue(e, (r) => jF(n, r));
      return H1(o).fold(() => [
        [],
        e
      ], (r) => {
        const {
          pass: c,
          fail: u
        } = ke(e, (m) => UF(m, r));
        return [
          c,
          u
        ];
      });
    }, WF = (e, n) => ({
      node: e.node,
      position: VF(e, n) < o8(e, n) ? fy.Before : fy.After
    }), ZF = (e, n, o) => n > e.left && n < e.right ? 0 : Math.min(Math.abs(e.left - n), Math.abs(e.right - n)), iE = (e, n, o) => {
      const r = (R) => Do(R.node) ? O.some(R) : Vn(R.node) ? iE(Os(R.node.childNodes), n, o) : O.none(), c = (R, F) => {
        if (R.length >= 2) {
          const W = r(R[0]).getOr(R[0]), K = r(R[1]).getOr(R[1]);
          if (Math.abs(F(W, n, o) - F(K, n, o)) < 2) {
            if (rn(W.node))
              return O.some(W);
            if (rn(K.node))
              return O.some(K);
          }
        }
        return O.none();
      }, u = (R, F) => {
        const W = ro(R, (K, ee) => F(K, n, o) - F(ee, n, o));
        return c(W, F).orThunk(() => Qs(W, r));
      }, [m, y] = r8(ZT(e), o), {
        pass: v,
        fail: x
      } = ke(y, (R) => R.top < o);
      return u(m, ZF).orThunk(() => u(x, jy)).orThunk(() => u(v, jy));
    }, xk = (e, n, o, r) => {
      const c = (u, m) => m.fold(() => iE(Os(u.dom.childNodes), o, r), (y) => {
        const v = ue(Os(u.dom.childNodes), (x) => x !== y.dom);
        return iE(v, o, r);
      }).orThunk(() => (Is(u, e) ? O.none() : am(u)).bind((v) => c(v, O.some(u))));
      return c(n, O.none());
    }, v1 = (e, n, o) => {
      const r = be.fromDom(e), c = ii(r), m = be.fromPoint(c, n, o).filter((y) => ya(r, y)).getOr(r);
      return xk(r, m, n, o);
    }, qF = (e, n, o) => v1(e, n, o).filter((r) => jg(r.node)).map((r) => WF(r, n)), uE = (e) => {
      const n = e.getBoundingClientRect(), o = e.ownerDocument, r = o.documentElement, c = o.defaultView;
      return {
        top: n.top + c.pageYOffset - r.clientTop,
        left: n.left + c.pageXOffset - r.clientLeft
      };
    }, GF = (e) => e.inline ? uE(e.getBody()) : {
      left: 0,
      top: 0
    }, KF = (e) => {
      const n = e.getBody();
      return e.inline ? {
        left: n.scrollLeft,
        top: n.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, YF = (e) => {
      const n = e.getBody(), o = e.getDoc().documentElement, r = {
        left: n.scrollLeft,
        top: n.scrollTop
      }, c = {
        left: n.scrollLeft || o.scrollLeft,
        top: n.scrollTop || o.scrollTop
      };
      return e.inline ? r : c;
    }, XF = (e, n) => {
      if (n.target.ownerDocument !== e.getDoc()) {
        const o = uE(e.getContentAreaContainer()), r = YF(e);
        return {
          left: n.pageX - o.left + r.left,
          top: n.pageY - o.top + r.top
        };
      }
      return {
        left: n.pageX,
        top: n.pageY
      };
    }, JF = (e, n, o) => ({
      pageX: o.left - e.left + n.left,
      pageY: o.top - e.top + n.top
    }), fC = (e, n) => JF(GF(e), KF(e), XF(e, n)), mC = Dr, a8 = Zl, QF = (e, n) => mC(n) && n !== e, e9 = (e, n, o) => n === o || e.dom.isChildOf(n, o) ? !1 : !mC(n), ZL = (e) => {
      const n = e.cloneNode(!0);
      return n.removeAttribute("data-mce-selected"), n;
    }, t9 = (e, n, o, r) => {
      const c = e.dom, u = n.cloneNode(!0);
      c.setStyles(u, {
        width: o,
        height: r
      }), c.setAttrib(u, "data-mce-selected", null);
      const m = c.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return c.setStyles(m, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: o,
        height: r
      }), c.setStyles(u, {
        margin: 0,
        boxSizing: "border-box"
      }), m.appendChild(u), m;
    }, dE = (e, n) => {
      e.parentNode !== n && n.appendChild(e);
    }, fE = (e, n, o, r, c, u) => {
      let m = 0, y = 0;
      e.style.left = n.pageX + "px", e.style.top = n.pageY + "px", n.pageX + o > c && (m = n.pageX + o - c), n.pageY + r > u && (y = n.pageY + r - u), e.style.width = o - m + "px", e.style.height = r - y + "px";
    }, Tk = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, n9 = (e) => e.button === 0, o9 = (e, n) => ({
      pageX: n.pageX - e.relX,
      pageY: n.pageY + 5
    }), c8 = (e, n) => (o) => {
      if (n9(o)) {
        const r = Wn(n.dom.getParents(o.target), XC(mC, a8)).getOr(null);
        if (QF(n.getBody(), r)) {
          const c = n.dom.getPos(r), u = n.getBody(), m = n.getDoc().documentElement;
          e.set({
            element: r,
            dragging: !1,
            screenX: o.screenX,
            screenY: o.screenY,
            maxX: (n.inline ? u.scrollWidth : m.offsetWidth) - 2,
            maxY: (n.inline ? u.scrollHeight : m.offsetHeight) - 2,
            relX: o.pageX - c.x,
            relY: o.pageY - c.y,
            width: r.offsetWidth,
            height: r.offsetHeight,
            ghost: t9(n, r, r.offsetWidth, r.offsetHeight)
          });
        }
      }
    }, s9 = (e, n) => {
      const o = zf((r, c) => {
        n._selectionOverrides.hideFakeCaret(), n.selection.placeCaretAt(r, c);
      }, 0);
      return n.on("remove", o.cancel), (r) => e.on((c) => {
        const u = Math.max(Math.abs(r.screenX - c.screenX), Math.abs(r.screenY - c.screenY));
        if (!c.dragging && u > 10) {
          if (n.dispatch("dragstart", { target: c.element }).isDefaultPrevented())
            return;
          c.dragging = !0, n.focus();
        }
        if (c.dragging) {
          const m = o9(c, fC(n, r));
          dE(c.ghost, n.getBody()), fE(c.ghost, m, c.width, c.height, c.maxX, c.maxY), o.throttle(r.clientX, r.clientY);
        }
      });
    }, mE = (e) => {
      const o = e.getSel().getRangeAt(0).startContainer;
      return o.nodeType === 3 ? o.parentNode : o;
    }, l8 = (e, n) => (o) => {
      e.on((r) => {
        if (r.dragging) {
          if (e9(n, mE(n.selection), r.element)) {
            const c = ZL(r.element);
            n.dispatch("drop", {
              clientX: o.clientX,
              clientY: o.clientY
            }).isDefaultPrevented() || n.undoManager.transact(() => {
              Tk(r.element), n.insertContent(n.dom.getOuterHTML(c)), n._selectionOverrides.hideFakeCaret();
            });
          }
          n.dispatch("dragend");
        }
      }), gE(e);
    }, r9 = (e, n) => () => {
      e.on((o) => {
        o.dragging && n.dispatch("dragend");
      }), gE(e);
    }, gE = (e) => {
      e.on((n) => {
        Tk(n.ghost);
      }), e.clear();
    }, a9 = (e) => {
      const n = Od(), o = Ks.DOM, r = document, c = c8(n, e), u = s9(n, e), m = l8(n, e), y = r9(n, e);
      e.on("mousedown", c), e.on("mousemove", u), e.on("mouseup", m), o.bind(r, "mousemove", u), o.bind(r, "mouseup", y), e.on("remove", () => {
        o.unbind(r, "mousemove", u), o.unbind(r, "mouseup", y);
      }), e.on("keydown", (v) => {
        v.keyCode === Tn.ESC && y();
      });
    }, qL = (e) => {
      const n = (c) => {
        if (!c.isDefaultPrevented()) {
          const u = c.dataTransfer;
          u && (Ae(u.types, "Files") || u.files.length > 0) && (c.preventDefault(), c.type === "drop" && Yv(e, "Dropped file type is not supported"));
        }
      }, o = (c) => {
        Y(e, c.target) && n(c);
      }, r = () => {
        const c = Ks.DOM, u = e.dom, m = document, y = e.inline ? e.getBody() : e.getDoc(), v = [
          "drop",
          "dragover"
        ];
        X(v, (x) => {
          c.bind(m, x, o), u.bind(y, x, n);
        }), e.on("remove", () => {
          X(v, (x) => {
            c.unbind(m, x, o), u.unbind(y, x, n);
          });
        });
      };
      e.on("init", () => {
        ml.setEditorTimeout(e, r, 0);
      });
    }, c9 = (e) => {
      a9(e), l0(e) && qL(e);
    }, l9 = (e) => {
      const n = zf(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const o = e.selection.getRng();
          if (o.collapsed) {
            const r = E2(e, o, !1);
            e.selection.setRng(r);
          }
        }
      }, 0);
      e.on("focus", () => {
        n.throttle();
      }), e.on("blur", () => {
        n.cancel();
      });
    }, i8 = (e) => {
      e.on("init", () => {
        e.on("focusin", (n) => {
          const o = n.target;
          if (tc(o)) {
            const r = hl(e.getBody(), o), c = Dr(r) ? r : o;
            e.selection.getNode() !== c && tk(e, c).each((u) => e.selection.setRng(u));
          }
        });
      });
    }, k1 = Dr, gC = (e, n) => hl(e.getBody(), n), i9 = (e) => {
      const n = e.selection, o = e.dom, r = o.isBlock, c = e.getBody(), u = fb(e, c, r, () => xr(e)), m = "sel-" + o.uniqueId(), y = "data-mce-selected";
      let v;
      const x = (xt) => o.hasClass(xt, "mce-offscreen-selection"), R = (xt) => xt !== c && (k1(xt) || tc(xt)) && o.isChildOf(xt, c), F = (xt) => {
        xt && n.setRng(xt);
      }, W = (xt, Zt, Xt, Qn = !0) => e.dispatch("ShowCaret", {
        target: Zt,
        direction: xt,
        before: Xt
      }).isDefaultPrevented() ? null : (Qn && n.scrollIntoView(Zt, xt === -1), u.show(Xt, Zt)), K = (xt) => {
        xt.hasAttribute("data-mce-caret") && (Ii(xt), n.scrollIntoView(xt));
      }, ee = () => {
        e.on("click", (Zt) => {
          const Xt = gC(e, Zt.target);
          Xt && k1(Xt) && (Zt.preventDefault(), e.focus());
        }), e.on("blur NewBlock", pt), e.on("ResizeWindow FullscreenStateChanged", u.reposition), e.on("tap", (Zt) => {
          const Xt = Zt.target, Qn = gC(e, Xt);
          k1(Qn) ? (Zt.preventDefault(), tk(e, Qn).each(qe)) : R(Xt) && tk(e, Xt).each(qe);
        }, !0), e.on("mousedown", (Zt) => {
          const Xt = Zt.target;
          if (Xt !== c && Xt.nodeName !== "HTML" && !o.isChildOf(Xt, c) || zN(e, Zt.clientX, Zt.clientY) === !1)
            return;
          pt(), vt();
          const Qn = gC(e, Xt);
          k1(Qn) ? (Zt.preventDefault(), tk(e, Qn).each(qe)) : qF(c, Zt.clientX, Zt.clientY).each((En) => {
            Zt.preventDefault();
            const fn = W(1, En.node, En.position === fy.Before, !1);
            F(fn), Vn(Qn) ? Qn.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (Zt) => {
          Tn.modifierPressed(Zt) || k1(n.getNode()) && Zt.preventDefault();
        }), e.on("GetSelectionRange", (Zt) => {
          let Xt = Zt.range;
          if (v) {
            if (!v.parentNode) {
              v = null;
              return;
            }
            Xt = Xt.cloneRange(), Xt.selectNode(v), Zt.range = Xt;
          }
        }), e.on("SetSelectionRange", (Zt) => {
          Zt.range = ve(Zt.range);
          const Xt = qe(Zt.range, Zt.forward);
          Xt && (Zt.range = Xt);
        });
        const xt = (Zt) => Zt.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (Zt) => {
          const Xt = Zt.range, Qn = Xt.startContainer.parentNode;
          !te(Xt) && !xt(Qn) && vt(), x(Qn) || pt();
        }), c9(e), l9(e), i8(e);
      }, J = (xt) => jt(xt) || hc(xt) || Fa(xt), te = (xt) => J(xt.startContainer) || J(xt.endContainer), ve = (xt) => {
        const Zt = e.schema.getVoidElements(), Xt = o.createRng(), Qn = xt.startContainer, En = xt.startOffset, fn = xt.endContainer, As = xt.endOffset;
        return Gn(Zt, Qn.nodeName.toLowerCase()) ? En === 0 ? Xt.setStartBefore(Qn) : Xt.setStartAfter(Qn) : Xt.setStart(Qn, En), Gn(Zt, fn.nodeName.toLowerCase()) ? As === 0 ? Xt.setEndBefore(fn) : Xt.setEndAfter(fn) : Xt.setEnd(fn, As), Xt;
      }, De = (xt, Zt) => {
        const Xt = be.fromDom(e.getBody()), Qn = e.getDoc(), En = kd(Xt, "#" + m).getOrThunk(() => {
          const Us = be.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', Qn);
          return ms(Us, "id", m), Kr(Xt, Us), Us;
        }), fn = o.createRng();
        ff(En), Fu(En, [
          be.fromText(Te, Qn),
          be.fromDom(Zt),
          be.fromText(Te, Qn)
        ]), fn.setStart(En.dom.firstChild, 1), fn.setEnd(En.dom.lastChild, 0), Or(En, { top: o.getPos(xt, e.getBody()).y + "px" }), _u(En);
        const As = n.getSel();
        return As.removeAllRanges(), As.addRange(fn), fn;
      }, Be = (xt) => {
        const Zt = xt.cloneNode(!0), Xt = e.dispatch("ObjectSelected", {
          target: xt,
          targetClone: Zt
        });
        if (Xt.isDefaultPrevented())
          return null;
        const Qn = De(xt, Xt.targetClone), En = be.fromDom(xt);
        return X(ia(be.fromDom(e.getBody()), `*[${y}]`), (fn) => {
          Is(En, fn) || $r(fn, y);
        }), o.getAttrib(xt, y) || xt.setAttribute(y, "1"), v = xt, vt(), Qn;
      }, qe = (xt, Zt) => {
        if (!xt)
          return null;
        if (xt.collapsed) {
          if (!te(xt)) {
            const fn = Zt ? 1 : -1, As = Gg(fn, c, xt), Us = As.getNode(!Zt);
            if (jg(Us))
              return W(fn, Us, Zt ? !As.isAtEnd() : !1, !1);
            const lr = As.getNode(Zt);
            if (jg(lr))
              return W(fn, lr, Zt ? !1 : !As.isAtEnd(), !1);
          }
          return null;
        }
        let Xt = xt.startContainer, Qn = xt.startOffset;
        const En = xt.endOffset;
        if (Xt.nodeType === 3 && Qn === 0 && k1(Xt.parentNode) && (Xt = Xt.parentNode, Qn = o.nodeIndex(Xt), Xt = Xt.parentNode), Xt.nodeType !== 1)
          return null;
        if (En === Qn + 1 && Xt === xt.endContainer) {
          const fn = Xt.childNodes[Qn];
          if (R(fn))
            return Be(fn);
        }
        return null;
      }, pt = () => {
        v && v.removeAttribute(y), kd(be.fromDom(e.getBody()), "#" + m).each(Gs), v = null;
      }, pn = () => {
        u.destroy(), v = null;
      }, vt = () => {
        u.hide();
      };
      return Wm(e) || ee(), {
        showCaret: W,
        showBlockCaretContainer: K,
        hideFakeCaret: vt,
        destroy: pn
      };
    }, u8 = (e, n, o) => {
      if (rn(n) && (o < 0 || o > n.data.length))
        return [];
      const r = [o];
      let c = n;
      for (; c !== e && c.parentNode; ) {
        const u = c.parentNode;
        for (let m = 0; m < u.childNodes.length; m++)
          if (u.childNodes[m] === c) {
            r.push(m);
            break;
          }
        c = u;
      }
      return c === e ? r.reverse() : [];
    }, pE = (e, n, o, r, c) => {
      const u = u8(e, n, o), m = u8(e, r, c);
      return {
        start: u,
        end: m
      };
    }, d8 = (e, n) => {
      const o = n.slice(), r = o.pop();
      return Ht(o, (u, m) => u.bind((y) => O.from(y.childNodes[m])), O.some(e)).bind((u) => rn(u) && (r < 0 || r > u.data.length) ? O.none() : O.some({
        node: u,
        offset: r
      }));
    }, hE = (e, n) => d8(e, n.start).bind(({
      node: o,
      offset: r
    }) => d8(e, n.end).map(({
      node: c,
      offset: u
    }) => {
      const m = document.createRange();
      return m.setStart(o, r), m.setEnd(c, u), m;
    })), GL = (e, n) => pE(e, n.startContainer, n.startOffset, n.endContainer, n.endOffset), w1 = (e, n, o) => {
      if (n && e.isEmpty(n) && !o(n)) {
        const r = n.parentNode;
        e.remove(n), w1(e, r, o);
      }
    }, Ek = (e, n, o, r = !0) => {
      const c = n.startContainer.parentNode, u = n.endContainer.parentNode;
      n.deleteContents(), r && !o(n.startContainer) && (rn(n.startContainer) && n.startContainer.data.length === 0 && e.remove(n.startContainer), rn(n.endContainer) && n.endContainer.data.length === 0 && e.remove(n.endContainer), w1(e, c, o), c !== u && w1(e, u, o));
    }, yE = (e, n) => O.from(e.dom.getParent(n.startContainer, e.dom.isBlock)), pC = (e, n, o) => {
      M$(n, 0, n).each((c) => {
        const u = c.container;
        h4(u, o.start.length, n).each((m) => {
          const y = e.createRng();
          y.setStart(u, 0), y.setEnd(m.container, m.offset), Ek(e, y, (v) => v === n);
        });
      });
    }, u9 = (e, n) => {
      const o = e.dom, r = n.pattern, c = hE(o.getRoot(), n.range).getOrDie("Unable to resolve path range"), u = (m, y) => {
        const v = y.get(m);
        return Re(v) && Go(v).exists((x) => Gn(x, "block"));
      };
      return yE(e, c).each((m) => {
        r.type === "block-format" ? u(r.format, e.formatter) && e.undoManager.transact(() => {
          pC(e.dom, m, r), e.formatter.apply(r.format);
        }) : r.type === "block-command" && e.undoManager.transact(() => {
          pC(e.dom, m, r), e.execCommand(r.cmd, !1, r.value);
        });
      }), !0;
    }, d9 = (e, n) => {
      const o = n.replace(Te, " ");
      return Wn(e, (r) => n.indexOf(r.start) === 0 || o.indexOf(r.start) === 0);
    }, f9 = (e, n) => {
      const o = e.dom, r = e.selection.getRng();
      return yE(e, r).filter((c) => {
        const u = Ir(e), m = o.is(c, u);
        return c !== null && m;
      }).bind((c) => {
        const u = c.textContent;
        return d9(n, u).map((y) => it.trim(u).length === y.start.length ? [] : [{
          pattern: y,
          range: pE(o.getRoot(), c, 0, c, 0)
        }]);
      }).getOr([]);
    }, f8 = (e, n) => {
      if (n.length === 0)
        return;
      const o = e.selection.getBookmark();
      X(n, (r) => u9(e, r)), e.selection.moveToBookmark(o);
    }, Ak = (e, n) => e.create("span", {
      "data-mce-type": "bookmark",
      id: n
    }), zk = (e, n) => {
      const o = e.createRng();
      return o.setStartAfter(n.start), o.setEndBefore(n.end), o;
    }, bE = (e, n, o) => {
      const r = hE(e.getRoot(), o).getOrDie("Unable to resolve path range"), c = r.startContainer, u = r.endContainer, m = r.endOffset === 0 ? u : u.splitText(r.endOffset), y = r.startOffset === 0 ? c : c.splitText(r.startOffset);
      return {
        prefix: n,
        end: m.parentNode.insertBefore(Ak(e, n + "-end"), m),
        start: y.parentNode.insertBefore(Ak(e, n + "-start"), y)
      };
    }, m8 = (e, n, o) => {
      w1(e, e.get(n.prefix + "-end"), o), w1(e, e.get(n.prefix + "-start"), o);
    }, vE = (e) => e.start.length === 0, g8 = (e) => (n, o) => {
      const c = n.data.substring(0, o), u = c.lastIndexOf(e.charAt(e.length - 1)), m = c.lastIndexOf(e);
      return m !== -1 ? m + e.length : u !== -1 ? u + 1 : -1;
    }, p8 = (e, n, o, r) => {
      const c = n.start;
      return y4(e, r.container, r.offset, g8(c), o).bind((m) => {
        if (m.offset >= c.length) {
          const y = e.createRng();
          return y.setStart(m.container, m.offset - c.length), y.setEnd(m.container, m.offset), O.some(y);
        } else {
          const y = m.offset - c.length;
          return p4(m.container, y, o).map((v) => {
            const x = e.createRng();
            return x.setStart(v.container, v.offset), x.setEnd(m.container, m.offset), x;
          }).filter((v) => v.toString() === c).orThunk(() => p8(e, n, o, Jd(m.container, 0)));
        }
      });
    }, m9 = (e, n, o, r, c, u = !1) => {
      if (n.start.length === 0 && !u) {
        const m = e.createRng();
        return m.setStart(o, r), m.setEnd(o, r), O.some(m);
      }
      return g4(o, r, c).bind((m) => p8(e, n, c, m).bind((v) => {
        if (u) {
          if (v.endContainer === m.container && v.endOffset === m.offset)
            return O.none();
          if (m.offset === 0 && v.endContainer.textContent.length === v.endOffset)
            return O.none();
        }
        return O.some(v);
      }));
    }, g9 = (e, n, o) => {
      const r = e.dom, c = r.getRoot(), u = o.pattern, m = o.position.container, y = o.position.offset;
      return p4(m, y - o.pattern.end.length, n).bind((v) => {
        const x = pE(c, v.container, v.offset, m, y);
        if (vE(u))
          return O.some({
            matches: [{
              pattern: u,
              startRng: x,
              endRng: x
            }],
            position: v
          });
        {
          const R = hC(e, o.remainingPatterns, v.container, v.offset, n), F = R.getOr({
            matches: [],
            position: v
          }), W = F.position;
          return m9(r, u, W.container, W.offset, n, R.isNone()).map((ee) => {
            const J = GL(c, ee);
            return {
              matches: F.matches.concat([{
                pattern: u,
                startRng: J,
                endRng: x
              }]),
              position: Jd(ee.startContainer, ee.startOffset)
            };
          });
        }
      });
    }, hC = (e, n, o, r, c) => {
      const u = e.dom;
      return g4(o, r, u.getRoot()).bind((m) => {
        const y = u.createRng();
        y.setStart(c, 0), y.setEnd(o, r);
        const v = y.toString();
        for (let x = 0; x < n.length; x++) {
          const R = n[x];
          if (!os(v, R.end))
            continue;
          const F = n.slice();
          F.splice(x, 1);
          const W = g9(e, c, {
            pattern: R,
            remainingPatterns: F,
            position: m
          });
          if (W.isSome())
            return W;
        }
        return O.none();
      });
    }, h8 = (e, n, o) => {
      e.selection.setRng(o), n.type === "inline-format" ? X(n.format, (r) => {
        e.formatter.apply(r);
      }) : e.execCommand(n.cmd, !1, n.value);
    }, p9 = (e, n, o, r) => {
      const c = zk(e.dom, o);
      Ek(e.dom, c, r), h8(e, n, c);
    }, h9 = (e, n, o, r, c) => {
      const u = e.dom, m = zk(u, r), y = zk(u, o);
      Ek(u, y, c), Ek(u, m, c);
      const v = {
        prefix: o.prefix,
        start: o.end,
        end: r.start
      }, x = zk(u, v);
      h8(e, n, x);
    }, y9 = (e, n) => {
      const o = Xk("mce_textpattern"), r = ct(n, (c, u) => {
        const m = bE(e, o + `_end${c.length}`, u.endRng);
        return c.concat([{
          ...u,
          endMarker: m
        }]);
      }, []);
      return ct(r, (c, u) => {
        const m = r.length - c.length - 1, y = vE(u.pattern) ? u.endMarker : bE(e, o + `_start${m}`, u.startRng);
        return c.concat([{
          ...u,
          startMarker: y
        }]);
      }, []);
    }, y8 = (e, n, o) => {
      const r = e.selection.getRng();
      return r.collapsed === !1 ? [] : yE(e, r).bind((c) => {
        const u = Math.max(0, r.startOffset - (o ? 1 : 0));
        return hC(e, n, r.startContainer, u, c);
      }).fold(() => [], (c) => c.matches);
    }, b8 = (e, n) => {
      if (n.length === 0)
        return;
      const o = e.dom, r = e.selection.getBookmark(), c = y9(o, n);
      X(c, (u) => {
        const m = o.getParent(u.startMarker.start, o.isBlock), y = (v) => v === m;
        vE(u.pattern) ? p9(e, u.pattern, u.endMarker, y) : h9(e, u.pattern, u.startMarker, u.endMarker, y), m8(o, u.endMarker, y), m8(o, u.startMarker, y);
      }), e.selection.moveToBookmark(r);
    }, v8 = (e) => e.inlinePatterns.length > 0 || e.blockPatterns.length > 0, k8 = (e, n) => {
      if (!e.selection.isCollapsed() || !v8(n))
        return !1;
      const o = y8(e, n.inlinePatterns, !1), r = f9(e, n.blockPatterns);
      return r.length > 0 || o.length > 0 ? (e.undoManager.add(), e.undoManager.extra(() => {
        e.execCommand("mceInsertNewLine");
      }, () => {
        e.insertContent(km), b8(e, o), f8(e, r);
        const c = e.selection.getRng(), u = g4(c.startContainer, c.startOffset, e.dom.getRoot());
        e.execCommand("mceInsertNewLine"), u.each((m) => {
          const y = m.container;
          y.data.charAt(m.offset - 1) === km && (y.deleteData(m.offset - 1, 1), w1(e.dom, y.parentNode, (v) => v === e.dom.getRoot()));
        });
      }), !0) : !1;
    }, yC = (e, n) => {
      if (n.length > 0) {
        const o = y8(e, n, !0);
        o.length > 0 && e.undoManager.transact(() => {
          b8(e, o);
        });
      }
    }, bC = (e, n, o) => {
      for (let r = 0; r < e.length; r++)
        if (o(e[r], n))
          return !0;
      return !1;
    }, b9 = (e, n) => bC(e, n, (o, r) => o === r.keyCode && Tn.modifierPressed(r) === !1), kE = (e, n) => bC(e, n, (o, r) => o.charCodeAt(0) === r.charCode), v9 = (e) => {
      const n = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], o = [32], r = () => Pg(d0(e)), c = () => $g(d0(e));
      e.on("keydown", (u) => {
        u.keyCode === 13 && !Tn.modifierPressed(u) && k8(e, r()) && u.preventDefault();
      }, !0), e.on("keyup", (u) => {
        b9(o, u) && yC(e, c());
      }), e.on("keypress", (u) => {
        kE(n, u) && ml.setEditorTimeout(e, () => {
          yC(e, c());
        });
      });
    }, k9 = (e) => {
      v9(e);
    }, w9 = (e) => {
      const n = it.each, o = Tn.BACKSPACE, r = Tn.DELETE, c = e.dom, u = e.selection, m = e.parser, y = Qt.browser, v = y.isFirefox(), x = y.isChromium() || y.isSafari(), R = Qt.deviceType.isiPhone() || Qt.deviceType.isiPad(), F = Qt.os.isMacOS() || Qt.os.isiOS(), W = (ln, lo) => {
        try {
          e.getDoc().execCommand(ln, !1, lo);
        } catch {
        }
      }, K = (ln) => ln.isDefaultPrevented(), ee = () => {
        const ln = (zn) => {
          const nn = c.create("body"), is = zn.cloneContents();
          return nn.appendChild(is), u.serializer.serialize(nn, { format: "html" });
        }, lo = (zn) => {
          const nn = ln(zn), is = c.createRng();
          is.selectNode(e.getBody());
          const _s = ln(is);
          return nn === _s;
        };
        e.on("keydown", (zn) => {
          const nn = zn.keyCode;
          let is, _s;
          if (!K(zn) && (nn === r || nn === o)) {
            if (is = e.selection.isCollapsed(), _s = e.getBody(), is && !c.isEmpty(_s) || !is && !lo(e.selection.getRng()))
              return;
            zn.preventDefault(), e.setContent(""), _s.firstChild && c.isBlock(_s.firstChild) ? e.selection.setCursorLocation(_s.firstChild, 0) : e.selection.setCursorLocation(_s, 0), e.nodeChanged();
          }
        });
      }, J = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, te = () => {
        e.inline || c.bind(e.getDoc(), "mousedown mouseup", (ln) => {
          let lo;
          if (ln.target === e.getDoc().documentElement)
            if (lo = u.getRng(), e.getBody().focus(), ln.type === "mousedown") {
              if (jt(lo.startContainer))
                return;
              u.placeCaretAt(ln.clientX, ln.clientY);
            } else
              u.setRng(lo);
        });
      }, ve = () => {
        e.on("keydown", (ln) => {
          if (!K(ln) && ln.keyCode === o) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (u.isCollapsed() && u.getRng().startOffset === 0) {
              const lo = u.getNode(), zn = lo.previousSibling;
              if (lo.nodeName === "HR") {
                c.remove(lo), ln.preventDefault();
                return;
              }
              zn && zn.nodeName && zn.nodeName.toLowerCase() === "hr" && (c.remove(zn), ln.preventDefault());
            }
          }
        });
      }, De = () => {
        Range.prototype.getClientRects || e.on("mousedown", (ln) => {
          if (!K(ln) && ln.target.nodeName === "HTML") {
            const lo = e.getBody();
            lo.blur(), ml.setEditorTimeout(e, () => {
              lo.focus();
            });
          }
        });
      }, Be = () => {
        const ln = Ew(e);
        e.on("click", (lo) => {
          const zn = lo.target;
          /^(IMG|HR)$/.test(zn.nodeName) && c.getContentEditableParent(zn) !== "false" && (lo.preventDefault(), e.selection.select(zn), e.nodeChanged()), zn.nodeName === "A" && c.hasClass(zn, ln) && zn.childNodes.length === 0 && (lo.preventDefault(), u.select(zn));
        });
      }, qe = () => {
        const ln = () => {
          const zn = c.getAttribs(u.getStart().cloneNode(!1));
          return () => {
            const nn = u.getStart();
            nn !== e.getBody() && (c.setAttrib(nn, "style", null), n(zn, (is) => {
              nn.setAttributeNode(is.cloneNode(!0));
            }));
          };
        }, lo = () => !u.isCollapsed() && c.getParent(u.getStart(), c.isBlock) !== c.getParent(u.getEnd(), c.isBlock);
        e.on("keypress", (zn) => {
          let nn;
          if (!K(zn) && (zn.keyCode === 8 || zn.keyCode === 46) && lo())
            return nn = ln(), e.getDoc().execCommand("delete", !1, null), nn(), zn.preventDefault(), !1;
        }), c.bind(e.getDoc(), "cut", (zn) => {
          let nn;
          !K(zn) && lo() && (nn = ln(), ml.setEditorTimeout(e, () => {
            nn();
          }));
        });
      }, pt = () => {
        e.on("keydown", (ln) => {
          if (!K(ln) && ln.keyCode === o && u.isCollapsed() && u.getRng().startOffset === 0) {
            const lo = u.getNode().previousSibling;
            if (lo && lo.nodeName && lo.nodeName.toLowerCase() === "table")
              return ln.preventDefault(), !1;
          }
        });
      }, pn = () => {
        e.on("keydown", (ln) => {
          let lo, zn;
          if (K(ln) || ln.keyCode !== Tn.BACKSPACE)
            return;
          lo = u.getRng();
          const nn = lo.startContainer, is = lo.startOffset, _s = c.getRoot();
          if (zn = nn, !(!lo.collapsed || is !== 0)) {
            for (; zn && zn.parentNode && zn.parentNode.firstChild === zn && zn.parentNode !== _s; )
              zn = zn.parentNode;
            zn.tagName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", null, zn), lo = c.createRng(), lo.setStart(nn, 0), lo.setEnd(nn, 0), u.setRng(lo));
          }
        });
      }, vt = () => {
        const ln = () => {
          W("StyleWithCSS", !1), W("enableInlineTableEditing", !1), wi(e) || W("enableObjectResizing", !1);
        };
        Aa(e) || e.on("BeforeExecCommand mousedown", ln);
      }, xt = () => {
        const ln = () => {
          n(c.select("a"), (lo) => {
            let zn = lo.parentNode;
            const nn = c.getRoot();
            if (zn.lastChild === lo) {
              for (; zn && !c.isBlock(zn); ) {
                if (zn.parentNode.lastChild !== zn || zn === nn)
                  return;
                zn = zn.parentNode;
              }
              c.add(zn, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (lo) => {
          (lo.type === "setcontent" || lo.command === "mceInsertLink") && ln();
        });
      }, Zt = () => {
        e.on("init", () => {
          W("DefaultParagraphSeparator", Ir(e));
        });
      }, Xt = (ln) => {
        const lo = ln.getBody(), zn = ln.selection.getRng();
        return zn.startContainer === zn.endContainer && zn.startContainer === lo && zn.startOffset === 0 && zn.endOffset === lo.childNodes.length;
      }, Qn = () => {
        e.on("keyup focusin mouseup", (ln) => {
          !Tn.modifierPressed(ln) && !Xt(e) && u.normalize();
        }, !0);
      }, En = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, fn = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, As = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (ln) => {
          let lo;
          ln.target.nodeName === "HTML" && (lo = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(lo), e.selection.normalize(), e.nodeChanged());
        }));
      }, Us = () => {
        F && e.on("keydown", (ln) => {
          Tn.metaKeyPressed(ln) && !ln.shiftKey && (ln.keyCode === 37 || ln.keyCode === 39) && (ln.preventDefault(), e.selection.getSel().modify("move", ln.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, lr = () => {
        e.on("click", (ln) => {
          let lo = ln.target;
          do
            if (lo.tagName === "A") {
              ln.preventDefault();
              return;
            }
          while (lo = lo.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, qa = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (ln) => {
            ln.preventDefault();
          });
        });
      }, Gt = () => {
        m.addNodeFilter("br", (ln) => {
          let lo = ln.length;
          for (; lo--; )
            ln[lo].attr("class") === "Apple-interchange-newline" && ln[lo].remove();
        });
      }, Hn = Se, ps = () => {
        if (!v || e.removed)
          return !1;
        const ln = e.selection.getSel();
        return !ln || !ln.rangeCount || ln.rangeCount === 0;
      }, ss = () => {
        x && (te(), Be(), qa(), J(), R && (fn(), As(), lr())), v && (De(), vt(), En(), Us());
      }, ac = () => {
        pn(), ee(), Qt.windowsPhone || Qn(), x && (te(), Be(), Zt(), qa(), pt(), Gt(), R ? (fn(), As(), lr()) : J()), v && (ve(), De(), qe(), vt(), xt(), En(), Us(), pt());
      };
      return Wm(e) ? ss() : ac(), {
        refreshContentEditable: Hn,
        isHidden: ps
      };
    }, wE = Ks.DOM, _9 = (e, n) => {
      const o = be.fromDom(e.getBody()), r = H(M(o)), c = be.fromTag("style");
      ms(c, "type", "text/css"), Kr(c, be.fromText(n)), Kr(r, c), e.on("remove", () => {
        Gs(c);
      });
    }, C9 = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, _E = (e) => hr(e, (n) => rt(n) === !1), CE = (e) => {
      const n = e.options.get, o = e.editorUpload.blobCache;
      return _E({
        allow_conditional_comments: n("allow_conditional_comments"),
        allow_html_data_urls: n("allow_html_data_urls"),
        allow_svg_data_urls: n("allow_svg_data_urls"),
        allow_html_in_named_anchor: n("allow_html_in_named_anchor"),
        allow_script_urls: n("allow_script_urls"),
        allow_unsafe_link_target: n("allow_unsafe_link_target"),
        convert_fonts_to_spans: n("convert_fonts_to_spans"),
        fix_list_elements: n("fix_list_elements"),
        font_size_legacy_values: n("font_size_legacy_values"),
        forced_root_block: n("forced_root_block"),
        forced_root_block_attrs: n("forced_root_block_attrs"),
        preserve_cdata: n("preserve_cdata"),
        remove_trailing_brs: n("remove_trailing_brs"),
        inline_styles: n("inline_styles"),
        root_name: C9(e),
        validate: !0,
        blob_cache: o,
        document: e.getDoc()
      });
    }, w8 = (e) => {
      const n = e.options.get;
      return _E({
        custom_elements: n("custom_elements"),
        extended_valid_elements: n("extended_valid_elements"),
        invalid_elements: n("invalid_elements"),
        invalid_styles: n("invalid_styles"),
        schema: n("schema"),
        valid_children: n("valid_children"),
        valid_classes: n("valid_classes"),
        valid_elements: n("valid_elements"),
        valid_styles: n("valid_styles"),
        verify_html: n("verify_html"),
        padd_empty_block_inline_children: n("format_empty_lines")
      });
    }, S9 = (e) => {
      const n = e.options.get;
      return {
        ...CE(e),
        ...w8(e),
        ..._E({
          url_converter: n("url_converter"),
          url_converter_scope: n("url_converter_scope"),
          element_format: n("element_format"),
          entities: n("entities"),
          entity_encoding: n("entity_encoding"),
          indent: n("indent"),
          indent_after: n("indent_after"),
          indent_before: n("indent_before")
        })
      };
    }, x9 = (e) => {
      const n = ty(CE(e), e.schema);
      return n.addAttributeFilter("src,href,style,tabindex", (o, r) => {
        let c = o.length, u, m;
        const y = e.dom, v = "data-mce-" + r;
        for (; c--; )
          if (u = o[c], m = u.attr(r), m && !u.attr(v)) {
            if (m.indexOf("data:") === 0 || m.indexOf("blob:") === 0)
              continue;
            r === "style" ? (m = y.serializeStyle(y.parseStyle(m), u.name), m.length || (m = null), u.attr(v, m), u.attr(r, m)) : r === "tabindex" ? (u.attr(v, m), u.attr(r, null)) : u.attr(v, e.convertURL(m, r, u.name));
          }
      }), n.addNodeFilter("script", (o) => {
        let r = o.length;
        for (; r--; ) {
          const c = o[r], u = c.attr("type") || "no/type";
          u.indexOf("mce-") !== 0 && c.attr("type", "mce-" + u);
        }
      }), e.options.get("preserve_cdata") && n.addNodeFilter("#cdata", (o) => {
        let r = o.length;
        for (; r--; ) {
          const c = o[r];
          c.type = 8, c.name = "#comment", c.value = "[CDATA[" + e.dom.encode(c.value) + "]]";
        }
      }), n.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (o) => {
        let r = o.length;
        const c = e.schema.getNonEmptyElements();
        for (; r--; ) {
          const u = o[r];
          u.isEmpty(c) && u.getAll("br").length === 0 && u.append(new pl("br", 1));
        }
      }), n;
    }, T9 = (e) => {
      const n = rb(e);
      n && ml.setEditorTimeout(e, () => {
        let o;
        n === !0 ? o = e : o = e.editorManager.get(n), o.destroyed || o.focus();
      }, 100);
    }, E9 = (e) => {
      const n = e.dom.getRoot();
      !e.inline && (!Th(e) || e.selection.getStart(!0) === n) && Xc(n).each((o) => {
        const r = o.getNode(), c = mi(r) ? Xc(r).getOr(o) : o;
        e.selection.setRng(c.toRange());
      });
    }, A9 = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, Bl(e), e.focus(!0), E9(e), e.nodeChanged({ initial: !0 });
      const n = zw(e);
      wn(n) && n.call(e, e), T9(e);
    }, _8 = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, C8 = (e, n, o) => {
      const r = [_8(e).loadAll(n)];
      return e.inline ? r : r.concat([e.ui.styleSheetLoader.loadAll(o)]);
    }, S8 = (e) => {
      const n = _8(e), o = _w(e), r = e.contentCSS, c = () => {
        n.unloadAll(r), e.inline || e.ui.styleSheetLoader.unloadAll(o);
      }, u = () => {
        e.removed ? c() : e.on("remove", c);
      };
      if (e.contentStyles.length > 0) {
        let v = "";
        it.each(e.contentStyles, (x) => {
          v += x + `\r
`;
        }), e.dom.addStyle(v);
      }
      const m = Promise.all(C8(e, r, o)).then(u).catch(u), y = Ha(e);
      return y && _9(e, y), m;
    }, SE = (e) => {
      const n = e.getDoc(), o = e.getBody();
      Db(e), Ow(e) || (n.body.spellcheck = !1, wE.setAttrib(o, "spellcheck", "false")), e.quirks = w9(e), Ua(e);
      const r = Cw(e);
      r !== void 0 && (o.dir = r);
      const c = Bf(e);
      c && e.on("BeforeSetContent", (u) => {
        it.each(c, (m) => {
          u.content = u.content.replace(m, (y) => "<!--mce:protected " + escape(y) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (u) => {
        e.composing = u.type === "compositionstart";
      });
    }, z9 = (e) => {
      Wm(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, xE = (e) => {
      e.removed !== !0 && (z9(e), A9(e));
    }, x8 = (e) => {
      const n = e.getElement();
      let o = e.getDoc();
      e.inline && (wE.addClass(n, "mce-content-body"), e.contentDocument = o = document, e.contentWindow = window, e.bodyElement = n, e.contentAreaContainer = n);
      const r = e.getBody();
      r.disabled = !0, e.readonly = Aa(e), e.readonly || (e.inline && wE.getStyle(r, "position", !0) === "static" && (r.style.position = "relative"), r.contentEditable = "true"), r.disabled = !1, e.editorUpload = v2(e), e.schema = pi(w8(e)), e.dom = Ks(o, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: () => e.inline,
        schema: e.schema,
        contentCssCors: nb(e),
        referrerPolicy: o0(e),
        onSetAttrib: (m) => {
          e.dispatch("SetAttrib", m);
        }
      }), e.parser = x9(e), e.serializer = uT(S9(e), e), e.selection = lT(e.dom, e.getWin(), e.serializer, e), e.annotator = u_(e), e.formatter = wT(e), e.undoManager = xu(e), e._nodeChangeDispatcher = new MD(e), e._selectionOverrides = i9(e), oO(e), PF(e), SL(e), Wm(e) || (n8(e), k9(e));
      const c = RD(e);
      t$(e, c), a$(e), XN(e), BF(e);
      const u = QM(e);
      SE(e), u.fold(() => {
        S8(e).then(() => xE(e));
      }, (m) => {
        e.setProgressState(!0), S8(e).then(() => {
          m().then((y) => {
            e.setProgressState(!1), xE(e), Mz(e);
          }, (y) => {
            e.notificationManager.open({
              type: "error",
              text: String(y)
            }), xE(e), Mz(e);
          });
        });
      });
    }, T8 = (e, n) => {
      if (e.inline || (e.getElement().style.visibility = e.orgVisibility), !n && !e.inline) {
        const o = e.iframeElement, r = jN(be.fromDom(o), "load", () => {
          r.unbind(), e.contentDocument = o.contentDocument, x8(e);
        });
        if (Qt.browser.isFirefox()) {
          const c = e.getDoc();
          c.open(), c.write(e.iframeHTML), c.close();
        } else
          o.srcdoc = e.iframeHTML;
      } else
        x8(e);
    }, vC = Ks.DOM, O9 = (e, n, o, r) => {
      const c = be.fromTag("iframe");
      return r.each((u) => ms(c, "tabindex", u)), ur(c, o), ur(c, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: n
      }), jl(c, "tox-edit-area__iframe"), c;
    }, kC = (e) => {
      let n = rS(e) + "<html><head>";
      pw(e) !== e.documentBaseUrl && (n += '<base href="' + e.documentBaseURI.getURI() + '" />'), n += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const o = vc(e), r = kc(e), c = e.translate(Aw(e));
      return Kc(e) && (n += '<meta http-equiv="Content-Security-Policy" content="' + Kc(e) + '" />'), n += `</head><body id="${o}" class="mce-content-body ${r}" data-id="${e.id}" aria-label="${c}"><br></body></html>`, n;
    }, D9 = (e, n) => {
      const o = e.translate("Rich Text Area"), r = _l(be.fromDom(e.getElement()), "tabindex").bind(br), c = O9(e.id, o, gw(e), r).dom;
      c.onload = () => {
        c.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = n.iframeContainer, e.iframeElement = c, e.iframeHTML = kC(e), vC.add(n.iframeContainer, c);
    }, R9 = (e, n) => {
      D9(e, n), n.editorContainer && (vC.get(n.editorContainer).style.display = e.orgDisplay, e.hidden = vC.isHidden(n.editorContainer)), e.getElement().style.display = "none", vC.setAttrib(e.id, "aria-hidden", "true"), T8(e);
    }, E8 = Ks.DOM, M9 = (e, n, o) => {
      const r = c1.get(o), c = c1.urls[o] || e.documentBaseUrl.replace(/\/$/, "");
      if (o = it.trim(o), r && it.inArray(n, o) === -1) {
        if (e.plugins[o])
          return;
        try {
          const u = r(e, c) || {};
          e.plugins[o] = u, wn(u.init) && (u.init(e, c), n.push(o));
        } catch (u) {
          IN(e, o, u);
        }
      }
    }, N9 = (e) => e.replace(/^\-/, ""), B9 = (e) => {
      const n = [];
      X(pu(e), (o) => {
        M9(e, n, N9(o));
      });
    }, $9 = (e) => {
      const n = it.trim(n0(e)), o = e.ui.registry.getAll().icons, r = {
        ...h2.get("default").icons,
        ...h2.get(n).icons
      };
      Jt(r, (c, u) => {
        Gn(o, u) || e.ui.registry.addIcon(u, c);
      });
    }, P9 = (e) => {
      const n = Am(e);
      if (ie(n)) {
        const o = Kd.get(n);
        e.theme = o(e, Kd.urls[n]) || {}, wn(e.theme.init) && e.theme.init(e, Kd.urls[n] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, F9 = (e) => {
      const n = _i(e), o = Cp.get(n);
      e.model = o(e, Cp.urls[n]);
    }, A8 = (e) => e.theme.renderUI(), I9 = (e) => {
      const n = e.getElement(), r = Am(e)(e, n);
      return r.editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || e.id + "_parent"), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || e.id + "_iframecontainer"), r.height = r.iframeHeight ? r.iframeHeight : n.offsetHeight, r;
    }, TE = (e) => ({
      editorContainer: e,
      iframeContainer: e,
      api: {}
    }), L9 = (e) => {
      const n = E8.create("div");
      return E8.insertAfter(n, e), TE(n);
    }, H9 = (e) => {
      const n = e.getElement();
      return e.inline ? TE(null) : L9(n);
    }, z8 = (e) => {
      const n = e.getElement();
      return e.orgDisplay = n.style.display, ie(Am(e)) ? A8(e) : wn(Am(e)) ? I9(e) : H9(e);
    }, Ok = (e, n) => {
      const o = {
        show: O.from(n.show).getOr(Se),
        hide: O.from(n.hide).getOr(Se),
        isEnabled: O.from(n.isEnabled).getOr(Xe),
        setEnabled: (r) => {
          e.mode.isReadOnly() || O.from(n.setEnabled).each((c) => c(r));
        }
      };
      e.ui = {
        ...e.ui,
        ...o
      };
    }, V9 = (e) => {
      e.dispatch("ScriptsLoaded"), $9(e), P9(e), F9(e), B9(e);
      const n = z8(e);
      Ok(e, O.from(n.api).getOr({}));
      const o = {
        editorContainer: n.editorContainer,
        iframeContainer: n.iframeContainer
      };
      return e.editorContainer = o.editorContainer ? o.editorContainer : null, kL(e), e.inline ? T8(e) : R9(e, o);
    }, Op = Ks.DOM, O8 = (e) => e.charAt(0) === "-", j9 = (e, n) => {
      const o = ww(n), r = lS(n);
      if (Dl.hasCode(o) === !1 && o !== "en") {
        const c = Bo(r) ? r : `${n.editorManager.baseURL}/langs/${o}.js`;
        e.add(c).catch(() => {
          $N(n, c, o);
        });
      }
    }, U9 = (e, n) => {
      const o = Am(e);
      if (ie(o) && !O8(o) && !Gn(Kd.urls, o)) {
        const r = Nd(e), c = r ? e.documentBaseURI.toAbsolute(r) : `themes/${o}/theme${n}.js`;
        Kd.load(o, c).catch(() => {
          PN(e, c, o);
        });
      }
    }, W9 = (e, n) => {
      const o = _i(e);
      if (o !== "plugin" && !Gn(Cp.urls, o)) {
        const r = r0(e), c = ie(r) ? e.documentBaseURI.toAbsolute(r) : `models/${o}/model${n}.js`;
        Cp.load(o, c).catch(() => {
          FN(e, c, o);
        });
      }
    }, D8 = (e) => O.from(aS(e)).filter(Bo).map((n) => ({
      url: n,
      name: O.none()
    })), R8 = (e, n, o) => O.from(n).filter((r) => Bo(r) && !h2.has(r)).map((r) => ({
      url: `${e.editorManager.baseURL}/icons/${r}/icons${o}.js`,
      name: O.some(r)
    })), M8 = (e, n, o) => {
      const r = R8(n, "default", o), c = D8(n).orThunk(() => R8(n, n0(n), ""));
      X(Ca([
        r,
        c
      ]), (u) => {
        e.add(u.url).catch(() => {
          BN(n, u.url, u.name.getOrUndefined());
        });
      });
    }, Z9 = (e, n) => {
      const o = (r, c) => {
        c1.load(r, c).catch(() => {
          NN(e, c, r);
        });
      };
      Jt(Tw(e), (r, c) => {
        o(c, r), e.options.set("plugins", pu(e).concat(c));
      }), X(pu(e), (r) => {
        r = it.trim(r), r && !c1.urls[r] && !O8(r) && o(r, `plugins/${r}/plugin${n}.js`);
      });
    }, q9 = (e) => {
      const n = Am(e);
      return !ie(n) || Q(Kd.get(n));
    }, G9 = (e) => {
      const n = _i(e);
      return Q(Cp.get(n));
    }, K9 = (e, n) => {
      const o = Yl.ScriptLoader, r = () => {
        !e.removed && q9(e) && G9(e) && V9(e);
      };
      U9(e, n), W9(e, n), j9(o, e), M8(o, e, n), Z9(e, n), o.loadQueue().then(r, r);
    }, Y9 = (e, n) => wd.forElement(e, {
      contentCssCors: yS(n),
      referrerPolicy: o0(n)
    }), X9 = (e) => {
      const n = e.id;
      Dl.setCode(ww(e));
      const o = () => {
        Op.unbind(window, "ready", o), e.render();
      };
      if (!fu.Event.domLoaded) {
        Op.bind(window, "ready", o);
        return;
      }
      if (!e.getElement())
        return;
      const r = be.fromDom(e.getElement()), c = Sa(r);
      e.on("remove", () => {
        je(r.dom.attributes, (m) => $r(r, m.name)), ur(r, c);
      }), e.ui.styleSheetLoader = Y9(r, e), mh(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const u = e.getElement().form || Op.getParent(n, "form");
      u && (e.formElement = u, Bd(e) && !pm(e.getElement()) && (Op.insertAfter(Op.create("input", {
        type: "hidden",
        name: n
      }), n), e.hasHiddenInput = !0), e.formEventDelegate = (m) => {
        e.dispatch(m.type, m);
      }, Op.bind(u, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), gS(e) && !u.submit.nodeType && !u.submit.length && !u._mceOldSubmit && (u._mceOldSubmit = u.submit, u.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), u._mceOldSubmit(u)))), e.windowManager = pT(e), e.notificationManager = DN(e), $w(e) && e.on("GetContent", (m) => {
        m.save && (m.content = Op.encode(m.content));
      }), xw(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), pS(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), K9(e, e.suffix);
    }, J9 = (e, n) => ({
      sections: Pe(e),
      options: Pe(n)
    }), N8 = Vo().deviceType, B8 = N8.isPhone(), $8 = N8.isTablet(), my = (e) => {
      if (lt(e))
        return [];
      {
        const n = Re(e) ? e : e.split(/[ ,]/), o = ae(n, zo);
        return ue(o, Bo);
      }
    }, P8 = (e, n) => {
      const o = Zs(n, (r, c) => Ae(e, c));
      return J9(o.t, o.f);
    }, F8 = (e, n, o = {}) => {
      const r = e.sections(), c = Xo(r, n).getOr({});
      return it.extend({}, o, c);
    }, EE = (e, n) => Gn(e.sections(), n), Q9 = (e, n) => EE(e, n) ? e.sections()[n] : {}, I8 = (e, n) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: Xo(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...n ? { menubar: !1 } : {}
    }), L8 = (e, n) => {
      var o;
      const r = (o = n.external_plugins) !== null && o !== void 0 ? o : {};
      return e && e.external_plugins ? it.extend({}, e.external_plugins, r) : r;
    }, eI = (e, n) => [].concat(my(e)).concat(my(n)), tI = (e, n, o, r) => e && EE(n, "mobile") ? r : o, AE = (e, n, o, r) => {
      const c = my(o.forced_plugins), u = my(r.plugins), m = Q9(n, "mobile"), y = m.plugins ? my(m.plugins) : u, v = tI(e, n, u, y), x = eI(c, v);
      return it.extend(r, {
        forced_plugins: c,
        plugins: x
      });
    }, wC = (e, n) => e && EE(n, "mobile"), _C = (e, n, o, r, c) => {
      var u;
      const m = e ? { mobile: I8((u = c.mobile) !== null && u !== void 0 ? u : {}, n) } : {}, y = P8(["mobile"], J2(m, c)), v = it.extend(o, r, y.options(), wC(e, y) ? F8(y, "mobile") : {}, { external_plugins: L8(r, y.options()) });
      return AE(e, y, r, v);
    }, tg = (e, n) => _C(B8 || $8, B8, n, e, n), CC = (e, n) => gN(e, n), _1 = (e) => {
      const n = (r, c) => {
        e.formatter.toggle(r, c), e.nodeChanged();
      }, o = (r) => () => {
        X("left,center,right,justify".split(","), (c) => {
          r !== c && e.formatter.remove("align" + c);
        }), r !== "none" && n("align" + r);
      };
      e.editorCommands.addCommands({
        JustifyLeft: o("left"),
        JustifyCenter: o("center"),
        JustifyRight: o("right"),
        JustifyFull: o("justify"),
        JustifyNone: o("none")
      });
    }, H8 = (e) => {
      const n = (o) => () => {
        const r = e.selection, c = r.isCollapsed() ? [e.dom.getParent(r.getNode(), e.dom.isBlock)] : r.getSelectedBlocks();
        return Oe(c, (u) => Q(e.formatter.matchNode(u, o)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("alignleft"),
        JustifyCenter: n("aligncenter"),
        JustifyRight: n("alignright"),
        JustifyFull: n("alignjustify")
      }, "state");
    }, nI = (e) => {
      _1(e), H8(e);
    }, oI = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (n) => {
          const o = e.getDoc();
          let r;
          try {
            o.execCommand(n);
          } catch {
            r = !0;
          }
          if (n === "paste" && !o.queryCommandEnabled(n) && (r = !0), r || !o.queryCommandSupported(n)) {
            let c = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (Qt.os.isMacOS() || Qt.os.isiOS()) && (c = c.replace(/Ctrl\+/g, "\u2318+")), e.notificationManager.open({
              text: c,
              type: "error"
            });
          }
        }
      });
    }, V8 = (e, n, o) => {
      const r = be.fromDom(e.getRoot());
      return jh(r, Ke.fromRangeStart(n)) ? o = o.replace(/^ /, "&nbsp;") : o = o.replace(/^&nbsp;/, " "), Px(r, Ke.fromRangeEnd(n)) ? o = o.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : o = o.replace(/&nbsp;(<br( \/)?>)?$/, " "), o;
    }, sI = (e) => {
      if (typeof e != "string") {
        const n = it.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: n
        };
      }
      return {
        content: e,
        details: {}
      };
    }, zE = (e, n) => {
      const o = e.selection, r = e.dom;
      return /^ | $/.test(n) ? V8(r, o.getRng(), n) : n;
    }, gy = (e, n) => {
      const { content: o, details: r } = sI(n);
      L3(e, {
        content: zE(e, o),
        format: "html",
        set: !1,
        selection: !0,
        paste: r.paste
      }).each((c) => {
        const u = mN(e, c.content, r);
        H3(e, u, c), e.addVisual();
      });
    }, Dp = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const n = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(n);
        },
        insertImage: (n, o, r) => {
          gy(e, e.dom.createHTML("img", { src: r }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (n, o, r) => {
          gy(e, e.dom.encode(r));
        },
        insertHTML: (n, o, r) => {
          gy(e, r);
        },
        mceInsertContent: (n, o, r) => {
          gy(e, r);
        },
        mceSetContent: (n, o, r) => {
          e.setContent(r);
        },
        mceReplaceContent: (n, o, r) => {
          e.execCommand("mceInsertContent", !1, r.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent("");
        }
      });
    }, py = {
      "font-size": "size",
      "font-family": "face"
    }, j8 = (e, n, o) => {
      const r = (u) => gd(u, e).orThunk(() => An(u) === "font" ? Xo(py, e).bind((m) => _l(u, m)) : O.none()), c = (u) => Is(be.fromDom(n), u);
      return Ev(be.fromDom(o), (u) => r(u), c);
    }, rI = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), aI = (e, n) => O.from(Ks.DOM.getStyle(n, e, !0)), U8 = (e) => (n, o) => O.from(o).map(be.fromDom).filter(Oo).bind((r) => j8(e, n, r.dom).or(aI(e, r.dom))).getOr(""), cI = U8("font-size"), lI = Qe(rI, U8("font-family")), iI = (e) => Xc(e.getBody()).map((n) => {
      const o = n.container();
      return rn(o) ? o.parentNode : o;
    }), W8 = (e) => O.from(e.selection.getRng()).bind((n) => {
      const o = e.getBody();
      return n.startContainer === o && n.startOffset === 0 ? O.none() : O.from(e.selection.getStart(!0));
    }), uI = (e, n) => W8(e).orThunk(Ct(iI, e)).map(be.fromDom).filter(Oo).bind(n), OE = (e, n) => uI(e, z(O.some, n)), Z8 = (e, n) => {
      if (/^[0-9.]+$/.test(n)) {
        const o = parseInt(n, 10);
        if (o >= 1 && o <= 7) {
          const r = SS(e), c = gh(e);
          return c ? c[o - 1] || n : r[o - 1] || n;
        } else
          return n;
      } else
        return n;
    }, KL = (e) => {
      const n = e.split(/\s*,\s*/);
      return ae(n, (o) => o.indexOf(" ") !== -1 && !(On(o, '"') || On(o, "'")) ? `'${o}'` : o).join(",");
    }, dI = (e, n) => {
      const o = Z8(e, n);
      e.formatter.toggle("fontname", { value: KL(o) }), e.nodeChanged();
    }, DE = (e) => OE(e, (n) => lI(e.getBody(), n.dom)).getOr(""), fI = (e, n) => {
      e.formatter.toggle("fontsize", { value: Z8(e, n) }), e.nodeChanged();
    }, mI = (e) => OE(e, (n) => cI(e.getBody(), n.dom)).getOr(""), q8 = (e) => OE(e, (n) => {
      const o = be.fromDom(e.getBody()), r = Ev(n, (u) => gd(u, "line-height"), Ct(Is, o)), c = () => {
        const u = parseFloat(Gr(n, "line-height")), m = parseFloat(Gr(n, "font-size"));
        return String(u / m);
      };
      return r.getOrThunk(c);
    }).getOr(""), gI = (e, n) => {
      e.formatter.toggle("lineheight", { value: String(n) }), e.nodeChanged();
    }, G8 = (e) => {
      const n = (o, r) => {
        e.formatter.toggle(o, r), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => {
          n(o);
        },
        "ForeColor,HiliteColor": (o, r, c) => {
          n(o, { value: c });
        },
        BackColor: (o, r, c) => {
          n("hilitecolor", { value: c });
        },
        FontName: (o, r, c) => {
          dI(e, c);
        },
        FontSize: (o, r, c) => {
          fI(e, c);
        },
        LineHeight: (o, r, c) => {
          gI(e, c);
        },
        Lang: (o, r, c) => {
          n(o, {
            value: c.code,
            customValue: c.customCode
          });
        },
        RemoveFormat: (o) => {
          e.formatter.remove(o);
        },
        mceBlockQuote: () => {
          n("blockquote");
        },
        FormatBlock: (o, r, c) => {
          n(ie(c) ? c : "p");
        },
        mceToggleFormat: (o, r, c) => {
          n(c);
        }
      });
    }, pI = (e) => {
      const n = (o) => e.formatter.match(o);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => n(o),
        mceBlockQuote: () => n("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => DE(e)), e.editorCommands.addQueryValueHandler("FontSize", () => mI(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => q8(e));
    }, RE = (e) => {
      G8(e), pI(e);
    }, hI = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, yI = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          _L(e);
        },
        Outdent: () => {
          Q6(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => G6(e) }, "state");
    }, bI = (e) => {
      const n = (o, r, c) => {
        const u = ie(c) ? { href: c } : c, m = e.dom.getParent(e.selection.getNode(), "a");
        dn(u) && ie(u.href) && (u.href = u.href.replace(/ /g, "%20"), (!m || !u.href) && e.formatter.remove("link"), u.href && e.formatter.apply("link", u, m));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isCollapsed()) {
            const o = e.dom.getParent(e.selection.getStart(), "a");
            o && e.dom.remove(o, !0);
            return;
          }
          e.formatter.remove("link");
        },
        mceInsertLink: n,
        createLink: n
      });
    }, vI = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (n) => {
          e.getDoc().execCommand(n);
          const o = e.dom.getParent(e.selection.getNode(), "ol,ul");
          if (o) {
            const r = o.parentNode;
            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(r.nodeName)) {
              const c = e.selection.getBookmark();
              e.dom.split(r, o), e.selection.moveToBookmark(c);
            }
          }
        }
      });
    }, K8 = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (n) => {
          const o = e.dom.getParent(e.selection.getNode(), "ul,ol");
          return o && (n === "insertunorderedlist" && o.tagName === "UL" || n === "insertorderedlist" && o.tagName === "OL");
        }
      }, "state");
    }, ME = (e) => {
      vI(e), K8(e);
    }, Y8 = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          iy(bD, e);
        },
        mceInsertNewLine: (n, o, r) => {
          SD(e, r);
        },
        InsertLineBreak: (n, o, r) => {
          iy(wD, e);
        }
      });
    }, NE = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (n, o, r) => {
          let c = 0;
          e.dom.getParent(e.selection.getNode(), (u) => {
            if (u.nodeType === 1 && c++ === r)
              return e.selection.select(u), !1;
          }, e.getBody());
        },
        mceSelectNode: (n, o, r) => {
          e.selection.select(r);
        },
        selectAll: () => {
          const n = e.dom.getParent(e.selection.getStart(), Zl);
          if (n) {
            const o = e.dom.createRng();
            o.selectNodeContents(n), e.selection.setRng(o);
          }
        }
      });
    }, kI = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (n, o, r) => {
          const c = r != null ? r : e.selection.getNode();
          if (c !== e.getBody()) {
            const u = e.selection.getBookmark();
            e.dom.remove(c, !0), e.selection.moveToBookmark(u);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (n, o, r) => {
          uv(e, r);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, YL = (e) => {
      nI(e), oI(e), hI(e), NE(e), Dp(e), bI(e), yI(e), Y8(e), ME(e), RE(e), kI(e);
    };
    class wI {
      constructor(n) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = n;
      }
      execCommand(n, o, r, c) {
        const u = this.editor, m = n.toLowerCase(), y = c == null ? void 0 : c.skip_focus;
        if (u.removed || (m !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(m) && !y ? u.focus() : gs(u)), u.dispatch("BeforeExecCommand", {
          command: n,
          ui: o,
          value: r
        }).isDefaultPrevented()))
          return !1;
        const x = this.commands.exec[m];
        return wn(x) ? (x(m, o, r), u.dispatch("ExecCommand", {
          command: n,
          ui: o,
          value: r
        }), !0) : !1;
      }
      queryCommandState(n) {
        if (this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const o = n.toLowerCase(), r = this.commands.state[o];
        return wn(r) ? r(o) : !1;
      }
      queryCommandValue(n) {
        if (this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const o = n.toLowerCase(), r = this.commands.value[o];
        return wn(r) ? r(o) : "";
      }
      addCommands(n, o = "exec") {
        const r = this.commands;
        Jt(n, (c, u) => {
          X(u.toLowerCase().split(","), (m) => {
            r[o][m] = c;
          });
        });
      }
      addCommand(n, o, r) {
        const c = n.toLowerCase();
        this.commands.exec[c] = (u, m, y) => o.call(r != null ? r : this.editor, m, y);
      }
      queryCommandSupported(n) {
        const o = n.toLowerCase();
        return !!this.commands.exec[o];
      }
      addQueryStateHandler(n, o, r) {
        this.commands.state[n.toLowerCase()] = () => o.call(r != null ? r : this.editor);
      }
      addQueryValueHandler(n, o, r) {
        this.commands.value[n.toLowerCase()] = () => o.call(r != null ? r : this.editor);
      }
    }
    const hy = "data-mce-contenteditable", X8 = (e, n, o) => {
      Bu(e, n) && o === !1 ? Nu(e, n) : o && jl(e, n);
    }, BE = (e, n, o) => {
      try {
        e.getDoc().execCommand(n, !1, String(o));
      } catch {
      }
    }, SC = (e, n) => {
      e.dom.contentEditable = n ? "true" : "false";
    }, _I = (e) => {
      X(ia(e, '*[contenteditable="true"]'), (n) => {
        ms(n, hy, "true"), SC(n, !1);
      });
    }, XL = (e) => {
      X(ia(e, `*[${hy}="true"]`), (n) => {
        $r(n, hy), SC(n, !0);
      });
    }, JL = (e) => {
      O.from(e.selection.getNode()).each((n) => {
        n.removeAttribute("data-mce-selected");
      });
    }, J8 = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, Q8 = (e, n) => {
      const o = be.fromDom(e.getBody());
      X8(o, "mce-content-readonly", n), n ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), JL(e), e.readonly = !0, SC(o, !1), _I(o)) : (e.readonly = !1, SC(o, !0), XL(o), BE(e, "StyleWithCSS", !1), BE(e, "enableInlineTableEditing", !1), BE(e, "enableObjectResizing", !1), gl(e) && e.focus(), J8(e), e.nodeChanged());
    }, yy = (e) => e.readonly, e7 = (e) => {
      e.parser.addAttributeFilter("contenteditable", (n) => {
        yy(e) && X(n, (o) => {
          o.attr(hy, o.attr("contenteditable")), o.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(hy, (n) => {
        yy(e) && X(n, (o) => {
          o.attr("contenteditable", o.attr(hy));
        });
      }), e.serializer.addTempAttr(hy);
    }, CI = (e) => {
      e.serializer ? e7(e) : e.on("PreInit", () => {
        e7(e);
      });
    }, QL = (e) => e.type === "click", eH = ["copy"], tH = (e) => Ae(eH, e.type), SI = (e, n) => Js(n, "a", (r) => Is(r, be.fromDom(e.getBody()))).bind((r) => _l(r, "href")), nH = (e, n) => {
      if (QL(n) && !Tn.metaKeyPressed(n)) {
        const o = be.fromDom(n.target);
        SI(e, o).each((r) => {
          if (n.preventDefault(), /^#/.test(r)) {
            const c = e.dom.select(`${r},[name="${on(r, "#")}"]`);
            c.length && e.selection.scrollIntoView(c[0], !0);
          } else
            window.open(r, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else
        tH(n) && e.dispatch(n.type, n);
    }, xI = (e) => {
      e.on("ShowCaret", (n) => {
        yy(e) && n.preventDefault();
      }), e.on("ObjectSelected", (n) => {
        yy(e) && n.preventDefault();
      });
    }, by = it.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class Dk {
      constructor(n) {
        this.bindings = {}, this.settings = n || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || Mn;
      }
      static isNative(n) {
        return !!by[n.toLowerCase()];
      }
      fire(n, o) {
        return this.dispatch(n, o);
      }
      dispatch(n, o) {
        const r = n.toLowerCase(), c = Ef(r, o != null ? o : {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(c);
        const u = this.bindings[r];
        if (u)
          for (let m = 0, y = u.length; m < y; m++) {
            const v = u[m];
            if (!v.removed) {
              if (v.once && this.off(r, v.func), c.isImmediatePropagationStopped())
                return c;
              if (v.func.call(this.scope, c) === !1)
                return c.preventDefault(), c;
            }
          }
        return c;
      }
      on(n, o, r, c) {
        if (o === !1 && (o = Mn), o) {
          const u = {
            func: o,
            removed: !1
          };
          c && it.extend(u, c);
          const m = n.toLowerCase().split(" ");
          let y = m.length;
          for (; y--; ) {
            const v = m[y];
            let x = this.bindings[v];
            x || (x = [], this.toggleEvent(v, !0)), r ? x = [
              u,
              ...x
            ] : x = [
              ...x,
              u
            ], this.bindings[v] = x;
          }
        }
        return this;
      }
      off(n, o) {
        if (n) {
          const r = n.toLowerCase().split(" ");
          let c = r.length;
          for (; c--; ) {
            const u = r[c];
            let m = this.bindings[u];
            if (!u)
              return Jt(this.bindings, (y, v) => {
                this.toggleEvent(v, !1), delete this.bindings[v];
              }), this;
            if (m) {
              if (!o)
                m.length = 0;
              else {
                const y = ke(m, (v) => v.func === o);
                m = y.fail, this.bindings[u] = m, X(y.pass, (v) => {
                  v.removed = !0;
                });
              }
              m.length || (this.toggleEvent(n, !1), delete this.bindings[u]);
            }
          }
        } else
          Jt(this.bindings, (r, c) => {
            this.toggleEvent(c, !1);
          }), this.bindings = {};
        return this;
      }
      once(n, o, r) {
        return this.on(n, o, r, { once: !0 });
      }
      has(n) {
        return n = n.toLowerCase(), !(!this.bindings[n] || this.bindings[n].length === 0);
      }
    }
    const Rp = (e) => (e._eventDispatcher || (e._eventDispatcher = new Dk({
      scope: e,
      toggleEvent: (n, o) => {
        Dk.isNative(n) && e.toggleNativeEvent && e.toggleNativeEvent(n, o);
      }
    })), e._eventDispatcher), xC = {
      fire(e, n, o) {
        return this.dispatch(e, n, o);
      },
      dispatch(e, n, o) {
        const r = this;
        if (r.removed && e !== "remove" && e !== "detach")
          return Ef(e.toLowerCase(), n != null ? n : {}, r);
        const c = Rp(r).dispatch(e, n);
        if (o !== !1 && r.parent) {
          let u = r.parent();
          for (; u && !c.isPropagationStopped(); )
            u.dispatch(e, c, !1), u = u.parent();
        }
        return c;
      },
      on(e, n, o) {
        return Rp(this).on(e, n, o);
      },
      off(e, n) {
        return Rp(this).off(e, n);
      },
      once(e, n) {
        return Rp(this).once(e, n);
      },
      hasEventListeners(e) {
        return Rp(this).has(e);
      }
    }, Rk = Ks.DOM;
    let Mp;
    const TC = (e, n) => {
      if (n === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(n))
        return e.getDoc().documentElement;
      const o = Xu(e);
      return o ? (e.eventRoot || (e.eventRoot = Rk.select(o)[0]), e.eventRoot) : e.getBody();
    }, TI = (e) => !e.hidden && !yy(e), t7 = (e, n, o) => {
      TI(e) ? e.dispatch(n, o) : yy(e) && nH(e, o);
    }, n7 = (e, n) => {
      let o;
      if (e.delegates || (e.delegates = {}), e.delegates[n] || e.removed)
        return;
      const r = TC(e, n);
      if (Xu(e)) {
        if (Mp || (Mp = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || Mp && (Jt(Mp, (c, u) => {
            e.dom.unbind(TC(e, u));
          }), Mp = null);
        })), Mp[n])
          return;
        o = (c) => {
          const u = c.target, m = e.editorManager.get();
          let y = m.length;
          for (; y--; ) {
            const v = m[y].getBody();
            (v === u || Rk.isChildOf(u, v)) && t7(m[y], n, c);
          }
        }, Mp[n] = o, Rk.bind(r, n, o);
      } else
        o = (c) => {
          t7(e, n, c);
        }, Rk.bind(r, n, o), e.delegates[n] = o;
    }, Np = {
      ...xC,
      bindPendingEventDelegates() {
        const e = this;
        it.each(e._pendingNativeEvents, (n) => {
          n7(e, n);
        });
      },
      toggleNativeEvent(e, n) {
        const o = this;
        e === "focus" || e === "blur" || o.removed || (n ? o.initialized ? n7(o, e) : o._pendingNativeEvents ? o._pendingNativeEvents.push(e) : o._pendingNativeEvents = [e] : o.initialized && (o.dom.unbind(TC(o, e), e, o.delegates[e]), delete o.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, n = e.getBody(), o = e.dom;
        e.delegates && (Jt(e.delegates, (r, c) => {
          e.dom.unbind(TC(e, c), c, r);
        }), delete e.delegates), !e.inline && n && o && (n.onload = null, o.unbind(e.getWin()), o.unbind(e.getDoc())), o && (o.unbind(n), o.unbind(e.getContainer()));
      }
    }, EI = (e) => ie(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : Ot(e, ie) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, o7 = (e) => {
      const n = (() => {
        switch (e) {
          case "array":
            return Re;
          case "boolean":
            return Je;
          case "function":
            return wn;
          case "number":
            return ft;
          case "object":
            return dn;
          case "string":
            return ie;
          case "string[]":
            return EI;
          case "object[]":
            return (o) => Ot(o, dn);
          case "regexp":
            return (o) => Ue(o, RegExp);
        }
      })();
      return (o) => $E(o, n, `The value must be a ${e}.`);
    }, AI = (e) => ie(e.processor), Mk = (e, n) => {
      const o = fs(n.message) ? "" : `. ${n.message}`;
      return e + o;
    }, s7 = (e) => e.valid, $E = (e, n, o = "") => {
      const r = n(e);
      return Je(r) ? r ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: o
      } : r;
    }, zI = (e, n, o) => {
      if (!rt(n)) {
        const r = $E(n, o);
        if (s7(r))
          return r.value;
        console.error(Mk(`Invalid default value passed for the "${e}" option`, r));
      }
    }, r7 = (e, n) => {
      const o = {}, r = {}, c = (F, W, K) => {
        const ee = $E(W, K);
        return s7(ee) ? (r[F] = ee.value, !0) : (console.warn(Mk(`Invalid value passed for the ${F} option`, ee)), !1);
      }, u = (F, W) => {
        const K = AI(W) ? o7(W.processor) : W.processor, ee = zI(F, W.default, K);
        o[F] = {
          ...W,
          default: ee,
          processor: K
        }, Xo(r, F).orThunk(() => Xo(n, F)).each((te) => c(F, te, K));
      }, m = (F) => Gn(o, F);
      return {
        register: u,
        isRegistered: m,
        get: (F) => Xo(r, F).orThunk(() => Xo(o, F).map((W) => W.default)).getOrUndefined(),
        set: (F, W) => {
          if (m(F)) {
            const K = o[F];
            return K.immutable ? (console.error(`"${F}" is an immutable option and cannot be updated`), !1) : c(F, W, K.processor);
          } else
            return console.warn(`"${F}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (F) => {
          const W = m(F);
          return W && delete r[F], W;
        },
        isSet: (F) => Gn(r, F)
      };
    }, OI = [
      "design",
      "readonly"
    ], a7 = (e, n, o, r) => {
      const c = o[n.get()], u = o[r];
      try {
        u.activate();
      } catch (m) {
        console.error(`problem while activating editor mode ${r}:`, m);
        return;
      }
      c.deactivate(), c.editorReadOnly !== u.editorReadOnly && Q8(e, u.editorReadOnly), n.set(r), np(e, r);
    }, DI = (e, n, o, r) => {
      if (r !== o.get()) {
        if (!Gn(n, r))
          throw new Error(`Editor mode '${r}' is invalid`);
        e.initialized ? a7(e, o, n, r) : e.on("init", () => a7(e, o, n, r));
      }
    }, RI = (e, n, o) => {
      if (Ae(OI, n))
        throw new Error(`Cannot override default mode ${n}`);
      return {
        ...e,
        [n]: {
          ...o,
          deactivate: () => {
            try {
              o.deactivate();
            } catch (r) {
              console.error(`problem while deactivating editor mode ${n}:`, r);
            }
          }
        }
      };
    }, PE = (e) => {
      const n = ka("design"), o = ka({
        design: {
          activate: Se,
          deactivate: Se,
          editorReadOnly: !1
        },
        readonly: {
          activate: Se,
          deactivate: Se,
          editorReadOnly: !0
        }
      });
      return CI(e), xI(e), {
        isReadOnly: () => yy(e),
        set: (r) => DI(e, o.get(), n, r),
        get: () => n.get(),
        register: (r, c) => {
          o.set(RI(o.get(), r, c));
        }
      };
    }, FE = it.each, IE = it.explode, Da = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, c7 = it.makeMap("alt,ctrl,shift,meta,access"), MI = (e) => {
      let n;
      const o = {}, r = Qt.os.isMacOS() || Qt.os.isiOS();
      FE(IE(e.toLowerCase(), "+"), (u) => {
        u in c7 ? o[u] = !0 : /^[0-9]{2,}$/.test(u) ? o.keyCode = parseInt(u, 10) : (o.charCode = u.charCodeAt(0), o.keyCode = Da[u] || u.toUpperCase().charCodeAt(0));
      });
      const c = [o.keyCode];
      for (n in c7)
        o[n] ? c.push(n) : o[n] = !1;
      return o.id = c.join(","), o.access && (o.alt = !0, r ? o.ctrl = !0 : o.shift = !0), o.meta && (r ? o.meta = !0 : (o.ctrl = !0, o.meta = !1)), o;
    };
    class LE {
      constructor(n) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = n;
        const o = this;
        n.on("keyup keypress keydown", (r) => {
          (o.hasModifier(r) || o.isFunctionKey(r)) && !r.isDefaultPrevented() && (FE(o.shortcuts, (c) => {
            if (o.matchShortcut(r, c))
              return o.pendingPatterns = c.subpatterns.slice(0), r.type === "keydown" && o.executeShortcutAction(c), !0;
          }), o.matchShortcut(r, o.pendingPatterns[0]) && (o.pendingPatterns.length === 1 && r.type === "keydown" && o.executeShortcutAction(o.pendingPatterns[0]), o.pendingPatterns.shift()));
        });
      }
      add(n, o, r, c) {
        const u = this, m = u.normalizeCommandFunc(r);
        return FE(IE(it.trim(n)), (y) => {
          const v = u.createShortcut(y, o, m, c);
          u.shortcuts[v.id] = v;
        }), !0;
      }
      remove(n) {
        const o = this.createShortcut(n);
        return this.shortcuts[o.id] ? (delete this.shortcuts[o.id], !0) : !1;
      }
      normalizeCommandFunc(n) {
        const o = this, r = n;
        return typeof r == "string" ? () => {
          o.editor.execCommand(r, !1, null);
        } : it.isArray(r) ? () => {
          o.editor.execCommand(r[0], r[1], r[2]);
        } : r;
      }
      createShortcut(n, o, r, c) {
        const u = it.map(IE(n, ">"), MI);
        return u[u.length - 1] = it.extend(u[u.length - 1], {
          func: r,
          scope: c || this.editor
        }), it.extend(u[0], {
          desc: this.editor.translate(o),
          subpatterns: u.slice(1)
        });
      }
      hasModifier(n) {
        return n.altKey || n.ctrlKey || n.metaKey;
      }
      isFunctionKey(n) {
        return n.type === "keydown" && n.keyCode >= 112 && n.keyCode <= 123;
      }
      matchShortcut(n, o) {
        return !o || o.ctrl !== n.ctrlKey || o.meta !== n.metaKey || o.alt !== n.altKey || o.shift !== n.shiftKey ? !1 : n.keyCode === o.keyCode || n.charCode && n.charCode === o.charCode ? (n.preventDefault(), !0) : !1;
      }
      executeShortcutAction(n) {
        return n.func ? n.func.call(n.scope) : null;
      }
    }
    const l7 = () => {
      const e = {}, n = {}, o = {}, r = {}, c = {}, u = {}, m = {}, y = (x, R) => (F, W) => x[F.toLowerCase()] = {
        ...W,
        type: R
      }, v = (x, R) => r[x.toLowerCase()] = R;
      return {
        addButton: y(e, "button"),
        addGroupToolbarButton: y(e, "grouptoolbarbutton"),
        addToggleButton: y(e, "togglebutton"),
        addMenuButton: y(e, "menubutton"),
        addSplitButton: y(e, "splitbutton"),
        addMenuItem: y(n, "menuitem"),
        addNestedMenuItem: y(n, "nestedmenuitem"),
        addToggleMenuItem: y(n, "togglemenuitem"),
        addAutocompleter: y(o, "autocompleter"),
        addContextMenu: y(c, "contextmenu"),
        addContextToolbar: y(u, "contexttoolbar"),
        addContextForm: y(u, "contextform"),
        addSidebar: y(m, "sidebar"),
        addIcon: v,
        getAll: () => ({
          buttons: e,
          menuItems: n,
          icons: r,
          popups: o,
          contextMenus: c,
          contextToolbars: u,
          sidebars: m
        })
      };
    }, HE = () => {
      const e = l7();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        getAll: e.getAll
      };
    }, vy = Ks.DOM, i7 = it.extend, NI = it.each;
    class EC {
      constructor(n, o, r) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.editorManager = r, this.documentBaseUrl = r.documentBaseURL, i7(this, Np);
        const c = this;
        this.id = n, this.hidden = !1;
        const u = tg(r.defaultOptions, o);
        this.options = r7(c, u), Q1(c);
        const m = this.options.get;
        m("deprecation_warnings") && xN(o, u);
        const y = m("suffix");
        y && (r.suffix = y), this.suffix = r.suffix;
        const v = m("base_url");
        v && r._setBaseUrl(v), this.baseUri = r.baseURI;
        const x = o0(c);
        x && (Yl.ScriptLoader._setReferrerPolicy(x), Ks.DOM.styleSheetLoader._setReferrerPolicy(x)), Dc.languageLoad = m("language_load"), Dc.baseURL = r.baseURL, this.setDirty(!1), this.documentBaseURI = new ad(pw(c), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = mh(c), this.shortcuts = new LE(this), this.editorCommands = new wI(this), YL(this);
        const R = m("cache_suffix");
        R && (Qt.cacheSuffix = R.replace(/^[\?\&]+/, "")), this.ui = {
          registry: HE(),
          styleSheetLoader: void 0,
          show: Se,
          hide: Se,
          setEnabled: Se,
          isEnabled: Xe
        }, this.mode = PE(c), r.dispatch("SetupEditor", { editor: this });
        const F = vS(c);
        wn(F) && F.call(c, c);
      }
      render() {
        X9(this);
      }
      focus(n) {
        this.execCommand("mceFocus", !1, n);
      }
      hasFocus() {
        return xr(this);
      }
      translate(n) {
        return Dl.translate(n);
      }
      getParam(n, o, r) {
        const c = this.options;
        return c.isRegistered(n) || (Q(r) ? c.register(n, {
          processor: r,
          default: o
        }) : c.register(n, {
          processor: Xe,
          default: o
        })), !c.isSet(n) && !rt(o) ? o : c.get(n);
      }
      hasPlugin(n, o) {
        return Ae(pu(this), n) ? o ? c1.get(n) !== void 0 : !0 : !1;
      }
      nodeChanged(n) {
        this._nodeChangeDispatcher.nodeChanged(n);
      }
      addCommand(n, o, r) {
        this.editorCommands.addCommand(n, o, r);
      }
      addQueryStateHandler(n, o, r) {
        this.editorCommands.addQueryStateHandler(n, o, r);
      }
      addQueryValueHandler(n, o, r) {
        this.editorCommands.addQueryValueHandler(n, o, r);
      }
      addShortcut(n, o, r, c) {
        this.shortcuts.add(n, o, r, c);
      }
      execCommand(n, o, r, c) {
        return this.editorCommands.execCommand(n, o, r, c);
      }
      queryCommandState(n) {
        return this.editorCommands.queryCommandState(n);
      }
      queryCommandValue(n) {
        return this.editorCommands.queryCommandValue(n);
      }
      queryCommandSupported(n) {
        return this.editorCommands.queryCommandSupported(n);
      }
      show() {
        const n = this;
        n.hidden && (n.hidden = !1, n.inline ? n.getBody().contentEditable = "true" : (vy.show(n.getContainer()), vy.hide(n.id)), n.load(), n.dispatch("show"));
      }
      hide() {
        const n = this;
        n.hidden || (n.save(), n.inline ? (n.getBody().contentEditable = "false", n === n.editorManager.focusedEditor && (n.editorManager.focusedEditor = null)) : (vy.hide(n.getContainer()), vy.setStyle(n.id, "display", n.orgDisplay)), n.hidden = !0, n.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(n, o) {
        this.dispatch("ProgressState", {
          state: n,
          time: o
        });
      }
      load(n) {
        const o = this;
        let r = o.getElement(), c;
        if (o.removed)
          return "";
        if (r) {
          n = n || {}, n.load = !0;
          const u = pm(r) ? r.value : r.innerHTML;
          return c = o.setContent(u, n), n.element = r, n.no_events || o.dispatch("LoadContent", n), n.element = r = null, c;
        }
      }
      save(n) {
        const o = this;
        let r = o.getElement(), c, u;
        if (!(!r || !o.initialized || o.removed))
          return n = n || {}, n.save = !0, n.element = r, c = n.content = o.getContent(n), n.no_events || o.dispatch("SaveContent", n), n.format === "raw" && o.dispatch("RawSaveContent", n), c = n.content, pm(r) ? r.value = c : ((n.is_removing || !o.inline) && (r.innerHTML = c), (u = vy.getParent(o.id, "form")) && NI(u.elements, (m) => {
            if (m.name === o.id)
              return m.value = c, !1;
          })), n.element = r = null, n.set_dirty !== !1 && o.setDirty(!1), c;
      }
      setContent(n, o) {
        return Vz(this, n, o);
      }
      getContent(n) {
        return dT(this, n);
      }
      insertContent(n, o) {
        o && (n = i7({ content: n }, o)), this.execCommand("mceInsertContent", !1, n);
      }
      resetContent(n) {
        n === void 0 ? Vz(this, this.startContent, { format: "raw" }) : Vz(this, n), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(n) {
        const o = !this.isNotDirty;
        this.isNotDirty = !n, n && n !== o && this.dispatch("dirty");
      }
      getContainer() {
        const n = this;
        return n.container || (n.container = vy.get(n.editorContainer || n.id + "_parent")), n.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = vy.get(this.id)), this.targetElm;
      }
      getWin() {
        const n = this;
        let o;
        return n.contentWindow || (o = n.iframeElement, o && (n.contentWindow = o.contentWindow)), n.contentWindow;
      }
      getDoc() {
        const n = this;
        let o;
        return n.contentDocument || (o = n.getWin(), o && (n.contentDocument = o.document)), n.contentDocument;
      }
      getBody() {
        const n = this.getDoc();
        return this.bodyElement || (n ? n.body : null);
      }
      convertURL(n, o, r) {
        const c = this, u = c.options.get, m = i0(c);
        return wn(m) ? m.call(c, n, r, !0, o) : !u("convert_urls") || r && r.nodeName === "LINK" || n.indexOf("file:") === 0 || n.length === 0 ? n : u("relative_urls") ? c.documentBaseURI.toRelative(n) : (n = c.documentBaseURI.toAbsolute(n, u("remove_script_host")), n);
      }
      addVisual(n) {
        CC(this, n);
      }
      remove() {
        Gd(this);
      }
      destroy(n) {
        Wz(this, n);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const C1 = Ks.DOM, AC = it.each;
    let u7 = !1, ng, ga = [];
    const zC = (e) => {
      const n = e.type;
      AC(Bp.get(), (o) => {
        switch (n) {
          case "scroll":
            o.dispatch("ScrollWindow", e);
            break;
          case "resize":
            o.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, d7 = (e) => {
      if (e !== u7) {
        const n = Ks.DOM;
        e ? (n.bind(window, "resize", zC), n.bind(window, "scroll", zC)) : (n.unbind(window, "resize", zC), n.unbind(window, "scroll", zC)), u7 = e;
      }
    }, f7 = (e) => {
      const n = ga;
      return ga = ue(ga, (o) => e !== o), Bp.activeEditor === e && (Bp.activeEditor = ga.length > 0 ? ga[0] : null), Bp.focusedEditor === e && (Bp.focusedEditor = null), n.length !== ga.length;
    }, BI = (e) => (e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (f7(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0, e = null), e), $I = document.compatMode !== "CSS1Compat", Bp = {
      ...xC,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "6",
      minorVersion: "1.2",
      releaseDate: "2022-07-29",
      i18n: Dl,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let n, o, r = "";
        o = ad.getDocumentBaseUrl(document.location), /^[^:]+:\/\/\/?[^\/]+\//.test(o) && (o = o.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(o) || (o += "/"));
        const c = window.tinymce || window.tinyMCEPreInit;
        if (c)
          n = c.base || c.baseURL, r = c.suffix;
        else {
          const u = document.getElementsByTagName("script");
          for (let m = 0; m < u.length; m++) {
            const y = u[m].src || "";
            if (y === "")
              continue;
            const v = y.substring(y.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(y)) {
              v.indexOf(".min") !== -1 && (r = ".min"), n = y.substring(0, y.lastIndexOf("/"));
              break;
            }
          }
          if (!n && document.currentScript) {
            const m = document.currentScript.src;
            m.indexOf(".min") !== -1 && (r = ".min"), n = m.substring(0, m.lastIndexOf("/"));
          }
        }
        e.baseURL = new ad(o).toAbsolute(n), e.documentBaseURL = o, e.baseURI = new ad(e.baseURL), e.suffix = r, Ut(e);
      },
      overrideDefaults(e) {
        const n = e.base_url;
        n && this._setBaseUrl(n);
        const o = e.suffix;
        e.suffix && (this.suffix = o), this.defaultOptions = e;
        const r = e.plugin_base_urls;
        r !== void 0 && Jt(r, (c, u) => {
          Dc.PluginManager.urls[u] = c;
        });
      },
      init(e) {
        const n = this;
        let o;
        const r = it.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), c = (R, F) => R.inline && F.tagName.toLowerCase() in r, u = (R) => {
          let F = R.id;
          return F || (F = Xo(R, "name").filter((W) => !C1.get(W)).getOrThunk(C1.uniqueId), R.setAttribute("id", F)), F;
        }, m = (R) => {
          const F = e[R];
          if (!!F)
            return F.apply(n, []);
        }, y = (R) => Qt.browser.isIE() || Qt.browser.isEdge() ? (y2("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : $I ? (y2("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : ie(R.selector) ? C1.select(R.selector) : Q(R.target) ? [R.target] : [];
        let v = (R) => {
          o = R;
        };
        const x = () => {
          let R = 0;
          const F = [];
          let W;
          const K = (ee, J, te) => {
            const ve = new EC(ee, J, n);
            F.push(ve), ve.on("init", () => {
              ++R === W.length && v(F);
            }), ve.targetElm = ve.targetElm || te, ve.render();
          };
          C1.unbind(window, "ready", x), m("onpageload"), W = we(y(e)), it.each(W, (ee) => {
            BI(n.get(ee.id));
          }), W = it.grep(W, (ee) => !n.get(ee.id)), W.length === 0 ? v([]) : AC(W, (ee) => {
            c(e, ee) ? y2("Could not initialize inline editor on invalid inline target element", ee) : K(u(ee), e, ee);
          });
        };
        return C1.bind(window, "ready", x), new Promise((R) => {
          o ? R(o) : v = (F) => {
            R(F);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? ga.slice(0) : ie(e) ? Wn(ga, (n) => n.id === e).getOr(null) : ft(e) && ga[e] ? ga[e] : null;
      },
      add(e) {
        const n = this, o = n.get(e.id);
        return o === e || (o === null && ga.push(e), d7(!0), n.activeEditor = e, n.dispatch("AddEditor", { editor: e }), ng || (ng = (r) => {
          const c = n.dispatch("BeforeUnload");
          if (c.returnValue)
            return r.preventDefault(), r.returnValue = c.returnValue, c.returnValue;
        }, window.addEventListener("beforeunload", ng))), e;
      },
      createEditor(e, n) {
        return this.add(new EC(e, n, this));
      },
      remove(e) {
        const n = this;
        let o, r;
        if (!e) {
          for (o = ga.length - 1; o >= 0; o--)
            n.remove(ga[o]);
          return;
        }
        if (ie(e)) {
          AC(C1.select(e), (c) => {
            r = n.get(c.id), r && n.remove(r);
          });
          return;
        }
        return r = e, oe(n.get(r.id)) ? null : (f7(r) && n.dispatch("RemoveEditor", { editor: r }), ga.length === 0 && window.removeEventListener("beforeunload", ng), r.remove(), d7(ga.length > 0), r);
      },
      execCommand(e, n, o) {
        var r;
        const c = this, u = dn(o) ? (r = o.id) !== null && r !== void 0 ? r : o.index : o;
        switch (e) {
          case "mceAddEditor": {
            if (!c.get(u)) {
              const m = o.options;
              new EC(u, m, c).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const m = c.get(u);
            return m && m.remove(), !0;
          }
          case "mceToggleEditor": {
            const m = c.get(u);
            return m ? (m.isHidden() ? m.show() : m.hide(), !0) : (c.execCommand("mceAddEditor", !1, o), !0);
          }
        }
        return c.activeEditor ? c.activeEditor.execCommand(e, n, o) : !1;
      },
      triggerSave: () => {
        AC(ga, (e) => {
          e.save();
        });
      },
      addI18n: (e, n) => {
        Dl.add(e, n);
      },
      translate: (e) => Dl.translate(e),
      setActive(e) {
        const n = this.activeEditor;
        this.activeEditor !== e && (n && n.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: n })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new ad(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new ad(this.baseURL);
      }
    };
    Bp.setup();
    const PI = (() => {
      const e = Od(), n = (u) => ({
        items: u,
        types: $e(u),
        getType: (m) => Xo(u, m).getOrUndefined()
      }), o = (u) => {
        e.set(u);
      }, r = () => e.get().getOrUndefined(), c = e.clear;
      return {
        FakeClipboardItem: n,
        write: o,
        read: r,
        clear: c
      };
    })(), m7 = Math.min, Nk = Math.max, OC = Math.round, g7 = (e, n, o) => {
      let r = n.x, c = n.y;
      const u = e.w, m = e.h, y = n.w, v = n.h, x = (o || "").split("");
      return x[0] === "b" && (c += v), x[1] === "r" && (r += y), x[0] === "c" && (c += OC(v / 2)), x[1] === "c" && (r += OC(y / 2)), x[3] === "b" && (c -= m), x[4] === "r" && (r -= u), x[3] === "c" && (c -= OC(m / 2)), x[4] === "c" && (r -= OC(u / 2)), Bk(r, c, u, m);
    }, FI = (e, n, o, r) => {
      let c, u;
      for (u = 0; u < r.length; u++)
        if (c = g7(e, n, r[u]), c.x >= o.x && c.x + c.w <= o.w + o.x && c.y >= o.y && c.y + c.h <= o.h + o.y)
          return r[u];
      return null;
    }, II = (e, n, o) => Bk(e.x - n, e.y - o, e.w + n * 2, e.h + o * 2), LI = (e, n) => {
      const o = Nk(e.x, n.x), r = Nk(e.y, n.y), c = m7(e.x + e.w, n.x + n.w), u = m7(e.y + e.h, n.y + n.h);
      return c - o < 0 || u - r < 0 ? null : Bk(o, r, c - o, u - r);
    }, HI = (e, n, o) => {
      let r = e.x, c = e.y, u = e.x + e.w, m = e.y + e.h;
      const y = n.x + n.w, v = n.y + n.h, x = Nk(0, n.x - r), R = Nk(0, n.y - c), F = Nk(0, u - y), W = Nk(0, m - v);
      return r += x, c += R, o && (u += x, m += R, r -= F, c -= W), u -= F, m -= W, Bk(r, c, u - r, m - c);
    }, Bk = (e, n, o, r) => ({
      x: e,
      y: n,
      w: o,
      h: r
    }), VI = {
      inflate: II,
      relativePosition: g7,
      findBestRelativePosition: FI,
      intersect: LI,
      clamp: HI,
      create: Bk,
      fromClientRect: (e) => Bk(e.left, e.top, e.width, e.height)
    }, jI = (e, n, o = 1e3) => {
      let r = !1, c = null;
      const u = (x) => (...R) => {
        r || (r = !0, c !== null && (clearTimeout(c), c = null), x.apply(null, R));
      }, m = u(e), y = u(n);
      return {
        start: (...x) => {
          !r && c === null && (c = setTimeout(() => y.apply(null, x), o));
        },
        resolve: m,
        reject: y
      };
    }, UI = (() => {
      const e = {}, n = {};
      return {
        load: (u, m) => {
          const y = `Script at URL "${m}" failed to load`, v = `Script at URL "${m}" did not call \`tinymce.Resource.add('${u}', data)\` within 1 second`;
          if (e[u] !== void 0)
            return e[u];
          {
            const x = new Promise((R, F) => {
              const W = jI(R, F);
              n[u] = W.resolve, Yl.ScriptLoader.loadScript(m).then(() => W.start(v), () => W.reject(y));
            });
            return e[u] = x, x;
          }
        },
        add: (u, m) => {
          n[u] !== void 0 && (n[u](m), delete n[u]), e[u] = Promise.resolve(m);
        },
        unload: (u) => {
          delete e[u];
        }
      };
    })(), WI = () => (() => {
      let e = {}, n = [];
      const o = {
        getItem: (r) => {
          const c = e[r];
          return c || null;
        },
        setItem: (r, c) => {
          n.push(r), e[r] = String(c);
        },
        key: (r) => n[r],
        removeItem: (r) => {
          n = n.filter((c) => c === r), delete e[r];
        },
        clear: () => {
          n = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(o, "length", {
        get: () => n.length,
        configurable: !1,
        enumerable: !1
      }), o;
    })();
    let $k;
    try {
      const e = "__storage_test__";
      $k = window.localStorage, $k.setItem(e, e), $k.removeItem(e);
    } catch {
      $k = WI();
    }
    var ZI = $k;
    const qI = {
      geom: { Rect: VI },
      util: {
        Delay: ml,
        Tools: it,
        VK: Tn,
        URI: ad,
        EventDispatcher: Dk,
        Observable: xC,
        I18n: Dl,
        LocalStorage: ZI,
        ImageUploader: cy
      },
      dom: {
        EventUtils: fu,
        TreeWalker: rr,
        TextSeeker: oc,
        DOMUtils: Ks,
        ScriptLoader: Yl,
        RangeUtils: cp,
        Serializer: uT,
        StyleSheetLoader: gi,
        ControlSelection: y_,
        BookmarkManager: Oh,
        Selection: lT,
        Event: fu.Event
      },
      html: {
        Styles: kr,
        Entities: Ls,
        Node: pl,
        Schema: pi,
        DomParser: ty,
        Writer: Tx,
        Serializer: gp
      },
      Env: Qt,
      AddOnManager: Dc,
      Annotator: u_,
      Formatter: wT,
      UndoManager: xu,
      EditorCommands: wI,
      WindowManager: pT,
      NotificationManager: DN,
      EditorObservable: Np,
      Shortcuts: LE,
      Editor: EC,
      FocusManager: lv,
      EditorManager: Bp,
      DOM: Ks.DOM,
      ScriptLoader: Yl.ScriptLoader,
      PluginManager: c1,
      ThemeManager: Kd,
      ModelManager: Cp,
      IconManager: h2,
      Resource: UI,
      FakeClipboard: PI,
      trim: it.trim,
      isArray: it.isArray,
      is: it.is,
      toArray: it.toArray,
      makeMap: it.makeMap,
      each: it.each,
      map: it.map,
      grep: it.grep,
      inArray: it.inArray,
      extend: it.extend,
      walk: it.walk,
      resolve: it.resolve,
      explode: it.explode,
      _addCacheSuffix: it._addCacheSuffix
    }, p7 = it.extend(Bp, qI), GI = (e) => {
      try {
        ns.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(p7), GI(p7);
  })();
})(gH);
const JI = gH.exports;
tinymce.IconManager.add("default", {
  icons: {
    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
    browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
    copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
    help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
    italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    notice: '<svg width="24" height="24"><path d="M17.8 9.8 15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8Zm0 0 2.2 5.7-2.3-5.8ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd"/></svg>',
    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
    sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
  }
});
(function() {
  const ns = Object.getPrototypeOf, To = (t, s, a) => {
    var l;
    return a(t, s.prototype) ? !0 : ((l = t.constructor) === null || l === void 0 ? void 0 : l.name) === s.name;
  }, Eo = (t) => {
    const s = typeof t;
    return t === null ? "null" : s === "object" && Array.isArray(t) ? "array" : s === "object" && To(t, String, (a, l) => l.isPrototypeOf(a)) ? "string" : s;
  }, In = (t) => (s) => Eo(s) === t, Jn = (t) => (s) => typeof s === t, uo = (t) => (s) => t === s, ho = (t, s) => Bt(t) && To(t, s, (a, l) => ns(a) === l), Kt = In("string"), Bt = In("object"), $t = (t) => ho(t, Object), Un = In("array"), Ao = uo(null), tn = Jn("boolean"), mt = uo(void 0), an = (t) => t == null, Ge = (t) => !an(t), At = Jn("function"), He = Jn("number"), Ue = (t, s) => {
    if (Un(t)) {
      for (let a = 0, l = t.length; a < l; ++a)
        if (!s(t[a]))
          return !1;
      return !0;
    }
    return !1;
  }, ie = () => {
  }, dn = (t) => () => t(), _t = (t, s) => (...a) => t(s.apply(null, a)), Re = (t, s) => (a) => t(s(a)), oe = (t) => () => t, Je = (t) => t, rt = (t, s) => t === s;
  function lt(t, ...s) {
    return (...a) => {
      const l = s.concat(a);
      return t.apply(null, l);
    };
  }
  const Q = (t) => (s) => !t(s), wn = (t) => () => {
    throw new Error(t);
  }, ft = (t) => t(), Ot = oe(!1), Se = oe(!0);
  var Qe = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  class z {
    constructor(s, a) {
      this.tag = s, this.value = a;
    }
    static some(s) {
      return new z(!0, s);
    }
    static none() {
      return z.singletonNone;
    }
    fold(s, a) {
      return this.tag ? a(this.value) : s();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(s) {
      return this.tag ? z.some(s(this.value)) : z.none();
    }
    bind(s) {
      return this.tag ? s(this.value) : z.none();
    }
    exists(s) {
      return this.tag && s(this.value);
    }
    forall(s) {
      return !this.tag || s(this.value);
    }
    filter(s) {
      return !this.tag || s(this.value) ? this : z.none();
    }
    getOr(s) {
      return this.tag ? this.value : s;
    }
    or(s) {
      return this.tag ? this : s;
    }
    getOrThunk(s) {
      return this.tag ? this.value : s();
    }
    orThunk(s) {
      return this.tag ? this : s();
    }
    getOrDie(s) {
      if (this.tag)
        return this.value;
      throw new Error(s != null ? s : "Called getOrDie on None");
    }
    static from(s) {
      return Ge(s) ? z.some(s) : z.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(s) {
      this.tag && s(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  z.singletonNone = new z(!1);
  const Pe = Array.prototype.slice, Rt = Array.prototype.indexOf, un = Array.prototype.push, Ct = (t, s) => Rt.call(t, s), _o = (t, s) => {
    const a = Ct(t, s);
    return a === -1 ? z.none() : z.some(a);
  }, Fn = (t, s) => Ct(t, s) > -1, Sn = (t, s) => {
    for (let a = 0, l = t.length; a < l; a++) {
      const f = t[a];
      if (s(f, a))
        return !0;
    }
    return !1;
  }, Dn = (t, s) => {
    const a = [];
    for (let l = 0; l < t; l++)
      a.push(s(l));
    return a;
  }, Mn = (t, s) => {
    const a = [];
    for (let l = 0; l < t.length; l += s) {
      const f = Pe.call(t, l, l + s);
      a.push(f);
    }
    return a;
  }, Xe = (t, s) => {
    const a = t.length, l = new Array(a);
    for (let f = 0; f < a; f++) {
      const g = t[f];
      l[f] = s(g, f);
    }
    return l;
  }, O = (t, s) => {
    for (let a = 0, l = t.length; a < l; a++) {
      const f = t[a];
      s(f, a);
    }
  }, gt = (t, s) => {
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a];
      s(l, a);
    }
  }, en = (t, s) => {
    const a = [], l = [];
    for (let f = 0, g = t.length; f < g; f++) {
      const h = t[f];
      (s(h, f) ? a : l).push(h);
    }
    return {
      pass: a,
      fail: l
    };
  }, Pt = (t, s) => {
    const a = [];
    for (let l = 0, f = t.length; l < f; l++) {
      const g = t[l];
      s(g, l) && a.push(g);
    }
    return a;
  }, Ne = (t, s, a) => (gt(t, (l, f) => {
    a = s(a, l, f);
  }), a), We = (t, s, a) => (O(t, (l, f) => {
    a = s(a, l, f);
  }), a), Ae = (t, s, a) => {
    for (let l = 0, f = t.length; l < f; l++) {
      const g = t[l];
      if (s(g, l))
        return z.some(g);
      if (a(g, l))
        break;
    }
    return z.none();
  }, Oe = (t, s) => Ae(t, s, Ot), ae = (t, s) => {
    for (let a = 0, l = t.length; a < l; a++) {
      const f = t[a];
      if (s(f, a))
        return z.some(a);
    }
    return z.none();
  }, X = (t) => {
    const s = [];
    for (let a = 0, l = t.length; a < l; ++a) {
      if (!Un(t[a]))
        throw new Error("Arr.flatten item " + a + " was not an array, input: " + t);
      un.apply(s, t[a]);
    }
    return s;
  }, je = (t, s) => X(Xe(t, s)), ke = (t, s) => {
    for (let a = 0, l = t.length; a < l; ++a) {
      const f = t[a];
      if (s(f, a) !== !0)
        return !1;
    }
    return !0;
  }, ue = (t) => {
    const s = Pe.call(t, 0);
    return s.reverse(), s;
  }, ct = (t, s) => Pt(t, (a) => !Fn(s, a)), Ht = (t, s) => {
    const a = {};
    for (let l = 0, f = t.length; l < f; l++) {
      const g = t[l];
      a[String(g)] = s(g, l);
    }
    return a;
  }, vo = (t) => [t], Wn = (t, s) => {
    const a = Pe.call(t, 0);
    return a.sort(s), a;
  }, ko = (t, s) => s >= 0 && s < t.length ? z.some(t[s]) : z.none(), fo = (t) => ko(t, 0), yn = (t) => ko(t, t.length - 1), ds = At(Array.from) ? Array.from : (t) => Pe.call(t), Ho = (t, s) => {
    for (let a = 0; a < t.length; a++) {
      const l = s(t[a], a);
      if (l.isSome())
        return l;
    }
    return z.none();
  }, mn = Object.keys, Io = Object.hasOwnProperty, ro = (t, s) => {
    const a = mn(t);
    for (let l = 0, f = a.length; l < f; l++) {
      const g = a[l], h = t[g];
      s(h, g);
    }
  }, Ln = (t, s) => Go(t, (a, l) => ({
    k: l,
    v: s(a, l)
  })), Go = (t, s) => {
    const a = {};
    return ro(t, (l, f) => {
      const g = s(l, f);
      a[g.k] = g.v;
    }), a;
  }, Ro = (t) => (s, a) => {
    t[a] = s;
  }, Os = (t, s, a, l) => {
    const f = {};
    return ro(t, (g, h) => {
      (s(g, h) ? a : l)(g, h);
    }), f;
  }, Qs = (t, s) => {
    const a = {}, l = {};
    return Os(t, s, Ro(a), Ro(l)), {
      t: a,
      f: l
    };
  }, we = (t, s) => {
    const a = {};
    return Os(t, s, Ro(a), ie), a;
  }, $e = (t, s) => {
    const a = [];
    return ro(t, (l, f) => {
      a.push(s(l, f));
    }), a;
  }, Vt = (t, s) => {
    const a = mn(t);
    for (let l = 0, f = a.length; l < f; l++) {
      const g = a[l], h = t[g];
      if (s(h, g, t))
        return z.some(h);
    }
    return z.none();
  }, Jt = (t) => $e(t, Je), ht = (t, s) => qn(t, s) ? z.from(t[s]) : z.none(), qn = (t, s) => Io.call(t, s), pr = (t, s) => qn(t, s) && t[s] !== void 0 && t[s] !== null, zr = (t, s, a = rt) => t.exists((l) => a(l, s)), Zs = (t, s, a = rt) => Tr(t, s, a).getOr(t.isNone() && s.isNone()), hr = (t) => {
    const s = [], a = (l) => {
      s.push(l);
    };
    for (let l = 0; l < t.length; l++)
      t[l].each(a);
    return s;
  }, Fs = (t) => {
    const s = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (l.isSome())
        s.push(l.getOrDie());
      else
        return z.none();
    }
    return z.some(s);
  }, Tr = (t, s, a) => t.isSome() && s.isSome() ? z.some(a(t.getOrDie(), s.getOrDie())) : z.none(), Xo = (t, s, a, l) => t.isSome() && s.isSome() && a.isSome() ? z.some(l(t.getOrDie(), s.getOrDie(), a.getOrDie())) : z.none(), Gn = (t, s) => t != null ? z.some(s(t)) : z.none(), er = (t, s) => t ? z.some(s) : z.none(), Ss = (t, s) => t + s, ir = (t, s) => t.substring(s), Ka = (t, s, a) => s === "" || t.length >= s.length && t.substr(a, a + s.length) === s, Ra = (t, s) => cc(t, s) ? ir(t, s.length) : t, Ur = (t, s) => Z(t, s) ? t : Ss(t, s), rs = (t, s) => t.indexOf(s) !== -1, cc = (t, s) => Ka(t, s, 0), Z = (t, s) => Ka(t, s, t.length - s.length), Ce = ((t) => (s) => s.replace(t, ""))(/^\s+|\s+$/g), wt = (t) => t.length > 0, Rn = (t) => !wt(t), Ft = (t) => t.style !== void 0 && At(t.style.getPropertyValue), Co = (t, s) => {
    const l = (s || document).createElement("div");
    if (l.innerHTML = t, !l.hasChildNodes() || l.childNodes.length > 1) {
      const f = "HTML does not have a single root node";
      throw console.error(f, t), new Error(f);
    }
    return No(l.childNodes[0]);
  }, tr = (t, s) => {
    const l = (s || document).createElement(t);
    return No(l);
  }, Bn = (t, s) => {
    const l = (s || document).createTextNode(t);
    return No(l);
  }, No = (t) => {
    if (t == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: t };
  }, bt = {
    fromHtml: Co,
    fromTag: tr,
    fromText: Bn,
    fromDom: No,
    fromPoint: (t, s, a) => z.from(t.dom.elementFromPoint(s, a)).map(No)
  };
  typeof window < "u" || Function("return this;")();
  const se = 9, me = 11, tt = 1, Lt = 3, zt = (t) => t.dom.nodeName.toLowerCase(), Nt = (t) => t.dom.nodeType, on = (t) => (s) => Nt(s) === t, Yt = on(tt), On = on(Lt), os = on(se), $s = on(me), zo = (t) => (s) => Yt(s) && zt(s) === t, Ya = (t, s) => {
    const a = t.dom;
    if (a.nodeType !== tt)
      return !1;
    {
      const l = a;
      if (l.matches !== void 0)
        return l.matches(s);
      if (l.msMatchesSelector !== void 0)
        return l.msMatchesSelector(s);
      if (l.webkitMatchesSelector !== void 0)
        return l.webkitMatchesSelector(s);
      if (l.mozMatchesSelector !== void 0)
        return l.mozMatchesSelector(s);
      throw new Error("Browser lacks native selectors");
    }
  }, sa = (t) => t.nodeType !== tt && t.nodeType !== se && t.nodeType !== me || t.childElementCount === 0, Bo = (t, s) => {
    const a = s === void 0 ? document : s.dom;
    return sa(a) ? [] : Xe(a.querySelectorAll(t), bt.fromDom);
  }, fs = (t, s) => {
    const a = s === void 0 ? document : s.dom;
    return sa(a) ? z.none() : z.from(a.querySelector(t)).map(bt.fromDom);
  }, Lo = (t, s) => t.dom === s.dom, br = (t, s) => {
    const a = t.dom, l = s.dom;
    return a === l ? !1 : a.contains(l);
  }, Er = (t) => bt.fromDom(t.dom.ownerDocument), ra = (t) => os(t) ? t : Er(t), nl = (t) => bt.fromDom(ra(t).dom.documentElement), pa = (t) => bt.fromDom(ra(t).dom.defaultView), Wr = (t) => z.from(t.dom.parentNode).map(bt.fromDom), Ma = (t) => z.from(t.dom.parentElement).map(bt.fromDom), ci = (t) => z.from(t.dom.offsetParent).map(bt.fromDom), ol = (t) => z.from(t.dom.nextSibling).map(bt.fromDom), aa = (t) => Xe(t.dom.childNodes, bt.fromDom), Xa = (t, s) => {
    const a = t.dom.childNodes;
    return z.from(a[s]).map(bt.fromDom);
  }, kl = (t) => Xa(t, 0), Ja = (t, s) => ({
    element: t,
    offset: s
  }), li = (t, s) => {
    const a = aa(t);
    return a.length > 0 && s < a.length ? Ja(a[s], 0) : Ja(t, s);
  }, Qa = (t) => $s(t) && Ge(t.dom.host), Fc = At(Element.prototype.attachShadow) && At(Node.prototype.getRootNode), Hl = oe(Fc), or = Fc ? (t) => bt.fromDom(t.dom.getRootNode()) : ra, U = (t) => Qa(t) ? t : bt.fromDom(ra(t).dom.body), fe = (t) => _e(t).isSome(), _e = (t) => {
    const s = or(t);
    return Qa(s) ? z.some(s) : z.none();
  }, nt = (t) => bt.fromDom(t.dom.host), Et = (t) => {
    if (Hl() && Ge(t.target)) {
      const s = bt.fromDom(t.target);
      if (Yt(s) && So(s) && t.composed && t.composedPath) {
        const a = t.composedPath();
        if (a)
          return fo(a);
      }
    }
    return z.from(t.target);
  }, So = (t) => Ge(t.dom.shadowRoot), Ko = (t) => {
    const s = On(t) ? t.dom.parentNode : t.dom;
    if (s == null || s.ownerDocument === null)
      return !1;
    const a = s.ownerDocument;
    return _e(bt.fromDom(s)).fold(() => a.body.contains(s), Re(Ko, nt));
  }, js = () => Ns(bt.fromDom(document)), Ns = (t) => {
    const s = t.dom.body;
    if (s == null)
      throw new Error("Body is not available yet");
    return bt.fromDom(s);
  }, Jr = (t, s, a) => {
    if (Kt(a) || tn(a) || He(a))
      t.setAttribute(s, a + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", s, ":: Value ", a, ":: Element ", t), new Error("Attribute value was not simple");
  }, to = (t, s, a) => {
    Jr(t.dom, s, a);
  }, Ic = (t, s) => {
    const a = t.dom;
    ro(s, (l, f) => {
      Jr(a, f, l);
    });
  }, Vo = (t, s) => {
    const a = t.dom.getAttribute(s);
    return a === null ? void 0 : a;
  }, ha = (t, s) => z.from(Vo(t, s)), Vl = (t, s) => {
    const a = t.dom;
    return a && a.hasAttribute ? a.hasAttribute(s) : !1;
  }, nr = (t, s) => {
    t.dom.removeAttribute(s);
  }, ca = (t) => We(t.dom.attributes, (s, a) => (s[a.name] = a.value, s), {}), lc = (t, s, a) => {
    if (!Kt(a))
      throw console.error("Invalid call to CSS.set. Property ", s, ":: Value ", a, ":: Element ", t), new Error("CSS value must be a string: " + a);
    Ft(t) && t.style.setProperty(s, a);
  }, Lc = (t, s) => {
    Ft(t) && t.style.removeProperty(s);
  }, Qt = (t, s, a) => {
    const l = t.dom;
    lc(l, s, a);
  }, Zr = (t, s) => {
    const a = t.dom;
    ro(s, (l, f) => {
      lc(a, f, l);
    });
  }, wl = (t, s) => {
    const a = t.dom;
    ro(s, (l, f) => {
      l.fold(() => {
        Lc(a, f);
      }, (g) => {
        lc(a, f, g);
      });
    });
  }, qr = (t, s) => {
    const a = t.dom, f = window.getComputedStyle(a).getPropertyValue(s);
    return f === "" && !Ko(t) ? B(a, s) : f;
  }, B = (t, s) => Ft(t) ? t.style.getPropertyValue(s) : "", j = (t, s) => {
    const a = t.dom, l = B(a, s);
    return z.from(l).filter((f) => f.length > 0);
  }, ce = (t) => {
    const s = {}, a = t.dom;
    if (Ft(a))
      for (let l = 0; l < a.style.length; l++) {
        const f = a.style.item(l);
        s[f] = a.style[f];
      }
    return s;
  }, Fe = (t, s, a) => {
    const l = bt.fromTag(t);
    return Qt(l, s, a), j(l, s).isSome();
  }, Dt = (t, s) => {
    const a = t.dom;
    Lc(a, s), zr(ha(t, "style").map(Ce), "") && nr(t, "style");
  }, $o = (t) => t.dom.offsetWidth, Jo = (t, s) => {
    const a = (w, C) => {
      if (!He(C) && !C.match(/^[0-9]+$/))
        throw new Error(t + ".set accepts only positive integer values. Value was " + C);
      const T = w.dom;
      Ft(T) && (T.style[t] = C + "px");
    }, l = (w) => {
      const C = s(w);
      if (C <= 0 || C === null) {
        const T = qr(w, t);
        return parseFloat(T) || 0;
      }
      return C;
    }, f = l, g = (w, C) => We(C, (T, D) => {
      const $ = qr(w, D), I = $ === void 0 ? 0 : parseInt($, 10);
      return isNaN(I) ? T : T + I;
    }, 0);
    return {
      set: a,
      get: l,
      getOuter: f,
      aggregate: g,
      max: (w, C, T) => {
        const D = g(w, T);
        return C > D ? C - D : 0;
      }
    };
  }, it = Jo("height", (t) => {
    const s = t.dom;
    return Ko(t) ? s.getBoundingClientRect().height : s.offsetHeight;
  }), hs = (t) => it.get(t), Ca = (t) => it.getOuter(t), qs = (t, s) => {
    const a = [
      "margin-top",
      "border-top-width",
      "padding-top",
      "padding-bottom",
      "border-bottom-width",
      "margin-bottom"
    ], l = it.max(t, s, a);
    Qt(t, "max-height", l + "px");
  }, Hc = (t, s) => ({
    left: t,
    top: s,
    translate: (l, f) => Hc(t + l, s + f)
  }), as = Hc, G = (t) => {
    const s = t.getBoundingClientRect();
    return as(s.left, s.top);
  }, re = (t, s) => t !== void 0 ? t : s !== void 0 ? s : 0, Me = (t) => {
    const s = t.dom.ownerDocument, a = s.body, l = s.defaultView, f = s.documentElement;
    if (a === t.dom)
      return as(a.offsetLeft, a.offsetTop);
    const g = re(l == null ? void 0 : l.pageYOffset, f.scrollTop), h = re(l == null ? void 0 : l.pageXOffset, f.scrollLeft), w = re(f.clientTop, a.clientTop), C = re(f.clientLeft, a.clientLeft);
    return Ye(t).translate(h - C, g - w);
  }, Ye = (t) => {
    const s = t.dom, l = s.ownerDocument.body;
    return l === s ? as(l.offsetLeft, l.offsetTop) : Ko(t) ? G(s) : as(0, 0);
  }, bn = Jo("width", (t) => t.dom.offsetWidth), An = (t, s) => bn.set(t, s), Wo = (t) => bn.get(t), Xs = (t) => bn.getOuter(t), ic = (t, s) => {
    const a = [
      "margin-left",
      "border-left-width",
      "padding-left",
      "padding-right",
      "border-right-width",
      "margin-right"
    ], l = bn.max(t, s, a);
    Qt(t, "max-width", l + "px");
  }, Oo = (t) => {
    let s = !1, a;
    return (...l) => (s || (s = !0, a = t.apply(null, l)), a);
  }, Ps = (t, s, a, l) => {
    const f = t.isiOS() && /ipad/i.test(a) === !0, g = t.isiOS() && !f, h = t.isiOS() || t.isAndroid(), w = h || l("(pointer:coarse)"), C = f || !g && h && l("(min-device-width:768px)"), T = g || h && !C, D = s.isSafari() && t.isiOS() && /safari/i.test(a) === !1, $ = !T && !C && !D;
    return {
      isiPad: oe(f),
      isiPhone: oe(g),
      isTablet: oe(C),
      isPhone: oe(T),
      isTouch: oe(w),
      isAndroid: t.isAndroid,
      isiOS: t.isiOS,
      isWebView: oe(D),
      isDesktop: oe($)
    };
  }, uc = (t, s) => {
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (l.test(s))
        return l;
    }
  }, dc = (t, s) => {
    const a = uc(t, s);
    if (!a)
      return {
        major: 0,
        minor: 0
      };
    const l = (f) => Number(s.replace(a, "$" + f));
    return ms(l(1), l(2));
  }, su = (t, s) => {
    const a = String(s).toLowerCase();
    return t.length === 0 ? fc() : dc(t, a);
  }, fc = () => ms(0, 0), ms = (t, s) => ({
    major: t,
    minor: s
  }), ur = {
    nu: ms,
    detect: su,
    unknown: fc
  }, Na = (t, s) => Ho(s.brands, (a) => {
    const l = a.brand.toLowerCase();
    return Oe(t, (f) => {
      var g;
      return l === ((g = f.brand) === null || g === void 0 ? void 0 : g.toLowerCase());
    }).map((f) => ({
      current: f.name,
      version: ur.nu(parseInt(a.version, 10), 0)
    }));
  }), _l = (t, s) => {
    const a = String(s).toLowerCase();
    return Oe(t, (l) => l.search(a));
  }, Ni = (t, s) => _l(t, s).map((a) => {
    const l = ur.detect(a.versionRegexes, s);
    return {
      current: a.name,
      version: l
    };
  }), $r = (t, s) => _l(t, s).map((a) => {
    const l = ur.detect(a.versionRegexes, s);
    return {
      current: a.name,
      version: l
    };
  }), Cl = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Sa = (t) => (s) => rs(s, t), Mu = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (t) => rs(t, "edge/") && rs(t, "chrome") && rs(t, "safari") && rs(t, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Cl
      ],
      search: (t) => rs(t, "chrome") && !rs(t, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (t) => rs(t, "msie") || rs(t, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Cl,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Sa("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Sa("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Cl,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (t) => (rs(t, "safari") || rs(t, "mobile/")) && rs(t, "applewebkit")
    }
  ], sm = [
    {
      name: "Windows",
      search: Sa("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (t) => rs(t, "iphone") || rs(t, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Sa("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Sa("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Sa("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Sa("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Sa("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Sa("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Sl = {
    browsers: oe(Mu),
    oses: oe(sm)
  }, xl = "Edge", Bi = "Chromium", ru = "IE", Ba = "Opera", sf = "Firefox", jl = "Safari", dd = () => Nu({
    current: void 0,
    version: ur.unknown()
  }), Nu = (t) => {
    const s = t.current, a = t.version, l = (f) => () => s === f;
    return {
      current: s,
      version: a,
      isEdge: l(xl),
      isChromium: l(Bi),
      isIE: l(ru),
      isOpera: l(Ba),
      isFirefox: l(sf),
      isSafari: l(jl)
    };
  }, fd = {
    unknown: dd,
    nu: Nu,
    edge: oe(xl),
    chromium: oe(Bi),
    ie: oe(ru),
    opera: oe(Ba),
    firefox: oe(sf),
    safari: oe(jl)
  }, Bu = "Windows", Tl = "iOS", og = "Android", $u = "Linux", rf = "macOS", mc = "Solaris", af = "FreeBSD", be = "ChromeOS", Pu = () => El({
    current: void 0,
    version: ur.unknown()
  }), El = (t) => {
    const s = t.current, a = t.version, l = (f) => () => s === f;
    return {
      current: s,
      version: a,
      isWindows: l(Bu),
      isiOS: l(Tl),
      isAndroid: l(og),
      isMacOS: l(rf),
      isLinux: l($u),
      isSolaris: l(mc),
      isFreeBSD: l(af),
      isChromeOS: l(be)
    };
  }, cf = {
    unknown: Pu,
    nu: El,
    windows: oe(Bu),
    ios: oe(Tl),
    android: oe(og),
    linux: oe($u),
    macos: oe(rf),
    solaris: oe(mc),
    freebsd: oe(af),
    chromeos: oe(be)
  }, sg = { detect: (t, s, a) => {
    const l = Sl.browsers(), f = Sl.oses(), g = s.bind((C) => Na(l, C)).orThunk(() => Ni(l, t)).fold(fd.unknown, fd.nu), h = $r(f, t).fold(cf.unknown, cf.nu), w = Ps(h, g, t, a);
    return {
      browser: g,
      os: h,
      deviceType: w
    };
  } }, Is = (t) => window.matchMedia(t).matches;
  let ya = Oo(() => sg.detect(navigator.userAgent, z.from(navigator.userAgentData), Is));
  const Ul = () => ya(), ii = (t, s, a, l, f, g, h) => ({
    target: t,
    x: s,
    y: a,
    stop: l,
    prevent: f,
    kill: g,
    raw: h
  }), rm = (t) => {
    const s = bt.fromDom(Et(t).getOr(t.target)), a = () => t.stopPropagation(), l = () => t.preventDefault(), f = _t(l, a);
    return ii(s, t.clientX, t.clientY, a, l, f, t);
  }, $i = (t, s) => (a) => {
    t(a) && s(rm(a));
  }, ec = (t, s, a, l, f) => {
    const g = $i(a, l);
    return t.dom.addEventListener(s, g, f), { unbind: lt(cm, t, s, g, f) };
  }, am = (t, s, a, l) => ec(t, s, a, l, !1), rg = (t, s, a, l) => ec(t, s, a, l, !0), cm = (t, s, a, l) => {
    t.dom.removeEventListener(s, a, l);
  }, sl = (t, s) => {
    Wr(t).each((l) => {
      l.dom.insertBefore(s.dom, t.dom);
    });
  }, lf = (t, s) => {
    ol(t).fold(() => {
      Wr(t).each((f) => {
        Ec(f, s);
      });
    }, (l) => {
      sl(l, s);
    });
  }, uf = (t, s) => {
    kl(t).fold(() => {
      Ec(t, s);
    }, (l) => {
      t.dom.insertBefore(s.dom, l.dom);
    });
  }, Ec = (t, s) => {
    t.dom.appendChild(s.dom);
  }, Qr = (t, s, a) => {
    Xa(t, a).fold(() => {
      Ec(t, s);
    }, (l) => {
      sl(l, s);
    });
  }, au = (t, s) => {
    O(s, (a) => {
      Ec(t, a);
    });
  }, md = (t) => {
    t.dom.textContent = "", O(aa(t), (s) => {
      rl(s);
    });
  }, rl = (t) => {
    const s = t.dom;
    s.parentNode !== null && s.parentNode.removeChild(s);
  }, al = (t) => {
    const s = t !== void 0 ? t.dom : document, a = s.body.scrollLeft || s.documentElement.scrollLeft, l = s.body.scrollTop || s.documentElement.scrollTop;
    return as(a, l);
  }, lm = (t, s, a) => {
    const f = (a !== void 0 ? a.dom : document).defaultView;
    f && f.scrollTo(t, s);
  }, im = (t) => {
    const s = t === void 0 ? window : t;
    return Ul().browser.isFirefox() ? z.none() : z.from(s.visualViewport);
  }, df = (t, s, a, l) => ({
    x: t,
    y: s,
    width: a,
    height: l,
    right: t + a,
    bottom: s + l
  }), E = (t) => {
    const s = t === void 0 ? window : t, a = s.document, l = al(bt.fromDom(a));
    return im(s).fold(() => {
      const f = s.document.documentElement, g = f.clientWidth, h = f.clientHeight;
      return df(l.left, l.top, g, h);
    }, (f) => df(Math.max(f.pageLeft, l.left), Math.max(f.pageTop, l.top), f.width, f.height));
  }, M = () => bt.fromDom(document), H = (t, s) => t.view(s).fold(oe([]), (l) => {
    const f = t.owner(l), g = H(t, f);
    return [l].concat(g);
  }), ye = (t, s) => {
    const a = s.owner(t), l = H(s, a);
    return z.some(l);
  };
  var Yn = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view: (t) => {
      var s;
      return (t.dom === document ? z.none() : z.from((s = t.dom.defaultView) === null || s === void 0 ? void 0 : s.frameElement)).map(bt.fromDom);
    },
    owner: (t) => Er(t)
  });
  const xo = (t) => {
    const s = M(), a = al(s);
    return ye(t, Yn).fold(lt(Me, t), (f) => {
      const g = Ye(t), h = Ne(f, (w, C) => {
        const T = Ye(C);
        return {
          left: w.left + T.left,
          top: w.top + T.top
        };
      }, {
        left: 0,
        top: 0
      });
      return as(h.left + g.left + a.left, h.top + g.top + a.top);
    });
  }, Zo = (t, s, a) => ({
    point: t,
    width: s,
    height: a
  }), jo = (t, s, a, l) => ({
    x: t,
    y: s,
    width: a,
    height: l
  }), ws = (t, s, a, l) => ({
    x: t,
    y: s,
    width: a,
    height: l,
    right: t + a,
    bottom: s + l
  }), Or = (t) => {
    const s = Me(t), a = Xs(t), l = Ca(t);
    return ws(s.left, s.top, a, l);
  }, Gr = (t) => {
    const s = xo(t), a = Xs(t), l = Ca(t);
    return ws(s.left, s.top, a, l);
  }, ui = () => E(window), gd = (t) => {
    const s = (g) => g(t), a = oe(t), l = () => f, f = {
      tag: !0,
      inner: t,
      fold: (g, h) => h(t),
      isValue: Se,
      isError: Ot,
      map: (g) => yo.value(g(t)),
      mapError: l,
      bind: s,
      exists: s,
      forall: s,
      getOr: a,
      or: l,
      getOrThunk: a,
      orThunk: l,
      getOrDie: a,
      each: (g) => {
        g(t);
      },
      toOptional: () => z.some(t)
    };
    return f;
  }, Ip = (t) => {
    const s = () => a, a = {
      tag: !1,
      inner: t,
      fold: (l, f) => l(t),
      isValue: Ot,
      isError: Se,
      map: s,
      mapError: (l) => yo.error(l(t)),
      bind: s,
      exists: Ot,
      forall: Se,
      getOr: Je,
      or: Je,
      getOrThunk: ft,
      orThunk: ft,
      getOrDie: wn(String(t)),
      each: ie,
      toOptional: z.none
    };
    return a;
  }, yo = {
    value: gd,
    error: Ip,
    fromOption: (t, s) => t.fold(() => Ip(s), gd)
  };
  var Mr;
  (function(t) {
    t[t.Error = 0] = "Error", t[t.Value = 1] = "Value";
  })(Mr || (Mr = {}));
  const cl = (t, s, a) => t.stype === Mr.Error ? s(t.serror) : a(t.svalue), _y = (t) => {
    const s = [], a = [];
    return O(t, (l) => {
      cl(l, (f) => a.push(f), (f) => s.push(f));
    }), {
      values: s,
      errors: a
    };
  }, Kr = (t, s) => t.stype === Mr.Error ? {
    stype: Mr.Error,
    serror: s(t.serror)
  } : t, Cy = (t, s) => t.stype === Mr.Value ? {
    stype: Mr.Value,
    svalue: s(t.svalue)
  } : t, um = (t, s) => t.stype === Mr.Value ? s(t.svalue) : t, Fu = (t, s) => t.stype === Mr.Error ? s(t.serror) : t, ff = (t) => ({
    stype: Mr.Value,
    svalue: t
  }), Gs = (t) => ({
    stype: Mr.Error,
    serror: t
  }), vs = {
    fromResult: (t) => t.fold(Gs, ff),
    toResult: (t) => cl(t, yo.error, yo.value),
    svalue: ff,
    partition: _y,
    serror: Gs,
    bind: um,
    bindError: Fu,
    map: Cy,
    mapError: Kr,
    fold: cl
  }, ag = (t, s, a, l) => ({
    tag: "field",
    key: t,
    newKey: s,
    presence: a,
    prop: l
  }), mf = (t, s) => ({
    tag: "custom",
    newKey: t,
    instantiator: s
  }), dm = (t, s, a) => {
    switch (t.tag) {
      case "field":
        return s(t.key, t.newKey, t.presence, t.prop);
      case "custom":
        return a(t.newKey, t.instantiator);
    }
  }, Iu = (t, s) => s, cg = (t, s) => $t(t) && $t(s) ? sr(t, s) : s, Sy = (t) => (...s) => {
    if (s.length === 0)
      throw new Error("Can't merge zero objects");
    const a = {};
    for (let l = 0; l < s.length; l++) {
      const f = s[l];
      for (const g in f)
        qn(f, g) && (a[g] = t(a[g], f[g]));
    }
    return a;
  }, sr = Sy(cg), fm = Sy(Iu), di = () => ({
    tag: "required",
    process: {}
  }), gf = (t) => ({
    tag: "defaultedThunk",
    process: t
  }), Lu = (t) => gf(oe(t)), lg = () => ({
    tag: "option",
    process: {}
  }), cu = (t) => ({
    tag: "mergeWithThunk",
    process: t
  }), pf = (t) => cu(oe(t)), pd = (t, s) => t.length > 0 ? vs.svalue(sr(s, fm.apply(void 0, t))) : vs.svalue(s), Po = (t) => _t(vs.serror, X)(t), ig = {
    consolidateObj: (t, s) => {
      const a = vs.partition(t);
      return a.errors.length > 0 ? Po(a.errors) : pd(a.values, s);
    },
    consolidateArr: (t) => {
      const s = vs.partition(t);
      return s.errors.length > 0 ? Po(s.errors) : vs.svalue(s.values);
    }
  }, gm = (t) => Bt(t) && mn(t).length > 100 ? " removed due to size" : JSON.stringify(t, null, 2), Hp = (t) => {
    const s = t.length > 10 ? t.slice(0, 10).concat([{
      path: [],
      getErrorInfo: oe("... (only showing first ten failures)")
    }]) : t;
    return Xe(s, (a) => "Failed path: (" + a.path.join(" > ") + `)
` + a.getErrorInfo());
  }, fi = (t, s) => vs.serror([{
    path: t,
    getErrorInfo: s
  }]), hf = (t, s, a) => fi(t, () => 'Could not find valid *required* value for "' + s + '" in ' + gm(a)), Vn = (t, s) => fi(t, () => 'Choice schema did not contain choice key: "' + s + '"'), Wl = (t, s, a) => fi(t, () => 'The chosen schema: "' + a + '" did not exist in branches: ' + gm(s)), yf = (t, s) => fi(t, () => "There are unsupported fields: [" + s.join(", ") + "] specified"), Vp = (t, s) => fi(t, oe(s)), ll = (t) => {
    const s = (l, f) => vs.bindError(t(f), (g) => Vp(l, g)), a = oe("val");
    return {
      extract: s,
      toString: a
    };
  }, Hu = ll(vs.svalue), ug = (t, s, a, l) => ht(s, a).fold(() => hf(t, a, s), l), mi = (t, s, a, l) => {
    const f = ht(t, s).getOrThunk(() => a(t));
    return l(f);
  }, xy = (t, s, a) => a(ht(t, s)), pm = (t, s, a, l) => {
    const f = ht(t, s).map((g) => g === !0 ? a(t) : g);
    return l(f);
  }, rn = (t, s, a, l, f) => {
    const g = (w) => f.extract(s.concat([l]), w), h = (w) => w.fold(() => vs.svalue(z.none()), (C) => {
      const T = f.extract(s.concat([l]), C);
      return vs.map(T, z.some);
    });
    switch (t.tag) {
      case "required":
        return ug(s, a, l, g);
      case "defaultedThunk":
        return mi(a, l, t.process, g);
      case "option":
        return xy(a, l, h);
      case "defaultedOptionThunk":
        return pm(a, l, t.process, h);
      case "mergeWithThunk":
        return mi(a, l, oe({}), (w) => {
          const C = sr(t.process(a), w);
          return g(C);
        });
    }
  }, Ty = (t, s, a) => {
    const l = {}, f = [];
    for (const g of a)
      dm(g, (h, w, C, T) => {
        const D = rn(C, t, s, h, T);
        vs.fold(D, ($) => {
          f.push(...$);
        }, ($) => {
          l[w] = $;
        });
      }, (h, w) => {
        l[h] = w(s);
      });
    return f.length > 0 ? vs.serror(f) : vs.svalue(l);
  }, jp = (t) => ({
    extract: (l, f) => t().extract(l, f),
    toString: () => t().toString()
  }), hm = (t) => mn(we(t, Ge)), gc = (t) => {
    const s = Pn(t), a = Ne(t, (f, g) => dm(g, (h) => sr(f, { [h]: !0 }), oe(f)), {});
    return {
      extract: (f, g) => {
        const h = tn(g) ? [] : hm(g), w = Pt(h, (C) => !pr(a, C));
        return w.length === 0 ? s.extract(f, g) : yf(f, w);
      },
      toString: s.toString
    };
  }, Pn = (t) => ({
    extract: (l, f) => Ty(l, f, t),
    toString: () => {
      const l = Xe(t, (f) => dm(f, (g, h, w, C) => g + " -> " + C.toString(), (g, h) => "state(" + g + ")"));
      return `obj{
` + l.join(`
`) + "}";
    }
  }), Cr = (t) => ({
    extract: (l, f) => {
      const g = Xe(f, (h, w) => t.extract(l.concat(["[" + w + "]"]), h));
      return ig.consolidateArr(g);
    },
    toString: () => "array(" + t.toString() + ")"
  }), Up = (t) => ({
    extract: (l, f) => {
      const g = [];
      for (const h of t) {
        const w = h.extract(l, f);
        if (w.stype === Mr.Value)
          return w;
        g.push(w);
      }
      return ig.consolidateArr(g);
    },
    toString: () => "oneOf(" + Xe(t, (l) => l.toString()).join(", ") + ")"
  }), Zl = (t, s) => {
    const a = (g, h) => Cr(ll(t)).extract(g, h);
    return {
      extract: (g, h) => {
        const w = mn(h), C = a(g, w);
        return vs.bind(C, (T) => {
          const D = Xe(T, ($) => ag($, $, di(), s));
          return Pn(D).extract(g, h);
        });
      },
      toString: () => "setOf(" + s.toString() + ")"
    };
  }, Dr = (t, s) => {
    const a = Oo(s);
    return {
      extract: (g, h) => a().extract(g, h),
      toString: () => a().toString()
    };
  }, yd = _t(Cr, Pn), tc = oe(Hu), Wp = (t, s) => ll((a) => {
    const l = typeof a;
    return t(a) ? vs.svalue(a) : vs.serror(`Expected type: ${s} but got: ${l}`);
  }), Pi = Wp(He, "number"), Pr = Wp(Kt, "string"), bf = Wp(tn, "boolean"), dg = Wp(At, "function"), ym = (t) => {
    if (Object(t) !== t)
      return !0;
    switch ({}.toString.call(t).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return !0;
      case "Array":
      case "Object":
        return Object.keys(t).every((s) => ym(t[s]));
      default:
        return !1;
    }
  }, vf = ll((t) => ym(t) ? vs.svalue(t) : vs.serror("Expected value to be acceptable for sending via postMessage")), bd = (t, s, a, l) => ht(a, l).fold(() => Wl(t, a, l), (g) => g.extract(t.concat(["branch: " + l]), s)), fg = (t, s) => ({
    extract: (f, g) => ht(g, t).fold(() => Vn(f, t), (w) => bd(f, g, s, w)),
    toString: () => "chooseOn(" + t + "). Possible values: " + mn(s)
  }), x1 = () => Cr(Hu), kf = (t) => ll((s) => t(s).fold(vs.serror, vs.svalue)), vd = (t, s) => Zl((a) => vs.fromResult(t(a)), s), kd = (t, s, a) => {
    const l = s.extract([t], a);
    return vs.mapError(l, (f) => ({
      input: a,
      errors: f
    }));
  }, Js = (t, s, a) => vs.toResult(kd(t, s, a)), gi = (t) => t.fold((s) => {
    throw new Error(wd(s));
  }, Je), Vc = (t, s, a) => gi(Js(t, s, a)), wd = (t) => `Errors: 
` + Hp(t.errors).join(`
`) + `

Input object: ` + gm(t.input), rr = (t, s) => fg(t, Ln(s, Pn)), T1 = (t, s) => Dr(t, s), ba = ag, va = mf, Zp = (t) => kf((s) => Fn(t, s) ? yo.value(s) : yo.error(`Unsupported value: "${s}", choose one of "${t.join(", ")}".`)), ut = (t) => ba(t, t, di(), tc()), Ac = (t, s) => ba(t, t, di(), s), Ey = (t) => Ac(t, Pi), la = (t) => Ac(t, Pr), bm = (t, s) => ba(t, t, di(), Zp(s)), Vu = (t) => Ac(t, bf), xa = (t) => Ac(t, dg), E1 = (t, s) => ba(t, t, lg(), ll((a) => vs.serror("The field: " + t + " is forbidden. " + s))), Fi = (t, s) => ba(t, t, di(), Pn(s)), _d = (t, s) => ba(t, t, di(), yd(s)), jc = (t, s) => ba(t, t, di(), Cr(s)), xs = (t) => ba(t, t, lg(), tc()), zl = (t, s) => ba(t, t, lg(), s), wf = (t) => zl(t, Pi), pc = (t) => zl(t, Pr), vm = (t, s) => zl(t, Zp(s)), _f = (t) => zl(t, dg), mg = (t, s) => zl(t, Cr(s)), zc = (t, s) => zl(t, Pn(s)), km = (t, s) => zl(t, gc(s)), Te = (t, s) => ba(t, t, Lu(s), tc()), Uc = (t, s, a) => ba(t, t, Lu(s), a), gg = (t, s) => Uc(t, s, Pi), lu = (t, s) => Uc(t, s, Pr), ia = (t, s, a) => Uc(t, s, Zp(a)), Oc = (t, s) => Uc(t, s, bf), Fr = (t, s) => Uc(t, s, dg), Cd = (t, s) => Uc(t, s, vf), ju = (t, s, a) => Uc(t, s, Cr(a)), qp = (t, s, a) => Uc(t, s, Pn(a)), Xn = (t) => {
    let s = t;
    return {
      get: () => s,
      set: (f) => {
        s = f;
      }
    };
  }, Pa = { generate: (t) => {
    if (!Un(t))
      throw new Error("cases must be an array");
    if (t.length === 0)
      throw new Error("there must be at least one case");
    const s = [], a = {};
    return O(t, (l, f) => {
      const g = mn(l);
      if (g.length !== 1)
        throw new Error("one and only one name per case");
      const h = g[0], w = l[h];
      if (a[h] !== void 0)
        throw new Error("duplicate key detected:" + h);
      if (h === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Un(w))
        throw new Error("case arguments must be an array");
      s.push(h), a[h] = (...C) => {
        const T = C.length;
        if (T !== w.length)
          throw new Error("Wrong number of arguments to case " + h + ". Expected " + w.length + " (" + w + "), got " + T);
        return {
          fold: (...$) => {
            if ($.length !== t.length)
              throw new Error("Wrong number of arguments to fold. Expected " + t.length + ", got " + $.length);
            return $[f].apply(null, C);
          },
          match: ($) => {
            const I = mn($);
            if (s.length !== I.length)
              throw new Error("Wrong number of arguments to match. Expected: " + s.join(",") + `
Actual: ` + I.join(","));
            if (!ke(s, (ne) => Fn(I, ne)))
              throw new Error("Not all branches were specified when using match. Specified: " + I.join(", ") + `
Required: ` + s.join(", "));
            return $[h].apply(null, C);
          },
          log: ($) => {
            console.log($, {
              constructors: s,
              constructor: h,
              params: C
            });
          }
        };
      };
    }), a;
  } };
  Pa.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  const A1 = (t) => {
    const s = [], a = [];
    return O(t, (l) => {
      l.fold((f) => {
        s.push(f);
      }, (f) => {
        a.push(f);
      });
    }), {
      errors: s,
      values: a
    };
  }, k = (t, s) => {
    const a = {};
    return ro(t, (l, f) => {
      Fn(s, f) || (a[f] = l);
    }), a;
  }, S = (t, s) => ({ [t]: s }), P = (t) => {
    const s = {};
    return O(t, (a) => {
      s[a.key] = a.value;
    }), s;
  }, q = (t, s) => k(t, s), ge = (t, s) => S(t, s), Ze = (t) => P(t), St = (t, s) => t.length === 0 ? yo.value(s) : yo.value(sr(s, fm.apply(void 0, t))), jt = (t) => yo.error(X(t)), mo = (t, s) => {
    const a = A1(t);
    return a.errors.length > 0 ? jt(a.errors) : St(a.values, s);
  }, Fo = (t) => At(t) ? t : Ot, Rr = (t, s, a) => {
    let l = t.dom;
    const f = Fo(a);
    for (; l.parentNode; ) {
      l = l.parentNode;
      const g = bt.fromDom(l), h = s(g);
      if (h.isSome())
        return h;
      if (f(g))
        break;
    }
    return z.none();
  }, ks = (t, s, a) => {
    const l = s(t), f = Fo(a);
    return l.orThunk(() => f(t) ? z.none() : Rr(t, s, f));
  }, vr = (t, s) => Lo(t.element, s.event.target), hc = {
    can: Se,
    abort: Ot,
    run: ie
  }, Fa = (t) => {
    if (!pr(t, "can") && !pr(t, "abort") && !pr(t, "run"))
      throw new Error("EventHandler defined by: " + JSON.stringify(t, null, 2) + " does not have can, abort, or run!");
    return {
      ...hc,
      ...t
    };
  }, iu = (t, s) => (...a) => We(t, (l, f) => l && s(f).apply(void 0, a), !0), Ii = (t, s) => (...a) => We(t, (l, f) => l || s(f).apply(void 0, a), !1), pg = (t) => At(t) ? {
    can: Se,
    abort: Ot,
    run: t
  } : t, wm = (t) => {
    const s = iu(t, (f) => f.can), a = Ii(t, (f) => f.abort);
    return {
      can: s,
      abort: a,
      run: (...f) => {
        O(t, (g) => {
          g.run.apply(void 0, f);
        });
      }
    };
  }, Nr = oe, Wc = Nr("touchstart"), Uu = Nr("touchmove"), uu = Nr("touchend"), Cf = Nr("touchcancel"), ql = Nr("mousedown"), hg = Nr("mousemove"), Do = Nr("mouseout"), dr = Nr("mouseup"), Br = Nr("mouseover"), Ta = Nr("focusin"), z1 = Nr("focusout"), xd = Nr("keydown"), Li = Nr("keyup"), Zc = Nr("input"), Gl = Nr("change"), yg = Nr("click"), O1 = Nr("transitioncancel"), Gp = Nr("transitionend"), Hk = Nr("transitionstart"), MC = Nr("selectstart"), ea = (t) => oe("alloy." + t), NC = { tap: ea("tap") }, du = ea("focus"), D1 = ea("blur.post"), Ay = ea("paste.post"), _m = ea("receive"), Kl = ea("execute"), ta = ea("focus.item"), bg = NC.tap, Vk = ea("longpress"), zy = ea("sandbox.close"), vg = ea("typeahead.cancel"), Oy = ea("system.init"), Dy = ea("system.touchmove"), BC = ea("system.touchend"), Sf = ea("system.scroll"), Ry = ea("system.resize"), Wu = ea("system.attached"), xf = ea("system.detached"), kg = ea("system.dismissRequested"), jk = ea("system.repositionRequested"), Uk = ea("focusmanager.shifted"), Td = ea("slotcontainer.visibility"), Wk = ea("change.tab"), R1 = ea("dismiss.tab"), Kp = ea("highlight"), Yp = ea("dehighlight"), Ts = (t, s) => {
    M1(t, t.element, s, {});
  }, no = (t, s, a) => {
    M1(t, t.element, s, a);
  }, Zu = (t) => {
    Ts(t, Kl());
  }, Xp = (t, s, a) => {
    M1(t, s, a, {});
  }, M1 = (t, s, a, l) => {
    const f = {
      target: s,
      ...l
    };
    t.getSystem().triggerEvent(a, s, f);
  }, $C = (t, s, a, l) => {
    t.getSystem().triggerEvent(a, s, l.event);
  }, Ls = (t) => Ze(t), qu = (t, s) => ({
    key: t,
    value: Fa({ abort: s })
  }), PC = (t, s) => ({
    key: t,
    value: Fa({ can: s })
  }), Tf = (t) => ({
    key: t,
    value: Fa({
      run: (s, a) => {
        a.event.prevent();
      }
    })
  }), dt = (t, s) => ({
    key: t,
    value: Fa({ run: s })
  }), Jp = (t, s, a) => ({
    key: t,
    value: Fa({
      run: (l, f) => {
        s.apply(void 0, [
          l,
          f
        ].concat(a));
      }
    })
  }), Qp = (t) => (s) => dt(t, s), My = (t) => (s) => ({
    key: t,
    value: Fa({
      run: (a, l) => {
        vr(a, l) && s(a, l);
      }
    })
  }), yc = (t, s) => dt(t, (a, l) => {
    a.getSystem().getByUid(s).each((f) => {
      $C(f, f.element, t, l);
    });
  }), Ed = (t, s, a) => {
    const l = s.partUids[a];
    return yc(t, l);
  }, Ny = (t, s) => dt(t, (a, l) => {
    const f = l.event, g = a.getSystem().getByDom(f.target).getOrThunk(() => ks(f.target, (w) => a.getSystem().getByDom(w).toOptional(), Ot).getOr(a));
    s(a, g, l);
  }), Ad = (t) => dt(t, (s, a) => {
    a.cut();
  }), N1 = (t) => dt(t, (s, a) => {
    a.stop();
  }), pi = (t, s) => My(t)(s), kr = My(Wu()), Hi = My(xf()), FC = My(Oy()), zd = Qp(Kl()), IC = (t, s) => {
    const l = (s || document).createElement("div");
    return l.innerHTML = t, aa(bt.fromDom(l));
  }, eh = (t) => t.dom.innerHTML, Ef = (t, s) => {
    const l = Er(t).dom, f = bt.fromDom(l.createDocumentFragment()), g = IC(s, l);
    au(f, g), md(t), Ec(t, f);
  }, B1 = (t) => {
    const s = bt.fromTag("div"), a = bt.fromDom(t.dom.cloneNode(!0));
    return Ec(s, a), eh(s);
  }, Gu = (t, s) => bt.fromDom(t.dom.cloneNode(s)), $1 = (t) => Gu(t, !1), By = (t) => {
    if (Qa(t))
      return "#shadow-root";
    {
      const s = $1(t);
      return B1(s);
    }
  }, Af = (t) => By(t), wg = (t, s, a) => Lo(s, t.element) && !Lo(s, a), LC = Ls([PC(du(), (t, s) => {
    const a = s.event, l = a.originator, f = a.target;
    return wg(t, l, f) ? (console.warn(du() + ` did not get interpreted by the desired target. 
Originator: ` + Af(l) + `
Target: ` + Af(f) + `
Check the ` + du() + " event handlers"), !1) : !0;
  })]);
  var fu = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: LC
  });
  let th = 0;
  const $n = (t) => {
    const a = new Date().getTime(), l = Math.floor(Math.random() * 1e9);
    return th++, t + "_" + l + th + String(a);
  }, $y = oe("alloy-id-"), nh = oe("data-alloy-id"), HC = $y(), Zk = nh(), _g = (t, s) => {
    const a = $n(HC + t);
    return Cg(s, a), a;
  }, Cg = (t, s) => {
    Object.defineProperty(t.dom, Zk, {
      value: s,
      writable: !0
    });
  }, Cm = (t) => {
    const s = Yt(t) ? t.dom[Zk] : null;
    return z.from(s);
  }, Ks = (t) => $n(t), Py = Je, Fy = (t) => {
    const s = (f) => `The component must be in a context to execute: ${f}` + (t ? `
` + Af(t().element) + " is not in context." : ""), a = (f) => () => {
      throw new Error(s(f));
    }, l = (f) => () => {
      console.warn(s(f));
    };
    return {
      debugInfo: oe("fake"),
      triggerEvent: l("triggerEvent"),
      triggerFocus: l("triggerFocus"),
      triggerEscape: l("triggerEscape"),
      broadcast: l("broadcast"),
      broadcastOn: l("broadcastOn"),
      broadcastEvent: l("broadcastEvent"),
      build: a("build"),
      buildOrPatch: a("buildOrPatch"),
      addToWorld: a("addToWorld"),
      removeFromWorld: a("removeFromWorld"),
      addToGui: a("addToGui"),
      removeFromGui: a("removeFromGui"),
      getByUid: a("getByUid"),
      getByDom: a("getByDom"),
      isConnected: Ot
    };
  }, qk = Fy(), Sg = (t, s, a) => {
    const l = a.toString(), f = l.indexOf(")") + 1, g = l.indexOf("("), h = l.substring(g + 1, f - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: s,
      parameters: xg(h.slice(0, 1).concat(h.slice(3)))
    }), t;
  }, xg = (t) => Xe(t, (s) => Z(s, "/*") ? s.substring(0, s.length - 2) : s), Yl = (t, s) => {
    const a = t.toString(), l = a.indexOf(")") + 1, f = a.indexOf("("), g = a.substring(f + 1, l - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: s,
      parameters: xg(g)
    }), t;
  }, ka = (t, s) => {
    const a = s.toString(), l = a.indexOf(")") + 1, f = a.indexOf("("), g = a.substring(f + 1, l - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: "OVERRIDE",
      parameters: xg(g.slice(1))
    }), t;
  }, Iy = $n("alloy-premade"), P1 = (t) => (Object.defineProperty(t.element.dom, Iy, {
    value: t.uid,
    writable: !0
  }), ge(Iy, t)), Sm = (t) => qn(t.dom, Iy), Ly = (t) => ht(t, Iy), oh = (t) => ka((s, ...a) => t(s.getApis(), s, ...a), t), Vi = { init: () => Ol({ readState: oe("No State required") }) }, Ol = (t) => t, VC = (t, s) => {
    const a = Xe(s, (f) => zc(f.name(), [
      ut("config"),
      Te("state", Vi)
    ])), l = Js("component.behaviours", Pn(a), t.behaviours).fold((f) => {
      throw new Error(wd(f) + `
Complete spec:
` + JSON.stringify(t, null, 2));
    }, Je);
    return {
      list: s,
      data: Ln(l, (f) => {
        const g = f.map((h) => ({
          config: h.config,
          state: h.state.init(h.config)
        }));
        return oe(g);
      })
    };
  }, jC = (t) => t.list, UC = (t) => t.data, GE = (t, s) => {
    const a = {};
    return ro(t, (l, f) => {
      ro(l, (g, h) => {
        const w = ht(a, h).getOr([]);
        a[h] = w.concat([s(f, g)]);
      });
    }), a;
  }, Ku = (t) => ({
    classes: mt(t.classes) ? [] : t.classes,
    attributes: mt(t.attributes) ? {} : t.attributes,
    styles: mt(t.styles) ? {} : t.styles
  }), Dl = (t, s) => ({
    ...t,
    attributes: {
      ...t.attributes,
      ...s.attributes
    },
    styles: {
      ...t.styles,
      ...s.styles
    },
    classes: t.classes.concat(s.classes)
  }), Dc = (t, s, a, l) => {
    const f = { ...s };
    O(a, (D) => {
      f[D.name()] = D.exhibit(t, l);
    });
    const g = GE(f, (D, $) => ({
      name: D,
      modification: $
    })), h = (D) => Ne(D, ($, I) => ({
      ...I.modification,
      ...$
    }), {}), w = Ne(g.classes, (D, $) => $.modification.concat(D), []), C = h(g.attributes), T = h(g.styles);
    return Ku({
      classes: w,
      attributes: C,
      styles: T
    });
  }, Gk = (t, s, a, l) => {
    try {
      const f = Wn(a, (g, h) => {
        const w = g[s], C = h[s], T = l.indexOf(w), D = l.indexOf(C);
        if (T === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + w + `.
Order specified: ` + JSON.stringify(l, null, 2));
        if (D === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + C + `.
Order specified: ` + JSON.stringify(l, null, 2));
        return T < D ? -1 : D < T ? 1 : 0;
      });
      return yo.value(f);
    } catch (f) {
      return yo.error([f]);
    }
  }, Od = (t, s) => ({
    handler: t,
    purpose: s
  }), zf = (t, s) => ({
    cHandler: t,
    purpose: s
  }), Hy = (t, s) => zf(lt.apply(void 0, [t.handler].concat(s)), t.purpose), xm = (t) => t.cHandler, Tm = (t, s) => ({
    name: t,
    handler: s
  }), Tg = (t, s) => {
    const a = {};
    return O(t, (l) => {
      a[l.name()] = l.handlers(s);
    }), a;
  }, sh = (t, s, a) => {
    const l = {
      ...a,
      ...Tg(s, t)
    };
    return GE(l, Tm);
  }, rh = (t, s, a, l) => {
    const f = sh(t, a, l);
    return ah(f, s);
  }, Eg = (t) => {
    const s = pg(t);
    return (a, l, ...f) => {
      const g = [
        a,
        l
      ].concat(f);
      s.abort.apply(void 0, g) ? l.stop() : s.can.apply(void 0, g) && s.run.apply(void 0, g);
    };
  }, Kk = (t, s) => yo.error(["The event (" + t + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(Xe(s, (a) => a.name), null, 2)]), Yk = (t, s, a) => {
    const l = s[a];
    return l ? Gk("Event: " + a, "name", t, l).map((f) => {
      const g = Xe(f, (h) => h.handler);
      return wm(g);
    }) : Kk(a, t);
  }, ah = (t, s) => {
    const a = $e(t, (l, f) => (l.length === 1 ? yo.value(l[0].handler) : Yk(l, s, f)).map((h) => {
      const w = Eg(h), C = l.length > 1 ? Pt(s[f], (T) => Sn(l, (D) => D.name === T)).join(" > ") : l[0].name;
      return ge(f, Od(w, C));
    }));
    return mo(a, {});
  }, Of = "alloy.base.behaviour", ch = Pn([
    ba("dom", "dom", di(), Pn([
      ut("tag"),
      Te("styles", {}),
      Te("classes", []),
      Te("attributes", {}),
      xs("value"),
      xs("innerHtml")
    ])),
    ut("components"),
    ut("uid"),
    Te("events", {}),
    Te("apis", {}),
    ba("eventOrder", "eventOrder", pf({
      [Kl()]: [
        "disabling",
        Of,
        "toggling",
        "typeaheadevents"
      ],
      [du()]: [
        Of,
        "focusing",
        "keying"
      ],
      [Oy()]: [
        Of,
        "disabling",
        "toggling",
        "representing"
      ],
      [Zc()]: [
        Of,
        "representing",
        "streaming",
        "invalidating"
      ],
      [xf()]: [
        Of,
        "representing",
        "item-events",
        "tooltipping"
      ],
      [ql()]: [
        "focusing",
        Of,
        "item-type-events"
      ],
      [Wc()]: [
        "focusing",
        Of,
        "item-type-events"
      ],
      [Br()]: [
        "item-type-events",
        "tooltipping"
      ],
      [_m()]: [
        "receiving",
        "reflecting",
        "tooltipping"
      ]
    }), tc()),
    xs("domModification")
  ]), Vy = (t) => Js("custom.definition", ch, t), F1 = (t) => ({
    ...t.dom,
    uid: t.uid,
    domChildren: Xe(t.components, (s) => s.element)
  }), nc = (t) => t.domModification.fold(() => Ku({}), Ku), WC = (t) => t.events, Ag = (t, s) => {
    const a = Vo(t, s);
    return a === void 0 || a === "" ? [] : a.split(" ");
  }, Xk = (t, s, a) => {
    const f = Ag(t, s).concat([a]);
    return to(t, s, f.join(" ")), !0;
  }, ZC = (t, s, a) => {
    const l = Pt(Ag(t, s), (f) => f !== a);
    return l.length > 0 ? to(t, s, l.join(" ")) : nr(t, s), !1;
  }, hi = (t) => t.dom.classList !== void 0, mu = (t) => Ag(t, "class"), zg = (t, s) => Xk(t, "class", s), I1 = (t, s) => ZC(t, "class", s), Ea = (t, s) => {
    hi(t) ? t.dom.classList.add(s) : zg(t, s);
  }, qC = (t) => {
    (hi(t) ? t.dom.classList : mu(t)).length === 0 && nr(t, "class");
  }, Yr = (t, s) => {
    hi(t) ? t.dom.classList.remove(s) : I1(t, s), qC(t);
  }, oc = (t, s) => hi(t) && t.dom.classList.contains(s), ji = (t, s) => {
    O(s, (a) => {
      Ea(t, a);
    });
  }, qc = (t, s) => {
    O(s, (a) => {
      Yr(t, a);
    });
  }, Jk = (t, s) => ke(s, (a) => oc(t, a)), Qk = (t) => {
    const s = t.dom.classList, a = new Array(s.length);
    for (let l = 0; l < s.length; l++) {
      const f = s.item(l);
      f !== null && (a[l] = f);
    }
    return a;
  }, L1 = (t) => hi(t) ? Qk(t) : mu(t), Ui = (t) => t.dom.value, yi = (t, s) => {
    if (s === void 0)
      throw new Error("Value.set was undefined");
    t.dom.value = s;
  }, GC = (t, s, a) => Xa(t, s).map((f) => {
    if (a.exists((h) => !Lo(h, f))) {
      const h = a.map(zt).getOr("span"), w = bt.fromTag(h);
      return sl(f, w), w;
    } else
      return f;
  }), H1 = (t, s, a) => {
    a.fold(() => Ec(t, s), (l) => {
      Lo(l, s) || (sl(l, s), rl(l));
    });
  }, jy = (t, s, a) => {
    const l = Xe(s, a), f = aa(t);
    return O(f.slice(l.length), rl), l;
  }, Uy = (t, s, a, l) => {
    const f = Xa(t, s), g = l(a, f), h = GC(t, s, f);
    return H1(t, g.element, h), g;
  }, KC = (t, s, a) => jy(t, s, (l, f) => Uy(t, f, l, a)), Wy = (t, s) => jy(t, s, (a, l) => {
    const f = Xa(t, l);
    return H1(t, a, f), a;
  }), Dd = (t, s) => {
    const a = mn(t), l = mn(s), f = ct(l, a), g = Qs(t, (h, w) => !qn(s, w) || h !== s[w]).t;
    return {
      toRemove: f,
      toSet: g
    };
  }, lh = (t, s) => {
    const {
      class: a,
      style: l,
      ...f
    } = ca(s), {
      toSet: g,
      toRemove: h
    } = Dd(t.attributes, f), w = () => {
      O(h, (kn) => nr(s, kn)), Ic(s, g);
    }, C = ce(s), {
      toSet: T,
      toRemove: D
    } = Dd(t.styles, C), $ = () => {
      O(D, (kn) => Dt(s, kn)), Zr(s, T);
    }, I = L1(s), V = ct(I, t.classes), ne = ct(t.classes, I), pe = () => {
      ji(s, ne), qc(s, V);
    }, Le = (kn) => {
      Ef(s, kn);
    }, he = () => {
      const kn = t.domChildren;
      Wy(s, kn);
    }, at = () => {
      const kn = s, et = t.value.getOrUndefined();
      et !== Ui(kn) && yi(kn, et != null ? et : "");
    };
    return w(), pe(), $(), t.innerHtml.fold(he, Le), at(), s;
  }, YC = (t) => {
    const s = bt.fromTag(t.tag);
    Ic(s, t.attributes), ji(s, t.classes), Zr(s, t.styles), t.innerHtml.each((l) => Ef(s, l));
    const a = t.domChildren;
    return au(s, a), t.value.each((l) => {
      yi(s, l);
    }), s;
  }, ew = (t, s) => {
    try {
      const a = lh(t, s);
      return z.some(a);
    } catch {
      return z.none();
    }
  }, XC = (t) => t.innerHtml.isSome() && t.domChildren.length > 0, tw = (t, s) => {
    const a = (f) => zt(f) === t.tag && !XC(t) && !Sm(f), l = s.filter(a).bind((f) => ew(t, f)).getOrThunk(() => YC(t));
    return Cg(l, t.uid), l;
  }, nw = (t) => {
    const s = ht(t, "behaviours").getOr({});
    return je(mn(s), (a) => {
      const l = s[a];
      return Ge(l) ? [l.me] : [];
    });
  }, ow = (t, s) => VC(t, s), V1 = (t) => {
    const s = nw(t);
    return ow(t, s);
  }, JC = (t, s, a) => {
    const l = F1(t), f = nc(t), g = { "alloy.base.modification": f }, h = s.length > 0 ? Dc(a, g, s, l) : f;
    return Dl(l, h);
  }, Og = (t, s, a) => {
    const l = { "alloy.base.behaviour": WC(t) };
    return rh(a, t.eventOrder, s, l).getOrDie();
  }, QC = (t, s) => {
    const a = () => kn, l = Xn(qk), f = gi(Vy(t)), g = V1(t), h = jC(g), w = UC(g), C = JC(f, h, w), T = tw(C, s), D = Og(f, h, w), $ = Xn(f.components), I = (et) => {
      l.set(et);
    }, V = () => {
      l.set(Fy(a));
    }, ne = () => {
      const et = aa(T), hn = je(et, (xn) => l.get().getByDom(xn).fold(() => [], vo));
      $.set(hn);
    }, pe = (et) => {
      const hn = w;
      return (At(hn[et.name()]) ? hn[et.name()] : () => {
        throw new Error("Could not find " + et.name() + " in " + JSON.stringify(t, null, 2));
      })();
    }, Le = (et) => At(w[et.name()]), he = () => f.apis, at = (et) => w[et]().map((hn) => hn.state.readState()).getOr("not enabled"), kn = {
      uid: t.uid,
      getSystem: l.get,
      config: pe,
      hasConfigured: Le,
      spec: t,
      readState: at,
      getApis: he,
      connect: I,
      disconnect: V,
      element: T,
      syncComponents: ne,
      components: $.get,
      events: D
    };
    return kn;
  }, Dg = (t, s) => {
    const a = ht(t, "components").getOr([]);
    return s.fold(() => Xe(a, bc), (l) => Xe(a, (f, g) => qy(f, Xa(l, g))));
  }, j1 = (t, s) => {
    const {
      events: a,
      ...l
    } = Py(t), f = Dg(l, s), g = {
      ...l,
      events: {
        ...fu,
        ...a
      },
      components: f
    };
    return yo.value(QC(g, s));
  }, wa = (t) => {
    const s = bt.fromText(t);
    return ih({ element: s });
  }, ih = (t) => {
    const s = Vc("external.component", gc([
      ut("element"),
      xs("uid")
    ]), t), a = Xn(Fy()), l = (w) => {
      a.set(w);
    }, f = () => {
      a.set(Fy(() => h));
    }, g = s.uid.getOrThunk(() => Ks("external"));
    Cg(s.element, g);
    const h = {
      uid: g,
      getSystem: a.get,
      config: z.none,
      hasConfigured: Ot,
      connect: l,
      disconnect: f,
      getApis: () => ({}),
      element: s.element,
      spec: t,
      readState: oe("No state"),
      syncComponents: ie,
      components: oe([]),
      events: {}
    };
    return P1(h);
  }, U1 = Ks, Zy = (t) => qn(t, "uid"), qy = (t, s) => Ly(t).getOrThunk(() => {
    const a = Zy(t) ? t : {
      uid: U1(""),
      ...t
    };
    return j1(a, s).getOrDie();
  }), bc = (t) => qy(t, z.none()), bi = P1;
  var sw = (t, s, a, l, f) => t(a, l) ? z.some(a) : At(f) && f(a) ? z.none() : s(a, l, f);
  const W1 = (t, s, a) => {
    let l = t.dom;
    const f = At(a) ? a : Ot;
    for (; l.parentNode; ) {
      l = l.parentNode;
      const g = bt.fromDom(l);
      if (s(g))
        return z.some(g);
      if (f(g))
        break;
    }
    return z.none();
  }, Yu = (t, s, a) => sw((f, g) => g(f), W1, t, s, a), Rd = (t, s) => {
    const a = (f) => s(bt.fromDom(f));
    return Oe(t.dom.childNodes, a).map(bt.fromDom);
  }, rw = (t, s) => {
    const a = (l) => {
      for (let f = 0; f < l.childNodes.length; f++) {
        const g = bt.fromDom(l.childNodes[f]);
        if (s(g))
          return z.some(g);
        const h = a(l.childNodes[f]);
        if (h.isSome())
          return h;
      }
      return z.none();
    };
    return a(t.dom);
  }, Ke = (t, s, a) => Yu(t, s, a).isSome(), Df = (t, s, a) => W1(t, (l) => Ya(l, s), a), eS = (t, s) => Rd(t, (a) => Ya(a, s)), sc = (t, s) => fs(s, t), Wi = (t, s, a) => sw((f, g) => Ya(f, g), Df, t, s, a), Ia = "aria-controls", tS = (t) => Yu(t, (a) => {
    if (!Yt(a))
      return !1;
    const l = Vo(a, "id");
    return l !== void 0 && l.indexOf(Ia) > -1;
  }).bind((a) => {
    const l = Vo(a, "id"), f = or(a);
    return sc(f, `[${Ia}="${l}"]`);
  }), Rf = () => {
    const t = $n(Ia);
    return {
      id: t,
      link: (l) => {
        to(l, Ia, t);
      },
      unlink: (l) => {
        nr(l, Ia);
      }
    };
  }, aw = (t, s) => tS(s).exists((a) => Md(t, a)), Md = (t, s) => Ke(s, (a) => Lo(a, t.element), Ot) || aw(t, s), Z1 = "unknown";
  var Em;
  (function(t) {
    t[t.STOP = 0] = "STOP", t[t.NORMAL = 1] = "NORMAL", t[t.LOGGING = 2] = "LOGGING";
  })(Em || (Em = {}));
  const q1 = Xn({}), cw = (t, s) => {
    const a = [], l = new Date().getTime();
    return {
      logEventCut: (f, g, h) => {
        a.push({
          outcome: "cut",
          target: g,
          purpose: h
        });
      },
      logEventStopped: (f, g, h) => {
        a.push({
          outcome: "stopped",
          target: g,
          purpose: h
        });
      },
      logNoParent: (f, g, h) => {
        a.push({
          outcome: "no-parent",
          target: g,
          purpose: h
        });
      },
      logEventNoHandlers: (f, g) => {
        a.push({
          outcome: "no-handlers-left",
          target: g
        });
      },
      logEventResponse: (f, g, h) => {
        a.push({
          outcome: "response",
          purpose: h,
          target: g
        });
      },
      write: () => {
        const f = new Date().getTime();
        Fn([
          "mousemove",
          "mouseover",
          "mouseout",
          Oy()
        ], t) || console.log(t, {
          event: t,
          time: f - l,
          target: s.dom,
          sequence: Xe(a, (g) => Fn([
            "cut",
            "stopped",
            "response"
          ], g.outcome) ? "{" + g.purpose + "} " + g.outcome + " at (" + Af(g.target) + ")" : g.outcome)
        });
      }
    };
  }, nS = (t, s, a) => {
    switch (ht(q1.get(), t).orThunk(() => {
      const f = mn(q1.get());
      return Ho(f, (g) => t.indexOf(g) > -1 ? z.some(q1.get()[g]) : z.none());
    }).getOr(Em.NORMAL)) {
      case Em.NORMAL:
        return a(Gy());
      case Em.LOGGING: {
        const f = cw(t, s), g = a(f);
        return f.write(), g;
      }
      case Em.STOP:
        return !0;
    }
  }, lw = [
    "alloy/data/Fields",
    "alloy/debugging/Debugging"
  ], oS = () => {
    const t = new Error();
    if (t.stack !== void 0) {
      const s = t.stack.split(`
`);
      return Oe(s, (a) => a.indexOf("alloy") > 0 && !Sn(lw, (l) => a.indexOf(l) > -1)).getOr(Z1);
    } else
      return Z1;
  }, G1 = {
    logEventCut: ie,
    logEventStopped: ie,
    logNoParent: ie,
    logEventNoHandlers: ie,
    logEventResponse: ie,
    write: ie
  }, uh = (t, s, a) => nS(t, s, a), Gy = oe(G1), iw = oe([
    ut("menu"),
    ut("selectedMenu")
  ]), Ky = oe([
    ut("item"),
    ut("selectedItem")
  ]);
  oe(Pn(Ky().concat(iw())));
  const Rg = oe(Pn(Ky())), Yy = Fi("initSize", [
    ut("numColumns"),
    ut("numRows")
  ]), K1 = () => Ac("markers", Rg()), Mg = () => Fi("markers", [ut("backgroundMenu")].concat(iw()).concat(Ky())), Mf = (t) => Fi("markers", Xe(t, ut)), Xy = (t, s, a) => (oS(), ba(s, s, a, kf((l) => yo.value((...f) => l.apply(void 0, f))))), Es = (t) => Xy("onHandler", t, Lu(ie)), il = (t) => Xy("onKeyboardHandler", t, Lu(z.none)), Ng = (t) => Xy("onHandler", t, di()), Rc = (t) => Xy("onKeyboardHandler", t, di()), fr = (t, s) => va(t, oe(s)), uw = (t) => va(t, Je), Y1 = oe(Yy), La = (t, s, a, l, f, g, h, w = !1) => ({
    x: t,
    y: s,
    bubble: a,
    direction: l,
    placement: f,
    restriction: g,
    label: `${h}-${f}`,
    alwaysFit: w
  }), gu = Pa.generate([
    { southeast: [] },
    { southwest: [] },
    { northeast: [] },
    { northwest: [] },
    { south: [] },
    { north: [] },
    { east: [] },
    { west: [] }
  ]), dw = (t, s, a, l, f, g, h, w, C) => t.fold(s, a, l, f, g, h, w, C), ul = (t, s, a, l) => t.fold(s, s, l, l, s, l, a, a), KE = (t, s, a, l) => t.fold(s, l, s, l, a, a, s, l), vi = gu.southeast, Jy = gu.southwest, Qy = gu.northeast, Bg = gu.northwest, fw = gu.south, mw = gu.north, Gc = gu.east, $g = gu.west, Pg = (t, s, a, l) => {
    const f = t + s;
    return f > l ? a : f < a ? l : f;
  }, ki = (t, s, a) => Math.min(Math.max(t, s), a), X1 = (t, s) => {
    switch (s) {
      case 1:
        return t.x;
      case 0:
        return t.x + t.width;
      case 2:
        return t.y;
      case 3:
        return t.y + t.height;
    }
  }, rc = (t, s) => Ht([
    "left",
    "right",
    "top",
    "bottom"
  ], (a) => ht(s, a).map((l) => X1(t, l))), sS = (t, s, a) => {
    const l = (C, T) => s[C].map((D) => {
      const $ = C === "top" || C === "bottom", I = $ ? a.top : a.left, ne = (C === "left" || C === "top" ? Math.max : Math.min)(D, T) + I;
      return $ ? ki(ne, t.y, t.bottom) : ki(ne, t.x, t.right);
    }).getOr(T), f = l("left", t.x), g = l("top", t.y), h = l("right", t.right), w = l("bottom", t.bottom);
    return ws(f, g, h - f, w - g);
  }, Nf = "layout", J1 = (t) => t.x, _n = (t, s) => t.x + t.width / 2 - s.width / 2, Fg = (t, s) => t.x + t.width - s.width, eb = (t, s) => t.y - s.height, Q1 = (t) => t.y + t.height, gw = (t, s) => t.y + t.height / 2 - s.height / 2, rS = (t) => t.x + t.width, pw = (t, s) => t.x - s.width, vc = (t, s, a) => La(J1(t), Q1(t), a.southeast(), vi(), "southeast", rc(t, {
    left: 1,
    top: 3
  }), Nf), kc = (t, s, a) => La(Fg(t, s), Q1(t), a.southwest(), Jy(), "southwest", rc(t, {
    right: 0,
    top: 3
  }), Nf), Kc = (t, s, a) => La(J1(t), eb(t, s), a.northeast(), Qy(), "northeast", rc(t, {
    left: 1,
    bottom: 2
  }), Nf), wc = (t, s, a) => La(Fg(t, s), eb(t, s), a.northwest(), Bg(), "northwest", rc(t, {
    right: 0,
    bottom: 2
  }), Nf), Ir = (t, s, a) => La(_n(t, s), eb(t, s), a.north(), mw(), "north", rc(t, { bottom: 2 }), Nf), ua = (t, s, a) => La(_n(t, s), Q1(t), a.south(), fw(), "south", rc(t, { top: 3 }), Nf), e0 = (t, s, a) => La(rS(t), gw(t, s), a.east(), Gc(), "east", rc(t, { left: 0 }), Nf), t0 = (t, s, a) => La(pw(t, s), gw(t, s), a.west(), $g(), "west", rc(t, { right: 1 }), Nf), hw = () => [
    vc,
    kc,
    Kc,
    wc,
    ua,
    Ir,
    e0,
    t0
  ], yw = () => [
    kc,
    vc,
    wc,
    Kc,
    ua,
    Ir,
    e0,
    t0
  ], bw = () => [
    Kc,
    wc,
    vc,
    kc,
    Ir,
    ua
  ], dh = () => [
    wc,
    Kc,
    kc,
    vc,
    Ir,
    ua
  ], Ig = () => [
    vc,
    kc,
    Kc,
    wc,
    ua,
    Ir
  ], tb = () => [
    kc,
    vc,
    wc,
    Kc,
    ua,
    Ir
  ], n0 = (t, s) => s.universal ? t : Pt(t, (a) => Fn(s.channels, a));
  var vw = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t) => Ls([dt(_m(), (s, a) => {
      const l = t.channels, f = mn(l), g = a, h = n0(f, g);
      O(h, (w) => {
        const C = l[w], T = C.schema, D = Vc("channel[" + w + `] data
Receiver: ` + Af(s.element), T, g.data);
        C.onReceive(s, D);
      });
    })])
  }), cS = [Ac("channels", vd(yo.value, gc([
    Ng("onReceive"),
    Te("schema", tc())
  ])))];
  const kw = (t, s, a) => zd((l) => {
    a(l, t, s);
  }), fh = (t, s, a) => FC((l, f) => {
    a(l, t, s);
  }), nb = (t, s, a, l, f, g) => {
    const h = gc(t), w = zc(s, [km("config", t)]);
    return s0(h, w, s, a, l, f, g);
  }, o0 = (t, s, a, l, f, g) => {
    const h = t, w = zc(s, [zl("config", t)]);
    return s0(h, w, s, a, l, f, g);
  }, ww = (t, s, a) => Sg((f, ...g) => {
    const h = [f].concat(g);
    return f.config({ name: oe(t) }).fold(() => {
      throw new Error("We could not find any behaviour configuration for: " + t + ". Using API: " + a);
    }, (w) => {
      const C = Array.prototype.slice.call(h, 1);
      return s.apply(void 0, [
        f,
        w.config,
        w.state
      ].concat(C));
    });
  }, a, s), lS = (t) => ({
    key: t,
    value: void 0
  }), s0 = (t, s, a, l, f, g, h) => {
    const w = ($) => pr($, a) ? $[a]() : z.none(), C = Ln(f, ($, I) => ww(a, $, I)), D = {
      ...Ln(g, ($, I) => Yl($, I)),
      ...C,
      revoke: lt(lS, a),
      config: ($) => {
        const I = Vc(a + "-config", t, $);
        return {
          key: a,
          value: {
            config: I,
            me: D,
            configAsRaw: Oo(() => Vc(a + "-config", t, $)),
            initialConfig: $,
            state: h
          }
        };
      },
      schema: oe(s),
      exhibit: ($, I) => Tr(w($), ht(l, "exhibit"), (V, ne) => ne(I, V.config, V.state)).getOrThunk(() => Ku({})),
      name: oe(a),
      handlers: ($) => w($).map((I) => ht(l, "events").getOr(() => ({}))(I.config, I.state)).getOr({})
    };
    return D;
  }, qt = (t) => Ze(t), iS = gc([
    ut("fields"),
    ut("name"),
    Te("active", {}),
    Te("apis", {}),
    Te("state", Vi),
    Te("extra", {})
  ]), Ha = (t) => {
    const s = Vc("Creating behaviour: " + t.name, iS, t);
    return nb(s.fields, s.name, s.active, s.apis, s.extra, s.state);
  }, _w = gc([
    ut("branchKey"),
    ut("branches"),
    ut("name"),
    Te("active", {}),
    Te("apis", {}),
    Te("state", Vi),
    Te("extra", {})
  ]), Cw = (t) => {
    const s = Vc("Creating behaviour: " + t.name, _w, t);
    return o0(rr(s.branchKey, s.branches), s.name, s.active, s.apis, s.extra, s.state);
  }, uS = oe(void 0), wi = Ha({
    fields: cS,
    name: "receiving",
    active: vw
  });
  var dS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, s) => Ku({
      classes: [],
      styles: s.useFixed() ? {} : { position: "relative" }
    })
  });
  const Xu = (t) => t.dom.focus(), fS = (t) => t.dom.blur(), Am = (t) => {
    const s = or(t).dom;
    return t.dom === s.activeElement;
  }, Nd = (t = M()) => z.from(t.dom.activeElement).map(bt.fromDom), _i = (t) => Nd(or(t)).filter((s) => t.dom.contains(s.dom)), r0 = (t, s) => {
    const a = or(s), l = Nd(a).bind((g) => {
      const h = (w) => Lo(g, w);
      return h(s) ? z.some(s) : rw(s, h);
    }), f = t(s);
    return l.each((g) => {
      Nd(a).filter((h) => Lo(h, g)).fold(() => {
        Xu(g);
      }, ie);
    }), f;
  }, Rl = (t, s, a, l, f) => {
    const g = (h) => h + "px";
    return {
      position: t,
      left: s.map(g),
      top: a.map(g),
      right: l.map(g),
      bottom: f.map(g)
    };
  }, mS = (t) => ({
    ...t,
    position: z.some(t.position)
  }), Sw = (t, s) => {
    wl(t, mS(s));
  }, a0 = Pa.generate([
    { none: [] },
    {
      relative: [
        "x",
        "y",
        "width",
        "height"
      ]
    },
    {
      fixed: [
        "x",
        "y",
        "width",
        "height"
      ]
    }
  ]), c0 = (t, s, a, l, f, g) => {
    const h = s.rect, w = h.x - a, C = h.y - l, T = h.width, D = h.height, $ = f - (w + T), I = g - (C + D), V = z.some(w), ne = z.some(C), pe = z.some($), Le = z.some(I), he = z.none();
    return dw(s.direction, () => Rl(t, V, ne, he, he), () => Rl(t, he, ne, pe, he), () => Rl(t, V, he, he, Le), () => Rl(t, he, he, pe, Le), () => Rl(t, V, ne, he, he), () => Rl(t, V, he, he, Le), () => Rl(t, V, ne, he, he), () => Rl(t, he, ne, pe, he));
  }, mh = (t, s) => t.fold(() => {
    const a = s.rect;
    return Rl("absolute", z.some(a.x), z.some(a.y), z.none(), z.none());
  }, (a, l, f, g) => c0("absolute", s, a, l, f, g), (a, l, f, g) => c0("fixed", s, a, l, f, g)), Bd = (t, s) => {
    const a = lt(xo, s), l = t.fold(a, a, () => {
      const h = al();
      return xo(s).translate(-h.left, -h.top);
    }), f = Xs(s), g = Ca(s);
    return ws(l.left, l.top, f, g);
  }, gS = (t, s) => s.fold(() => t.fold(ui, ui, ws), (a) => t.fold(a, a, () => {
    const l = a(), f = xw(t, l.x, l.y);
    return ws(f.left, f.top, l.width, l.height);
  })), xw = (t, s, a) => {
    const l = as(s, a), f = () => {
      const g = al();
      return l.translate(-g.left, -g.top);
    };
    return t.fold(oe(l), oe(l), f);
  }, pS = (t, s, a, l) => t.fold(s, a, l);
  a0.none;
  const hS = a0.relative, ob = a0.fixed, Aa = (t, s) => ({
    anchorBox: t,
    origin: s
  }), yS = (t, s) => Aa(t, s), pu = "data-alloy-placement", Tw = (t, s) => {
    to(t, pu, s);
  }, l0 = (t) => ha(t, pu), bS = (t) => nr(t, pu), sb = Pa.generate([
    { fit: ["reposition"] },
    {
      nofit: [
        "reposition",
        "visibleW",
        "visibleH",
        "isVisible"
      ]
    }
  ]), Ew = (t, s) => {
    const {
      x: a,
      y: l,
      right: f,
      bottom: g
    } = s, { x: h, y: w, right: C, bottom: T, width: D, height: $ } = t, I = h >= a && h <= f, V = w >= l && w <= g, ne = I && V, pe = C <= f && C >= a, Le = T <= g && T >= l, he = pe && Le, at = Math.min(D, h >= a ? f - h : C - a), kn = Math.min($, w >= l ? g - w : T - l);
    return {
      originInBounds: ne,
      sizeInBounds: he,
      visibleW: at,
      visibleH: kn
    };
  }, Aw = (t, s) => {
    const {
      x: a,
      y: l,
      right: f,
      bottom: g
    } = s, { x: h, y: w, width: C, height: T } = t, D = Math.max(a, f - C), $ = Math.max(l, g - T), I = ki(h, a, D), V = ki(w, l, $), ne = Math.min(I + C, f) - I, pe = Math.min(V + T, g) - V;
    return ws(I, V, ne, pe);
  }, vS = (t, s, a) => {
    const l = oe(s.bottom - a.y), f = oe(a.bottom - s.y), g = ul(t, f, f, l), h = oe(s.right - a.x), w = oe(a.right - s.x);
    return {
      maxWidth: KE(t, w, w, h),
      maxHeight: g
    };
  }, zw = (t, s, a, l) => {
    const f = t.bubble, g = f.offset, h = sS(l, t.restriction, g), w = t.x + g.left, C = t.y + g.top, T = ws(w, C, s, a), { originInBounds: D, sizeInBounds: $, visibleW: I, visibleH: V } = Ew(T, h), ne = D && $, pe = ne ? T : Aw(T, h), Le = pe.width > 0 && pe.height > 0, { maxWidth: he, maxHeight: at } = vS(t.direction, pe, l), kn = {
      rect: pe,
      maxHeight: at,
      maxWidth: he,
      direction: t.direction,
      placement: t.placement,
      classes: {
        on: f.classesOn,
        off: f.classesOff
      },
      layout: t.label,
      testY: C
    };
    return ne || t.alwaysFit ? sb.fit(kn) : sb.nofit(kn, I, V, Le);
  }, i0 = (t, s, a, l, f, g) => {
    const h = l.width, w = l.height, C = (D, $, I, V, ne) => {
      const pe = D(a, l, f, t, g), Le = zw(pe, h, w, g);
      return Le.fold(oe(Le), (he, at, kn, et) => (ne === et ? kn > V || at > I : !ne && et) ? Le : sb.nofit($, I, V, ne));
    };
    return We(s, (D, $) => {
      const I = lt(C, $);
      return D.fold(oe(D), I);
    }, sb.nofit({
      rect: a,
      maxHeight: l.height,
      maxWidth: l.width,
      direction: vi(),
      placement: "southeast",
      classes: {
        on: [],
        off: []
      },
      layout: "none",
      testY: a.y
    }, -1, -1, !1)).fold(Je, Je);
  }, rb = (t) => {
    const s = Xn(z.none()), a = () => s.get().each(t);
    return {
      clear: () => {
        a(), s.set(z.none());
      },
      isSet: () => s.get().isSome(),
      get: () => s.get(),
      set: (w) => {
        a(), s.set(z.some(w));
      }
    };
  }, Ow = () => rb((t) => t.destroy()), Bf = () => rb((t) => t.unbind()), Ar = () => {
    const t = rb(ie);
    return {
      ...t,
      on: (a) => t.get().each(a)
    };
  }, Ju = Se, Va = (t, s, a) => am(t, s, Ju, a), Dw = (t, s, a) => rg(t, s, Ju, a), u0 = rm, Rw = [
    "top",
    "bottom",
    "right",
    "left"
  ], ab = "data-alloy-transition-timer", kS = (t, s) => Jk(t, s.classes), Mw = (t, s, a) => a.exists((l) => {
    const f = t.mode;
    return f === "all" ? !0 : l[f] !== s[f];
  }), wS = (t, s) => {
    const a = (l) => parseFloat(l).toFixed(3);
    return Vt(s, (l, f) => {
      const g = t[f].map(a), h = l.map(a);
      return !Zs(g, h);
    }).isSome();
  }, Nw = (t) => {
    const s = (g) => {
      const w = qr(t, g).split(/\s*,\s*/);
      return Pt(w, wt);
    }, a = (g) => {
      if (Kt(g) && /^[\d.]+/.test(g)) {
        const h = parseFloat(g);
        return Z(g, "ms") ? h : h * 1e3;
      } else
        return 0;
    }, l = s("transition-delay"), f = s("transition-duration");
    return We(f, (g, h, w) => {
      const C = a(l[w]) + a(h);
      return Math.max(g, C);
    }, 0);
  }, d0 = (t, s) => {
    const a = Bf(), l = Bf();
    let f;
    const g = (T) => {
      var D;
      const $ = (D = T.raw.pseudoElement) !== null && D !== void 0 ? D : "";
      return Lo(T.target, t) && Rn($) && Fn(Rw, T.raw.propertyName);
    }, h = (T) => {
      if (an(T) || g(T)) {
        a.clear(), l.clear();
        const D = T == null ? void 0 : T.raw.type;
        (an(D) || D === Gp()) && (clearTimeout(f), nr(t, ab), qc(t, s.classes));
      }
    }, w = Va(t, Hk(), (T) => {
      g(T) && (w.unbind(), a.set(Va(t, Gp(), h)), l.set(Va(t, O1(), h)));
    }), C = Nw(t);
    requestAnimationFrame(() => {
      f = setTimeout(h, C + 17), to(t, ab, f);
    });
  }, Bw = (t, s) => {
    ji(t, s.classes), ha(t, ab).each((a) => {
      clearTimeout(parseInt(a, 10)), nr(t, ab);
    }), d0(t, s);
  }, _S = (t, s, a, l, f, g) => {
    const h = Mw(l, f, g);
    if (h || kS(t, l)) {
      Qt(t, "position", a.position);
      const w = Bd(s, t), C = mh(s, {
        ...f,
        rect: w
      }), T = Ht(Rw, (D) => C[D]);
      wS(a, T) && (wl(t, T), h && Bw(t, l), $o(t));
    } else
      qc(t, l.classes);
  }, CS = (t) => ({
    width: Xs(t),
    height: Ca(t)
  }), SS = (t, s, a, l) => {
    Dt(s, "max-height"), Dt(s, "max-width");
    const f = CS(s);
    return i0(s, l.preference, t, f, a, l.bounds);
  }, gh = (t, s) => {
    const a = s.classes;
    qc(t, a.off), ji(t, a.on);
  }, $w = (t, s, a) => {
    const l = a.maxHeightFunction;
    l(t, s.maxHeight);
  }, xS = (t, s, a) => {
    const l = a.maxWidthFunction;
    l(t, s.maxWidth);
  }, zm = (t, s, a) => {
    const l = mh(a.origin, s);
    a.transition.each((f) => {
      _S(t, a.origin, l, f, s, a.lastPlacement);
    }), Sw(t, l);
  }, TS = (t, s) => {
    Tw(t, s.placement);
  }, f0 = (t, s) => {
    qs(t, Math.floor(s));
  }, Pw = oe((t, s) => {
    f0(t, s), Zr(t, {
      "overflow-x": "hidden",
      "overflow-y": "auto"
    });
  }), Lg = oe((t, s) => {
    f0(t, s);
  }), cb = (t, s, a) => t[s] === void 0 ? a : t[s], lb = (t, s, a, l, f, g, h, w) => {
    const C = cb(h, "maxHeightFunction", Pw()), T = cb(h, "maxWidthFunction", ie), D = t.anchorBox, $ = t.origin, I = {
      bounds: gS($, g),
      origin: $,
      preference: l,
      maxHeightFunction: C,
      maxWidthFunction: T,
      lastPlacement: f,
      transition: w
    };
    return ES(D, s, a, I);
  }, ES = (t, s, a, l) => {
    const f = SS(t, s, a, l);
    return zm(s, f, l), TS(s, f), gh(s, f), $w(s, f, l), xS(s, f, l), {
      layout: f.layout,
      placement: f.placement
    };
  }, AS = [
    "valignCentre",
    "alignLeft",
    "alignRight",
    "alignCentre",
    "top",
    "bottom",
    "left",
    "right",
    "inset"
  ], Hg = (t, s, a, l = 1) => {
    const f = t * l, g = s * l, h = (C) => ht(a, C).getOr([]), w = (C, T, D) => {
      const $ = ct(AS, D);
      return {
        offset: as(C, T),
        classesOn: je(D, h),
        classesOff: je($, h)
      };
    };
    return {
      southeast: () => w(-t, s, [
        "top",
        "alignLeft"
      ]),
      southwest: () => w(t, s, [
        "top",
        "alignRight"
      ]),
      south: () => w(-t / 2, s, [
        "top",
        "alignCentre"
      ]),
      northeast: () => w(-t, -s, [
        "bottom",
        "alignLeft"
      ]),
      northwest: () => w(t, -s, [
        "bottom",
        "alignRight"
      ]),
      north: () => w(-t / 2, -s, [
        "bottom",
        "alignCentre"
      ]),
      east: () => w(t, -s / 2, [
        "valignCentre",
        "left"
      ]),
      west: () => w(-t, -s / 2, [
        "valignCentre",
        "right"
      ]),
      insetNortheast: () => w(f, g, [
        "top",
        "alignLeft",
        "inset"
      ]),
      insetNorthwest: () => w(-f, g, [
        "top",
        "alignRight",
        "inset"
      ]),
      insetNorth: () => w(-f / 2, g, [
        "top",
        "alignCentre",
        "inset"
      ]),
      insetSoutheast: () => w(f, -g, [
        "bottom",
        "alignLeft",
        "inset"
      ]),
      insetSouthwest: () => w(-f, -g, [
        "bottom",
        "alignRight",
        "inset"
      ]),
      insetSouth: () => w(-f / 2, -g, [
        "bottom",
        "alignCentre",
        "inset"
      ]),
      insetEast: () => w(-f, -g / 2, [
        "valignCentre",
        "right",
        "inset"
      ]),
      insetWest: () => w(f, -g / 2, [
        "valignCentre",
        "left",
        "inset"
      ])
    };
  }, ib = () => Hg(0, 0, {}), ub = Je, $d = (t, s) => (a) => zS(a) === "rtl" ? s : t, zS = (t) => qr(t, "direction") === "rtl" ? "rtl" : "ltr";
  var Qu;
  (function(t) {
    t.TopToBottom = "toptobottom", t.BottomToTop = "bottomtotop";
  })(Qu || (Qu = {}));
  const db = "data-alloy-vertical-dir", Fw = (t) => Ke(t, (s) => Yt(s) && Vo(s, "data-alloy-vertical-dir") === Qu.BottomToTop), ed = () => zc("layouts", [
    ut("onLtr"),
    ut("onRtl"),
    xs("onBottomLtr"),
    xs("onBottomRtl")
  ]), ph = (t, s, a, l, f, g, h) => {
    const w = h.map(Fw).getOr(!1), C = s.layouts.map((V) => V.onLtr(t)), T = s.layouts.map((V) => V.onRtl(t)), D = w ? s.layouts.bind((V) => V.onBottomLtr.map((ne) => ne(t))).or(C).getOr(f) : C.getOr(a), $ = w ? s.layouts.bind((V) => V.onBottomRtl.map((ne) => ne(t))).or(T).getOr(g) : T.getOr(l);
    return $d(D, $)(t);
  }, fb = (t, s, a) => {
    const l = s.hotspot, f = Bd(a, l.element), g = ph(t.element, s, Ig(), tb(), bw(), dh(), z.some(s.hotspot.element));
    return z.some(ub({
      anchorBox: f,
      bubble: s.bubble.getOr(ib()),
      overrides: s.overrides,
      layouts: g,
      placer: z.none()
    }));
  };
  var Vg = [
    ut("hotspot"),
    xs("bubble"),
    Te("overrides", {}),
    ed(),
    fr("placement", fb)
  ];
  const Om = (t, s, a) => {
    const l = xw(a, s.x, s.y), f = ws(l.left, l.top, s.width, s.height), g = ph(t.element, s, hw(), yw(), hw(), yw(), z.none());
    return z.some(ub({
      anchorBox: f,
      bubble: s.bubble,
      overrides: s.overrides,
      layouts: g,
      placer: z.none()
    }));
  };
  var jg = [
    ut("x"),
    ut("y"),
    Te("height", 0),
    Te("width", 0),
    Te("bubble", ib()),
    Te("overrides", {}),
    ed(),
    fr("placement", Om)
  ];
  const Iw = Pa.generate([
    { screen: ["point"] },
    {
      absolute: [
        "point",
        "scrollLeft",
        "scrollTop"
      ]
    }
  ]), m0 = (t) => t.fold(Je, (s, a, l) => s.translate(-a, -l)), OS = (t) => t.fold(Je, Je), g0 = (t) => We(t, (s, a) => s.translate(a.left, a.top), as(0, 0)), Lw = (t) => {
    const s = Xe(t, m0);
    return g0(s);
  }, p0 = (t) => {
    const s = Xe(t, OS);
    return g0(s);
  }, h0 = Iw.screen, DS = Iw.absolute, Ug = (t, s, a) => {
    const l = pa(a.root).dom, f = (g) => {
      const h = Er(g), w = Er(t.element);
      return Lo(h, w);
    };
    return z.from(l.frameElement).map(bt.fromDom).filter(f).map(Me);
  }, $f = (t, s, a) => {
    const l = Er(t.element), f = al(l), g = Ug(t, s, a).getOr(f);
    return DS(g, f.left, f.top);
  }, hh = (t, s, a, l) => {
    const f = h0(as(t, s));
    return z.some(Zo(f, a, l));
  }, Wg = (t, s, a, l, f) => t.map((g) => {
    const h = [
      s,
      g.point
    ], w = pS(l, () => p0(h), () => p0(h), () => Lw(h)), C = jo(w.left, w.top, g.width, g.height), T = a.showAbove ? bw() : Ig(), D = a.showAbove ? dh() : tb(), $ = ph(f, a, T, D, T, D, z.none());
    return ub({
      anchorBox: C,
      bubble: a.bubble.getOr(ib()),
      overrides: a.overrides,
      layouts: $,
      placer: z.none()
    });
  }), RS = (t, s, a) => {
    const l = $f(t, a, s);
    return s.node.filter(Ko).bind((f) => {
      const g = f.dom.getBoundingClientRect(), h = hh(g.left, g.top, g.width, g.height), w = s.node.getOr(t.element);
      return Wg(h, l, s, a, w);
    });
  };
  var Pf = [
    ut("node"),
    ut("root"),
    xs("bubble"),
    ed(),
    Te("overrides", {}),
    Te("showAbove", !1),
    fr("placement", RS)
  ];
  const td = "\uFEFF", y0 = "\xA0", gb = { create: (t, s, a, l) => ({
    start: t,
    soffset: s,
    finish: a,
    foffset: l
  }) }, Zg = Pa.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), Dm = (t, s, a, l) => t.fold(s, a, l), qg = (t) => t.fold(Je, Je, Je), yh = Zg.before, b0 = Zg.on, Gg = Zg.after, bh = {
    before: yh,
    on: b0,
    after: Gg,
    cata: Dm,
    getStart: qg
  }, pb = Pa.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), hb = (t) => pb.exact(t.start, t.soffset, t.finish, t.foffset), vh = (t) => t.match({
    domRange: (s) => bt.fromDom(s.startContainer),
    relative: (s, a) => bh.getStart(s),
    exact: (s, a, l, f) => s
  }), ja = pb.domRange, v0 = pb.relative, nd = pb.exact, Hw = (t) => {
    const s = vh(t);
    return pa(s);
  }, k0 = gb.create, Zi = {
    domRange: ja,
    relative: v0,
    exact: nd,
    exactFromRange: hb,
    getWin: Hw,
    range: k0
  }, Vw = (t, s) => {
    s.fold((a) => {
      t.setStartBefore(a.dom);
    }, (a, l) => {
      t.setStart(a.dom, l);
    }, (a) => {
      t.setStartAfter(a.dom);
    });
  }, yb = (t, s) => {
    s.fold((a) => {
      t.setEndBefore(a.dom);
    }, (a, l) => {
      t.setEnd(a.dom, l);
    }, (a) => {
      t.setEndAfter(a.dom);
    });
  }, jw = (t, s, a) => {
    const l = t.document.createRange();
    return Vw(l, s), yb(l, a), l;
  }, w0 = (t, s, a, l, f) => {
    const g = t.document.createRange();
    return g.setStart(s.dom, a), g.setEnd(l.dom, f), g;
  }, _0 = (t) => ({
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom,
    width: t.width,
    height: t.height
  }), Yc = (t) => {
    const s = t.getClientRects(), a = s.length > 0 ? s[0] : t.getBoundingClientRect();
    return a.width > 0 || a.height > 0 ? z.some(a).map(_0) : z.none();
  }, Uw = (t) => {
    const s = t.getBoundingClientRect();
    return s.width > 0 || s.height > 0 ? z.some(s).map(_0) : z.none();
  }, _c = Pa.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Ww = (t, s, a) => s(bt.fromDom(a.startContainer), a.startOffset, bt.fromDom(a.endContainer), a.endOffset), MS = (t, s) => s.match({
    domRange: (a) => ({
      ltr: oe(a),
      rtl: z.none
    }),
    relative: (a, l) => ({
      ltr: Oo(() => jw(t, a, l)),
      rtl: Oo(() => z.some(jw(t, l, a)))
    }),
    exact: (a, l, f, g) => ({
      ltr: Oo(() => w0(t, a, l, f, g)),
      rtl: Oo(() => z.some(w0(t, f, g, a, l)))
    })
  }), Zw = (t, s) => {
    const a = s.ltr();
    return a.collapsed ? s.rtl().filter((f) => f.collapsed === !1).map((f) => _c.rtl(bt.fromDom(f.endContainer), f.endOffset, bt.fromDom(f.startContainer), f.startOffset)).getOrThunk(() => Ww(t, _c.ltr, a)) : Ww(t, _c.ltr, a);
  }, qw = (t, s) => {
    const a = MS(t, s);
    return Zw(t, a);
  }, C0 = (t, s) => qw(t, s).match({
    ltr: (l, f, g, h) => {
      const w = t.document.createRange();
      return w.setStart(l.dom, f), w.setEnd(g.dom, h), w;
    },
    rtl: (l, f, g, h) => {
      const w = t.document.createRange();
      return w.setStart(g.dom, h), w.setEnd(l.dom, f), w;
    }
  });
  _c.ltr, _c.rtl;
  const Mc = (t, s) => Bo(s, t), S0 = (t, s, a, l) => {
    const g = Er(t).dom.createRange();
    return g.setStart(t.dom, s), g.setEnd(a.dom, l), g;
  }, Ci = (t, s, a, l) => {
    const f = S0(t, s, a, l), g = Lo(t, a) && s === l;
    return f.collapsed && !g;
  }, bb = (t) => z.from(t.getSelection()), Rm = (t) => {
    if (t.rangeCount > 0) {
      const s = t.getRangeAt(0), a = t.getRangeAt(t.rangeCount - 1);
      return z.some(gb.create(bt.fromDom(s.startContainer), s.startOffset, bt.fromDom(a.endContainer), a.endOffset));
    } else
      return z.none();
  }, Mm = (t) => {
    if (t.anchorNode === null || t.focusNode === null)
      return Rm(t);
    {
      const s = bt.fromDom(t.anchorNode), a = bt.fromDom(t.focusNode);
      return Ci(s, t.anchorOffset, a, t.focusOffset) ? z.some(gb.create(s, t.anchorOffset, a, t.focusOffset)) : Rm(t);
    }
  }, Si = (t) => bb(t).filter((s) => s.rangeCount > 0).bind(Mm), qi = (t, s) => {
    const a = C0(t, s);
    return Yc(a);
  }, Xc = (t, s) => {
    const a = C0(t, s);
    return Uw(a);
  }, NS = ((t, s) => {
    const a = (g) => {
      if (!t(g))
        throw new Error("Can only get " + s + " value of a " + s + " node");
      return l(g).getOr("");
    }, l = (g) => t(g) ? z.from(g.dom.nodeValue) : z.none();
    return {
      get: a,
      getOption: l,
      set: (g, h) => {
        if (!t(g))
          throw new Error("Can only set raw " + s + " value of a " + s + " node");
        g.dom.nodeValue = h;
      }
    };
  })(On, "text"), Xl = (t) => NS.get(t), Pd = (t, s) => ({
    element: t,
    offset: s
  }), Gw = (t, s) => {
    const a = aa(t);
    if (a.length === 0)
      return Pd(t, s);
    if (s < a.length)
      return Pd(a[s], 0);
    {
      const l = a[a.length - 1], f = On(l) ? Xl(l).length : aa(l).length;
      return Pd(l, f);
    }
  }, x0 = (t, s) => On(t) ? Pd(t, s) : Gw(t, s), kh = (t, s) => s.getSelection.getOrThunk(() => () => Si(t))().map((l) => {
    const f = x0(l.start, l.soffset), g = x0(l.finish, l.foffset);
    return Zi.range(f.element, f.offset, g.element, g.offset);
  }), Kw = (t, s, a) => {
    const l = pa(s.root).dom, f = $f(t, a, s), g = kh(l, s).bind((C) => Xc(l, Zi.exactFromRange(C)).orThunk(() => {
      const D = bt.fromText(td);
      sl(C.start, D);
      const $ = qi(l, Zi.exact(D, 0, D, 1));
      return rl(D), $;
    }).bind((D) => hh(D.left, D.top, D.width, D.height))), w = kh(l, s).bind((C) => Yt(C.start) ? z.some(C.start) : Ma(C.start)).getOr(t.element);
    return Wg(g, f, s, a, w);
  };
  var T0 = [
    xs("getSelection"),
    ut("root"),
    xs("bubble"),
    ed(),
    Te("overrides", {}),
    Te("showAbove", !1),
    fr("placement", Kw)
  ];
  const Nm = "link-layout", wh = (t) => t.x + t.width, E0 = (t, s) => t.x - s.width, Bm = (t, s) => t.y - s.height + t.height, Kg = (t) => t.y, Yw = (t, s, a) => La(wh(t), Kg(t), a.southeast(), vi(), "southeast", rc(t, {
    left: 0,
    top: 2
  }), Nm), vb = (t, s, a) => La(E0(t, s), Kg(t), a.southwest(), Jy(), "southwest", rc(t, {
    right: 1,
    top: 2
  }), Nm), Xw = (t, s, a) => La(wh(t), Bm(t, s), a.northeast(), Qy(), "northeast", rc(t, {
    left: 0,
    bottom: 3
  }), Nm), A0 = (t, s, a) => La(E0(t, s), Bm(t, s), a.northwest(), Bg(), "northwest", rc(t, {
    right: 1,
    bottom: 3
  }), Nm), kb = () => [
    Yw,
    vb,
    Xw,
    A0
  ], wb = () => [
    vb,
    Yw,
    A0,
    Xw
  ], BS = (t, s, a) => {
    const l = Bd(a, s.item.element), f = ph(t.element, s, kb(), wb(), kb(), wb(), z.none());
    return z.some(ub({
      anchorBox: l,
      bubble: ib(),
      overrides: s.overrides,
      layouts: f,
      placer: z.none()
    }));
  };
  var $S = [
    ut("item"),
    ed(),
    Te("overrides", {}),
    fr("placement", BS)
  ], Jw = rr("type", {
    selection: T0,
    node: Pf,
    hotspot: Vg,
    submenu: $S,
    makeshift: jg
  });
  const PS = [
    jc("classes", Pr),
    ia("mode", "all", [
      "all",
      "layout",
      "placement"
    ])
  ], FS = [
    Te("useFixed", Ot),
    xs("getBounds")
  ], Jl = [
    Ac("anchor", Jw),
    zc("transition", PS)
  ], IS = () => {
    const t = document.documentElement;
    return ob(0, 0, t.clientWidth, t.clientHeight);
  }, $m = (t) => {
    const s = Me(t.element), a = t.element.dom.getBoundingClientRect();
    return hS(s.left, s.top, a.width, a.height);
  }, Yg = (t, s, a, l, f, g, h) => {
    const w = yS(a.anchorBox, s);
    return lb(w, f.element, a.bubble, a.layouts, g, l, a.overrides, h);
  }, _b = (t, s, a, l, f) => {
    Qw(t, s, a, l, f, z.none());
  }, Qw = (t, s, a, l, f, g) => {
    const h = g.map(Or);
    return Cb(t, s, a, l, f, h);
  }, Cb = (t, s, a, l, f, g) => {
    const h = Vc("placement.info", Pn(Jl), f), w = h.anchor, C = l.element, T = a.get(l.uid);
    r0(() => {
      Qt(C, "position", "fixed");
      const D = j(C, "visibility");
      Qt(C, "visibility", "hidden");
      const $ = s.useFixed() ? IS() : $m(t), I = w.placement, V = g.map(oe).or(s.getBounds);
      I(t, w, $).each((ne) => {
        const Le = ne.placer.getOr(Yg)(t, $, ne, V, l, T, h.transition);
        a.set(l.uid, Le);
      }), D.fold(() => {
        Dt(C, "visibility");
      }, (ne) => {
        Qt(C, "visibility", ne);
      }), j(C, "left").isNone() && j(C, "top").isNone() && j(C, "right").isNone() && j(C, "bottom").isNone() && zr(j(C, "position"), "fixed") && Dt(C, "position");
    }, C);
  };
  var LS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    position: _b,
    positionWithin: Qw,
    positionWithinBounds: Cb,
    getMode: (t, s, a) => s.useFixed() ? "fixed" : "absolute",
    reset: (t, s, a, l) => {
      const f = l.element;
      O([
        "position",
        "left",
        "right",
        "top",
        "bottom"
      ], (g) => Dt(f, g)), bS(f), a.clear(l.uid);
    }
  }), VS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = {};
      return Ol({
        readState: () => t,
        clear: (f) => {
          Ge(f) ? delete t[f] : t = {};
        },
        set: (f, g) => {
          t[f] = g;
        },
        get: (f) => ht(t, f)
      });
    }
  });
  const dl = Ha({
    fields: FS,
    name: "positioning",
    active: dS,
    apis: LS,
    state: VS
  }), yu = (t) => t.getSystem().isConnected(), Ff = (t) => {
    Ts(t, xf());
    const s = t.components();
    O(s, Ff);
  }, _h = (t) => {
    const s = t.components();
    O(s, _h), Ts(t, Wu());
  }, O0 = (t, s) => {
    t.getSystem().addToWorld(s), Ko(t.element) && _h(s);
  }, Xg = (t) => {
    Ff(t), t.getSystem().removeFromWorld(t);
  }, Jg = (t, s) => {
    Ec(t.element, s.element);
  }, Qg = (t) => {
    O(t.components(), (s) => rl(s.element)), md(t.element), t.syncComponents();
  }, D0 = (t, s, a) => {
    const l = t.components();
    Qg(t);
    const f = a(s), g = ct(l, f);
    O(g, (h) => {
      Ff(h), t.getSystem().removeFromWorld(h);
    }), O(f, (h) => {
      yu(h) ? Jg(t, h) : (t.getSystem().addToWorld(h), Jg(t, h), Ko(t.element) && _h(h));
    }), t.syncComponents();
  }, jS = (t, s, a) => {
    const l = t.components(), f = je(s, (w) => Ly(w).toArray());
    O(l, (w) => {
      Fn(f, w) || Xg(w);
    });
    const g = a(s), h = ct(l, g);
    O(h, (w) => {
      yu(w) && Xg(w);
    }), O(g, (w) => {
      yu(w) || O0(t, w);
    }), t.syncComponents();
  }, Ml = (t, s) => {
    Sb(t, s, Ec);
  }, Sb = (t, s, a) => {
    t.getSystem().addToWorld(s), a(t.element, s.element), Ko(t.element) && _h(s), t.syncComponents();
  }, Pm = (t) => {
    Ff(t), rl(t.element), t.getSystem().removeFromWorld(t);
  }, Nl = (t) => {
    const s = Wr(t.element).bind((a) => t.getSystem().getByDom(a).toOptional());
    Pm(t), s.each((a) => {
      a.syncComponents();
    });
  }, xb = (t) => {
    const s = t.components();
    O(s, Pm), md(t.element), t.syncComponents();
  }, ep = (t, s) => {
    e_(t, s, Ec);
  }, US = (t, s) => {
    e_(t, s, lf);
  }, e_ = (t, s, a) => {
    a(t, s.element);
    const l = aa(s.element);
    O(l, (f) => {
      s.getByDom(f).each(_h);
    });
  }, Ql = (t) => {
    const s = aa(t.element);
    O(s, (a) => {
      t.getByDom(a).each(Ff);
    }), rl(t.element);
  }, fl = (t, s, a, l) => {
    a.get().each((h) => {
      xb(t);
    });
    const f = s.getAttachPoint(t);
    Ml(f, t);
    const g = t.getSystem().build(l);
    return Ml(t, g), a.set(g), g;
  }, za = (t, s, a, l) => {
    const f = fl(t, s, a, l);
    return s.onOpen(t, f), f;
  }, t_ = (t, s, a, l) => a.get().map(() => fl(t, s, a, l)), Fd = (t, s, a, l, f) => {
    R0(t, s), za(t, s, a, l), f(), s_(t, s);
  }, Fm = (t, s, a) => {
    a.get().each((l) => {
      xb(t), Nl(t), s.onClose(t, l), a.clear();
    });
  }, Gi = (t, s, a) => a.isOpen(), n_ = (t, s, a, l) => Gi(t, s, a) && a.get().exists((f) => s.isPartOf(t, f, l)), o_ = (t, s, a) => a.get(), WS = (t, s, a, l) => {
    j(t.element, s).fold(() => {
      nr(t.element, a);
    }, (f) => {
      to(t.element, a, f);
    }), Qt(t.element, s, l);
  }, ZS = (t, s, a) => {
    ha(t.element, a).fold(() => Dt(t.element, s), (l) => Qt(t.element, s, l));
  }, R0 = (t, s, a) => {
    const l = s.getAttachPoint(t);
    Qt(t.element, "position", dl.getMode(l)), WS(t, "visibility", s.cloakVisibilityAttr, "hidden");
  }, qS = (t) => Sn([
    "top",
    "left",
    "right",
    "bottom"
  ], (s) => j(t, s).isSome()), s_ = (t, s, a) => {
    qS(t.element) || Dt(t.element, "position"), ZS(t, "visibility", s.cloakVisibilityAttr);
  };
  var r_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    cloak: R0,
    decloak: s_,
    open: za,
    openWhileCloaked: Fd,
    close: Fm,
    isOpen: Gi,
    isPartOf: n_,
    getState: o_,
    setContent: t_
  }), a_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => Ls([dt(zy(), (a, l) => {
      Fm(a, t, s);
    })])
  }), N0 = [
    Es("onOpen"),
    Es("onClose"),
    ut("isPartOf"),
    ut("getAttachPoint"),
    Te("cloakVisibilityAttr", "data-precloak-visibility")
  ], c_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Ar(), s = oe("not-implemented");
      return Ol({
        readState: s,
        isOpen: t.isSet,
        clear: t.clear,
        set: t.set,
        get: t.get
      });
    }
  });
  const Yo = Ha({
    fields: N0,
    name: "sandboxing",
    active: a_,
    apis: r_,
    state: c_
  }), xi = oe("dismiss.popups"), Id = oe("reposition.popups"), Tb = oe("mouse.released"), GS = gc([
    Te("isExtraPart", Ot),
    zc("fireEventInstead", [Te("event", kg())])
  ]), B0 = (t) => {
    const s = Vc("Dismissal", GS, t);
    return {
      [xi()]: {
        schema: gc([ut("target")]),
        onReceive: (a, l) => {
          Yo.isOpen(a) && (Yo.isPartOf(a, l.target) || s.isExtraPart(a, l.target) || s.fireEventInstead.fold(() => Yo.close(a), (g) => Ts(a, g.event)));
        }
      }
    };
  }, KS = gc([
    zc("fireEventInstead", [Te("event", jk())]),
    xa("doReposition")
  ]), Sh = (t) => {
    const s = Vc("Reposition", KS, t);
    return {
      [Id()]: {
        onReceive: (a) => {
          Yo.isOpen(a) && s.fireEventInstead.fold(() => s.doReposition(a), (l) => Ts(a, l.event));
        }
      }
    };
  }, Ld = (t, s, a) => {
    s.store.manager.onLoad(t, s, a);
  }, tp = (t, s, a) => {
    s.store.manager.onUnload(t, s, a);
  };
  var P0 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: Ld,
    onUnload: tp,
    setValue: (t, s, a, l) => {
      s.store.manager.setValue(t, s, a, l);
    },
    getValue: (t, s, a) => s.store.manager.getValue(t, s, a),
    getState: (t, s, a) => a
  }), Eb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => {
      const a = t.resetOnDom ? [
        kr((l, f) => {
          Ld(l, t, s);
        }),
        Hi((l, f) => {
          tp(l, t, s);
        })
      ] : [fh(t, s, Ld)];
      return Ls(a);
    }
  });
  const Th = () => {
    const t = Xn(null), s = () => ({
      mode: "memory",
      value: t.get()
    }), a = () => t.get() === null, l = () => {
      t.set(null);
    };
    return Ol({
      set: t.set,
      get: t.get,
      isNotSet: a,
      clear: l,
      readState: s
    });
  }, Ab = () => Ol({ readState: ie }), Eh = () => {
    const t = Xn({}), s = Xn({});
    return Ol({
      readState: () => ({
        mode: "dataset",
        dataByValue: t.get(),
        dataByText: s.get()
      }),
      lookup: (h) => ht(t.get(), h).orThunk(() => ht(s.get(), h)),
      update: (h) => {
        const w = t.get(), C = s.get(), T = {}, D = {};
        O(h, ($) => {
          T[$.value] = $, ht($, "meta").each((I) => {
            ht(I, "text").each((V) => {
              D[V] = $;
            });
          });
        }), t.set({
          ...w,
          ...T
        }), s.set({
          ...C,
          ...D
        });
      },
      clear: () => {
        t.set({}), s.set({});
      }
    });
  };
  var F0 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    memory: Th,
    dataset: Eh,
    manual: Ab,
    init: (t) => t.store.manager.state(t)
  });
  const zh = (t, s, a, l) => {
    const f = s.store;
    a.update([l]), f.setValue(t, l), s.onSetValue(t, l);
  }, zb = (t, s, a) => {
    const l = s.store, f = l.getDataKey(t);
    return a.lookup(f).getOrThunk(() => l.getFallbackEntry(f));
  }, l_ = (t, s, a) => {
    s.store.initialValue.each((f) => {
      zh(t, s, a, f);
    });
  }, XS = (t, s, a) => {
    a.clear();
  };
  var i_ = [
    xs("initialValue"),
    ut("getFallbackEntry"),
    ut("getDataKey"),
    ut("setValue"),
    fr("manager", {
      setValue: zh,
      getValue: zb,
      onLoad: l_,
      onUnload: XS,
      state: Eh
    })
  ];
  const JS = (t, s, a) => s.store.getValue(t), Ob = (t, s, a, l) => {
    s.store.setValue(t, l), s.onSetValue(t, l);
  }, u_ = (t, s, a) => {
    s.store.initialValue.each((l) => {
      s.store.setValue(t, l);
    });
  };
  var Oh = [
    ut("getValue"),
    Te("setValue", ie),
    xs("initialValue"),
    fr("manager", {
      setValue: Ob,
      getValue: JS,
      onLoad: u_,
      onUnload: ie,
      state: Vi.init
    })
  ];
  const d_ = (t, s, a, l) => {
    a.set(l), s.onSetValue(t, l);
  }, QS = (t, s, a) => a.get(), ex = (t, s, a) => {
    s.store.initialValue.each((l) => {
      a.isNotSet() && a.set(l);
    });
  }, tx = (t, s, a) => {
    a.clear();
  };
  var nx = [
    xs("initialValue"),
    fr("manager", {
      setValue: d_,
      getValue: QS,
      onLoad: ex,
      onUnload: tx,
      state: Th
    })
  ], np = [
    Uc("store", { mode: "memory" }, rr("mode", {
      memory: nx,
      manual: Oh,
      dataset: i_
    })),
    Es("onSetValue"),
    Te("resetOnDom", !1)
  ];
  const cn = Ha({
    fields: np,
    name: "representing",
    active: Eb,
    apis: P0,
    extra: {
      setValueFrom: (t, s) => {
        const a = cn.getValue(s);
        cn.setValue(t, a);
      }
    },
    state: F0
  }), Oa = (t, s) => qp(t, {}, Xe(s, (a) => E1(a.name(), "Cannot configure " + a.name() + " for " + t)).concat([va("dump", Je)])), Db = (t) => t.dump, Ua = (t, s) => ({
    ...qt(s),
    ...t.dump
  }), Bl = {
    field: Oa,
    augment: Ua,
    get: Db
  }, f_ = "placeholder", Dh = Pa.generate([
    {
      single: [
        "required",
        "valueThunk"
      ]
    },
    {
      multiple: [
        "required",
        "valueThunks"
      ]
    }
  ]), Rb = (t) => qn(t, "uiType"), I0 = (t, s, a, l) => t.exists((f) => f !== a.owner) ? Dh.single(!0, oe(a)) : ht(l, a.name).fold(() => {
    throw new Error("Unknown placeholder component: " + a.name + `
Known: [` + mn(l) + `]
Namespace: ` + t.getOr("none") + `
Spec: ` + JSON.stringify(a, null, 2));
  }, (f) => f.replace()), Mb = (t, s, a, l) => Rb(a) && a.uiType === f_ ? I0(t, s, a, l) : Dh.single(!1, oe(a)), Nb = (t, s, a, l) => Mb(t, s, a, l).fold((g, h) => {
    const w = Rb(a) ? h(s, a.config, a.validated) : h(s), C = ht(w, "components").getOr([]), T = je(C, (D) => Nb(t, s, D, l));
    return [{
      ...w,
      components: T
    }];
  }, (g, h) => {
    if (Rb(a)) {
      const w = h(s, a.config, a.validated);
      return a.validated.preprocess.getOr(Je)(w);
    } else
      return h(s);
  }), L0 = (t, s, a, l) => je(a, (f) => Nb(t, s, f, l)), m_ = (t, s) => {
    let a = !1;
    const l = () => a, f = () => {
      if (a)
        throw new Error("Trying to use the same placeholder more than once: " + t);
      return a = !0, s;
    }, g = () => s.fold((h, w) => h, (h, w) => h);
    return {
      name: oe(t),
      required: g,
      used: l,
      replace: f
    };
  }, g_ = (t, s, a, l) => {
    const f = Ln(l, (h, w) => m_(w, h)), g = L0(t, s, a, f);
    return ro(f, (h) => {
      if (h.used() === !1 && h.required())
        throw new Error("Placeholder: " + h.name() + ` was not found in components list
Namespace: ` + t.getOr("none") + `
Components: ` + JSON.stringify(s.components, null, 2));
    }), g;
  }, H0 = Dh.single, p_ = Dh.multiple, V0 = oe(f_), Bb = Pa.generate([
    { required: ["data"] },
    { external: ["data"] },
    { optional: ["data"] },
    { group: ["data"] }
  ]), op = Te("factory", { sketch: Je }), Tn = Te("schema", []), bu = ut("name"), j0 = ba("pname", "pname", gf((t) => "<alloy." + $n(t.name) + ">"), tc()), h_ = va("schema", () => [xs("preprocess")]), Im = Te("defaults", oe({})), If = Te("overrides", oe({})), sp = Pn([
    op,
    Tn,
    bu,
    j0,
    Im,
    If
  ]), y_ = Pn([
    op,
    Tn,
    bu,
    Im,
    If
  ]), ox = Pn([
    op,
    Tn,
    bu,
    j0,
    Im,
    If
  ]), sx = Pn([
    op,
    h_,
    bu,
    ut("unit"),
    j0,
    Im,
    If
  ]), Rh = (t) => t.fold(z.some, z.none, z.some, z.some), $b = (t) => {
    const s = (a) => a.name;
    return t.fold(s, s, s, s);
  }, Mh = (t) => t.fold(Je, Je, Je, Je), Lf = (t, s) => (a) => {
    const l = Vc("Converting part type", s, a);
    return t(l);
  }, Cc = Lf(Bb.required, sp), Ki = Lf(Bb.external, y_), vu = Lf(Bb.optional, ox), ku = Lf(Bb.group, sx), Pb = oe("entirety");
  var rx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    required: Cc,
    external: Ki,
    optional: vu,
    group: ku,
    asNamedPart: Rh,
    name: $b,
    asCommon: Mh,
    original: Pb
  });
  const Nh = (t, s, a, l) => sr(s.defaults(t, a, l), a, { uid: t.partUids[s.name] }, s.overrides(t, a, l)), ax = (t, s, a) => {
    const l = {}, f = {};
    return O(a, (g) => {
      g.fold((h) => {
        l[h.pname] = H0(!0, (w, C, T) => h.factory.sketch(Nh(w, h, C, T)));
      }, (h) => {
        const w = s.parts[h.name];
        f[h.name] = oe(h.factory.sketch(Nh(s, h, w[Pb()]), w));
      }, (h) => {
        l[h.pname] = H0(!1, (w, C, T) => h.factory.sketch(Nh(w, h, C, T)));
      }, (h) => {
        l[h.pname] = p_(!0, (w, C, T) => {
          const D = w[h.name];
          return Xe(D, ($) => h.factory.sketch(sr(h.defaults(w, $, T), $, h.overrides(w, $))));
        });
      });
    }), {
      internals: oe(l),
      externals: oe(f)
    };
  }, U0 = (t, s) => {
    const a = {};
    return O(s, (l) => {
      Rh(l).each((f) => {
        const g = W0(t, f.pname);
        a[f.name] = (h) => {
          const w = Vc("Part: " + f.name + " in " + t, Pn(f.schema), h);
          return {
            ...g,
            config: h,
            validated: w
          };
        };
      });
    }), a;
  }, W0 = (t, s) => ({
    uiType: V0(),
    owner: t,
    name: s
  }), b_ = (t, s, a) => ({
    uiType: V0(),
    owner: t,
    name: s,
    config: a,
    validated: {}
  }), cx = (t) => je(t, (s) => s.fold(z.none, z.some, z.none, z.none).map((a) => Fi(a.name, a.schema.concat([uw(Pb())]))).toArray()), v_ = (t) => Xe(t, $b), Z0 = (t, s, a) => ax(t, s, a), q0 = (t, s, a) => g_(z.some(t), s, s.components, a), Ds = (t, s, a) => {
    const l = s.partUids[a];
    return t.getSystem().getByUid(l).toOptional();
  }, Ti = (t, s, a) => Ds(t, s, a).getOrDie("Could not find part: " + a), k_ = (t, s, a) => {
    const l = {}, f = s.partUids, g = t.getSystem();
    return O(a, (h) => {
      l[h] = oe(g.getByUid(f[h]));
    }), l;
  }, w_ = (t, s) => {
    const a = t.getSystem();
    return Ln(s.partUids, (l, f) => oe(a.getByUid(l)));
  }, __ = (t) => mn(t.partUids), G0 = (t, s, a) => {
    const l = {}, f = s.partUids, g = t.getSystem();
    return O(a, (h) => {
      l[h] = oe(g.getByUid(f[h]).getOrDie());
    }), l;
  }, C_ = (t, s) => {
    const a = v_(s);
    return Ze(Xe(a, (l) => ({
      key: l,
      value: t + "-" + l
    })));
  }, Fb = (t) => ba("partUids", "partUids", cu((s) => C_(s.uid, t)), tc());
  var lx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generate: U0,
    generateOne: b_,
    schemas: cx,
    names: v_,
    substitutes: Z0,
    components: q0,
    defaultUids: C_,
    defaultUidsSchema: Fb,
    getAllParts: w_,
    getAllPartNames: __,
    getPart: Ds,
    getPartOrDie: Ti,
    getParts: k_,
    getPartsOrDie: G0
  });
  const rp = (t, s) => (t.length > 0 ? [Fi("parts", t)] : []).concat([
    ut("uid"),
    Te("dom", {}),
    Te("components", []),
    uw("originalSpec"),
    Te("debug.sketcher", {})
  ]).concat(s), Bh = (t, s, a, l, f) => {
    const g = rp(l, f);
    return Vc(t + " [SpecSchema]", gc(g.concat(s)), a);
  }, ix = (t, s, a, l) => {
    const f = Hf(l), g = Bh(t, s, f, [], []);
    return a(g, f);
  }, Ib = (t, s, a, l, f) => {
    const g = Hf(f), h = cx(a), w = Fb(a), C = Bh(t, s, g, h, [w]), T = Z0(t, C, a), D = q0(t, C, T.internals());
    return l(C, D, g, T.externals());
  }, ap = (t) => qn(t, "uid"), Hf = (t) => ap(t) ? t : {
    ...t,
    uid: Ks("uid")
  }, K0 = (t) => t.uid !== void 0, ux = gc([
    ut("name"),
    ut("factory"),
    ut("configFields"),
    Te("apis", {}),
    Te("extraApis", {})
  ]), Ei = gc([
    ut("name"),
    ut("factory"),
    ut("configFields"),
    ut("partFields"),
    Te("apis", {}),
    Te("extraApis", {})
  ]), Wa = (t) => {
    const s = Vc("Sketcher for " + t.name, ux, t), a = (g) => ix(s.name, s.configFields, s.factory, g), l = Ln(s.apis, oh), f = Ln(s.extraApis, (g, h) => Yl(g, h));
    return {
      name: s.name,
      configFields: s.configFields,
      sketch: a,
      ...l,
      ...f
    };
  }, Jc = (t) => {
    const s = Vc("Sketcher for " + t.name, Ei, t), a = (h) => Ib(s.name, s.configFields, s.partFields, s.factory, h), l = U0(s.name, s.partFields), f = Ln(s.apis, oh), g = Ln(s.extraApis, (h, w) => Yl(h, w));
    return {
      name: s.name,
      partFields: s.partFields,
      configFields: s.configFields,
      sketch: a,
      parts: l,
      ...f,
      ...g
    };
  }, wu = (t) => zo("input")(t) && Vo(t, "type") !== "radio" || zo("textarea")(t);
  var Y0 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCurrent: (t, s, a) => s.find(t)
  });
  const dx = [ut("find")], cs = Ha({
    fields: dx,
    name: "composing",
    apis: Y0
  }), S_ = [
    "input",
    "button",
    "textarea",
    "select"
  ], x_ = (t, s, a) => {
    (s.disabled() ? T_ : Q0)(t, s);
  }, X0 = (t, s) => s.useNative === !0 && Fn(S_, zt(t.element)), J0 = (t) => Vl(t.element, "disabled"), Lb = (t) => {
    to(t.element, "disabled", "disabled");
  }, Hb = (t) => {
    nr(t.element, "disabled");
  }, Vb = (t) => Vo(t.element, "aria-disabled") === "true", jb = (t) => {
    to(t.element, "aria-disabled", "true");
  }, cp = (t) => {
    to(t.element, "aria-disabled", "false");
  }, T_ = (t, s, a) => {
    s.disableClass.each((f) => {
      Ea(t.element, f);
    }), (X0(t, s) ? Lb : jb)(t), s.onDisabled(t);
  }, Q0 = (t, s, a) => {
    s.disableClass.each((f) => {
      Yr(t.element, f);
    }), (X0(t, s) ? Hb : cp)(t), s.onEnabled(t);
  }, E_ = (t, s) => X0(t, s) ? J0(t) : Vb(t);
  var fx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enable: Q0,
    disable: T_,
    isDisabled: E_,
    onLoad: x_,
    set: (t, s, a, l) => {
      (l ? T_ : Q0)(t, s);
    }
  }), k7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, s) => Ku({ classes: s.disabled() ? s.disableClass.toArray() : [] }),
    events: (t, s) => Ls([
      qu(Kl(), (a, l) => E_(a, t)),
      fh(t, s, x_)
    ])
  }), e5 = [
    Fr("disabled", Ot),
    Te("useNative", !0),
    xs("disableClass"),
    Es("onDisabled"),
    Es("onEnabled")
  ];
  const ao = Ha({
    fields: e5,
    name: "disabling",
    active: k7,
    apis: fx
  }), ev = (t, s, a, l) => {
    const f = Mc(t.element, "." + s.highlightClass);
    O(f, (g) => {
      Sn(l, (h) => h.element === g) || (Yr(g, s.highlightClass), t.getSystem().getByDom(g).each((h) => {
        s.onDehighlight(t, h), Ts(h, Yp());
      }));
    });
  }, gx = (t, s, a) => ev(t, s, a, []), px = (t, s, a, l) => {
    Wb(t, s, a, l) && (Yr(l.element, s.highlightClass), s.onDehighlight(t, l), Ts(l, Yp()));
  }, Ub = (t, s, a, l) => {
    ev(t, s, a, [l]), Wb(t, s, a, l) || (Ea(l.element, s.highlightClass), s.onHighlight(t, l), Ts(l, Kp()));
  }, $h = (t, s, a) => {
    ov(t, s).each((l) => {
      Ub(t, s, a, l);
    });
  }, hx = (t, s, a) => {
    Ph(t, s).each((l) => {
      Ub(t, s, a, l);
    });
  }, yx = (t, s, a, l) => {
    nv(t, s, a, l).fold((f) => {
      throw f;
    }, (f) => {
      Ub(t, s, a, f);
    });
  }, z_ = (t, s, a, l) => {
    const f = rv(t, s);
    Oe(f, l).each((h) => {
      Ub(t, s, a, h);
    });
  }, Wb = (t, s, a, l) => oc(l.element, s.highlightClass), tv = (t, s, a) => sc(t.element, "." + s.highlightClass).bind((l) => t.getSystem().getByDom(l).toOptional()), nv = (t, s, a, l) => {
    const f = Mc(t.element, "." + s.itemClass);
    return z.from(f[l]).fold(() => yo.error(new Error("No element found with index " + l)), t.getSystem().getByDom);
  }, ov = (t, s, a) => sc(t.element, "." + s.itemClass).bind((l) => t.getSystem().getByDom(l).toOptional()), Ph = (t, s, a) => {
    const l = Mc(t.element, "." + s.itemClass);
    return (l.length > 0 ? z.some(l[l.length - 1]) : z.none()).bind((g) => t.getSystem().getByDom(g).toOptional());
  }, sv = (t, s, a, l) => {
    const f = Mc(t.element, "." + s.itemClass);
    return ae(f, (h) => oc(h, s.highlightClass)).bind((h) => {
      const w = Pg(h, l, 0, f.length - 1);
      return t.getSystem().getByDom(f[w]).toOptional();
    });
  }, O_ = (t, s, a) => sv(t, s, a, -1), Zb = (t, s, a) => sv(t, s, a, 1), rv = (t, s, a) => {
    const l = Mc(t.element, "." + s.itemClass);
    return hr(Xe(l, (f) => t.getSystem().getByDom(f).toOptional()));
  };
  var bx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    dehighlightAll: gx,
    dehighlight: px,
    highlight: Ub,
    highlightFirst: $h,
    highlightLast: hx,
    highlightAt: yx,
    highlightBy: z_,
    isHighlighted: Wb,
    getHighlighted: tv,
    getFirst: ov,
    getLast: Ph,
    getPrevious: O_,
    getNext: Zb,
    getCandidates: rv
  }), vx = [
    ut("highlightClass"),
    ut("itemClass"),
    Es("onHighlight"),
    Es("onDehighlight")
  ];
  const Hs = Ha({
    fields: vx,
    name: "highlighting",
    apis: bx
  }), av = [8], Ai = [9], _u = [13], Fh = [27], Qc = [32], qb = [37], lp = [38], Gb = [39], ip = [40], D_ = (t, s, a) => {
    const l = ue(t.slice(0, s)), f = ue(t.slice(s + 1));
    return Oe(l.concat(f), a);
  }, t5 = (t, s, a) => {
    const l = ue(t.slice(0, s));
    return Oe(l, a);
  }, n5 = (t, s, a) => {
    const l = t.slice(0, s), f = t.slice(s + 1);
    return Oe(f.concat(l), a);
  }, o5 = (t, s, a) => {
    const l = t.slice(s + 1);
    return Oe(l, a);
  }, ls = (t) => (s) => {
    const a = s.raw;
    return Fn(t, a.which);
  }, Cu = (t) => (s) => ke(t, (a) => a(s)), up = (t) => t.raw.shiftKey === !0, cv = (t) => t.raw.ctrlKey === !0, Vf = Q(up), gs = (t, s) => ({
    matches: t,
    classification: s
  }), s5 = (t, s) => Oe(t, (l) => l.matches(s)).map((l) => l.classification), lv = (t, s, a) => {
    s.exists((f) => a.exists((g) => Lo(g, f))) || no(t, Uk(), {
      prevFocus: s,
      newFocus: a
    });
  }, iv = () => {
    const t = (a) => _i(a.element);
    return {
      get: t,
      set: (a, l) => {
        const f = t(a);
        a.getSystem().triggerFocus(l, a.element);
        const g = t(a);
        lv(a, f, g);
      }
    };
  }, kx = () => {
    const t = (a) => Hs.getHighlighted(a).map((l) => l.element);
    return {
      get: t,
      set: (a, l) => {
        const f = t(a);
        a.getSystem().getByDom(l).fold(ie, (h) => {
          Hs.highlight(a, h);
        });
        const g = t(a);
        lv(a, f, g);
      }
    };
  };
  var ml;
  (function(t) {
    t.OnFocusMode = "onFocus", t.OnEnterOrSpaceMode = "onEnterOrSpace", t.OnApiMode = "onApi";
  })(ml || (ml = {}));
  const Lm = (t, s, a, l, f) => {
    const g = () => t.concat([
      Te("focusManager", iv()),
      Uc("focusInside", "onFocus", kf((T) => Fn([
        "onFocus",
        "onEnterOrSpace",
        "onApi"
      ], T) ? yo.value(T) : yo.error("Invalid value for focusInside"))),
      fr("handler", C),
      fr("state", s),
      fr("sendFocusIn", f)
    ]), h = (T, D, $, I, V) => {
      const ne = $(T, D, I, V);
      return s5(ne, D.event).bind((pe) => pe(T, D, I, V));
    }, C = {
      schema: g,
      processKey: h,
      toEvents: (T, D) => {
        const $ = T.focusInside !== ml.OnFocusMode ? z.none() : f(T).map((ne) => dt(du(), (pe, Le) => {
          ne(pe, T, D), Le.stop();
        })), I = (ne, pe) => {
          const Le = ls(Qc.concat(_u))(pe.event);
          T.focusInside === ml.OnEnterOrSpaceMode && Le && vr(ne, pe) && f(T).each((he) => {
            he(ne, T, D), pe.stop();
          });
        }, V = [
          dt(xd(), (ne, pe) => {
            h(ne, pe, a, T, D).fold(() => {
              I(ne, pe);
            }, (Le) => {
              pe.stop();
            });
          }),
          dt(Li(), (ne, pe) => {
            h(ne, pe, l, T, D).each((Le) => {
              pe.stop();
            });
          })
        ];
        return Ls($.toArray().concat(V));
      }
    };
    return C;
  }, i = (t) => {
    const s = [
      xs("onEscape"),
      xs("onEnter"),
      Te("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
      Te("firstTabstop", 0),
      Te("useTabstopAt", Se),
      xs("visibilitySelector")
    ].concat([t]), a = (pe, Le) => {
      const he = pe.visibilitySelector.bind((at) => Wi(Le, at)).getOr(Le);
      return hs(he) > 0;
    }, l = (pe, Le) => {
      const he = Mc(pe.element, Le.selector), at = Pt(he, (kn) => a(Le, kn));
      return z.from(at[Le.firstTabstop]);
    }, f = (pe, Le) => Le.focusManager.get(pe).bind((he) => Wi(he, Le.selector)), g = (pe, Le) => a(pe, Le) && pe.useTabstopAt(Le), h = (pe, Le, he) => {
      l(pe, Le).each((at) => {
        Le.focusManager.set(pe, at);
      });
    }, w = (pe, Le, he, at, kn) => kn(Le, he, (et) => g(at, et)).fold(() => at.cyclic ? z.some(!0) : z.none(), (et) => (at.focusManager.set(pe, et), z.some(!0))), C = (pe, Le, he, at) => {
      const kn = Mc(pe.element, he.selector);
      return f(pe, he).bind((et) => ae(kn, lt(Lo, et)).bind((xn) => w(pe, kn, xn, he, at)));
    }, T = (pe, Le, he) => {
      const at = he.cyclic ? D_ : t5;
      return C(pe, Le, he, at);
    }, D = (pe, Le, he) => {
      const at = he.cyclic ? n5 : o5;
      return C(pe, Le, he, at);
    }, $ = (pe, Le, he) => he.onEnter.bind((at) => at(pe, Le)), I = (pe, Le, he) => he.onEscape.bind((at) => at(pe, Le)), V = oe([
      gs(Cu([
        up,
        ls(Ai)
      ]), T),
      gs(ls(Ai), D),
      gs(Cu([
        Vf,
        ls(_u)
      ]), $)
    ]), ne = oe([gs(ls(Fh), I)]);
    return Lm(s, Vi.init, V, ne, () => z.some(h));
  };
  var d = i(va("cyclic", Ot)), p = i(va("cyclic", Se));
  const b = (t, s, a) => (Xp(t, a, Kl()), z.some(!0)), _ = (t, s, a) => wu(a) && ls(Qc)(s.event) ? z.none() : b(t, s, a), A = (t, s) => z.some(!0), N = [
    Te("execute", _),
    Te("useSpace", !1),
    Te("useEnter", !0),
    Te("useControlEnter", !1),
    Te("useDown", !1)
  ], L = (t, s, a) => a.execute(t, s, t.element), Y = (t, s, a, l) => {
    const f = a.useSpace && !wu(t.element) ? Qc : [], g = a.useEnter ? _u : [], h = a.useDown ? ip : [], w = f.concat(g).concat(h);
    return [gs(ls(w), L)].concat(a.useControlEnter ? [gs(Cu([
      cv,
      ls(_u)
    ]), L)] : []);
  }, de = (t, s, a, l) => a.useSpace && !wu(t.element) ? [gs(ls(Qc), A)] : [];
  var Ee = Lm(N, Vi.init, Y, de, () => z.none());
  const yt = () => {
    const t = Ar();
    return Ol({
      readState: () => t.get().map((f) => ({
        numRows: String(f.numRows),
        numColumns: String(f.numColumns)
      })).getOr({
        numRows: "?",
        numColumns: "?"
      }),
      setGridSize: (f, g) => {
        t.set({
          numRows: f,
          numColumns: g
        });
      },
      getNumRows: () => t.get().map((f) => f.numRows),
      getNumColumns: () => t.get().map((f) => f.numColumns)
    });
  };
  var It = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    flatgrid: yt,
    init: (t) => t.state(t)
  });
  const st = (t) => (s, a, l, f) => {
    const g = t(s.element);
    return co(g, s, a, l, f);
  }, Wt = (t, s) => {
    const a = $d(t, s);
    return st(a);
  }, ot = (t, s) => {
    const a = $d(s, t);
    return st(a);
  }, gn = (t) => (s, a, l, f) => co(t, s, a, l, f), co = (t, s, a, l, f) => l.focusManager.get(s).bind((h) => t(s.element, h, l, f)).map((h) => (l.focusManager.set(s, h), !0)), Mo = gn, Sr = gn, da = gn, xr = (t) => t.offsetWidth <= 0 && t.offsetHeight <= 0, gl = (t) => !xr(t.dom), dp = (t, s) => ae(t, s).map((a) => ({
    index: a,
    candidates: t
  })), fp = (t, s, a) => {
    const l = (h) => Lo(h, s), f = Mc(t, a), g = Pt(f, gl);
    return dp(g, l);
  }, uv = (t, s) => ae(t, (a) => Lo(s, a)), Ih = (t, s, a, l) => {
    const f = Math.floor(s / a), g = s % a;
    return l(f, g).bind((h) => {
      const w = h.row * a + h.column;
      return w >= 0 && w < t.length ? z.some(t[w]) : z.none();
    });
  }, Ys = (t, s, a, l, f) => Ih(t, s, l, (g, h) => {
    const C = g === a - 1 ? t.length - g * l : l, T = Pg(h, f, 0, C - 1);
    return z.some({
      row: g,
      column: T
    });
  }), Sc = (t, s, a, l, f) => Ih(t, s, l, (g, h) => {
    const w = Pg(g, f, 0, a - 1), T = w === a - 1 ? t.length - w * l : l, D = ki(h, 0, T - 1);
    return z.some({
      row: w,
      column: D
    });
  }), Nc = (t, s, a, l) => Ys(t, s, a, l, 1), Yi = (t, s, a, l) => Ys(t, s, a, l, -1), zi = (t, s, a, l) => Sc(t, s, a, l, -1), mp = (t, s, a, l) => Sc(t, s, a, l, 1), xc = [
    ut("selector"),
    Te("execute", _),
    il("onEscape"),
    Te("captureTab", !1),
    Y1()
  ], dv = (t, s, a) => {
    sc(t.element, s.selector).each((l) => {
      s.focusManager.set(t, l);
    });
  }, Lh = (t, s) => s.focusManager.get(t).bind((a) => Wi(a, s.selector)), od = (t, s, a, l) => Lh(t, a).bind((f) => a.execute(t, s, f)), _a = (t) => (s, a, l, f) => fp(s, a, l.selector).bind((g) => t(g.candidates, g.index, f.getNumRows().getOr(l.initSize.numRows), f.getNumColumns().getOr(l.initSize.numColumns))), R_ = (t, s, a) => a.captureTab ? z.some(!0) : z.none(), wx = (t, s, a) => a.onEscape(t, s), M_ = _a(Yi), fv = _a(Nc), _x = _a(zi), mv = _a(mp), N_ = oe([
    gs(ls(qb), Wt(M_, fv)),
    gs(ls(Gb), ot(M_, fv)),
    gs(ls(lp), Mo(_x)),
    gs(ls(ip), Sr(mv)),
    gs(Cu([
      up,
      ls(Ai)
    ]), R_),
    gs(Cu([
      Vf,
      ls(Ai)
    ]), R_),
    gs(ls(Qc.concat(_u)), od)
  ]), Hh = oe([
    gs(ls(Fh), wx),
    gs(ls(Qc), A)
  ]);
  var w7 = Lm(xc, yt, N_, Hh, () => z.some(dv));
  const Vh = (t, s, a, l) => {
    const f = (h) => zt(h) === "button" && Vo(h, "disabled") === "disabled", g = (h, w, C) => {
      const T = Pg(w, l, 0, C.length - 1);
      return T === h ? z.none() : f(C[T]) ? g(h, T, C) : z.from(C[T]);
    };
    return fp(t, a, s).bind((h) => {
      const w = h.index, C = h.candidates;
      return g(w, w, C);
    });
  }, _7 = [
    ut("selector"),
    Te("getInitial", z.none),
    Te("execute", _),
    il("onEscape"),
    Te("executeOnMove", !1),
    Te("allowVertical", !0)
  ], r5 = (t, s) => s.focusManager.get(t).bind((a) => Wi(a, s.selector)), pl = (t, s, a) => r5(t, a).bind((l) => a.execute(t, s, l)), C7 = (t, s, a) => {
    s.getInitial(t).orThunk(() => sc(t.element, s.selector)).each((l) => {
      s.focusManager.set(t, l);
    });
  }, Cx = (t, s, a) => Vh(t, a.selector, s, -1), a5 = (t, s, a) => Vh(t, a.selector, s, 1), c5 = (t) => (s, a, l, f) => t(s, a, l, f).bind(() => l.executeOnMove ? pl(s, a, l) : z.some(!0)), l5 = (t, s, a) => a.onEscape(t, s), S7 = (t, s, a, l) => {
    const f = qb.concat(a.allowVertical ? lp : []), g = Gb.concat(a.allowVertical ? ip : []);
    return [
      gs(ls(f), c5(Wt(Cx, a5))),
      gs(ls(g), c5(ot(Cx, a5))),
      gs(ls(_u), pl),
      gs(ls(Qc), pl)
    ];
  }, x7 = oe([
    gs(ls(Qc), A),
    gs(ls(Fh), l5)
  ]);
  var T7 = Lm(_7, Vi.init, S7, x7, () => z.some(C7));
  const B_ = (t, s, a) => z.from(t[s]).bind((l) => z.from(l[a]).map((f) => ({
    rowIndex: s,
    columnIndex: a,
    cell: f
  }))), i5 = (t, s, a, l) => {
    const g = t[s].length, h = Pg(a, l, 0, g - 1);
    return B_(t, s, h);
  }, Sx = (t, s, a, l) => {
    const f = Pg(a, l, 0, t.length - 1), g = t[f].length, h = ki(s, 0, g - 1);
    return B_(t, f, h);
  }, xx = (t, s, a, l) => {
    const g = t[s].length, h = ki(a + l, 0, g - 1);
    return B_(t, s, h);
  }, Tx = (t, s, a, l) => {
    const f = ki(a + l, 0, t.length - 1), g = t[f].length, h = ki(s, 0, g - 1);
    return B_(t, f, h);
  }, gp = (t, s, a) => i5(t, s, a, 1), u5 = (t, s, a) => i5(t, s, a, -1), d5 = (t, s, a) => Sx(t, a, s, -1), Ex = (t, s, a) => Sx(t, a, s, 1), E7 = (t, s, a) => xx(t, s, a, -1), A7 = (t, s, a) => xx(t, s, a, 1), z7 = (t, s, a) => Tx(t, a, s, -1), O7 = (t, s, a) => Tx(t, a, s, 1), f5 = [
    Fi("selectors", [
      ut("row"),
      ut("cell")
    ]),
    Te("cycles", !0),
    Te("previousSelector", z.none),
    Te("execute", _)
  ], Ax = (t, s, a) => {
    s.previousSelector(t).orThunk(() => {
      const f = s.selectors;
      return sc(t.element, f.cell);
    }).each((f) => {
      s.focusManager.set(t, f);
    });
  }, zx = (t, s, a) => _i(t.element).bind((l) => a.execute(t, s, l)), D7 = (t, s) => Xe(t, (a) => Mc(a, s.selectors.cell)), Hd = (t, s) => (a, l, f) => {
    const g = f.cycles ? t : s;
    return Wi(l, f.selectors.row).bind((h) => {
      const w = Mc(h, f.selectors.cell);
      return uv(w, l).bind((C) => {
        const T = Mc(a, f.selectors.row);
        return uv(T, h).bind((D) => {
          const $ = D7(T, f);
          return g($, D, C).map((I) => I.cell);
        });
      });
    });
  }, Ox = Hd(u5, E7), Dx = Hd(gp, A7), R7 = Hd(d5, z7), M7 = Hd(Ex, O7), gv = oe([
    gs(ls(qb), Wt(Ox, Dx)),
    gs(ls(Gb), ot(Ox, Dx)),
    gs(ls(lp), Mo(R7)),
    gs(ls(ip), Sr(M7)),
    gs(ls(Qc.concat(_u)), zx)
  ]), pv = oe([gs(ls(Qc), A)]);
  var m5 = Lm(f5, Vi.init, gv, pv, () => z.some(Ax));
  const g5 = [
    ut("selector"),
    Te("execute", _),
    Te("moveOnTab", !1)
  ], Hm = (t, s, a) => a.focusManager.get(t).bind((l) => a.execute(t, s, l)), pp = (t, s, a) => {
    sc(t.element, s.selector).each((l) => {
      s.focusManager.set(t, l);
    });
  }, p5 = (t, s, a) => Vh(t, a.selector, s, -1), h5 = (t, s, a) => Vh(t, a.selector, s, 1), y5 = (t, s, a, l) => a.moveOnTab ? da(p5)(t, s, a, l) : z.none(), Vm = (t, s, a, l) => a.moveOnTab ? da(h5)(t, s, a, l) : z.none(), Rx = oe([
    gs(ls(lp), da(p5)),
    gs(ls(ip), da(h5)),
    gs(Cu([
      up,
      ls(Ai)
    ]), y5),
    gs(Cu([
      Vf,
      ls(Ai)
    ]), Vm),
    gs(ls(_u), Hm),
    gs(ls(Qc), Hm)
  ]), b5 = oe([gs(ls(Qc), A)]);
  var v5 = Lm(g5, Vi.init, Rx, b5, () => z.some(pp));
  const k5 = [
    il("onSpace"),
    il("onEnter"),
    il("onShiftEnter"),
    il("onLeft"),
    il("onRight"),
    il("onTab"),
    il("onShiftTab"),
    il("onUp"),
    il("onDown"),
    il("onEscape"),
    Te("stopSpaceKeyup", !1),
    xs("focusIn")
  ], Mx = (t, s, a) => [
    gs(ls(Qc), a.onSpace),
    gs(Cu([
      Vf,
      ls(_u)
    ]), a.onEnter),
    gs(Cu([
      up,
      ls(_u)
    ]), a.onShiftEnter),
    gs(Cu([
      up,
      ls(Ai)
    ]), a.onShiftTab),
    gs(Cu([
      Vf,
      ls(Ai)
    ]), a.onTab),
    gs(ls(lp), a.onUp),
    gs(ls(ip), a.onDown),
    gs(ls(qb), a.onLeft),
    gs(ls(Gb), a.onRight),
    gs(ls(Qc), a.onSpace)
  ], w5 = (t, s, a) => [
    ...a.stopSpaceKeyup ? [gs(ls(Qc), A)] : [],
    gs(ls(Fh), a.onEscape)
  ];
  var N7 = Lm(k5, Vi.init, Mx, w5, (t) => t.focusIn);
  const B7 = d.schema(), $7 = p.schema(), $_ = T7.schema(), Nx = w7.schema(), Bx = m5.schema(), P7 = Ee.schema(), F7 = v5.schema(), _5 = N7.schema();
  var C5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    acyclic: B7,
    cyclic: $7,
    flow: $_,
    flatgrid: Nx,
    matrix: Bx,
    execution: P7,
    menu: F7,
    special: _5
  });
  const S5 = (t) => pr(t, "setGridSize"), Kn = Cw({
    branchKey: "mode",
    branches: C5,
    name: "keying",
    active: {
      events: (t, s) => t.handler.toEvents(t, s)
    },
    apis: {
      focusIn: (t, s, a) => {
        s.sendFocusIn(s).fold(() => {
          t.getSystem().triggerFocus(t.element, t.element);
        }, (l) => {
          l(t, s, a);
        });
      },
      setGridSize: (t, s, a, l, f) => {
        S5(a) ? a.setGridSize(l, f) : console.error("Layout does not support setGridSize");
      }
    },
    state: It
  }), x5 = (t, s) => {
    r0(() => {
      D0(t, s, () => Xe(s, t.getSystem().build));
    }, t.element);
  }, P_ = (t, s) => {
    r0(() => {
      jS(t, s, () => KC(t.element, s, t.getSystem().buildOrPatch));
    }, t.element);
  }, I7 = (t, s, a, l) => {
    Xg(s);
    const f = Uy(t.element, a, l, t.getSystem().buildOrPatch);
    O0(t, f), t.syncComponents();
  }, $x = (t, s, a) => {
    const l = t.getSystem().build(a);
    Sb(t, l, s);
  }, L7 = (t, s, a, l) => {
    Nl(s), $x(t, (f, g) => Qr(f, g, a), l);
  }, H7 = (t, s, a, l) => (s.reuseDom ? P_ : x5)(t, l), V7 = (t, s, a, l) => {
    $x(t, Ec, l);
  }, j7 = (t, s, a, l) => {
    $x(t, uf, l);
  }, U7 = (t, s, a, l) => {
    const f = jh(t);
    Oe(f, (h) => Lo(l.element, h.element)).each(Nl);
  }, jh = (t, s) => t.components(), T5 = (t, s, a, l, f) => {
    const g = jh(t);
    return z.from(g[l]).map((h) => (f.fold(() => Nl(h), (w) => {
      (s.reuseDom ? I7 : L7)(t, h, l, w);
    }), h));
  };
  var E5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    append: V7,
    prepend: j7,
    remove: U7,
    replaceAt: T5,
    replaceBy: (t, s, a, l, f) => {
      const g = jh(t);
      return ae(g, l).bind((h) => T5(t, s, a, h, f));
    },
    set: H7,
    contents: jh
  });
  const Uo = Ha({
    fields: [Oc("reuseDom", !0)],
    name: "replacing",
    apis: E5
  }), W7 = (t, s) => {
    const a = Ls(s);
    return Ha({
      fields: [ut("enabled")],
      name: t,
      active: { events: oe(a) }
    });
  }, ys = (t, s) => {
    const a = W7(t, s);
    return {
      key: t,
      value: {
        config: {},
        me: a,
        configAsRaw: oe({}),
        initialConfig: {},
        state: Vi
      }
    };
  }, A5 = (t, s) => {
    s.ignore || (Xu(t.element), s.onFocus(t));
  };
  var Z7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: A5,
    blur: (t, s) => {
      s.ignore || fS(t.element);
    },
    isFocused: (t) => Am(t.element)
  }), F_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, s) => {
      const a = s.ignore ? {} : { attributes: { tabindex: "-1" } };
      return Ku(a);
    },
    events: (t) => Ls([dt(du(), (s, a) => {
      A5(s, t), a.stop();
    })].concat(t.stopMousedown ? [dt(ql(), (s, a) => {
      a.event.prevent();
    })] : []))
  }), Fx = [
    Es("onFocus"),
    Te("stopMousedown", !1),
    Te("ignore", !1)
  ];
  const go = Ha({
    fields: Fx,
    name: "focusing",
    active: F_,
    apis: Z7
  }), G7 = (t) => ({ init: () => {
    const a = Xn(t);
    return {
      get: () => a.get(),
      set: (w) => a.set(w),
      clear: () => a.set(t),
      readState: () => a.get()
    };
  } }), K7 = (t, s, a) => {
    const l = s.aria;
    l.update(t, l, a.get());
  }, Y7 = (t, s, a) => {
    s.toggleClass.each((l) => {
      a.get() ? Ea(t.element, l) : Yr(t.element, l);
    });
  }, hv = (t, s, a, l) => {
    const f = a.get();
    a.set(l), Y7(t, s, a), K7(t, s, a), f !== l && s.onToggled(t, l);
  }, Ix = (t, s, a) => {
    hv(t, s, a, !a.get());
  }, z5 = (t, s, a) => {
    hv(t, s, a, !0);
  }, X7 = (t, s, a) => {
    hv(t, s, a, !1);
  }, J7 = (t, s, a) => a.get(), O5 = (t, s, a) => {
    hv(t, s, a, s.selected);
  };
  var Q7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: O5,
    toggle: Ix,
    isOn: J7,
    on: z5,
    off: X7,
    set: hv
  }), D5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: () => Ku({}),
    events: (t, s) => {
      const a = kw(t, s, Ix), l = fh(t, s, O5);
      return Ls(X([
        t.toggleOnExecute ? [a] : [],
        [l]
      ]));
    }
  });
  const eR = (t, s, a) => {
    to(t.element, "aria-pressed", a), s.syncWithExpanded && R5(t, s, a);
  }, tR = (t, s, a) => {
    to(t.element, "aria-selected", a);
  }, nR = (t, s, a) => {
    to(t.element, "aria-checked", a);
  }, R5 = (t, s, a) => {
    to(t.element, "aria-expanded", a);
  };
  var oR = [
    Te("selected", !1),
    xs("toggleClass"),
    Te("toggleOnExecute", !0),
    Es("onToggled"),
    Uc("aria", { mode: "none" }, rr("mode", {
      pressed: [
        Te("syncWithExpanded", !1),
        fr("update", eR)
      ],
      checked: [fr("update", nR)],
      expanded: [fr("update", R5)],
      selected: [fr("update", tR)],
      none: [fr("update", ie)]
    }))
  ];
  const Qo = Ha({
    fields: oR,
    name: "toggling",
    active: D5,
    apis: Q7,
    state: G7(!1)
  }), M5 = () => {
    const t = (s, a) => {
      a.stop(), Zu(s);
    };
    return [
      dt(yg(), t),
      dt(bg(), t),
      Ad(Wc()),
      Ad(ql())
    ];
  }, I_ = (t) => {
    const s = (a) => zd((l, f) => {
      a(l), f.stop();
    });
    return Ls(X([
      t.map(s).toArray(),
      M5()
    ]));
  }, hp = "alloy.item-hover", N5 = "alloy.item-focus", B5 = "alloy.item-toggled", jm = (t) => {
    (_i(t.element).isNone() || go.isFocused(t)) && (go.isFocused(t) || go.focus(t), no(t, hp, { item: t }));
  }, $5 = (t) => {
    no(t, N5, { item: t });
  }, sR = (t, s) => {
    no(t, B5, {
      item: t,
      state: s
    });
  }, Xi = oe(hp), P5 = oe(N5), F5 = oe(B5), I5 = (t) => t.toggling.map((s) => s.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), Lx = (t) => ({
    aria: { mode: "checked" },
    ...we(t, (s, a) => a !== "exclusive"),
    onToggled: (s, a) => {
      At(t.onToggled) && t.onToggled(s, a), sR(s, a);
    }
  }), rR = (t) => ({
    dom: t.dom,
    domModification: {
      ...t.domModification,
      attributes: {
        role: I5(t),
        ...t.domModification.attributes,
        "aria-haspopup": t.hasSubmenu,
        ...t.hasSubmenu ? { "aria-expanded": !1 } : {}
      }
    },
    behaviours: Bl.augment(t.itemBehaviours, [
      t.toggling.fold(Qo.revoke, (s) => Qo.config(Lx(s))),
      go.config({
        ignore: t.ignoreFocus,
        stopMousedown: t.ignoreFocus,
        onFocus: (s) => {
          $5(s);
        }
      }),
      Kn.config({ mode: "execution" }),
      cn.config({
        store: {
          mode: "memory",
          initialValue: t.data
        }
      }),
      ys("item-type-events", [
        ...M5(),
        dt(Br(), jm),
        dt(ta(), go.focus)
      ])
    ]),
    components: t.components,
    eventOrder: t.eventOrder
  }), aR = [
    ut("data"),
    ut("components"),
    ut("dom"),
    Te("hasSubmenu", !1),
    xs("toggling"),
    Bl.field("itemBehaviours", [
      Qo,
      go,
      Kn,
      cn
    ]),
    Te("ignoreFocus", !1),
    Te("domModification", {}),
    fr("builder", rR),
    Te("eventOrder", {})
  ], cR = (t) => ({
    dom: t.dom,
    components: t.components,
    events: Ls([N1(ta())])
  }), L_ = [
    ut("dom"),
    ut("components"),
    fr("builder", cR)
  ], yv = oe("item-widget"), Hx = oe([Cc({
    name: "widget",
    overrides: (t) => ({
      behaviours: qt([cn.config({
        store: {
          mode: "manual",
          getValue: (s) => t.data,
          setValue: ie
        }
      })])
    })
  })]), L5 = (t) => {
    const s = Z0(yv(), t, Hx()), a = q0(yv(), t, s.internals()), l = (g) => Ds(g, t, "widget").map((h) => (Kn.focusIn(h), h)), f = (g, h) => wu(h.event.target) ? z.none() : (() => (t.autofocus && h.setSource(g.element), z.none()))();
    return {
      dom: t.dom,
      components: a,
      domModification: t.domModification,
      events: Ls([
        zd((g, h) => {
          l(g).each((w) => {
            h.stop();
          });
        }),
        dt(Br(), jm),
        dt(ta(), (g, h) => {
          t.autofocus ? l(g) : go.focus(g);
        })
      ]),
      behaviours: Bl.augment(t.widgetBehaviours, [
        cn.config({
          store: {
            mode: "memory",
            initialValue: t.data
          }
        }),
        go.config({
          ignore: t.ignoreFocus,
          onFocus: (g) => {
            $5(g);
          }
        }),
        Kn.config({
          mode: "special",
          focusIn: t.autofocus ? (g) => {
            l(g);
          } : uS(),
          onLeft: f,
          onRight: f,
          onEscape: (g, h) => !go.isFocused(g) && !t.autofocus ? (go.focus(g), z.some(!0)) : (t.autofocus && h.setSource(g.element), z.none())
        })
      ])
    };
  }, H5 = [
    ut("uid"),
    ut("data"),
    ut("components"),
    ut("dom"),
    Te("autofocus", !1),
    Te("ignoreFocus", !1),
    Bl.field("widgetBehaviours", [
      cn,
      go,
      Kn
    ]),
    Te("domModification", {}),
    Fb(Hx()),
    fr("builder", L5)
  ], lR = rr("type", {
    widget: H5,
    item: aR,
    separator: L_
  }), Vx = (t, s) => ({
    mode: "flatgrid",
    selector: "." + t.markers.item,
    initSize: {
      numColumns: s.initSize.numColumns,
      numRows: s.initSize.numRows
    },
    focusManager: t.focusManager
  }), iR = (t, s) => ({
    mode: "matrix",
    selectors: {
      row: s.rowSelector,
      cell: "." + t.markers.item
    },
    focusManager: t.focusManager
  }), jx = (t, s) => ({
    mode: "menu",
    selector: "." + t.markers.item,
    moveOnTab: s.moveOnTab,
    focusManager: t.focusManager
  }), uR = oe([ku({
    factory: {
      sketch: (t) => {
        const s = Vc("menu.spec item", lR, t);
        return s.builder(s);
      }
    },
    name: "items",
    unit: "item",
    defaults: (t, s) => qn(s, "uid") ? s : {
      ...s,
      uid: Ks("item")
    },
    overrides: (t, s) => ({
      type: s.type,
      ignoreFocus: t.fakeFocus,
      domModification: { classes: [t.markers.item] }
    })
  })]), bv = oe([
    ut("value"),
    ut("items"),
    ut("dom"),
    ut("components"),
    Te("eventOrder", {}),
    Oa("menuBehaviours", [
      Hs,
      cn,
      cs,
      Kn
    ]),
    Uc("movement", {
      mode: "menu",
      moveOnTab: !0
    }, rr("mode", {
      grid: [
        Y1(),
        fr("config", Vx)
      ],
      matrix: [
        fr("config", iR),
        ut("rowSelector")
      ],
      menu: [
        Te("moveOnTab", !0),
        fr("config", jx)
      ]
    })),
    K1(),
    Te("fakeFocus", !1),
    Te("focusManager", iv()),
    Es("onHighlight")
  ]), vv = oe("alloy.menu-focus"), V5 = (t, s) => {
    const a = Mc(t.element, '[role="menuitemradio"][aria-checked="true"]');
    O(a, (l) => {
      Lo(l, s.element) || t.getSystem().getByDom(l).each((f) => {
        Qo.off(f);
      });
    });
  }, j5 = (t, s, a, l) => ({
    uid: t.uid,
    dom: t.dom,
    markers: t.markers,
    behaviours: Ua(t.menuBehaviours, [
      Hs.config({
        highlightClass: t.markers.selectedItem,
        itemClass: t.markers.item,
        onHighlight: t.onHighlight
      }),
      cn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      }),
      cs.config({ find: z.some }),
      Kn.config(t.movement.config(t, t.movement))
    ]),
    events: Ls([
      dt(P5(), (f, g) => {
        const h = g.event;
        f.getSystem().getByDom(h.target).each((w) => {
          Hs.highlight(f, w), g.stop(), no(f, vv(), {
            menu: f,
            item: w
          });
        });
      }),
      dt(Xi(), (f, g) => {
        const h = g.event.item;
        Hs.highlight(f, h);
      }),
      dt(F5(), (f, g) => {
        const { item: h, state: w } = g.event;
        w && Vo(h.element, "role") === "menuitemradio" && V5(f, h);
      })
    ]),
    components: s,
    eventOrder: t.eventOrder,
    domModification: { attributes: { role: "menu" } }
  }), Uh = Jc({
    name: "Menu",
    configFields: bv(),
    partFields: uR(),
    factory: j5
  }), dR = (t) => Go(t, (s, a) => ({
    k: s,
    v: a
  })), U5 = (t, s, a, l) => ht(a, l).bind((f) => ht(t, f).bind((g) => {
    const h = U5(t, s, a, g);
    return z.some([g].concat(h));
  })).getOr([]), fR = (t, s) => {
    const a = {};
    ro(t, (h, w) => {
      O(h, (C) => {
        a[C] = w;
      });
    });
    const l = s, f = dR(s), g = Ln(f, (h, w) => [w].concat(U5(a, l, f, w)));
    return Ln(a, (h) => ht(g, h).getOr([h]));
  }, Ux = () => {
    const t = Xn({}), s = Xn({}), a = Xn({}), l = Ar(), f = Xn({}), g = () => {
      t.set({}), s.set({}), a.set({}), l.clear();
    }, h = () => l.get().isNone(), w = (hn, xn) => {
      s.set({
        ...s.get(),
        [hn]: {
          type: "prepared",
          menu: xn
        }
      });
    }, C = (hn, xn, Cn, oo) => {
      l.set(hn), t.set(Cn), s.set(xn), f.set(oo);
      const so = fR(oo, Cn);
      a.set(so);
    }, T = (hn) => Vt(t.get(), (xn, Cn) => xn === hn), D = (hn, xn, Cn) => pe(hn).bind((oo) => T(hn).bind((so) => xn(so).map((us) => ({
      triggeredMenu: oo,
      triggeringItem: us,
      triggeringPath: Cn
    })))), $ = (hn, xn) => {
      const Cn = Pt(he(hn).toArray(), (oo) => pe(oo).isSome());
      return ht(a.get(), hn).bind((oo) => {
        const so = ue(Cn.concat(oo)), us = je(so, (Ms, jn) => D(Ms, xn, so.slice(0, jn + 1)).fold(() => zr(l.get(), Ms) ? [] : [z.none()], (zs) => [z.some(zs)]));
        return Fs(us);
      });
    }, I = (hn) => ht(t.get(), hn).map((xn) => {
      const Cn = ht(a.get(), hn).getOr([]);
      return [xn].concat(Cn);
    }), V = (hn) => ht(a.get(), hn).bind((xn) => xn.length > 1 ? z.some(xn.slice(1)) : z.none()), ne = (hn) => ht(a.get(), hn), pe = (hn) => Le(hn).bind(Wx), Le = (hn) => ht(s.get(), hn), he = (hn) => ht(t.get(), hn);
    return {
      setMenuBuilt: w,
      setContents: C,
      expand: I,
      refresh: ne,
      collapse: V,
      lookupMenu: Le,
      lookupItem: he,
      otherMenus: (hn) => {
        const xn = f.get();
        return ct(mn(xn), hn);
      },
      getPrimary: () => l.get().bind(pe),
      getMenus: () => s.get(),
      clear: g,
      isClear: h,
      getTriggeringPath: $
    };
  }, Wx = (t) => t.type === "prepared" ? z.some(t.menu) : z.none(), Zx = {
    init: Ux,
    extractPreparedMenu: Wx
  }, qx = (t, s) => {
    const a = Ar(), l = (Mt, Nn, wo) => Ln(wo, (ts, ar) => {
      const jr = () => Uh.sketch({
        ...ts,
        value: ar,
        markers: t.markers,
        fakeFocus: t.fakeFocus,
        onHighlight: t.onHighlight,
        focusManager: t.fakeFocus ? kx() : iv()
      });
      return ar === Nn ? {
        type: "prepared",
        menu: Mt.getSystem().build(jr())
      } : {
        type: "notbuilt",
        nbMenu: jr
      };
    }), f = Zx.init(), g = (Mt) => {
      const Nn = l(Mt, t.data.primary, t.data.menus), wo = C();
      return f.setContents(t.data.primary, Nn, t.data.expansions, wo), f.getPrimary();
    }, h = (Mt) => cn.getValue(Mt).value, w = (Mt, Nn, wo) => Ho(Nn, (ts) => {
      if (!ts.getSystem().isConnected())
        return z.none();
      const ar = Hs.getCandidates(ts);
      return Oe(ar, (jr) => h(jr) === wo);
    }), C = (Mt) => Ln(t.data.menus, (Nn, wo) => je(Nn.items, (ts) => ts.type === "separator" ? [] : [ts.data.value])), T = (Mt, Nn) => {
      Hs.highlight(Mt, Nn), Hs.getHighlighted(Nn).orThunk(() => Hs.getFirst(Nn)).each((wo) => {
        Xp(Mt, wo.element, ta());
      });
    }, D = (Mt, Nn) => hr(Xe(Nn, (wo) => Mt.lookupMenu(wo).bind((ts) => ts.type === "prepared" ? z.some(ts.menu) : z.none()))), $ = (Mt, Nn, wo) => {
      const ts = D(Nn, Nn.otherMenus(wo));
      O(ts, (ar) => {
        qc(ar.element, [t.markers.backgroundMenu]), t.stayInDom || Uo.remove(Mt, ar);
      });
    }, I = (Mt) => a.get().getOrThunk(() => {
      const Nn = {}, wo = Mc(Mt.element, `.${t.markers.item}`), ts = Pt(wo, (ar) => Vo(ar, "aria-haspopup") === "true");
      return O(ts, (ar) => {
        Mt.getSystem().getByDom(ar).each((jr) => {
          const Ru = h(jr);
          Nn[Ru] = jr;
        });
      }), a.set(Nn), Nn;
    }), V = (Mt, Nn) => {
      const wo = I(Mt);
      ro(wo, (ts, ar) => {
        const jr = Fn(Nn, ar);
        to(ts.element, "aria-expanded", jr);
      });
    }, ne = (Mt, Nn, wo) => z.from(wo[0]).bind((ts) => Nn.lookupMenu(ts).bind((ar) => {
      if (ar.type === "notbuilt")
        return z.none();
      {
        const jr = ar.menu, Ru = D(Nn, wo.slice(1));
        return O(Ru, (of) => {
          Ea(of.element, t.markers.backgroundMenu);
        }), Ko(jr.element) || Uo.append(Mt, bi(jr)), qc(jr.element, [t.markers.backgroundMenu]), T(Mt, jr), $(Mt, Nn, wo), z.some(jr);
      }
    }));
    let pe;
    (function(Mt) {
      Mt[Mt.HighlightSubmenu = 0] = "HighlightSubmenu", Mt[Mt.HighlightParent = 1] = "HighlightParent";
    })(pe || (pe = {}));
    const Le = (Mt, Nn, wo) => {
      if (wo.type === "notbuilt") {
        const ts = Mt.getSystem().build(wo.nbMenu());
        return f.setMenuBuilt(Nn, ts), ts;
      } else
        return wo.menu;
    }, he = (Mt, Nn, wo = pe.HighlightSubmenu) => {
      if (Nn.hasConfigured(ao) && ao.isDisabled(Nn))
        return z.some(Nn);
      {
        const ts = h(Nn);
        return f.expand(ts).bind((ar) => (V(Mt, ar), z.from(ar[0]).bind((jr) => f.lookupMenu(jr).bind((Ru) => {
          const of = Le(Mt, jr, Ru);
          return Ko(of.element) || Uo.append(Mt, bi(of)), t.onOpenSubmenu(Mt, Nn, of, ue(ar)), wo === pe.HighlightSubmenu ? (Hs.highlightFirst(of), ne(Mt, f, ar)) : (Hs.dehighlightAll(of), z.some(Nn));
        }))));
      }
    }, at = (Mt, Nn) => {
      const wo = h(Nn);
      return f.collapse(wo).bind((ts) => (V(Mt, ts), ne(Mt, f, ts).map((ar) => (t.onCollapseMenu(Mt, Nn, ar), ar))));
    }, kn = (Mt, Nn) => {
      const wo = h(Nn);
      return f.refresh(wo).bind((ts) => (V(Mt, ts), ne(Mt, f, ts)));
    }, et = (Mt, Nn) => wu(Nn.element) ? z.none() : he(Mt, Nn, pe.HighlightSubmenu), hn = (Mt, Nn) => wu(Nn.element) ? z.none() : at(Mt, Nn), xn = (Mt, Nn) => at(Mt, Nn).orThunk(() => t.onEscape(Mt, Nn).map(() => Mt)), Cn = (Mt) => (Nn, wo) => Wi(wo.getSource(), "." + t.markers.item).bind((ts) => Nn.getSystem().getByDom(ts).toOptional().bind((ar) => Mt(Nn, ar).map(Se))), oo = Ls([
      dt(vv(), (Mt, Nn) => {
        const wo = Nn.event.item;
        f.lookupItem(h(wo)).each(() => {
          const ts = Nn.event.menu;
          Hs.highlight(Mt, ts);
          const ar = h(Nn.event.item);
          f.refresh(ar).each((jr) => $(Mt, f, jr));
        });
      }),
      zd((Mt, Nn) => {
        const wo = Nn.event.target;
        Mt.getSystem().getByDom(wo).each((ts) => {
          h(ts).indexOf("collapse-item") === 0 && at(Mt, ts), he(Mt, ts, pe.HighlightSubmenu).fold(() => {
            t.onExecute(Mt, ts);
          }, ie);
        });
      }),
      kr((Mt, Nn) => {
        g(Mt).each((wo) => {
          Uo.append(Mt, bi(wo)), t.onOpenMenu(Mt, wo), t.highlightImmediately && T(Mt, wo);
        });
      })
    ].concat(t.navigateOnHover ? [dt(Xi(), (Mt, Nn) => {
      const wo = Nn.event.item;
      kn(Mt, wo), he(Mt, wo, pe.HighlightParent), t.onHover(Mt, wo);
    })] : [])), so = (Mt) => Hs.getHighlighted(Mt).bind(Hs.getHighlighted), us = (Mt) => {
      so(Mt).each((Nn) => {
        at(Mt, Nn);
      });
    }, Ms = (Mt) => {
      f.getPrimary().each((Nn) => {
        T(Mt, Nn);
      });
    }, jn = (Mt) => z.from(Mt.components()[0]).filter((Nn) => Vo(Nn.element, "role") === "menu"), io = {
      collapseMenu: us,
      highlightPrimary: Ms,
      repositionMenus: (Mt) => {
        f.getPrimary().bind((wo) => so(Mt).bind((ts) => {
          const ar = h(ts), jr = Jt(f.getMenus()), Ru = hr(Xe(jr, Zx.extractPreparedMenu));
          return f.getTriggeringPath(ar, (of) => w(Mt, Ru, of));
        }).map((ts) => ({
          primary: wo,
          triggeringPath: ts
        }))).fold(() => {
          jn(Mt).each((wo) => {
            t.onRepositionMenu(Mt, wo, []);
          });
        }, ({ primary: wo, triggeringPath: ts }) => {
          t.onRepositionMenu(Mt, wo, ts);
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      markers: t.markers,
      behaviours: Ua(t.tmenuBehaviours, [
        Kn.config({
          mode: "special",
          onRight: Cn(et),
          onLeft: Cn(hn),
          onEscape: Cn(xn),
          focusIn: (Mt, Nn) => {
            f.getPrimary().each((wo) => {
              Xp(Mt, wo.element, ta());
            });
          }
        }),
        Hs.config({
          highlightClass: t.markers.selectedMenu,
          itemClass: t.markers.menu
        }),
        cs.config({
          find: (Mt) => Hs.getHighlighted(Mt)
        }),
        Uo.config({})
      ]),
      eventOrder: t.eventOrder,
      apis: io,
      events: oo
    };
  }, mR = oe("collapse-item"), W5 = (t, s, a) => ({
    primary: t,
    menus: s,
    expansions: a
  }), gR = (t, s) => ({
    primary: t,
    menus: ge(t, s),
    expansions: {}
  }), pR = (t) => ({
    value: $n(mR()),
    meta: { text: t }
  }), Wh = Wa({
    name: "TieredMenu",
    configFields: [
      Rc("onExecute"),
      Rc("onEscape"),
      Ng("onOpenMenu"),
      Ng("onOpenSubmenu"),
      Es("onRepositionMenu"),
      Es("onCollapseMenu"),
      Te("highlightImmediately", !0),
      Fi("data", [
        ut("primary"),
        ut("menus"),
        ut("expansions")
      ]),
      Te("fakeFocus", !1),
      Es("onHighlight"),
      Es("onHover"),
      Mg(),
      ut("dom"),
      Te("navigateOnHover", !0),
      Te("stayInDom", !1),
      Oa("tmenuBehaviours", [
        Kn,
        Hs,
        cs,
        Uo
      ]),
      Te("eventOrder", {})
    ],
    apis: {
      collapseMenu: (t, s) => {
        t.collapseMenu(s);
      },
      highlightPrimary: (t, s) => {
        t.highlightPrimary(s);
      },
      repositionMenus: (t, s) => {
        t.repositionMenus(s);
      }
    },
    factory: qx,
    extraApis: {
      tieredData: W5,
      singleData: gR,
      collapseItem: pR
    }
  }), Z5 = (t, s, a, l, f) => {
    const g = () => t.lazySink(s), h = l.type === "horizontal" ? {
      layouts: {
        onLtr: () => Ig(),
        onRtl: () => tb()
      }
    } : {}, w = (T) => T.length === 2, C = (T) => w(T) ? h : {};
    return Wh.sketch({
      dom: { tag: "div" },
      data: l.data,
      markers: l.menu.markers,
      highlightImmediately: l.menu.highlightImmediately,
      fakeFocus: l.menu.fakeFocus,
      onEscape: () => (Yo.close(s), t.onEscape.map((T) => T(s)), z.some(!0)),
      onExecute: () => z.some(!0),
      onOpenMenu: (T, D) => {
        dl.positionWithinBounds(g().getOrDie(), D, a, f());
      },
      onOpenSubmenu: (T, D, $, I) => {
        const V = g().getOrDie();
        dl.position(V, $, {
          anchor: {
            type: "submenu",
            item: D,
            ...C(I)
          }
        });
      },
      onRepositionMenu: (T, D, $) => {
        const I = g().getOrDie();
        dl.positionWithinBounds(I, D, a, f()), O($, (V) => {
          const ne = C(V.triggeringPath);
          dl.position(I, V.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: V.triggeringItem,
              ...ne
            }
          });
        });
      }
    });
  }, hR = (t, s) => {
    const a = (V, ne) => t.getRelated(V).exists((Le) => Md(Le, ne)), l = (V, ne) => {
      Yo.setContent(V, ne);
    }, f = (V, ne, pe) => {
      g(V, ne, pe, z.none());
    }, g = (V, ne, pe, Le) => {
      h(V, ne, pe, () => Le.map((he) => Or(he)));
    }, h = (V, ne, pe, Le) => {
      const he = t.lazySink(V).getOrDie();
      Yo.openWhileCloaked(V, ne, () => dl.positionWithinBounds(he, V, pe, Le())), cn.setValue(V, z.some({
        mode: "position",
        config: pe,
        getBounds: Le
      }));
    }, w = (V, ne, pe) => {
      C(V, ne, pe, z.none);
    }, C = (V, ne, pe, Le) => {
      const he = Z5(t, V, ne, pe, Le);
      Yo.open(V, he), cn.setValue(V, z.some({
        mode: "menu",
        menu: he
      }));
    }, T = (V) => {
      Yo.isOpen(V) && (cn.setValue(V, z.none()), Yo.close(V));
    }, D = (V) => Yo.getState(V), $ = (V) => {
      Yo.isOpen(V) && cn.getValue(V).each((ne) => {
        switch (ne.mode) {
          case "menu":
            Yo.getState(V).each(Wh.repositionMenus);
            break;
          case "position":
            const pe = t.lazySink(V).getOrDie();
            dl.positionWithinBounds(pe, V, ne.config, ne.getBounds());
            break;
        }
      });
    }, I = {
      setContent: l,
      showAt: f,
      showWithin: g,
      showWithinBounds: h,
      showMenuAt: w,
      showMenuWithinBounds: C,
      hide: T,
      getContent: D,
      reposition: $,
      isOpen: Yo.isOpen
    };
    return {
      uid: t.uid,
      dom: t.dom,
      behaviours: Ua(t.inlineBehaviours, [
        Yo.config({
          isPartOf: (V, ne, pe) => Md(ne, pe) || a(V, pe),
          getAttachPoint: (V) => t.lazySink(V).getOrDie(),
          onOpen: (V) => {
            t.onShow(V);
          },
          onClose: (V) => {
            t.onHide(V);
          }
        }),
        cn.config({
          store: {
            mode: "memory",
            initialValue: z.none()
          }
        }),
        wi.config({
          channels: {
            ...B0({
              isExtraPart: s.isExtraPart,
              ...t.fireDismissalEventInstead.map((V) => ({ fireEventInstead: { event: V.event } })).getOr({})
            }),
            ...Sh({
              ...t.fireRepositionEventInstead.map((V) => ({ fireEventInstead: { event: V.event } })).getOr({}),
              doReposition: $
            })
          }
        })
      ]),
      eventOrder: t.eventOrder,
      apis: I
    };
  }, na = Wa({
    name: "InlineView",
    configFields: [
      ut("lazySink"),
      Es("onShow"),
      Es("onHide"),
      _f("onEscape"),
      Oa("inlineBehaviours", [
        Yo,
        cn,
        wi
      ]),
      zc("fireDismissalEventInstead", [Te("event", kg())]),
      zc("fireRepositionEventInstead", [Te("event", jk())]),
      Te("getRelated", z.none),
      Te("isExtraPart", Ot),
      Te("eventOrder", z.none)
    ],
    factory: hR,
    apis: {
      showAt: (t, s, a, l) => {
        t.showAt(s, a, l);
      },
      showWithin: (t, s, a, l, f) => {
        t.showWithin(s, a, l, f);
      },
      showWithinBounds: (t, s, a, l, f) => {
        t.showWithinBounds(s, a, l, f);
      },
      showMenuAt: (t, s, a, l) => {
        t.showMenuAt(s, a, l);
      },
      showMenuWithinBounds: (t, s, a, l, f) => {
        t.showMenuWithinBounds(s, a, l, f);
      },
      hide: (t, s) => {
        t.hide(s);
      },
      isOpen: (t, s) => t.isOpen(s),
      getContent: (t, s) => t.getContent(s),
      setContent: (t, s, a) => {
        t.setContent(s, a);
      },
      reposition: (t, s) => {
        t.reposition(s);
      }
    }
  });
  var Kb = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const $l = Wa({
    name: "Button",
    factory: (t) => {
      const s = I_(t.action), a = t.dom.tag, l = (g) => ht(t.dom, "attributes").bind((h) => ht(h, g)), f = () => {
        if (a === "button") {
          const g = l("type").getOr("button"), h = l("role").map((w) => ({ role: w })).getOr({});
          return {
            type: g,
            ...h
          };
        } else
          return { role: l("role").getOr("button") };
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: t.components,
        events: s,
        behaviours: Bl.augment(t.buttonBehaviours, [
          go.config({}),
          Kn.config({
            mode: "execution",
            useSpace: !0,
            useEnter: !0
          })
        ]),
        domModification: { attributes: f() },
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Te("uid", void 0),
      ut("dom"),
      Te("components", []),
      Bl.field("buttonBehaviours", [
        go,
        Kn
      ]),
      xs("action"),
      xs("role"),
      Te("eventOrder", {})
    ]
  }), wr = (t) => {
    const s = K0(t) && pr(t, "uid") ? t.uid : Ks("memento");
    return {
      get: (g) => g.getSystem().getByUid(s).getOrDie(),
      getOpt: (g) => g.getSystem().getByUid(s).toOptional(),
      asSpec: () => ({
        ...t,
        uid: s
      })
    };
  };
  var Su = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const bR = {
    indent: !0,
    outdent: !0,
    "table-insert-column-after": !0,
    "table-insert-column-before": !0,
    "paste-column-after": !0,
    "paste-column-before": !0,
    "unordered-list": !0,
    "list-bull-circle": !0,
    "list-bull-default": !0,
    "list-bull-square": !0
  }, q5 = "temporary-placeholder", Gx = (t) => () => ht(t, q5).getOr("!not found!"), Kx = (t, s) => {
    const a = t.toLowerCase();
    if (Su.isRtl()) {
      const l = Ur(a, "-rtl");
      return qn(s, l) ? l : a;
    } else
      return a;
  }, G5 = (t, s) => ht(s, Kx(t, s)), Yx = (t, s) => {
    const a = s();
    return G5(t, a).getOrThunk(Gx(a));
  }, Xx = (t, s, a) => {
    const l = s();
    return G5(t, l).or(a).getOrThunk(Gx(l));
  }, vR = (t) => Su.isRtl() ? qn(bR, t) : !1, Yb = () => ys("add-focusable", [kr((t) => {
    eS(t.element, "svg").each((s) => to(s, "focusable", "false"));
  })]), K5 = (t, s, a, l) => {
    var f, g;
    const h = vR(s) ? ["tox-icon--flip"] : [], w = ht(a, Kx(s, a)).or(l).getOrThunk(Gx(a));
    return {
      dom: {
        tag: t.tag,
        attributes: (f = t.attributes) !== null && f !== void 0 ? f : {},
        classes: t.classes.concat(h),
        innerHtml: w
      },
      behaviours: qt([
        ...(g = t.behaviours) !== null && g !== void 0 ? g : [],
        Yb()
      ])
    };
  }, Vd = (t, s, a, l = z.none()) => K5(s, t, a(), l), kR = (t, s, a) => {
    const l = a(), f = Oe(t, (g) => qn(l, Kx(g, l)));
    return K5(s, f.getOr(q5), l, z.none());
  }, wR = {
    success: "checkmark",
    error: "warning",
    err: "error",
    warning: "warning",
    warn: "warning",
    info: "info"
  }, Jx = Wa({
    name: "Notification",
    factory: (t) => {
      const s = wr({
        dom: {
          tag: "p",
          innerHtml: t.translationProvider(t.text)
        },
        behaviours: qt([Uo.config({})])
      }), a = (V) => ({
        dom: {
          tag: "div",
          classes: ["tox-bar"],
          styles: { width: `${V}%` }
        }
      }), l = (V) => ({
        dom: {
          tag: "div",
          classes: ["tox-text"],
          innerHtml: `${V}%`
        }
      }), f = wr({
        dom: {
          tag: "div",
          classes: t.progress ? [
            "tox-progress-bar",
            "tox-progress-indicator"
          ] : ["tox-progress-bar"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-bar-container"]
            },
            components: [a(0)]
          },
          l(0)
        ],
        behaviours: qt([Uo.config({})])
      }), w = {
        updateProgress: (V, ne) => {
          V.getSystem().isConnected() && f.getOpt(V).each((pe) => {
            Uo.set(pe, [
              {
                dom: {
                  tag: "div",
                  classes: ["tox-bar-container"]
                },
                components: [a(ne)]
              },
              l(ne)
            ]);
          });
        },
        updateText: (V, ne) => {
          if (V.getSystem().isConnected()) {
            const pe = s.get(V);
            Uo.set(pe, [wa(ne)]);
          }
        }
      }, C = X([
        t.icon.toArray(),
        t.level.toArray(),
        t.level.bind((V) => z.from(wR[V])).toArray()
      ]), T = wr($l.sketch({
        dom: {
          tag: "button",
          classes: [
            "tox-notification__dismiss",
            "tox-button",
            "tox-button--naked",
            "tox-button--icon"
          ]
        },
        components: [Vd("close", {
          tag: "div",
          classes: ["tox-icon"],
          attributes: { "aria-label": t.translationProvider("Close") }
        }, t.iconProvider)],
        action: (V) => {
          t.onAction(V);
        }
      })), D = kR(C, {
        tag: "div",
        classes: ["tox-notification__icon"]
      }, t.iconProvider), $ = {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"]
        },
        components: [s.asSpec()],
        behaviours: qt([Uo.config({})])
      }, I = [
        D,
        $
      ];
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: { role: "alert" },
          classes: t.level.map((V) => [
            "tox-notification",
            "tox-notification--in",
            `tox-notification--${V}`
          ]).getOr([
            "tox-notification",
            "tox-notification--in"
          ])
        },
        behaviours: qt([
          go.config({}),
          ys("notification-events", [dt(Ta(), (V) => {
            T.getOpt(V).each(go.focus);
          })])
        ]),
        components: I.concat(t.progress ? [f.asSpec()] : []).concat(t.closeButton ? [T.asSpec()] : []),
        apis: w
      };
    },
    configFields: [
      xs("level"),
      ut("progress"),
      ut("icon"),
      ut("onAction"),
      ut("text"),
      ut("iconProvider"),
      ut("translationProvider"),
      Oc("closeButton", !0)
    ],
    apis: {
      updateProgress: (t, s, a) => {
        t.updateProgress(s, a);
      },
      updateText: (t, s, a) => {
        t.updateText(s, a);
      }
    }
  });
  var Y5 = (t, s, a) => {
    const l = s.backstage.shared, f = () => {
      const C = Or(bt.fromDom(t.getContentAreaContainer())), T = ui(), D = ki(T.x, C.x, C.right), $ = ki(T.y, C.y, C.bottom), I = Math.max(C.right, T.right), V = Math.max(C.bottom, T.bottom);
      return z.some(ws(D, $, I - D, V - $));
    };
    return {
      open: (C, T) => {
        const D = () => {
          T(), na.hide(I);
        }, $ = bc(Jx.sketch({
          text: C.text,
          level: Fn([
            "success",
            "error",
            "warning",
            "warn",
            "info"
          ], C.type) ? C.type : void 0,
          progress: C.progressBar === !0,
          icon: z.from(C.icon),
          closeButton: C.closeButton,
          onAction: D,
          iconProvider: l.providers.icons,
          translationProvider: l.providers.translate
        })), I = bc(na.sketch({
          dom: {
            tag: "div",
            classes: ["tox-notifications-container"]
          },
          lazySink: l.getSink,
          fireDismissalEventInstead: {},
          ...l.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} }
        }));
        a.add(I), C.timeout > 0 && Kb.setEditorTimeout(t, () => {
          D();
        }, C.timeout);
        const ne = {
          close: D,
          reposition: () => {
            const pe = bi($), Le = { maxHeightFunction: Lg() }, he = t.notificationManager.getNotifications();
            if (he[0] === ne) {
              const at = {
                ...l.anchors.banner(),
                overrides: Le
              };
              na.showWithinBounds(I, pe, { anchor: at }, f);
            } else
              _o(he, ne).each((at) => {
                const kn = he[at - 1].getEl(), et = {
                  type: "node",
                  root: js(),
                  node: z.some(bt.fromDom(kn)),
                  overrides: Le,
                  layouts: {
                    onRtl: () => [ua],
                    onLtr: () => [ua]
                  }
                };
                na.showWithinBounds(I, pe, { anchor: et }, f);
              });
          },
          text: (pe) => {
            Jx.updateText($, pe);
          },
          settings: C,
          getEl: () => $.element.dom,
          progressBar: {
            value: (pe) => {
              Jx.updateProgress($, pe);
            }
          }
        };
        return ne;
      },
      close: (C) => {
        C.close();
      },
      getArgs: (C) => C.settings
    };
  }, kv = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), _R = tinymce.util.Tools.resolve("tinymce.EditorManager"), yp = tinymce.util.Tools.resolve("tinymce.Env"), hl;
  (function(t) {
    t.default = "wrap", t.floating = "floating", t.sliding = "sliding", t.scrolling = "scrolling";
  })(hl || (hl = {}));
  var Zh;
  (function(t) {
    t.auto = "auto", t.top = "top", t.bottom = "bottom";
  })(Zh || (Zh = {}));
  const _r = (t) => (s) => s.options.get(t), wv = (t) => (s) => z.from(t(s)), Qx = (t) => {
    const s = yp.deviceType.isPhone(), a = yp.deviceType.isTablet() || s, l = t.options.register, f = (h) => Kt(h) || h === !1, g = (h) => Kt(h) || He(h);
    l("skin", {
      processor: (h) => Kt(h) || h === !1,
      default: "oxide"
    }), l("skin_url", { processor: "string" }), l("height", {
      processor: g,
      default: Math.max(t.getElement().offsetHeight, 400)
    }), l("width", {
      processor: g,
      default: kv.DOM.getStyle(t.getElement(), "width")
    }), l("min_height", {
      processor: "number",
      default: 100
    }), l("min_width", { processor: "number" }), l("max_height", { processor: "number" }), l("max_width", { processor: "number" }), l("style_formats", { processor: "object[]" }), l("style_formats_merge", {
      processor: "boolean",
      default: !1
    }), l("style_formats_autohide", {
      processor: "boolean",
      default: !1
    }), l("line_height_formats", {
      processor: "string",
      default: "1 1.1 1.2 1.3 1.4 1.5 2"
    }), l("font_family_formats", {
      processor: "string",
      default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
    }), l("font_size_formats", {
      processor: "string",
      default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
    }), l("block_formats", {
      processor: "string",
      default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
    }), l("content_langs", { processor: "object[]" }), l("removed_menuitems", {
      processor: "string",
      default: ""
    }), l("menubar", {
      processor: (h) => Kt(h) || tn(h),
      default: !s
    }), l("menu", {
      processor: "object",
      default: {}
    }), l("toolbar", {
      processor: (h) => tn(h) || Kt(h) || Un(h) ? {
        value: h,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean, string or array."
      },
      default: !0
    }), Dn(9, (h) => {
      l("toolbar" + (h + 1), { processor: "string" });
    }), l("toolbar_mode", {
      processor: "string",
      default: a ? "scrolling" : "floating"
    }), l("toolbar_groups", {
      processor: "object",
      default: {}
    }), l("toolbar_location", {
      processor: "string",
      default: Zh.auto
    }), l("toolbar_persist", {
      processor: "boolean",
      default: !1
    }), l("toolbar_sticky", {
      processor: "boolean",
      default: t.inline
    }), l("toolbar_sticky_offset", {
      processor: "number",
      default: 0
    }), l("fixed_toolbar_container", {
      processor: "string",
      default: ""
    }), l("fixed_toolbar_container_target", { processor: "object" }), l("file_picker_callback", { processor: "function" }), l("file_picker_validator_handler", { processor: "function" }), l("file_picker_types", { processor: "string" }), l("typeahead_urls", {
      processor: "boolean",
      default: !0
    }), l("anchor_top", {
      processor: f,
      default: "#top"
    }), l("anchor_bottom", {
      processor: f,
      default: "#bottom"
    }), l("draggable_modal", {
      processor: "boolean",
      default: !1
    }), l("statusbar", {
      processor: "boolean",
      default: !0
    }), l("elementpath", {
      processor: "boolean",
      default: !0
    }), l("branding", {
      processor: "boolean",
      default: !0
    }), l("resize", {
      processor: (h) => h === "both" || tn(h),
      default: !yp.deviceType.isTouch()
    }), l("sidebar_show", { processor: "string" });
  }, e3 = _r("readonly"), _v = _r("height"), t3 = _r("width"), H_ = wv(_r("min_width")), n3 = wv(_r("min_height")), bp = wv(_r("max_width")), o3 = wv(_r("max_height")), V_ = wv(_r("style_formats")), j_ = _r("style_formats_merge"), X5 = _r("style_formats_autohide"), J5 = _r("content_langs"), U_ = _r("removed_menuitems"), Xb = _r("toolbar_mode"), Q5 = _r("toolbar_groups"), s3 = _r("toolbar_location"), CR = _r("fixed_toolbar_container"), SR = _r("fixed_toolbar_container_target"), eA = _r("toolbar_persist"), tA = _r("toolbar_sticky_offset"), nA = _r("menubar"), W_ = _r("toolbar"), oA = _r("file_picker_callback"), sA = _r("file_picker_validator_handler"), rA = _r("file_picker_types"), Z_ = _r("typeahead_urls"), aA = _r("anchor_top"), cA = _r("anchor_bottom"), lA = _r("draggable_modal"), r3 = _r("statusbar"), iA = _r("elementpath"), uA = _r("branding"), dA = _r("resize"), fA = _r("paste_as_text"), mA = _r("sidebar_show"), a3 = (t) => t.options.get("skin") === !1, Jb = (t) => t.options.get("menubar") !== !1, gA = (t) => {
    const s = t.options.get("skin_url");
    if (a3(t))
      return s;
    if (s)
      return t.documentBaseURI.toAbsolute(s);
    {
      const a = t.options.get("skin");
      return _R.baseURL + "/skins/ui/" + a;
    }
  }, pA = (t) => t.options.get("line_height_formats").split(" "), q_ = (t) => {
    const s = W_(t), a = Kt(s), l = Un(s) && s.length > 0;
    return !Cv(t) && (l || a || s === !0);
  }, c3 = (t) => {
    const s = Dn(9, (l) => t.options.get("toolbar" + (l + 1))), a = Pt(s, Kt);
    return er(a.length > 0, a);
  }, Cv = (t) => c3(t).fold(() => {
    const s = W_(t);
    return Ue(s, Kt) && s.length > 0;
  }, Se), l3 = (t) => s3(t) === Zh.bottom, hA = (t) => {
    if (!t.inline)
      return z.none();
    const s = CR(t);
    if (s.length > 0)
      return sc(js(), s);
    const a = SR(t);
    return Ge(a) ? z.some(bt.fromDom(a)) : z.none();
  }, Sv = (t) => t.inline && hA(t).isSome(), i3 = (t) => hA(t).getOrThunk(() => U(or(bt.fromDom(t.getElement())))), u3 = (t) => t.inline && !Jb(t) && !q_(t) && !Cv(t), xv = (t) => (t.options.get("toolbar_sticky") || t.inline) && !Sv(t) && !u3(t), Tv = (t) => {
    const s = t.options.get("menu");
    return Ln(s, (a) => ({
      ...a,
      items: a.items
    }));
  };
  var xR = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get ToolbarMode() {
      return hl;
    },
    get ToolbarLocation() {
      return Zh;
    },
    register: Qx,
    getSkinUrl: gA,
    isReadOnly: e3,
    isSkinDisabled: a3,
    getHeightOption: _v,
    getWidthOption: t3,
    getMinWidthOption: H_,
    getMinHeightOption: n3,
    getMaxWidthOption: bp,
    getMaxHeightOption: o3,
    getUserStyleFormats: V_,
    shouldMergeStyleFormats: j_,
    shouldAutoHideStyleFormats: X5,
    getLineHeightFormats: pA,
    getContentLanguages: J5,
    getRemovedMenuItems: U_,
    isMenubarEnabled: Jb,
    isMultipleToolbars: Cv,
    isToolbarEnabled: q_,
    isToolbarPersist: eA,
    getMultipleToolbarsOption: c3,
    getUiContainer: i3,
    useFixedContainer: Sv,
    getToolbarMode: Xb,
    isDraggableModal: lA,
    isDistractionFree: u3,
    isStickyToolbar: xv,
    getStickyToolbarOffset: tA,
    getToolbarLocation: s3,
    isToolbarLocationBottom: l3,
    getToolbarGroups: Q5,
    getMenus: Tv,
    getMenubar: nA,
    getToolbar: W_,
    getFilePickerCallback: oA,
    getFilePickerTypes: rA,
    useTypeaheadUrls: Z_,
    getAnchorTop: aA,
    getAnchorBottom: cA,
    getFilePickerValidatorHandler: sA,
    useStatusBar: r3,
    useElementPath: iA,
    useBranding: uA,
    getResize: dA,
    getPasteAsText: fA,
    getSidebarShow: mA
  });
  const G_ = "[data-mce-autocompleter]", yA = (t) => Wi(t, G_), TR = (t) => sc(t, G_), ER = { setup: (t, s) => {
    const a = (f, g) => {
      no(f, xd(), { raw: g });
    }, l = () => t.getMenu().bind(Hs.getHighlighted);
    s.on("keydown", (f) => {
      const g = f.which;
      !t.isActive() || (t.isMenuOpen() ? g === 13 ? (l().each(Zu), f.preventDefault()) : g === 40 ? (l().fold(() => {
        t.getMenu().each(Hs.highlightFirst);
      }, (h) => {
        a(h, f);
      }), f.preventDefault(), f.stopImmediatePropagation()) : (g === 37 || g === 38 || g === 39) && l().each((h) => {
        a(h, f), f.preventDefault(), f.stopImmediatePropagation();
      }) : (g === 13 || g === 38 || g === 40) && t.cancelIfNecessary());
    }), s.on("NodeChange", (f) => {
      t.isActive() && !t.isProcessingAction() && yA(bt.fromDom(f.element)).isNone() && t.cancelIfNecessary();
    });
  } };
  var K_;
  (function(t) {
    t[t.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", t[t.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
  })(K_ || (K_ = {}));
  var jd = K_;
  const Ev = "tox-menu-nav__js", Av = "tox-collection__item", Y_ = "tox-swatch", d3 = {
    normal: Ev,
    color: Y_
  }, zv = "tox-collection__item--enabled", bA = "tox-collection__group-heading", Ud = "tox-collection__item-icon", Ov = "tox-collection__item-label", AR = "tox-collection__item-accessory", vA = "tox-collection__item-caret", zR = "tox-collection__item-checkmark", Dv = "tox-collection__item--active", qh = "tox-collection__item-container", kA = "tox-collection__item-container--column", wA = "tox-collection__item-container--row", OR = "tox-collection__item-container--align-right", _A = "tox-collection__item-container--align-left", CA = "tox-collection__item-container--valign-top", f3 = "tox-collection__item-container--valign-middle", DR = "tox-collection__item-container--valign-bottom", X_ = (t) => ht(d3, t).getOr(Ev), m3 = (t) => t === "color" ? "tox-swatches" : "tox-menu", g3 = (t) => ({
    backgroundMenu: "tox-background-menu",
    selectedMenu: "tox-selected-menu",
    selectedItem: "tox-collection__item--active",
    hasIcons: "tox-menu--has-icons",
    menu: m3(t),
    tieredMenu: "tox-tiered-menu"
  }), vp = (t) => {
    const s = g3(t);
    return {
      backgroundMenu: s.backgroundMenu,
      selectedMenu: s.selectedMenu,
      menu: s.menu,
      selectedItem: s.selectedItem,
      item: X_(t)
    };
  }, SA = (t, s, a) => {
    const l = g3(a);
    return {
      tag: "div",
      classes: X([
        [
          l.menu,
          `tox-menu-${s}-column`
        ],
        t ? [l.hasIcons] : []
      ])
    };
  }, RR = [Uh.parts.items({})], J_ = (t, s, a) => {
    const l = g3(a);
    return {
      dom: {
        tag: "div",
        classes: X([[l.tieredMenu]])
      },
      markers: vp(a)
    };
  }, p3 = (t, s) => (a) => {
    const l = Mn(a, s);
    return Xe(l, (f) => ({
      dom: t,
      components: f
    }));
  }, MR = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-swatches-menu"
      ]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-swatches"]
      },
      components: [Uh.parts.items({
        preprocess: t !== "auto" ? p3({
          tag: "div",
          classes: ["tox-swatches__row"]
        }, t) : Je
      })]
    }]
  }), NR = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection",
        "tox-collection--toolbar",
        "tox-collection--toolbar-lg"
      ]
    },
    components: [Uh.parts.items({
      preprocess: p3({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)
    })]
  }), xA = (t, s) => {
    const a = [];
    let l = [];
    return O(t, (f, g) => {
      s(f, g) ? (l.length > 0 && a.push(l), l = [], (qn(f.dom, "innerHtml") || f.components.length > 0) && l.push(f)) : l.push(f);
    }), l.length > 0 && a.push(l), Xe(a, (f) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection__group"]
      },
      components: f
    }));
  }, h3 = (t, s, a = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection"
      ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
    },
    components: [Uh.parts.items({
      preprocess: (l) => t !== "auto" && t > 1 ? p3({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)(l) : xA(l, (f, g) => s[g].type === "separator")
    })]
  }), BR = (t, s = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-collection",
        "tox-collection--horizontal"
      ]
    },
    components: [Uh.parts.items({ preprocess: (a) => xA(a, (l, f) => t[f].type === "separator") })]
  }), Gh = (t) => Sn(t, (s) => "icon" in s && s.icon !== void 0), jf = (t) => (console.error(wd(t)), console.log(t), z.none()), TA = (t, s, a, l, f) => {
    const g = BR(a);
    return {
      value: t,
      dom: g.dom,
      components: g.components,
      items: a
    };
  }, y3 = (t, s, a, l, f) => {
    if (f === "color") {
      const g = MR(l);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }
    if (f === "normal" && l === "auto") {
      const g = h3(l, a);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }
    if (f === "normal" && l === 1) {
      const g = h3(1, a);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }
    if (f === "normal") {
      const g = h3(l, a);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }
    if (f === "listpreview" && l !== "auto") {
      const g = NR(l);
      return {
        value: t,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }
    return {
      value: t,
      dom: SA(s, l, f),
      components: RR,
      items: a
    };
  }, fa = la("type"), Rv = la("name"), Mv = la("label"), Um = la("text"), EA = la("title"), b3 = la("icon"), Nv = la("value"), v3 = xa("fetch"), $R = xa("getSubmenuItems"), Kh = xa("onAction"), AA = xa("onItemAction"), Wd = Fr("onSetup", () => ie), PR = pc("name"), kp = pc("text"), Ji = pc("icon"), Q_ = pc("tooltip"), e2 = pc("label"), zA = pc("shortcut"), OA = _f("select"), Qb = Oc("active", !1), DA = Oc("borderless", !1), sd = Oc("enabled", !0), t2 = Oc("primary", !1), k3 = (t) => Te("columns", t), wp = Te("meta", {}), w3 = Fr("onAction", ie), Yh = (t) => lu("type", t), _3 = (t) => ba("name", "name", gf(() => $n(`${t}-name`)), Pr), RA = (t) => ba("value", "value", gf(() => $n(`${t}-value`)), tc()), C3 = Pn([
    fa,
    kp
  ]), FR = (t) => Js("separatormenuitem", C3, t), IR = Pn([
    Yh("autocompleteitem"),
    Qb,
    sd,
    wp,
    Nv,
    kp,
    Ji
  ]), LR = (t) => Js("Autocompleter.Separator", C3, t), HR = (t) => Js("Autocompleter.Item", IR, t), Bv = [
    sd,
    Q_,
    Ji,
    kp,
    Wd
  ], n2 = Pn([
    fa,
    Kh
  ].concat(Bv)), MA = (t) => Js("toolbarbutton", n2, t), S3 = [Qb].concat(Bv), NA = Pn(S3.concat([
    fa,
    Kh
  ])), x3 = (t) => Js("ToggleButton", NA, t), BA = [
    Fr("predicate", Ot),
    ia("scope", "node", [
      "node",
      "editor"
    ]),
    ia("position", "selection", [
      "node",
      "selection",
      "line"
    ])
  ], $A = Bv.concat([
    Yh("contextformbutton"),
    t2,
    Kh,
    va("original", Je)
  ]), PA = S3.concat([
    Yh("contextformbutton"),
    t2,
    Kh,
    va("original", Je)
  ]), FA = Bv.concat([Yh("contextformbutton")]), IA = S3.concat([Yh("contextformtogglebutton")]), VR = rr("type", {
    contextformbutton: $A,
    contextformtogglebutton: PA
  }), jR = Pn([
    Yh("contextform"),
    Fr("initValue", oe("")),
    e2,
    jc("commands", VR),
    zl("launch", rr("type", {
      contextformbutton: FA,
      contextformtogglebutton: IA
    }))
  ].concat(BA)), UR = (t) => Js("ContextForm", jR, t), WR = Pn([
    Yh("contexttoolbar"),
    la("items")
  ].concat(BA)), Xh = (t) => Js("ContextToolbar", WR, t), T3 = [
    fa,
    la("src"),
    pc("alt"),
    ju("classes", [], Pr)
  ], ZR = Pn(T3), o2 = [
    fa,
    Um,
    PR,
    ju("classes", ["tox-collection__item-label"], Pr)
  ], Zd = Pn(o2), LA = jp(() => fg("type", {
    cardimage: ZR,
    cardtext: Zd,
    cardcontainer: qR
  })), qR = Pn([
    fa,
    lu("direction", "horizontal"),
    lu("align", "left"),
    lu("valign", "middle"),
    jc("items", LA)
  ]), e1 = [
    sd,
    kp,
    zA,
    RA("menuitem"),
    wp
  ], E3 = Pn([
    fa,
    e2,
    jc("items", LA),
    Wd,
    w3
  ].concat(e1)), GR = (t) => Js("cardmenuitem", E3, t), KR = Pn([
    fa,
    Qb,
    Ji
  ].concat(e1)), HA = (t) => Js("choicemenuitem", KR, t), VA = [
    fa,
    la("fancytype"),
    w3
  ], YR = [Te("initData", {})].concat(VA), XR = [qp("initData", {}, [
    Oc("allowCustomColors", !0),
    mg("colors", tc())
  ])].concat(VA), Oi = rr("fancytype", {
    inserttable: YR,
    colorswatch: XR
  }), Uf = (t) => Js("fancymenuitem", Oi, t), JR = Pn([
    fa,
    Wd,
    w3,
    Ji
  ].concat(e1)), jA = (t) => Js("menuitem", JR, t), s2 = Pn([
    fa,
    $R,
    Wd,
    Ji
  ].concat(e1)), A3 = (t) => Js("nestedmenuitem", s2, t), QR = Pn([
    fa,
    Ji,
    Qb,
    Wd,
    Kh
  ].concat(e1)), eM = (t) => Js("togglemenuitem", QR, t), Jh = (t, s, a) => {
    const l = Mc(t.element, "." + a);
    if (l.length > 0) {
      const f = ae(l, (g) => {
        const h = g.dom.getBoundingClientRect().top, w = l[0].dom.getBoundingClientRect().top;
        return Math.abs(h - w) > s;
      }).getOr(l.length);
      return z.some({
        numColumns: f,
        numRows: Math.ceil(l.length / f)
      });
    } else
      return z.none();
  }, $v = (t, s) => qt([ys(t, s)]), qd = {
    namedEvents: $v,
    unnamedEvents: (t) => $v($n("unnamed-events"), t)
  }, UA = $n("tooltip.exclusive"), Pv = $n("tooltip.show"), el = $n("tooltip.hide"), r2 = (t, s, a) => {
    t.getSystem().broadcastOn([UA], {});
  };
  var tM = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hideAllExclusive: r2,
    setComponents: (t, s, a, l) => {
      a.getTooltip().each((f) => {
        f.getSystem().isConnected() && Uo.set(f, l);
      });
    }
  }), Qh = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => {
      const a = (f) => {
        s.getTooltip().each((g) => {
          Nl(g), t.onHide(f, g), s.clearTooltip();
        }), s.clearTimer();
      }, l = (f) => {
        if (!s.isShowing()) {
          r2(f);
          const g = t.lazySink(f).getOrDie(), h = f.getSystem().build({
            dom: t.tooltipDom,
            components: t.tooltipComponents,
            events: Ls(t.mode === "normal" ? [
              dt(Br(), (w) => {
                Ts(f, Pv);
              }),
              dt(Do(), (w) => {
                Ts(f, el);
              })
            ] : []),
            behaviours: qt([Uo.config({})])
          });
          s.setTooltip(h), Ml(g, h), t.onShow(f, h), dl.position(g, h, { anchor: t.anchor(f) });
        }
      };
      return Ls(X([
        [
          dt(Pv, (f) => {
            s.resetTimer(() => {
              l(f);
            }, t.delay);
          }),
          dt(el, (f) => {
            s.resetTimer(() => {
              a(f);
            }, t.delay);
          }),
          dt(_m(), (f, g) => {
            const h = g;
            h.universal || Fn(h.channels, UA) && a(f);
          }),
          Hi((f) => {
            a(f);
          })
        ],
        t.mode === "normal" ? [
          dt(Ta(), (f) => {
            Ts(f, Pv);
          }),
          dt(D1(), (f) => {
            Ts(f, el);
          }),
          dt(Br(), (f) => {
            Ts(f, Pv);
          }),
          dt(Do(), (f) => {
            Ts(f, el);
          })
        ] : [
          dt(Kp(), (f, g) => {
            Ts(f, Pv);
          }),
          dt(Yp(), (f) => {
            Ts(f, el);
          })
        ]
      ]));
    }
  }), a2 = [
    ut("lazySink"),
    ut("tooltipDom"),
    Te("exclusive", !0),
    Te("tooltipComponents", []),
    Te("delay", 300),
    ia("mode", "normal", [
      "normal",
      "follow-highlight"
    ]),
    Te("anchor", (t) => ({
      type: "hotspot",
      hotspot: t,
      layouts: {
        onLtr: oe([
          ua,
          Ir,
          vc,
          Kc,
          kc,
          wc
        ]),
        onRtl: oe([
          ua,
          Ir,
          vc,
          Kc,
          kc,
          wc
        ])
      }
    })),
    Es("onHide"),
    Es("onShow")
  ], z3 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Ar(), s = Ar(), a = () => {
        t.on(clearTimeout);
      }, l = (g, h) => {
        a(), t.set(setTimeout(g, h));
      }, f = oe("not-implemented");
      return Ol({
        getTooltip: s.get,
        isShowing: s.isSet,
        setTooltip: s.set,
        clearTooltip: s.clear,
        clearTimer: a,
        resetTimer: l,
        readState: f
      });
    }
  });
  const c2 = Ha({
    fields: a2,
    name: "tooltipping",
    active: Qh,
    state: z3,
    apis: tM
  }), oM = (t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), Fv = "silver.readonly", sM = Pn([Vu("readonly")]), Iv = (t, s) => {
    const l = t.outerContainer.element;
    s && (t.mothership.broadcastOn([xi()], { target: l }), t.uiMothership.broadcastOn([xi()], { target: l })), t.mothership.broadcastOn([Fv], { readonly: s }), t.uiMothership.broadcastOn([Fv], { readonly: s });
  }, O3 = (t, s) => {
    t.on("init", () => {
      t.mode.isReadOnly() && Iv(s, !0);
    }), t.on("SwitchMode", () => Iv(s, t.mode.isReadOnly())), e3(t) && t.mode.set("readonly");
  }, ma = () => wi.config({
    channels: {
      [Fv]: {
        schema: sM,
        onReceive: (t, s) => {
          ao.set(t, s.readonly);
        }
      }
    }
  }), rd = {
    item: (t) => ao.config({
      disabled: t,
      disableClass: "tox-collection__item--state-disabled"
    }),
    button: (t) => ao.config({ disabled: t }),
    splitButton: (t) => ao.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled"
    }),
    toolbarButton: (t) => ao.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled",
      useNative: !1
    })
  }, l2 = (t, s) => {
    const a = t.getApi(s);
    return (l) => {
      l(a);
    };
  }, Lv = (t, s) => kr((a) => {
    l2(t, a)((f) => {
      const g = t.onSetup(f);
      At(g) && s.set(g);
    });
  }), Hv = (t, s) => Hi((a) => l2(t, a)(s.get())), aM = (t, s) => zd((a, l) => {
    l2(t, a)(t.onAction), !t.triggersSubmenu && s === jd.CLOSE_ON_EXECUTE && (a.getSystem().isConnected() && Ts(a, zy()), l.stop());
  }), cM = {
    [Kl()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "item-events"
    ]
  }, Vv = hr, t1 = (t, s, a, l) => {
    const f = Xn(ie);
    return {
      type: "item",
      dom: s.dom,
      components: Vv(s.optComponents),
      data: t.data,
      eventOrder: cM,
      hasSubmenu: t.triggersSubmenu,
      itemBehaviours: qt([
        ys("item-events", [
          aM(t, a),
          Lv(t, f),
          Hv(t, f)
        ]),
        rd.item(() => !t.enabled || l.isDisabled()),
        ma(),
        Uo.config({})
      ].concat(t.itemBehaviours))
    };
  }, ey = (t) => ({
    value: t.value,
    meta: {
      text: t.text.getOr(""),
      ...t.meta
    }
  }), lM = (t) => {
    const s = yp.os.isMacOS() || yp.os.isiOS(), f = s ? {
      alt: "\u2325",
      ctrl: "\u2303",
      shift: "\u21E7",
      meta: "\u2318",
      access: "\u2303\u2325"
    } : {
      meta: "Ctrl",
      access: "Shift+Alt"
    }, g = t.split("+"), h = Xe(g, (w) => {
      const C = w.toLowerCase().trim();
      return qn(f, C) ? f[C] : w;
    });
    return s ? h.join("") : h.join("+");
  }, i2 = (t, s, a = [Ud]) => Vd(t, {
    tag: "div",
    classes: a
  }, s), R3 = (t) => ({
    dom: {
      tag: "div",
      classes: [Ov]
    },
    components: [wa(Su.translate(t))]
  }), WA = (t, s) => ({
    dom: {
      tag: "div",
      classes: s,
      innerHtml: t
    }
  }), iM = (t, s) => ({
    dom: {
      tag: "div",
      classes: [Ov]
    },
    components: [{
      dom: {
        tag: t.tag,
        styles: t.styles
      },
      components: [wa(Su.translate(s))]
    }]
  }), uM = (t) => ({
    dom: {
      tag: "div",
      classes: [AR]
    },
    components: [wa(lM(t))]
  }), ZA = (t) => i2("checkmark", t, [zR]), dM = (t) => i2("chevron-right", t, [vA]), fM = (t) => i2("chevron-down", t, [vA]), mM = (t, s) => {
    const a = t.direction === "vertical" ? kA : wA, l = t.align === "left" ? _A : OR;
    return {
      dom: {
        tag: "div",
        classes: [
          qh,
          a,
          l,
          (() => {
            switch (t.valign) {
              case "top":
                return CA;
              case "middle":
                return f3;
              case "bottom":
                return DR;
            }
          })()
        ]
      },
      components: s
    };
  }, M3 = (t, s, a) => ({
    dom: {
      tag: "img",
      classes: s,
      attributes: {
        src: t,
        alt: a.getOr("")
      }
    }
  }), qA = (t, s, a) => {
    const l = "custom", f = "remove", g = t.ariaLabel, h = t.value, w = t.iconContent.map((T) => Xx(T, s.icons, a));
    return {
      dom: (() => {
        const T = Y_, D = w.getOr(""), $ = g.map((V) => ({ title: s.translate(V) })).getOr({}), I = {
          tag: "div",
          attributes: $,
          classes: [T]
        };
        return h === l ? {
          ...I,
          tag: "button",
          classes: [
            ...I.classes,
            "tox-swatches__picker-btn"
          ],
          innerHtml: D
        } : h === f ? {
          ...I,
          classes: [
            ...I.classes,
            "tox-swatch--remove"
          ],
          innerHtml: D
        } : {
          ...I,
          attributes: {
            ...I.attributes,
            "data-mce-color": h
          },
          styles: { "background-color": h }
        };
      })(),
      optComponents: []
    };
  }, GA = (t) => {
    const s = t.map((a) => ({ attributes: { title: Su.translate(a) } })).getOr({});
    return {
      tag: "div",
      classes: [
        Ev,
        Av
      ],
      ...s
    };
  }, gM = (t, s, a, l) => {
    const f = {
      tag: "div",
      classes: [Ud]
    }, g = (I) => Vd(I, f, s.icons, l), h = () => z.some({ dom: f }), w = a ? t.iconContent.map(g).orThunk(h) : z.none(), C = t.checkMark, T = z.from(t.meta).fold(() => R3, (I) => qn(I, "style") ? lt(iM, I.style) : R3), D = t.htmlContent.fold(() => t.textContent.map(T), (I) => z.some(WA(I, [Ov])));
    return {
      dom: GA(t.ariaLabel),
      optComponents: [
        w,
        D,
        t.shortcutContent.map(uM),
        C,
        t.caret
      ]
    };
  }, n1 = (t, s, a, l = z.none()) => t.presets === "color" ? qA(t, s, l) : gM(t, s, a, l), KA = (t, s) => ht(t, "tooltipWorker").map((a) => [c2.config({
    lazySink: s.getSink,
    tooltipDom: {
      tag: "div",
      classes: ["tox-tooltip-worker-container"]
    },
    tooltipComponents: [],
    anchor: (l) => ({
      type: "submenu",
      item: l,
      overrides: { maxHeightFunction: Lg }
    }),
    mode: "follow-highlight",
    onShow: (l, f) => {
      a((g) => {
        c2.setComponents(l, [ih({ element: bt.fromDom(g) })]);
      });
    }
  })]).getOr([]), pM = (t) => kv.DOM.encode(t), N3 = (t, s) => {
    const a = Su.translate(t), l = pM(a);
    if (s.length > 0) {
      const f = new RegExp(oM(s), "gi");
      return l.replace(f, (g) => `<span class="tox-autocompleter-highlight">${g}</span>`);
    } else
      return l;
  }, YA = (t, s, a, l, f, g, h, w = !0) => {
    const C = n1({
      presets: l,
      textContent: z.none(),
      htmlContent: a ? t.text.map((T) => N3(T, s)) : z.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: z.none(),
      checkMark: z.none(),
      caret: z.none(),
      value: t.value
    }, h.providers, w, t.icon);
    return t1({
      data: ey(t),
      enabled: t.enabled,
      getApi: oe({}),
      onAction: (T) => f(t.value, t.meta),
      onSetup: oe(ie),
      triggersSubmenu: !1,
      itemBehaviours: KA(t.meta, h)
    }, C, g, h.providers);
  }, B3 = (t, s) => Xe(t, (a) => {
    switch (a.type) {
      case "cardcontainer":
        return mM(a, B3(a.items, s));
      case "cardimage":
        return M3(a.src, a.classes, a.alt);
      case "cardtext":
        const f = a.name.exists((g) => Fn(s.cardText.highlightOn, g)) ? z.from(s.cardText.matchText).getOr("") : "";
        return WA(N3(a.text, f), a.classes);
    }
  }), hM = (t, s, a, l) => {
    const f = (h) => ({
      isEnabled: () => !ao.isDisabled(h),
      setEnabled: (w) => {
        ao.set(h, !w), O(Mc(h.element, "*"), (C) => {
          h.getSystem().getByDom(C).each((T) => {
            T.hasConfigured(ao) && ao.set(T, !w);
          });
        });
      }
    }), g = {
      dom: GA(t.label),
      optComponents: [z.some({
        dom: {
          tag: "div",
          classes: [
            qh,
            wA
          ]
        },
        components: B3(t.items, l)
      })]
    };
    return t1({
      data: ey({
        text: z.none(),
        ...t
      }),
      enabled: t.enabled,
      getApi: f,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: z.from(l.itemBehaviours).getOr([])
    }, g, s, a.providers);
  }, yM = (t, s, a, l, f, g, h, w = !0) => {
    const C = (D) => ({
      setActive: ($) => {
        Qo.set(D, $);
      },
      isActive: () => Qo.isOn(D),
      isEnabled: () => !ao.isDisabled(D),
      setEnabled: ($) => ao.set(D, !$)
    }), T = n1({
      presets: a,
      textContent: s ? t.text : z.none(),
      htmlContent: z.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: s ? t.shortcut : z.none(),
      checkMark: s ? z.some(ZA(h.icons)) : z.none(),
      caret: z.none(),
      value: t.value
    }, h, w);
    return sr(t1({
      data: ey(t),
      enabled: t.enabled,
      getApi: C,
      onAction: (D) => l(t.value),
      onSetup: (D) => (D.setActive(f), ie),
      triggersSubmenu: !1,
      itemBehaviours: []
    }, T, g, h), {
      toggling: {
        toggleClass: zv,
        toggleOnExecute: !1,
        selected: t.active,
        exclusive: !0
      }
    });
  }, XA = U0(yv(), Hx()), JA = (t) => ({ value: t }), QA = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, $3 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, ez = (t) => QA.test(t) || $3.test(t), bM = (t) => Ra(t, "#").toUpperCase(), vM = (t) => ez(t) ? z.some({ value: bM(t) }) : z.none(), kM = (t) => ({ value: t.value.replace(QA, (a, l, f, g) => l + l + f + f + g + g) }), wM = (t) => {
    const s = kM(t), a = $3.exec(s.value);
    return a === null ? [
      "FFFFFF",
      "FF",
      "FF",
      "FF"
    ] : a;
  }, P3 = (t) => {
    const s = t.toString(16);
    return (s.length === 1 ? "0" + s : s).toUpperCase();
  }, o1 = (t) => {
    const s = P3(t.red) + P3(t.green) + P3(t.blue);
    return JA(s);
  }, ad = Math.min, F3 = Math.max, jv = Math.round, _M = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, CM = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, Zf = (t, s, a, l) => ({
    red: t,
    green: s,
    blue: a,
    alpha: l
  }), I3 = (t) => {
    const s = parseInt(t, 10);
    return s.toString() === t && s >= 0 && s <= 255;
  }, tz = (t) => {
    let s, a, l;
    const f = (t.hue || 0) % 360;
    let g = t.saturation / 100, h = t.value / 100;
    if (g = F3(0, ad(g, 1)), h = F3(0, ad(h, 1)), g === 0)
      return s = a = l = jv(255 * h), Zf(s, a, l, 1);
    const w = f / 60, C = h * g, T = C * (1 - Math.abs(w % 2 - 1)), D = h - C;
    switch (Math.floor(w)) {
      case 0:
        s = C, a = T, l = 0;
        break;
      case 1:
        s = T, a = C, l = 0;
        break;
      case 2:
        s = 0, a = C, l = T;
        break;
      case 3:
        s = 0, a = T, l = C;
        break;
      case 4:
        s = T, a = 0, l = C;
        break;
      case 5:
        s = C, a = 0, l = T;
        break;
      default:
        s = a = l = 0;
    }
    return s = jv(255 * (s + D)), a = jv(255 * (a + D)), l = jv(255 * (l + D)), Zf(s, a, l, 1);
  }, s1 = (t) => {
    const s = wM(t), a = parseInt(s[1], 16), l = parseInt(s[2], 16), f = parseInt(s[3], 16);
    return Zf(a, l, f, 1);
  }, nz = (t, s, a, l) => {
    const f = parseInt(t, 10), g = parseInt(s, 10), h = parseInt(a, 10), w = parseFloat(l);
    return Zf(f, g, h, w);
  }, oz = (t) => {
    if (t === "transparent")
      return z.some(Zf(0, 0, 0, 0));
    const s = _M.exec(t);
    if (s !== null)
      return z.some(nz(s[1], s[2], s[3], "1"));
    const a = CM.exec(t);
    return a !== null ? z.some(nz(a[1], a[2], a[3], a[4])) : z.none();
  }, sz = (t) => `rgba(${t.red},${t.green},${t.blue},${t.alpha})`, ty = Zf(255, 0, 0, 1), SM = (t) => t.dispatch("SkinLoaded"), rz = (t, s) => t.dispatch("SkinLoadError", s), az = (t) => t.dispatch("ResizeEditor"), u2 = (t, s) => t.dispatch("ResizeContent", s), L3 = (t, s) => t.dispatch("ScrollContent", s), H3 = (t, s) => t.dispatch("TextColorChange", s), ny = (t, s, a) => ({
    hue: t,
    saturation: s,
    value: a
  }), d2 = (t) => {
    let s = 0, a = 0, l = 0;
    const f = t.red / 255, g = t.green / 255, h = t.blue / 255, w = Math.min(f, Math.min(g, h)), C = Math.max(f, Math.max(g, h));
    if (w === C)
      return l = w, ny(0, 0, l * 100);
    const T = f === w ? g - h : h === w ? f - g : h - f;
    return s = f === w ? 3 : h === w ? 1 : 5, s = 60 * (s - T / (C - w)), a = (C - w) / C, l = C, ny(Math.round(s), Math.round(a * 100), Math.round(l * 100));
  }, xM = (t) => d2(s1(t)), V3 = (t) => o1(tz(t)), TM = (t) => vM(t).orThunk(() => oz(t).map(o1)).getOrThunk(() => {
    const s = document.createElement("canvas");
    s.height = 1, s.width = 1;
    const a = s.getContext("2d");
    a.clearRect(0, 0, s.width, s.height), a.fillStyle = "#FFFFFF", a.fillStyle = t, a.fillRect(0, 0, 1, 1);
    const l = a.getImageData(0, 0, 1, 1).data, f = l[0], g = l[1], h = l[2], w = l[3];
    return o1(Zf(f, g, h, w));
  });
  var f2 = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const cz = "tinymce-custom-colors";
  var lz = (t = 10) => {
    const s = f2.getItem(cz), a = Kt(s) ? JSON.parse(s) : [], f = ((C) => t - C.length < 0 ? C.slice(0, t) : C)(a), g = (C) => {
      _o(f, C).each(h), f.unshift(C), f.length > t && f.pop(), f2.setItem(cz, JSON.stringify(f));
    }, h = (C) => {
      f.splice(C, 1);
    };
    return {
      add: g,
      state: () => f.slice(0)
    };
  };
  const j3 = lz(10), iz = (t) => Math.max(5, Math.ceil(Math.sqrt(t))), EM = (t) => {
    const s = [];
    for (let a = 0; a < t.length; a += 2)
      s.push({
        text: t[a + 1],
        value: "#" + TM(t[a]).value,
        type: "choiceitem"
      });
    return s;
  }, U3 = (t) => (s) => s.options.get(t), AM = (t) => {
    const s = t.options.register;
    s("color_map", {
      processor: (a) => Ue(a, Kt) ? {
        value: EM(a),
        valid: !0
      } : {
        valid: !1,
        message: "Must be an array of strings."
      },
      default: [
        "#BFEDD2",
        "Light Green",
        "#FBEEB8",
        "Light Yellow",
        "#F8CAC6",
        "Light Red",
        "#ECCAFA",
        "Light Purple",
        "#C2E0F4",
        "Light Blue",
        "#2DC26B",
        "Green",
        "#F1C40F",
        "Yellow",
        "#E03E2D",
        "Red",
        "#B96AD9",
        "Purple",
        "#3598DB",
        "Blue",
        "#169179",
        "Dark Turquoise",
        "#E67E23",
        "Orange",
        "#BA372A",
        "Dark Red",
        "#843FA1",
        "Dark Purple",
        "#236FA1",
        "Dark Blue",
        "#ECF0F1",
        "Light Gray",
        "#CED4D9",
        "Medium Gray",
        "#95A5A6",
        "Gray",
        "#7E8C8D",
        "Dark Gray",
        "#34495E",
        "Navy Blue",
        "#000000",
        "Black",
        "#ffffff",
        "White"
      ]
    }), s("color_cols", {
      processor: "number",
      default: iz(W3(t).length)
    }), s("custom_colors", {
      processor: "boolean",
      default: !0
    });
  }, uz = U3("color_cols"), dz = U3("custom_colors"), W3 = U3("color_map"), zM = () => Xe(j3.state(), (t) => ({
    type: "choiceitem",
    text: t,
    value: t
  })), fz = (t) => {
    j3.add(t);
  }, Z3 = "#000000", OM = (t, s) => {
    let a;
    return t.dom.getParents(t.selection.getStart(), (l) => {
      let f;
      (f = l.style[s === "forecolor" ? "color" : "background-color"]) && (a = a || f);
    }), z.from(a);
  }, DM = (t, s, a) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.apply(s, { value: a }), t.nodeChanged();
    });
  }, mz = (t, s) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.remove(s, { value: null }, null, !0), t.nodeChanged();
    });
  }, RM = (t) => {
    t.addCommand("mceApplyTextcolor", (s, a) => {
      DM(t, s, a);
    }), t.addCommand("mceRemoveTextcolor", (s) => {
      mz(t, s);
    });
  }, gz = (t) => {
    const s = "choiceitem", a = {
      type: s,
      text: "Remove color",
      icon: "color-swatch-remove-color",
      value: "remove"
    };
    return t ? [
      a,
      {
        type: s,
        text: "Custom color",
        icon: "color-picker",
        value: "custom"
      }
    ] : [a];
  }, q3 = (t, s, a, l) => {
    a === "custom" ? bz(t)((g) => {
      g.each((h) => {
        fz(h), t.execCommand("mceApplyTextcolor", s, h), l(h);
      });
    }, Z3) : a === "remove" ? (l(""), t.execCommand("mceRemoveTextcolor", s)) : (l(a), t.execCommand("mceApplyTextcolor", s, a));
  }, pz = (t, s) => t.concat(zM().concat(gz(s))), hz = (t, s) => (a) => {
    a(pz(t, s));
  }, Uv = (t, s, a) => {
    const l = s === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    t.setIconFill(l, a);
  }, G3 = (t, s, a, l, f) => {
    t.ui.registry.addSplitButton(s, {
      tooltip: l,
      presets: "color",
      icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
      select: (g) => OM(t, a).bind((w) => oz(w).map((C) => {
        const T = o1(C).value;
        return rs(g.toLowerCase(), T);
      })).getOr(!1),
      columns: uz(t),
      fetch: hz(W3(t), dz(t)),
      onAction: (g) => {
        q3(t, a, f.get(), ie);
      },
      onItemAction: (g, h) => {
        q3(t, a, h, (w) => {
          f.set(w), H3(t, {
            name: s,
            color: w
          });
        });
      },
      onSetup: (g) => {
        Uv(g, s, f.get());
        const h = (w) => {
          w.name === s && Uv(g, w.name, w.color);
        };
        return t.on("TextColorChange", h), () => {
          t.off("TextColorChange", h);
        };
      }
    });
  }, yz = (t, s, a, l) => {
    t.ui.registry.addNestedMenuItem(s, {
      text: l,
      icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        onAction: (f) => {
          q3(t, a, f.value, ie);
        }
      }]
    });
  }, bz = (t) => (s, a) => {
    let l = !1;
    const f = (w) => {
      const T = w.getData().colorpicker;
      l ? (s(z.from(T)), w.close()) : t.windowManager.alert(t.translate([
        "Invalid hex color code: {0}",
        T
      ]));
    }, g = (w, C) => {
      C.name === "hex-valid" && (l = C.value);
    }, h = { colorpicker: a };
    t.windowManager.open({
      title: "Color Picker",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          type: "colorpicker",
          name: "colorpicker",
          label: "Color"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: h,
      onAction: g,
      onSubmit: f,
      onClose: ie,
      onCancel: () => {
        s(z.none());
      }
    });
  }, MM = (t) => {
    RM(t);
    const s = Xn(Z3), a = Xn(Z3);
    G3(t, "forecolor", "forecolor", "Text color", s), G3(t, "backcolor", "hilitecolor", "Background color", a), yz(t, "forecolor", "forecolor", "Text color"), yz(t, "backcolor", "hilitecolor", "Background color");
  }, K3 = (t, s, a, l, f, g, h, w) => {
    const C = Gh(s), D = NM(s, a, l, f !== "color" ? "normal" : "color", g, h, w);
    return y3(t, C, D, l, f);
  }, NM = (t, s, a, l, f, g, h) => hr(Xe(t, (w) => w.type === "choiceitem" ? HA(w).fold(jf, (C) => z.some(yM(C, a === 1, l, s, g(w.value), f, h, Gh(t)))) : z.none())), m2 = (t, s) => {
    const a = vp(s);
    return t === 1 ? {
      mode: "menu",
      moveOnTab: !0
    } : t === "auto" ? {
      mode: "grid",
      selector: "." + a.item,
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      rowSelector: "." + (s === "color" ? "tox-swatches__row" : "tox-collection__group")
    };
  }, Y3 = (t, s) => t === 1 ? {
    mode: "menu",
    moveOnTab: !1,
    selector: ".tox-collection__item"
  } : t === "auto" ? {
    mode: "flatgrid",
    selector: ".tox-collection__item",
    initSize: {
      numColumns: 1,
      numRows: 1
    }
  } : {
    mode: "matrix",
    selectors: {
      row: s === "color" ? ".tox-swatches__row" : ".tox-collection__group",
      cell: s === "color" ? `.${Y_}` : `.${Av}`
    }
  }, vz = (t, s) => {
    const a = kz(t, s), l = s.colorinput.getColorCols(), f = "color", h = {
      ...K3($n("menu-value"), a, (w) => {
        t.onAction({ value: w });
      }, l, f, jd.CLOSE_ON_EXECUTE, Ot, s.shared.providers),
      markers: vp(f),
      movement: m2(l, f)
    };
    return {
      type: "widget",
      data: { value: $n("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: !0,
      components: [XA.widget(Uh.sketch(h))]
    };
  }, kz = (t, s) => {
    const a = t.initData.allowCustomColors && s.colorinput.hasCustomColors();
    return t.initData.colors.fold(() => pz(s.colorinput.getColors(), a), (l) => l.concat(gz(a)));
  }, wz = $n("cell-over"), X3 = $n("cell-execute"), BM = (t, s, a) => {
    const l = (h) => no(h, wz, {
      row: t,
      col: s
    }), f = (h) => no(h, X3, {
      row: t,
      col: s
    }), g = (h, w) => {
      w.stop(), f(h);
    };
    return bc({
      dom: {
        tag: "div",
        attributes: {
          role: "button",
          ["aria-labelledby"]: a
        }
      },
      behaviours: qt([
        ys("insert-table-picker-cell", [
          dt(Br(), go.focus),
          dt(Kl(), f),
          dt(yg(), g),
          dt(bg(), g)
        ]),
        Qo.config({
          toggleClass: "tox-insert-table-picker__selected",
          toggleOnExecute: !1
        }),
        go.config({ onFocus: l })
      ])
    });
  }, $M = (t, s, a) => {
    const l = [];
    for (let f = 0; f < s; f++) {
      const g = [];
      for (let h = 0; h < a; h++)
        g.push(BM(f, h, t));
      l.push(g);
    }
    return l;
  }, PM = (t, s, a, l, f) => {
    for (let g = 0; g < l; g++)
      for (let h = 0; h < f; h++)
        Qo.set(t[g][h], g <= s && h <= a);
  }, FM = (t) => je(t, (s) => Xe(s, bi)), _z = (t, s) => wa(`${s}x${t}`), IM = {
    inserttable: (t) => {
      const l = $n("size-label"), f = $M(l, 10, 10), g = _z(0, 0), h = wr({
        dom: {
          tag: "span",
          classes: ["tox-insert-table-picker__label"],
          attributes: { id: l }
        },
        components: [g],
        behaviours: qt([Uo.config({})])
      });
      return {
        type: "widget",
        data: { value: $n("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [XA.widget({
          dom: {
            tag: "div",
            classes: ["tox-insert-table-picker"]
          },
          components: FM(f).concat(h.asSpec()),
          behaviours: qt([
            ys("insert-table-picker", [
              kr((w) => {
                Uo.set(h.get(w), [g]);
              }),
              Ny(wz, (w, C, T) => {
                const { row: D, col: $ } = T.event;
                PM(f, D, $, 10, 10), Uo.set(h.get(w), [_z(D + 1, $ + 1)]);
              }),
              Ny(X3, (w, C, T) => {
                const { row: D, col: $ } = T.event;
                t.onAction({
                  numRows: D + 1,
                  numColumns: $ + 1
                }), Ts(w, zy());
              })
            ]),
            Kn.config({
              initSize: {
                numRows: 10,
                numColumns: 10
              },
              mode: "flatgrid",
              selector: '[role="button"]'
            })
          ])
        })]
      };
    },
    colorswatch: vz
  }, LM = (t, s) => ht(IM, t.fancytype).map((a) => a(t, s)), HM = (t, s, a, l = !0, f = !1) => {
    const g = f ? fM(a.icons) : dM(a.icons), h = (C) => ({
      isEnabled: () => !ao.isDisabled(C),
      setEnabled: (T) => ao.set(C, !T)
    }), w = n1({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      caret: z.some(g),
      checkMark: z.none(),
      shortcutContent: t.shortcut
    }, a, l);
    return t1({
      data: ey(t),
      getApi: h,
      enabled: t.enabled,
      onAction: ie,
      onSetup: t.onSetup,
      triggersSubmenu: !0,
      itemBehaviours: []
    }, w, s, a);
  }, VM = (t, s, a, l = !0) => {
    const f = (h) => ({
      isEnabled: () => !ao.isDisabled(h),
      setEnabled: (w) => ao.set(h, !w)
    }), g = n1({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      caret: z.none(),
      checkMark: z.none(),
      shortcutContent: t.shortcut
    }, a, l);
    return t1({
      data: ey(t),
      getApi: f,
      enabled: t.enabled,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, g, s, a);
  }, g2 = (t) => ({
    type: "separator",
    dom: {
      tag: "div",
      classes: [
        Av,
        bA
      ]
    },
    components: t.text.map(wa).toArray()
  }), J3 = (t, s, a, l = !0) => {
    const f = (h) => ({
      setActive: (w) => {
        Qo.set(h, w);
      },
      isActive: () => Qo.isOn(h),
      isEnabled: () => !ao.isDisabled(h),
      setEnabled: (w) => ao.set(h, !w)
    }), g = n1({
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      checkMark: z.some(ZA(a.icons)),
      caret: z.none(),
      shortcutContent: t.shortcut,
      presets: "normal",
      meta: t.meta
    }, a, l);
    return sr(t1({
      data: ey(t),
      enabled: t.enabled,
      getApi: f,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, g, s, a), {
      toggling: {
        toggleClass: zv,
        toggleOnExecute: !1,
        selected: t.active
      }
    });
  }, Q3 = YA, eT = g2, jM = VM, UM = HM, tT = J3, nT = LM, p2 = hM;
  var Wv;
  (function(t) {
    t[t.ContentFocus = 0] = "ContentFocus", t[t.UiFocus = 1] = "UiFocus";
  })(Wv || (Wv = {}));
  const WM = (t, s, a, l, f) => {
    const g = a.shared.providers, h = (w) => f ? {
      ...w,
      shortcut: z.none(),
      icon: w.text.isSome() ? z.none() : w.icon
    } : w;
    switch (t.type) {
      case "menuitem":
        return jA(t).fold(jf, (w) => z.some(jM(h(w), s, g, l)));
      case "nestedmenuitem":
        return A3(t).fold(jf, (w) => z.some(UM(h(w), s, g, l, f)));
      case "togglemenuitem":
        return eM(t).fold(jf, (w) => z.some(tT(h(w), s, g, l)));
      case "separator":
        return FR(t).fold(jf, (w) => z.some(eT(w)));
      case "fancymenuitem":
        return Uf(t).fold(jf, (w) => nT(h(w), a));
      default:
        return console.error("Unknown item in general menu", t), z.none();
    }
  }, ZM = (t, s, a, l, f, g, h) => {
    const w = l === 1, C = !w || Gh(t);
    return hr(Xe(t, (T) => {
      switch (T.type) {
        case "separator":
          return LR(T).fold(jf, (D) => z.some(eT(D)));
        case "cardmenuitem":
          return GR(T).fold(jf, (D) => z.some(p2({
            ...D,
            onAction: ($) => {
              D.onAction($), a(D.value, D.meta);
            }
          }, f, g, {
            itemBehaviours: KA(D.meta, g),
            cardText: {
              matchText: s,
              highlightOn: h
            }
          })));
        case "autocompleteitem":
        default:
          return HR(T).fold(jf, (D) => z.some(Q3(D, s, w, "normal", a, f, g, C)));
      }
    }));
  }, Cz = (t, s, a, l, f) => {
    const g = Gh(s), h = hr(Xe(s, (C) => {
      const T = ($) => f ? !qn($, "text") : g, D = ($) => WM($, a, l, T($), f);
      return C.type === "nestedmenuitem" && C.getSubmenuItems().length <= 0 ? D({
        ...C,
        enabled: !1
      }) : D(C);
    }));
    return (f ? TA : y3)(t, g, h, 1, "normal");
  }, oT = (t) => Wh.singleData(t.value, t), qM = (t, s, a, l) => {
    const f = m2(s, l), g = vp(l);
    return {
      data: oT({
        ...t,
        movement: f,
        menuBehaviours: qd.unnamedEvents(s !== "auto" ? [] : [kr((h, w) => {
          Jh(h, 4, g.item).each(({ numColumns: C, numRows: T }) => {
            Kn.setGridSize(h, T, C);
          });
        })])
      }),
      menu: {
        markers: vp(l),
        fakeFocus: a === Wv.ContentFocus
      }
    };
  }, GM = (t, s) => yA(bt.fromDom(s.startContainer)).map((a) => {
    const l = t.createRng();
    return l.selectNode(a.dom), l;
  }), KM = { register: (t, s) => {
    const a = Xn(!1), l = Xn(!1), f = bc(na.sketch({
      dom: {
        tag: "div",
        classes: ["tox-autocompleter"]
      },
      components: [],
      fireDismissalEventInstead: {},
      inlineBehaviours: qt([ys("dismissAutocompleter", [dt(kg(), () => T())])]),
      lazySink: s.getSink
    })), g = () => na.isOpen(f), h = l.get, w = () => {
      g() && na.hide(f);
    }, C = () => na.getContent(f).bind((ne) => ko(ne.components(), 0)), T = () => t.execCommand("mceAutocompleterClose"), D = (ne) => {
      const pe = Ho(ne, (Le) => z.from(Le.columns)).getOr(1);
      return je(ne, (Le) => {
        const he = Le.items;
        return ZM(he, Le.matchText, (at, kn) => {
          const et = t.selection.getRng();
          GM(t.dom, et).each((hn) => {
            const xn = {
              hide: () => T(),
              reload: (Cn) => {
                w(), t.execCommand("mceAutocompleterReload", !1, { fetchOptions: Cn });
              }
            };
            a.set(!0), Le.onAction(xn, hn, at, kn), a.set(!1);
          });
        }, pe, jd.BUBBLE_TO_SANDBOX, s, Le.highlightOn);
      });
    }, $ = (ne, pe) => {
      TR(bt.fromDom(t.getBody())).each((Le) => {
        const he = Ho(ne, (at) => z.from(at.columns)).getOr(1);
        na.showMenuAt(f, {
          anchor: {
            type: "node",
            root: bt.fromDom(t.getBody()),
            node: z.from(Le)
          }
        }, qM(y3("autocompleter-value", !0, pe, he, "normal"), he, Wv.ContentFocus, "normal"));
      }), C().each(Hs.highlightFirst);
    }, I = (ne) => {
      const pe = D(ne);
      pe.length > 0 ? $(ne, pe) : w();
    };
    t.on("AutocompleterStart", ({ lookupData: ne }) => {
      l.set(!0), a.set(!1), I(ne);
    }), t.on("AutocompleterUpdate", ({ lookupData: ne }) => I(ne)), t.on("AutocompleterEnd", () => {
      w(), l.set(!1), a.set(!1);
    });
    const V = {
      cancelIfNecessary: T,
      isMenuOpen: g,
      isActive: h,
      isProcessingAction: a.get,
      getMenu: C
    };
    ER.setup(V, t);
  } }, Zv = (t, s, a) => Wi(t, s, a).isSome(), Sz = (t, s) => {
    let a = null;
    return {
      cancel: () => {
        a !== null && (clearTimeout(a), a = null);
      },
      schedule: (...g) => {
        a = setTimeout(() => {
          t.apply(null, g), a = null;
        }, s);
      }
    };
  }, xz = 5, YM = 400, Tz = (t) => {
    const s = t.raw;
    return s.touches === void 0 || s.touches.length !== 1 ? z.none() : z.some(s.touches[0]);
  }, Ez = (t, s) => {
    const a = Math.abs(t.clientX - s.x), l = Math.abs(t.clientY - s.y);
    return a > xz || l > xz;
  }, XM = (t) => {
    const s = Ar(), a = Xn(!1), l = Sz((T) => {
      t.triggerEvent(Vk(), T), a.set(!0);
    }, YM), f = (T) => (Tz(T).each((D) => {
      l.cancel();
      const $ = {
        x: D.clientX,
        y: D.clientY,
        target: T.target
      };
      l.schedule(T), a.set(!1), s.set($);
    }), z.none()), g = (T) => (l.cancel(), Tz(T).each((D) => {
      s.on(($) => {
        Ez(D, $) && s.clear();
      });
    }), z.none()), h = (T) => {
      l.cancel();
      const D = ($) => Lo($.target, T.target);
      return s.get().filter(D).map(($) => a.get() ? (T.prevent(), !1) : t.triggerEvent(bg(), T));
    }, w = Ze([
      {
        key: Wc(),
        value: f
      },
      {
        key: Uu(),
        value: g
      },
      {
        key: uu(),
        value: h
      }
    ]);
    return { fireIfReady: (T, D) => ht(w, D).bind(($) => $(T)) };
  }, JM = (t) => t.raw.which === av[0] && !Fn([
    "input",
    "textarea"
  ], zt(t.target)) && !Zv(t.target, '[contenteditable="true"]'), Wm = (t, s) => {
    const a = {
      stopBackspace: !0,
      ...s
    }, l = [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "gesturestart",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "click"
    ], f = XM(a), g = Xe(l.concat([
      "selectstart",
      "input",
      "contextmenu",
      "change",
      "transitionend",
      "transitioncancel",
      "drag",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "drop",
      "keyup"
    ]), (V) => Va(t, V, (ne) => {
      f.fireIfReady(ne, V).each((Le) => {
        Le && ne.kill();
      }), a.triggerEvent(V, ne) && ne.kill();
    })), h = Ar(), w = Va(t, "paste", (V) => {
      f.fireIfReady(V, "paste").each((pe) => {
        pe && V.kill();
      }), a.triggerEvent("paste", V) && V.kill(), h.set(setTimeout(() => {
        a.triggerEvent(Ay(), V);
      }, 0));
    }), C = Va(t, "keydown", (V) => {
      a.triggerEvent("keydown", V) ? V.kill() : a.stopBackspace && JM(V) && V.prevent();
    }), T = Va(t, "focusin", (V) => {
      a.triggerEvent("focusin", V) && V.kill();
    }), D = Ar(), $ = Va(t, "focusout", (V) => {
      a.triggerEvent("focusout", V) && V.kill(), D.set(setTimeout(() => {
        a.triggerEvent(D1(), V);
      }, 0));
    });
    return { unbind: () => {
      O(g, (V) => {
        V.unbind();
      }), C.unbind(), T.unbind(), $.unbind(), w.unbind(), h.on(clearTimeout), D.on(clearTimeout);
    } };
  }, Az = (t, s) => {
    const a = ht(t, "target").getOr(s);
    return Xn(a);
  }, QM = (t, s) => {
    const a = Xn(!1), l = Xn(!1);
    return {
      stop: () => {
        a.set(!0);
      },
      cut: () => {
        l.set(!0);
      },
      isStopped: a.get,
      isCut: l.get,
      event: t,
      setSource: s.set,
      getSource: s.get
    };
  }, sT = (t) => {
    const s = Xn(!1);
    return {
      stop: () => {
        s.set(!0);
      },
      cut: ie,
      isStopped: s.get,
      isCut: Ot,
      event: t,
      setSource: wn("Cannot set source of a broadcasted event"),
      getSource: wn("Cannot get source of a broadcasted event")
    };
  }, Lr = Pa.generate([
    { stopped: [] },
    { resume: ["element"] },
    { complete: [] }
  ]), zz = (t, s, a, l, f, g) => {
    const h = t(s, l), w = QM(a, f);
    return h.fold(() => (g.logEventNoHandlers(s, l), Lr.complete()), (C) => {
      const T = C.descHandler;
      return xm(T)(w), w.isStopped() ? (g.logEventStopped(s, C.element, T.purpose), Lr.stopped()) : w.isCut() ? (g.logEventCut(s, C.element, T.purpose), Lr.complete()) : Wr(C.element).fold(() => (g.logNoParent(s, C.element, T.purpose), Lr.complete()), ($) => (g.logEventResponse(s, C.element, T.purpose), Lr.resume($)));
    });
  }, Oz = (t, s, a, l, f, g) => zz(t, s, a, l, f, g).fold(Se, (h) => Oz(t, s, a, h, f, g), Ot), eN = (t, s, a, l, f) => {
    const g = Az(a, l);
    return zz(t, s, a, l, g, f);
  }, tN = (t, s, a) => {
    const l = sT(s);
    return O(t, (f) => {
      const g = f.descHandler;
      xm(g)(l);
    }), l.isStopped();
  }, nN = (t, s, a, l) => Dz(t, s, a, a.target, l), Dz = (t, s, a, l, f) => {
    const g = Az(a, l);
    return Oz(t, s, a, l, g, f);
  }, oN = (t, s) => ({
    element: t,
    descHandler: s
  }), sN = (t, s) => ({
    id: t,
    descHandler: s
  }), rN = () => {
    const t = {}, s = (h, w, C) => {
      ro(C, (T, D) => {
        const $ = t[D] !== void 0 ? t[D] : {};
        $[w] = Hy(T, h), t[D] = $;
      });
    }, a = (h, w) => Cm(w).bind((C) => ht(h, C)).map((C) => oN(w, C));
    return {
      registerId: s,
      unregisterId: (h) => {
        ro(t, (w, C) => {
          qn(w, h) && delete w[h];
        });
      },
      filterByType: (h) => ht(t, h).map((w) => $e(w, (C, T) => sN(T, C))).getOr([]),
      find: (h, w, C) => ht(t, w).bind((T) => ks(C, (D) => a(T, D), h))
    };
  }, aN = () => {
    const t = rN(), s = {}, a = (T) => {
      const D = T.element;
      return Cm(D).getOrThunk(() => _g("uid-", T.element));
    }, l = (T, D) => {
      const $ = s[D];
      if ($ === T)
        g(T);
      else
        throw new Error('The tagId "' + D + '" is already used by: ' + Af($.element) + `
Cannot use it for: ` + Af(T.element) + `
The conflicting element is` + (Ko($.element) ? " " : " not ") + "already in the DOM");
    }, f = (T) => {
      const D = a(T);
      pr(s, D) && l(T, D);
      const $ = [T];
      t.registerId($, D, T.events), s[D] = T;
    }, g = (T) => {
      Cm(T.element).each((D) => {
        delete s[D], t.unregisterId(D);
      });
    };
    return {
      find: (T, D, $) => t.find(T, D, $),
      filter: (T) => t.filterByType(T),
      register: f,
      unregister: g,
      getById: (T) => ht(s, T)
    };
  }, Zm = Wa({
    name: "Container",
    factory: (t) => {
      const { attributes: s, ...a } = t.dom;
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "presentation",
            ...s
          },
          ...a
        },
        components: t.components,
        behaviours: Db(t.containerBehaviours),
        events: t.events,
        domModification: t.domModification,
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Te("components", []),
      Oa("containerBehaviours", []),
      Te("events", {}),
      Te("domModification", {}),
      Te("eventOrder", {})
    ]
  }), Rz = (t) => {
    const s = (he) => Wr(t.element).fold(Se, (at) => Lo(he, at)), a = aN(), l = (he, at) => a.find(s, he, at), f = Wm(t.element, {
      triggerEvent: (he, at) => uh(he, at.target, (kn) => nN(l, he, at, kn))
    }), g = {
      debugInfo: oe("real"),
      triggerEvent: (he, at, kn) => {
        uh(he, at, (et) => Dz(l, he, kn, at, et));
      },
      triggerFocus: (he, at) => {
        Cm(he).fold(() => {
          Xu(he);
        }, (kn) => {
          uh(du(), he, (et) => (eN(l, du(), {
            originator: at,
            kill: ie,
            prevent: ie,
            target: he
          }, he, et), !1));
        });
      },
      triggerEscape: (he, at) => {
        g.triggerEvent("keydown", he.element, at.event);
      },
      getByUid: (he) => pe(he),
      getByDom: (he) => Le(he),
      build: bc,
      buildOrPatch: qy,
      addToGui: (he) => {
        C(he);
      },
      removeFromGui: (he) => {
        T(he);
      },
      addToWorld: (he) => {
        h(he);
      },
      removeFromWorld: (he) => {
        w(he);
      },
      broadcast: (he) => {
        I(he);
      },
      broadcastOn: (he, at) => {
        V(he, at);
      },
      broadcastEvent: (he, at) => {
        ne(he, at);
      },
      isConnected: Se
    }, h = (he) => {
      he.connect(g), On(he.element) || (a.register(he), O(he.components(), h), g.triggerEvent(Oy(), he.element, { target: he.element }));
    }, w = (he) => {
      On(he.element) || (O(he.components(), w), a.unregister(he)), he.disconnect();
    }, C = (he) => {
      Ml(t, he);
    }, T = (he) => {
      Nl(he);
    }, D = () => {
      f.unbind(), rl(t.element);
    }, $ = (he) => {
      const at = a.filter(_m());
      O(at, (kn) => {
        const et = kn.descHandler;
        xm(et)(he);
      });
    }, I = (he) => {
      $({
        universal: !0,
        data: he
      });
    }, V = (he, at) => {
      $({
        universal: !1,
        channels: he,
        data: at
      });
    }, ne = (he, at) => {
      const kn = a.filter(he);
      return tN(kn, at);
    }, pe = (he) => a.getById(he).fold(() => yo.error(new Error('Could not find component with uid: "' + he + '" in system.')), yo.value), Le = (he) => {
      const at = Cm(he).getOr("not found");
      return pe(at);
    };
    return h(t), {
      root: t,
      element: t.element,
      destroy: D,
      add: C,
      remove: T,
      getByUid: pe,
      getByDom: Le,
      addToWorld: h,
      removeFromWorld: w,
      broadcast: I,
      broadcastOn: V,
      broadcastEvent: ne
    };
  }, cN = (t, s) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-bar",
        "tox-form__controls-h-stack"
      ]
    },
    components: Xe(t.items, s.interpreter)
  }), lN = oe([
    Te("prefix", "form-field"),
    Oa("fieldBehaviours", [
      cs,
      cn
    ])
  ]), iN = oe([
    vu({
      schema: [ut("dom")],
      name: "label"
    }),
    vu({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [ut("text")],
      name: "aria-descriptor"
    }),
    Cc({
      factory: {
        sketch: (t) => {
          const s = q(t, ["factory"]);
          return t.factory.sketch(s);
        }
      },
      schema: [ut("factory")],
      name: "field"
    })
  ]), uN = (t, s, a, l) => {
    const f = Ua(t.fieldBehaviours, [
      cs.config({
        find: (w) => Ds(w, t, "field")
      }),
      cn.config({
        store: {
          mode: "manual",
          getValue: (w) => cs.getCurrent(w).bind(cn.getValue),
          setValue: (w, C) => {
            cs.getCurrent(w).each((T) => {
              cn.setValue(T, C);
            });
          }
        }
      })
    ]), g = Ls([kr((w, C) => {
      const T = k_(w, t, [
        "label",
        "field",
        "aria-descriptor"
      ]);
      T.field().each((D) => {
        const $ = $n(t.prefix);
        T.label().each((I) => {
          to(I.element, "for", $), to(D.element, "id", $);
        }), T["aria-descriptor"]().each((I) => {
          const V = $n(t.prefix);
          to(I.element, "id", V), to(D.element, "aria-describedby", V);
        });
      });
    })]), h = {
      getField: (w) => Ds(w, t, "field"),
      getLabel: (w) => Ds(w, t, "label")
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: f,
      events: g,
      apis: h
    };
  }, Bs = Jc({
    name: "FormField",
    configFields: lN(),
    partFields: iN(),
    factory: uN,
    apis: {
      getField: (t, s) => t.getField(s),
      getLabel: (t, s) => t.getLabel(s)
    }
  });
  var dN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, s) => Ku({
      attributes: Ze([{
        key: s.tabAttr,
        value: "true"
      }])
    })
  }), fN = [Te("tabAttr", "data-alloy-tabstop")];
  const oa = Ha({
    fields: fN,
    name: "tabstopping",
    active: dN
  });
  var mN = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const qv = (t, s, a, l) => {
    const f = Mz(t, s, a, l);
    return Bs.sketch(f);
  }, gN = (t, s) => qv(t, s, [], []), Mz = (t, s, a, l) => ({
    dom: Nz(a),
    components: t.toArray().concat([s]),
    fieldBehaviours: qt(l)
  }), pN = () => Nz([]), Nz = (t) => ({
    tag: "div",
    classes: ["tox-form__group"].concat(t)
  }), _p = (t, s) => Bs.parts.label({
    dom: {
      tag: "label",
      classes: ["tox-label"]
    },
    components: [wa(s.translate(t))]
  }), ei = $n("form-component-change"), Gv = $n("form-close"), oy = $n("form-cancel"), qm = $n("form-action"), r1 = $n("form-submit"), rT = $n("form-block"), aT = $n("form-unblock"), Bz = $n("form-tabchange"), $z = $n("form-resize"), Pz = (t, s, a) => {
    const l = t.label.map(($) => _p($, s)), f = ($) => (I, V) => {
      Wi(V.event.target, "[data-collection-item-value]").each((ne) => {
        $(I, V, ne, Vo(ne, "data-collection-item-value"));
      });
    }, g = ($, I) => {
      const V = Xe(I, (Le) => {
        const he = Su.translate(Le.text), at = t.columns === 1 ? `<div class="tox-collection__item-label">${he}</div>` : "", kn = `<div class="tox-collection__item-icon">${Le.icon}</div>`, et = {
          _: " ",
          " - ": " ",
          "-": " "
        }, hn = he.replace(/\_| \- |\-/g, (Cn) => et[Cn]);
        return `<div class="tox-collection__item${s.isDisabled() ? " tox-collection__item--state-disabled" : ""}" tabindex="-1" data-collection-item-value="${mN.encodeAllRaw(Le.value)}" title="${hn}" aria-label="${hn}">${kn}${at}</div>`;
      }), ne = t.columns !== "auto" && t.columns > 1 ? Mn(V, t.columns) : [V], pe = Xe(ne, (Le) => `<div class="tox-collection__group">${Le.join("")}</div>`);
      Ef($.element, pe.join(""));
    }, h = f(($, I, V, ne) => {
      I.stop(), s.isDisabled() || no($, qm, {
        name: t.name,
        value: ne
      });
    }), w = [
      dt(Br(), f(($, I, V) => {
        Xu(V);
      })),
      dt(yg(), h),
      dt(bg(), h),
      dt(Ta(), f(($, I, V) => {
        sc($.element, "." + Dv).each((ne) => {
          Yr(ne, Dv);
        }), Ea(V, Dv);
      })),
      dt(z1(), f(($) => {
        sc($.element, "." + Dv).each((I) => {
          Yr(I, Dv);
        });
      })),
      zd(f(($, I, V, ne) => {
        no($, qm, {
          name: t.name,
          value: ne
        });
      }))
    ], C = ($, I) => Xe(Mc($.element, ".tox-collection__item"), I), T = Bs.parts.field({
      dom: {
        tag: "div",
        classes: ["tox-collection"].concat(t.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
      },
      components: [],
      factory: { sketch: Je },
      behaviours: qt([
        ao.config({
          disabled: s.isDisabled,
          onDisabled: ($) => {
            C($, (I) => {
              Ea(I, "tox-collection__item--state-disabled"), to(I, "aria-disabled", !0);
            });
          },
          onEnabled: ($) => {
            C($, (I) => {
              Yr(I, "tox-collection__item--state-disabled"), nr(I, "aria-disabled");
            });
          }
        }),
        ma(),
        Uo.config({}),
        cn.config({
          store: {
            mode: "memory",
            initialValue: a.getOr([])
          },
          onSetValue: ($, I) => {
            g($, I), t.columns === "auto" && Jh($, 5, "tox-collection__item").each(({ numRows: V, numColumns: ne }) => {
              Kn.setGridSize($, V, ne);
            }), Ts($, $z);
          }
        }),
        oa.config({}),
        Kn.config(Y3(t.columns, "normal")),
        ys("collection-events", w)
      ]),
      eventOrder: {
        [Kl()]: [
          "disabling",
          "alloy.base.behaviour",
          "collection-events"
        ]
      }
    });
    return qv(l, T, ["tox-form__group--collection"], []);
  }, Fz = oe([
    xs("data"),
    Te("inputAttributes", {}),
    Te("inputStyles", {}),
    Te("tag", "input"),
    Te("inputClasses", []),
    Es("onSetValue"),
    Te("styles", {}),
    Te("eventOrder", {}),
    Oa("inputBehaviours", [
      cn,
      go
    ]),
    Te("selectOnFocus", !0)
  ]), cT = (t) => qt([go.config({
    onFocus: t.selectOnFocus ? (s) => {
      const a = s.element, l = Ui(a);
      a.dom.setSelectionRange(0, l.length);
    } : ie
  })]), hN = (t) => ({
    ...cT(t),
    ...Ua(t.inputBehaviours, [cn.config({
      store: {
        mode: "manual",
        ...t.data.map((s) => ({ initialValue: s })).getOr({}),
        getValue: (s) => Ui(s.element),
        setValue: (s, a) => {
          Ui(s.element) !== a && yi(s.element, a);
        }
      },
      onSetValue: t.onSetValue
    })])
  }), lT = (t) => ({
    tag: t.tag,
    attributes: {
      type: "text",
      ...t.inputAttributes
    },
    styles: t.inputStyles,
    classes: t.inputClasses
  }), yN = (t, s) => ({
    uid: t.uid,
    dom: lT(t),
    components: [],
    behaviours: hN(t),
    eventOrder: t.eventOrder
  }), Kv = Wa({
    name: "Input",
    configFields: Fz(),
    factory: yN
  }), iT = (t) => {
    let s = z.none(), a = [];
    const l = (T) => iT((D) => {
      f(($) => {
        D(T($));
      });
    }), f = (T) => {
      h() ? C(T) : a.push(T);
    }, g = (T) => {
      h() || (s = z.some(T), w(a), a = []);
    }, h = () => s.isSome(), w = (T) => {
      O(T, C);
    }, C = (T) => {
      s.each((D) => {
        setTimeout(() => {
          T(D);
        }, 0);
      });
    };
    return t(g), {
      get: f,
      map: l,
      isReady: h
    };
  }, bN = {
    nu: iT,
    pure: (t) => iT((s) => {
      s(t);
    })
  }, vN = (t) => {
    setTimeout(() => {
      throw t;
    }, 0);
  }, a1 = (t) => {
    const s = (C) => {
      t().then(C, vN);
    };
    return {
      map: (C) => a1(() => t().then(C)),
      bind: (C) => a1(() => t().then((T) => C(T).toPromise())),
      anonBind: (C) => a1(() => t().then(() => C.toPromise())),
      toLazy: () => bN.nu(s),
      toCached: () => {
        let C = null;
        return a1(() => (C === null && (C = t()), C));
      },
      toPromise: t,
      get: s
    };
  }, Bc = {
    nu: (t) => a1(() => new Promise(t)),
    pure: (t) => a1(() => Promise.resolve(t))
  }, kN = [
    "input",
    "textarea"
  ], Iz = (t) => {
    const s = zt(t);
    return Fn(kN, s);
  }, uT = (t, s) => {
    const a = s.getRoot(t).getOr(t.element);
    Yr(a, s.invalidClass), s.notify.each((l) => {
      Iz(t.element) && to(t.element, "aria-invalid", !1), l.getContainer(t).each((f) => {
        Ef(f, l.validHtml);
      }), l.onValid(t);
    });
  }, Lz = (t, s, a, l) => {
    const f = s.getRoot(t).getOr(t.element);
    Ea(f, s.invalidClass), s.notify.each((g) => {
      Iz(t.element) && to(t.element, "aria-invalid", !0), g.getContainer(t).each((h) => {
        Ef(h, l);
      }), g.onInvalid(t, l);
    });
  }, Hz = (t, s, a) => s.validator.fold(() => Bc.pure(yo.value(!0)), (l) => l.validate(t)), dT = (t, s, a) => (s.notify.each((l) => {
    l.onValidate(t);
  }), Hz(t, s).map((l) => t.getSystem().isConnected() ? l.fold((f) => (Lz(t, s, a, f), yo.error(f)), (f) => (uT(t, s), yo.value(f))) : yo.error("No longer in system")));
  var wN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    markValid: uT,
    markInvalid: Lz,
    query: Hz,
    run: dT,
    isInvalid: (t, s) => {
      const a = s.getRoot(t).getOr(t.element);
      return oc(a, s.invalidClass);
    }
  }), _N = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => t.validator.map((a) => Ls([dt(a.onEvent, (l) => {
      dT(l, t, s).get(Je);
    })].concat(a.validateOnLoad ? [kr((l) => {
      dT(l, t, s).get(ie);
    })] : []))).getOr({})
  }), CN = [
    ut("invalidClass"),
    Te("getRoot", z.none),
    zc("notify", [
      Te("aria", "alert"),
      Te("getContainer", z.none),
      Te("validHtml", ""),
      Es("onValid"),
      Es("onInvalid"),
      Es("onValidate")
    ]),
    zc("validator", [
      ut("validate"),
      Te("onEvent", "input"),
      Te("validateOnLoad", !0)
    ])
  ];
  const qf = Ha({
    fields: CN,
    name: "invalidating",
    active: _N,
    apis: wN,
    extra: {
      validation: (t) => (s) => {
        const a = cn.getValue(s);
        return Bc.pure(t(a));
      }
    }
  });
  var SN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCoupled: (t, s, a, l) => a.getOrCreate(t, s, l)
  }), xN = [Ac("others", vd(yo.value, tc()))], TN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = {}, s = (l, f, g) => {
        const h = mn(f.others);
        if (h)
          return ht(t, g).getOrThunk(() => {
            const C = ht(f.others, g).getOrDie("No information found for coupled component: " + g)(l), T = l.getSystem().build(C);
            return t[g] = T, T;
          });
        throw new Error("Cannot find coupled component: " + g + ". Known coupled components: " + JSON.stringify(h, null, 2));
      }, a = oe({});
      return Ol({
        readState: a,
        getOrCreate: s
      });
    }
  });
  const Hr = Ha({
    fields: xN,
    name: "coupling",
    apis: SN,
    state: TN
  }), jz = oe("sink"), Uz = oe(vu({
    name: jz(),
    overrides: oe({
      dom: { tag: "div" },
      behaviours: qt([dl.config({ useFixed: Se })]),
      events: Ls([
        Ad(xd()),
        Ad(ql()),
        Ad(yg())
      ])
    })
  }));
  var Gd;
  (function(t) {
    t[t.HighlightFirst = 0] = "HighlightFirst", t[t.HighlightNone = 1] = "HighlightNone";
  })(Gd || (Gd = {}));
  const Wz = (t, s) => {
    const a = t.getHotspot(s).getOr(s), l = "hotspot", f = t.getAnchorOverrides();
    return t.layouts.fold(() => ({
      type: l,
      hotspot: a,
      overrides: f
    }), (g) => ({
      type: l,
      hotspot: a,
      overrides: f,
      layouts: g
    }));
  }, bL = (t, s, a) => {
    const l = t.fetch;
    return l(a).map(s);
  }, h2 = (t, s, a, l, f, g, h) => {
    const w = bL(t, s, l), C = qz(l, t);
    return w.map((T) => T.bind((D) => z.from(Wh.sketch({
      ...g.menu(),
      uid: Ks(""),
      data: D,
      highlightImmediately: h === Gd.HighlightFirst,
      onOpenMenu: ($, I) => {
        const V = C().getOrDie();
        dl.position(V, I, { anchor: a }), Yo.decloak(f);
      },
      onOpenSubmenu: ($, I, V) => {
        const ne = C().getOrDie();
        dl.position(ne, V, {
          anchor: {
            type: "submenu",
            item: I
          }
        }), Yo.decloak(f);
      },
      onRepositionMenu: ($, I, V) => {
        const ne = C().getOrDie();
        dl.position(ne, I, { anchor: a }), O(V, (pe) => {
          dl.position(ne, pe.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: pe.triggeringItem
            }
          });
        });
      },
      onEscape: () => (go.focus(l), Yo.close(f), z.some(!0))
    }))));
  }, Cp = (t, s, a, l, f, g, h) => {
    const w = Wz(t, a);
    return h2(t, s, w, a, l, f, h).map((T) => (T.fold(() => {
      Yo.isOpen(l) && Yo.close(l);
    }, (D) => {
      Yo.cloak(l), Yo.open(l, D), g(l);
    }), l));
  }, Zz = (t, s, a, l, f, g, h) => (Yo.close(l), Bc.pure(l)), sy = (t, s, a, l, f, g) => {
    const h = Hr.getCoupled(a, "sandbox");
    return (Yo.isOpen(h) ? Zz : Cp)(t, s, a, h, l, f, g);
  }, EN = (t, s, a) => {
    const l = cs.getCurrent(s).getOr(s), f = Wo(t.element);
    a ? Qt(l.element, "min-width", f + "px") : An(l.element, f);
  }, qz = (t, s) => t.getSystem().getByUid(s.uid + "-" + jz()).map((a) => () => yo.value(a)).getOrThunk(() => s.lazySink.fold(() => () => yo.error(new Error("No internal sink is specified, nor could an external sink be found")), (a) => () => a(t))), Gz = (t) => {
    Yo.getState(t).each((s) => {
      Wh.repositionMenus(s);
    });
  }, mT = (t, s, a) => {
    const l = Rf(), f = (w, C) => {
      const T = Wz(t, s);
      l.link(s.element), t.matchWidth && EN(T.hotspot, C, t.useMinWidth), t.onOpen(T, w, C), a !== void 0 && a.onOpen !== void 0 && a.onOpen(w, C);
    }, g = (w, C) => {
      l.unlink(s.element), a !== void 0 && a.onClose !== void 0 && a.onClose(w, C);
    }, h = qz(s, t);
    return {
      dom: {
        tag: "div",
        classes: t.sandboxClasses,
        attributes: {
          id: l.id,
          role: "listbox"
        }
      },
      behaviours: Bl.augment(t.sandboxBehaviours, [
        cn.config({
          store: {
            mode: "memory",
            initialValue: s
          }
        }),
        Yo.config({
          onOpen: f,
          onClose: g,
          isPartOf: (w, C, T) => Md(C, T) || Md(s, T),
          getAttachPoint: () => h().getOrDie()
        }),
        cs.config({
          find: (w) => Yo.getState(w).bind((C) => cs.getCurrent(C))
        }),
        wi.config({
          channels: {
            ...B0({ isExtraPart: Ot }),
            ...Sh({ doReposition: Gz })
          }
        })
      ])
    };
  }, Kz = (t) => {
    const s = Hr.getCoupled(t, "sandbox");
    Gz(s);
  }, gT = () => [
    Te("sandboxClasses", []),
    Bl.field("sandboxBehaviours", [
      cs,
      wi,
      Yo,
      cn
    ])
  ], AN = oe([
    ut("dom"),
    ut("fetch"),
    Es("onOpen"),
    il("onExecute"),
    Te("getHotspot", z.some),
    Te("getAnchorOverrides", oe({})),
    ed(),
    Oa("dropdownBehaviours", [
      Qo,
      Hr,
      Kn,
      go
    ]),
    ut("toggleClass"),
    Te("eventOrder", {}),
    xs("lazySink"),
    Te("matchWidth", !1),
    Te("useMinWidth", !1),
    xs("role")
  ].concat(gT())), zN = oe([
    Ki({
      schema: [Mg()],
      name: "menu",
      defaults: (t) => ({ onExecute: t.onExecute })
    }),
    Uz()
  ]), ON = (t, s, a, l) => {
    const f = (T) => ht(t.dom, "attributes").bind((D) => ht(D, T)), g = (T) => {
      Yo.getState(T).each((D) => {
        Wh.highlightPrimary(D);
      });
    }, h = (T) => {
      sy(t, Je, T, l, g, Gd.HighlightFirst).get(ie);
    }, w = {
      expand: (T) => {
        Qo.isOn(T) || sy(t, Je, T, l, ie, Gd.HighlightNone).get(ie);
      },
      open: (T) => {
        Qo.isOn(T) || sy(t, Je, T, l, ie, Gd.HighlightFirst).get(ie);
      },
      isOpen: Qo.isOn,
      close: (T) => {
        Qo.isOn(T) && sy(t, Je, T, l, ie, Gd.HighlightFirst).get(ie);
      },
      repositionMenus: (T) => {
        Qo.isOn(T) && Kz(T);
      }
    }, C = (T, D) => (Zu(T), z.some(!0));
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Ua(t.dropdownBehaviours, [
        Qo.config({
          toggleClass: t.toggleClass,
          aria: { mode: "expanded" }
        }),
        Hr.config({
          others: {
            sandbox: (T) => mT(t, T, {
              onOpen: () => Qo.on(T),
              onClose: () => Qo.off(T)
            })
          }
        }),
        Kn.config({
          mode: "special",
          onSpace: C,
          onEnter: C,
          onDown: (T, D) => {
            if (cd.isOpen(T)) {
              const $ = Hr.getCoupled(T, "sandbox");
              g($);
            } else
              cd.open(T);
            return z.some(!0);
          },
          onEscape: (T, D) => cd.isOpen(T) ? (cd.close(T), z.some(!0)) : z.none()
        }),
        go.config({})
      ]),
      events: I_(z.some(h)),
      eventOrder: {
        ...t.eventOrder,
        [Kl()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      apis: w,
      domModification: {
        attributes: {
          "aria-haspopup": "true",
          ...t.role.fold(() => ({}), (T) => ({ role: T })),
          ...t.dom.tag === "button" ? { type: f("type").getOr("button") } : {}
        }
      }
    };
  }, cd = Jc({
    name: "Dropdown",
    configFields: AN(),
    partFields: zN(),
    factory: ON,
    apis: {
      open: (t, s) => t.open(s),
      expand: (t, s) => t.expand(s),
      close: (t, s) => t.close(s),
      isOpen: (t, s) => t.isOpen(s),
      repositionMenus: (t, s) => t.repositionMenus(s)
    }
  });
  var c1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: () => Ls([qu(MC(), Se)]),
    exhibit: () => Ku({
      styles: {
        "-webkit-user-select": "none",
        "user-select": "none",
        "-ms-user-select": "none",
        "-moz-user-select": "-moz-none"
      },
      attributes: { unselectable: "on" }
    })
  });
  const Kd = Ha({
    fields: [],
    name: "unselecting",
    active: c1
  }), RN = (t, s) => cd.sketch({
    dom: t.dom,
    components: t.components,
    toggleClass: "mce-active",
    dropdownBehaviours: qt([
      rd.button(s.providers.isDisabled),
      ma(),
      Kd.config({}),
      oa.config({})
    ]),
    layouts: t.layouts,
    sandboxClasses: ["tox-dialog__popups"],
    lazySink: s.getSink,
    fetch: (a) => Bc.nu((l) => t.fetch(l)).map((l) => z.from(oT(sr(K3($n("menu-value"), l, (f) => {
      t.onItemAction(a, f);
    }, t.columns, t.presets, jd.CLOSE_ON_EXECUTE, Ot, s.providers), { movement: m2(t.columns, t.presets) })))),
    parts: { menu: J_(!1, 1, t.presets) }
  }), pT = $n("color-input-change"), hT = $n("color-swatch-change"), Yv = $n("color-picker-cancel"), MN = (t, s, a, l) => {
    const f = Bs.parts.field({
      factory: Kv,
      inputClasses: ["tox-textfield"],
      data: l,
      onSetValue: (T) => qf.run(T).get(ie),
      inputBehaviours: qt([
        ao.config({ disabled: s.providers.isDisabled }),
        ma(),
        oa.config({}),
        qf.config({
          invalidClass: "tox-textbox-field-invalid",
          getRoot: (T) => Ma(T.element),
          notify: {
            onValid: (T) => {
              const D = cn.getValue(T);
              no(T, pT, { color: D });
            }
          },
          validator: {
            validateOnLoad: !1,
            validate: (T) => {
              const D = cn.getValue(T);
              if (D.length === 0)
                return Bc.pure(yo.value(!0));
              {
                const $ = bt.fromTag("span");
                Qt($, "background-color", D);
                const I = j($, "background-color").fold(() => yo.error("blah"), (V) => yo.value(D));
                return Bc.pure(I);
              }
            }
          }
        })
      ]),
      selectOnFocus: !1
    }), g = t.label.map((T) => _p(T, s.providers)), h = (T, D) => {
      no(T, hT, { value: D });
    }, w = (T, D) => {
      C.getOpt(T).each(($) => {
        D === "custom" ? a.colorPicker((I) => {
          I.fold(() => Ts($, Yv), (V) => {
            h($, V), fz(V);
          });
        }, "#ffffff") : D === "remove" ? h($, "") : h($, D);
      });
    }, C = wr(RN({
      dom: {
        tag: "span",
        attributes: { "aria-label": s.providers.translate("Color swatch") }
      },
      layouts: {
        onRtl: () => [
          kc,
          vc,
          ua
        ],
        onLtr: () => [
          vc,
          kc,
          ua
        ]
      },
      components: [],
      fetch: hz(a.getColors(), a.hasCustomColors()),
      columns: a.getColorCols(),
      presets: "color",
      onItemAction: w
    }, s));
    return Bs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: g.toArray().concat([{
        dom: {
          tag: "div",
          classes: ["tox-color-input"]
        },
        components: [
          f,
          C.asSpec()
        ]
      }]),
      fieldBehaviours: qt([ys("form-field-events", [
        dt(pT, (T, D) => {
          C.getOpt(T).each(($) => {
            Qt($.element, "background-color", D.event.color);
          }), no(T, ei, { name: t.name });
        }),
        dt(hT, (T, D) => {
          Bs.getField(T).each(($) => {
            cn.setValue($, D.event.value), cs.getCurrent(T).each(go.focus);
          });
        }),
        dt(Yv, (T, D) => {
          Bs.getField(T).each(($) => {
            cs.getCurrent(T).each(go.focus);
          });
        })
      ])])
    });
  }, Xv = vu({
    schema: [ut("dom")],
    name: "label"
  }), ld = (t) => vu({
    name: "" + t + "-edge",
    overrides: (s) => s.model.manager.edgeActions[t].fold(() => ({}), (l) => ({
      events: Ls([
        Jp(Wc(), (f, g, h) => l(f, h), [s]),
        Jp(ql(), (f, g, h) => l(f, h), [s]),
        Jp(hg(), (f, g, h) => {
          h.mouseIsDown.get() && l(f, h);
        }, [s])
      ])
    }))
  }), NN = ld("top-left"), BN = ld("top"), $N = ld("top-right"), PN = ld("right"), FN = ld("bottom-right"), IN = ld("bottom"), y2 = ld("bottom-left"), LN = ld("left"), HN = Cc({
    name: "thumb",
    defaults: oe({ dom: { styles: { position: "absolute" } } }),
    overrides: (t) => ({
      events: Ls([
        Ed(Wc(), t, "spectrum"),
        Ed(Uu(), t, "spectrum"),
        Ed(uu(), t, "spectrum"),
        Ed(ql(), t, "spectrum"),
        Ed(hg(), t, "spectrum"),
        Ed(dr(), t, "spectrum")
      ])
    })
  }), VN = Cc({
    schema: [va("mouseIsDown", () => Xn(!1))],
    name: "spectrum",
    overrides: (t) => {
      const a = t.model.manager, l = (f, g) => a.getValueFromEvent(g).map((h) => a.setValueFrom(f, t, h));
      return {
        behaviours: qt([
          Kn.config({
            mode: "special",
            onLeft: (f) => a.onLeft(f, t),
            onRight: (f) => a.onRight(f, t),
            onUp: (f) => a.onUp(f, t),
            onDown: (f) => a.onDown(f, t)
          }),
          go.config({})
        ]),
        events: Ls([
          dt(Wc(), l),
          dt(Uu(), l),
          dt(ql(), l),
          dt(hg(), (f, g) => {
            t.mouseIsDown.get() && l(f, g);
          })
        ])
      };
    }
  });
  var Yz = [
    Xv,
    LN,
    PN,
    BN,
    IN,
    NN,
    $N,
    y2,
    FN,
    HN,
    VN
  ];
  const Jv = oe("slider.change.value"), jN = (t) => t.type.indexOf("touch") !== -1, yT = (t) => {
    const s = t.event.raw;
    if (jN(s)) {
      const a = s;
      return a.touches !== void 0 && a.touches.length === 1 ? z.some(a.touches[0]).map((l) => as(l.clientX, l.clientY)) : z.none();
    } else {
      const a = s;
      return a.clientX !== void 0 ? z.some(a).map((l) => as(l.clientX, l.clientY)) : z.none();
    }
  }, UN = "top", Xz = "right", WN = "bottom", ZN = "left", ry = (t) => t.model.minX, ay = (t) => t.model.minY, b2 = (t) => t.model.minX - 1, Qv = (t) => t.model.minY - 1, Sp = (t) => t.model.maxX, cy = (t) => t.model.maxY, v2 = (t) => t.model.maxX + 1, k2 = (t) => t.model.maxY + 1, bT = (t, s, a) => s(t) - a(t), xp = (t) => bT(t, Sp, ry), vT = (t) => bT(t, cy, ay), Jz = (t) => xp(t) / 2, Qz = (t) => vT(t) / 2, Gm = (t) => t.stepSize, ti = (t) => t.snapToGrid, kT = (t) => t.snapStart, e6 = (t) => t.rounded, w2 = (t, s) => t[s + "-edge"] !== void 0, t6 = (t) => w2(t, ZN), n6 = (t) => w2(t, Xz), wT = (t) => w2(t, UN), _T = (t) => w2(t, WN), Km = (t) => t.model.value.get(), Tp = (t, s) => ({
    x: t,
    y: s
  }), xu = (t, s) => {
    no(t, Jv(), { value: s });
  }, qN = (t, s) => {
    xu(t, Tp(b2(s), Qv(s)));
  }, o6 = (t, s) => {
    xu(t, Qv(s));
  }, s6 = (t, s) => {
    xu(t, Tp(Jz(s), Qv(s)));
  }, r6 = (t, s) => {
    xu(t, Tp(v2(s), Qv(s)));
  }, GN = (t, s) => {
    xu(t, v2(s));
  }, KN = (t, s) => {
    xu(t, Tp(v2(s), Qz(s)));
  }, YN = (t, s) => {
    xu(t, Tp(v2(s), k2(s)));
  }, XN = (t, s) => {
    xu(t, k2(s));
  }, JN = (t, s) => {
    xu(t, Tp(Jz(s), k2(s)));
  }, QN = (t, s) => {
    xu(t, Tp(b2(s), k2(s)));
  }, CT = (t, s) => {
    xu(t, b2(s));
  }, eB = (t, s) => {
    xu(t, Tp(b2(s), Qz(s)));
  }, ST = (t, s, a, l) => t < s ? t : t > a ? a : t === s ? s - 1 : Math.max(s, t - l), xT = (t, s, a, l) => t > a ? t : t < s ? s : t === a ? a + 1 : Math.min(a, t + l), a6 = (t, s, a) => Math.max(s, Math.min(a, t)), tB = (t, s, a, l, f) => f.fold(() => {
    const g = t - s, h = Math.round(g / l) * l;
    return a6(s + h, s - 1, a + 1);
  }, (g) => {
    const h = (t - g) % l, w = Math.round(h / l), C = Math.floor((t - g) / l), T = Math.floor((a - g) / l), D = Math.min(T, C + w), $ = g + D * l;
    return Math.max(g, $);
  }), nB = (t, s, a) => Math.min(a, Math.max(t, s)) - s, c6 = (t) => {
    const { min: s, max: a, range: l, value: f, step: g, snap: h, snapStart: w, rounded: C, hasMinEdge: T, hasMaxEdge: D, minBound: $, maxBound: I, screenRange: V } = t, ne = T ? s - 1 : s, pe = D ? a + 1 : a;
    if (f < $)
      return ne;
    if (f > I)
      return pe;
    {
      const Le = nB(f, $, I), he = a6(Le / V * l + s, ne, pe);
      return h && he >= s && he <= a ? tB(he, s, a, g, w) : C ? Math.round(he) : he;
    }
  }, TT = (t) => {
    const { min: s, max: a, range: l, value: f, hasMinEdge: g, hasMaxEdge: h, maxBound: w, maxOffset: C, centerMinEdge: T, centerMaxEdge: D } = t;
    return f < s ? g ? 0 : T : f > a ? h ? w : D : (f - s) / l * C;
  }, _2 = "top", l6 = "right", i6 = "bottom", ET = "left", oB = "width", sB = "height", Yd = (t) => t.element.dom.getBoundingClientRect(), Tu = (t, s) => t[s], ek = (t) => {
    const s = Yd(t);
    return Tu(s, ET);
  }, C2 = (t) => {
    const s = Yd(t);
    return Tu(s, l6);
  }, S2 = (t) => {
    const s = Yd(t);
    return Tu(s, _2);
  }, AT = (t) => {
    const s = Yd(t);
    return Tu(s, i6);
  }, u6 = (t) => {
    const s = Yd(t);
    return Tu(s, oB);
  }, d6 = (t) => {
    const s = Yd(t);
    return Tu(s, sB);
  }, f6 = (t, s, a) => (t + s) / 2 - a, m6 = (t, s) => {
    const a = Yd(t), l = Yd(s), f = Tu(a, ET), g = Tu(a, l6), h = Tu(l, ET);
    return f6(f, g, h);
  }, x2 = (t, s) => {
    const a = Yd(t), l = Yd(s), f = Tu(a, _2), g = Tu(a, i6), h = Tu(l, _2);
    return f6(f, g, h);
  }, T2 = (t, s) => {
    no(t, Jv(), { value: s });
  }, zT = (t, s, a) => {
    const l = {
      min: ry(s),
      max: Sp(s),
      range: xp(s),
      value: a,
      step: Gm(s),
      snap: ti(s),
      snapStart: kT(s),
      rounded: e6(s),
      hasMinEdge: t6(s),
      hasMaxEdge: n6(s),
      minBound: ek(t),
      maxBound: C2(t),
      screenRange: u6(t)
    };
    return c6(l);
  }, Ym = (t, s, a) => {
    const l = zT(t, s, a);
    return T2(t, l), l;
  }, rB = (t, s) => {
    const a = ry(s);
    T2(t, a);
  }, tk = (t, s) => {
    const a = Sp(s);
    T2(t, a);
  }, aB = (t, s, a) => {
    const f = (t > 0 ? xT : ST)(Km(a), ry(a), Sp(a), Gm(a));
    return T2(s, f), z.some(f);
  }, E2 = (t) => (s, a) => aB(t, s, a).map(Se), cB = (t) => yT(t).map((a) => a.left), lB = (t, s, a, l, f) => {
    const h = u6(t), w = l.bind((D) => z.some(m6(D, t))).getOr(0), C = f.bind((D) => z.some(m6(D, t))).getOr(h), T = {
      min: ry(s),
      max: Sp(s),
      range: xp(s),
      value: a,
      hasMinEdge: t6(s),
      hasMaxEdge: n6(s),
      minBound: ek(t),
      minOffset: 0,
      maxBound: C2(t),
      maxOffset: h,
      centerMinEdge: w,
      centerMaxEdge: C
    };
    return TT(T);
  }, OT = (t, s, a, l, f, g) => {
    const h = lB(s, g, a, l, f);
    return ek(s) - ek(t) + h;
  }, g6 = (t, s, a, l) => {
    const f = Km(a), g = OT(t, l.getSpectrum(t), f, l.getLeftEdge(t), l.getRightEdge(t), a), h = Wo(s.element) / 2;
    Qt(s.element, "left", g - h + "px");
  }, iB = E2(-1), DT = E2(1), RT = z.none, MT = z.none, uB = {
    "top-left": z.none(),
    top: z.none(),
    "top-right": z.none(),
    right: z.some(GN),
    "bottom-right": z.none(),
    bottom: z.none(),
    "bottom-left": z.none(),
    left: z.some(CT)
  };
  var Qi = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: Ym,
    setToMin: rB,
    setToMax: tk,
    findValueOfOffset: zT,
    getValueFromEvent: cB,
    findPositionOfValue: OT,
    setPositionFromValue: g6,
    onLeft: iB,
    onRight: DT,
    onUp: RT,
    onDown: MT,
    edgeActions: uB
  });
  const A2 = (t, s) => {
    no(t, Jv(), { value: s });
  }, NT = (t, s, a) => {
    const l = {
      min: ay(s),
      max: cy(s),
      range: vT(s),
      value: a,
      step: Gm(s),
      snap: ti(s),
      snapStart: kT(s),
      rounded: e6(s),
      hasMinEdge: wT(s),
      hasMaxEdge: _T(s),
      minBound: S2(t),
      maxBound: AT(t),
      screenRange: d6(t)
    };
    return c6(l);
  }, p6 = (t, s, a) => {
    const l = NT(t, s, a);
    return A2(t, l), l;
  }, h6 = (t, s) => {
    const a = ay(s);
    A2(t, a);
  }, dB = (t, s) => {
    const a = cy(s);
    A2(t, a);
  }, fB = (t, s, a) => {
    const f = (t > 0 ? xT : ST)(Km(a), ay(a), cy(a), Gm(a));
    return A2(s, f), z.some(f);
  }, y6 = (t) => (s, a) => fB(t, s, a).map(Se), mB = (t) => yT(t).map((a) => a.top), gB = (t, s, a, l, f) => {
    const h = d6(t), w = l.bind((D) => z.some(x2(D, t))).getOr(0), C = f.bind((D) => z.some(x2(D, t))).getOr(h), T = {
      min: ay(s),
      max: cy(s),
      range: vT(s),
      value: a,
      hasMinEdge: wT(s),
      hasMaxEdge: _T(s),
      minBound: S2(t),
      minOffset: 0,
      maxBound: AT(t),
      maxOffset: h,
      centerMinEdge: w,
      centerMaxEdge: C
    };
    return TT(T);
  }, BT = (t, s, a, l, f, g) => {
    const h = gB(s, g, a, l, f);
    return S2(s) - S2(t) + h;
  }, pB = (t, s, a, l) => {
    const f = Km(a), g = BT(t, l.getSpectrum(t), f, l.getTopEdge(t), l.getBottomEdge(t), a), h = hs(s.element) / 2;
    Qt(s.element, "top", g - h + "px");
  }, b6 = z.none, hB = z.none, yB = y6(-1), bB = y6(1), v6 = {
    "top-left": z.none(),
    top: z.some(o6),
    "top-right": z.none(),
    right: z.none(),
    "bottom-right": z.none(),
    bottom: z.some(XN),
    "bottom-left": z.none(),
    left: z.none()
  };
  var $T = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: p6,
    setToMin: h6,
    setToMax: dB,
    findValueOfOffset: NT,
    getValueFromEvent: mB,
    findPositionOfValue: BT,
    setPositionFromValue: pB,
    onLeft: b6,
    onRight: hB,
    onUp: yB,
    onDown: bB,
    edgeActions: v6
  });
  const z2 = (t, s) => {
    no(t, Jv(), { value: s });
  }, l1 = (t, s) => ({
    x: t,
    y: s
  }), i1 = (t, s, a) => {
    const l = zT(t, s, a.left), f = NT(t, s, a.top), g = l1(l, f);
    return z2(t, g), g;
  }, k6 = (t, s, a, l) => {
    const f = t > 0 ? xT : ST, g = s ? Km(l).x : f(Km(l).x, ry(l), Sp(l), Gm(l)), h = s ? f(Km(l).y, ay(l), cy(l), Gm(l)) : Km(l).y;
    return z2(a, l1(g, h)), z.some(g);
  }, nk = (t, s) => (a, l) => k6(t, s, a, l).map(Se), w6 = (t, s) => {
    const a = ry(s), l = ay(s);
    z2(t, l1(a, l));
  }, vB = (t, s) => {
    const a = Sp(s), l = cy(s);
    z2(t, l1(a, l));
  }, kB = (t) => yT(t), O2 = (t, s, a, l) => {
    const f = Km(a), g = OT(t, l.getSpectrum(t), f.x, l.getLeftEdge(t), l.getRightEdge(t), a), h = BT(t, l.getSpectrum(t), f.y, l.getTopEdge(t), l.getBottomEdge(t), a), w = Wo(s.element) / 2, C = hs(s.element) / 2;
    Qt(s.element, "left", g - w + "px"), Qt(s.element, "top", h - C + "px");
  }, wB = nk(-1, !1), _B = nk(1, !1), _6 = nk(-1, !0), C6 = nk(1, !0), PT = {
    "top-left": z.some(qN),
    top: z.some(s6),
    "top-right": z.some(r6),
    right: z.some(KN),
    "bottom-right": z.some(YN),
    bottom: z.some(JN),
    "bottom-left": z.some(QN),
    left: z.some(eB)
  };
  var S6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: i1,
    setToMin: w6,
    setToMax: vB,
    getValueFromEvent: kB,
    setPositionFromValue: O2,
    onLeft: wB,
    onRight: _B,
    onUp: _6,
    onDown: C6,
    edgeActions: PT
  });
  const Pl = [
    Te("stepSize", 1),
    Te("onChange", ie),
    Te("onChoose", ie),
    Te("onInit", ie),
    Te("onDragStart", ie),
    Te("onDragEnd", ie),
    Te("snapToGrid", !1),
    Te("rounded", !0),
    xs("snapStart"),
    Ac("model", rr("mode", {
      x: [
        Te("minX", 0),
        Te("maxX", 100),
        va("value", (t) => Xn(t.mode.minX)),
        ut("getInitialValue"),
        fr("manager", Qi)
      ],
      y: [
        Te("minY", 0),
        Te("maxY", 100),
        va("value", (t) => Xn(t.mode.minY)),
        ut("getInitialValue"),
        fr("manager", $T)
      ],
      xy: [
        Te("minX", 0),
        Te("maxX", 100),
        Te("minY", 0),
        Te("maxY", 100),
        va("value", (t) => Xn({
          x: t.mode.minX,
          y: t.mode.minY
        })),
        ut("getInitialValue"),
        fr("manager", S6)
      ]
    })),
    Oa("sliderBehaviours", [
      Kn,
      cn
    ]),
    va("mouseIsDown", () => Xn(!1))
  ], id = Jc({
    name: "Slider",
    configFields: Pl,
    partFields: Yz,
    factory: (t, s, a, l) => {
      const f = (et) => Ti(et, t, "thumb"), g = (et) => Ti(et, t, "spectrum"), h = (et) => Ds(et, t, "left-edge"), w = (et) => Ds(et, t, "right-edge"), C = (et) => Ds(et, t, "top-edge"), T = (et) => Ds(et, t, "bottom-edge"), D = t.model, $ = D.manager, I = (et, hn) => {
        $.setPositionFromValue(et, hn, t, {
          getLeftEdge: h,
          getRightEdge: w,
          getTopEdge: C,
          getBottomEdge: T,
          getSpectrum: g
        });
      }, V = (et, hn) => {
        D.value.set(hn);
        const xn = f(et);
        I(et, xn);
      }, ne = (et, hn) => {
        V(et, hn);
        const xn = f(et);
        return t.onChange(et, xn, hn), z.some(!0);
      }, pe = (et) => {
        $.setToMin(et, t);
      }, Le = (et) => {
        $.setToMax(et, t);
      }, he = (et) => {
        const hn = () => {
          Ds(et, t, "thumb").each((Cn) => {
            const oo = D.value.get();
            t.onChoose(et, Cn, oo);
          });
        }, xn = t.mouseIsDown.get();
        t.mouseIsDown.set(!1), xn && hn();
      }, at = (et, hn) => {
        hn.stop(), t.mouseIsDown.set(!0), t.onDragStart(et, f(et));
      }, kn = (et, hn) => {
        hn.stop(), t.onDragEnd(et, f(et)), he(et);
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: s,
        behaviours: Ua(t.sliderBehaviours, [
          Kn.config({
            mode: "special",
            focusIn: (et) => Ds(et, t, "spectrum").map(Kn.focusIn).map(Se)
          }),
          cn.config({
            store: {
              mode: "manual",
              getValue: (et) => D.value.get(),
              setValue: V
            }
          }),
          wi.config({ channels: { [Tb()]: { onReceive: he } } })
        ]),
        events: Ls([
          dt(Jv(), (et, hn) => {
            ne(et, hn.event.value);
          }),
          kr((et, hn) => {
            const xn = D.getInitialValue();
            D.value.set(xn);
            const Cn = f(et);
            I(et, Cn);
            const oo = g(et);
            t.onInit(et, Cn, oo, D.value.get());
          }),
          dt(Wc(), at),
          dt(uu(), kn),
          dt(ql(), at),
          dt(dr(), kn)
        ]),
        apis: {
          resetToMin: pe,
          resetToMax: Le,
          setValue: V,
          refresh: I
        },
        domModification: { styles: { position: "relative" } }
      };
    },
    apis: {
      setValue: (t, s, a) => {
        t.setValue(s, a);
      },
      resetToMin: (t, s) => {
        t.resetToMin(s);
      },
      resetToMax: (t, s) => {
        t.resetToMax(s);
      },
      refresh: (t, s) => {
        t.refresh(s);
      }
    }
  }), FT = $n("rgb-hex-update"), IT = $n("slider-update"), x6 = $n("palette-update"), SB = (t, s) => {
    const a = id.parts.spectrum({
      dom: {
        tag: "div",
        classes: [s("hue-slider-spectrum")],
        attributes: { role: "presentation" }
      }
    }), l = id.parts.thumb({
      dom: {
        tag: "div",
        classes: [s("hue-slider-thumb")],
        attributes: { role: "presentation" }
      }
    });
    return id.sketch({
      dom: {
        tag: "div",
        classes: [s("hue-slider")],
        attributes: { role: "presentation" }
      },
      rounded: !1,
      model: {
        mode: "y",
        getInitialValue: oe(0)
      },
      components: [
        a,
        l
      ],
      sliderBehaviours: qt([go.config({})]),
      onChange: (f, g, h) => {
        no(f, IT, { value: h });
      }
    });
  }, T6 = "form", E6 = [Oa("formBehaviours", [cn])], Xd = (t) => "<alloy.field." + t + ">", LT = (t) => {
    const s = (() => {
      const g = [];
      return {
        field: (w, C) => (g.push(w), b_(T6, Xd(w), C)),
        record: oe(g)
      };
    })(), a = t(s), l = s.record(), f = Xe(l, (g) => Cc({
      name: g,
      pname: Xd(g)
    }));
    return Ib(T6, E6, f, D2, a);
  }, A6 = (t, s) => t.fold(() => yo.error(s), yo.value), D2 = (t, s) => ({
    uid: t.uid,
    dom: t.dom,
    components: s,
    behaviours: Ua(t.formBehaviours, [cn.config({
      store: {
        mode: "manual",
        getValue: (a) => {
          const l = w_(a, t);
          return Ln(l, (f, g) => f().bind((h) => {
            const w = cs.getCurrent(h);
            return A6(w, new Error(`Cannot find a current component to extract the value from for form part '${g}': ` + Af(h.element)));
          }).map(cn.getValue));
        },
        setValue: (a, l) => {
          ro(l, (f, g) => {
            Ds(a, t, g).each((h) => {
              cs.getCurrent(h).each((w) => {
                cn.setValue(w, f);
              });
            });
          });
        }
      }
    })]),
    apis: {
      getField: (a, l) => Ds(a, t, l).bind(cs.getCurrent)
    }
  }), Ep = {
    getField: oh((t, s, a) => t.getField(s, a)),
    sketch: LT
  }, z6 = $n("valid-input"), O6 = $n("invalid-input"), D6 = $n("validating-input"), HT = "colorcustom.rgb.", xB = (t, s, a, l) => {
    const f = (I, V) => qf.config({
      invalidClass: s("invalid"),
      notify: {
        onValidate: (ne) => {
          no(ne, D6, { type: I });
        },
        onValid: (ne) => {
          no(ne, z6, {
            type: I,
            value: cn.getValue(ne)
          });
        },
        onInvalid: (ne) => {
          no(ne, O6, {
            type: I,
            value: cn.getValue(ne)
          });
        }
      },
      validator: {
        validate: (ne) => {
          const pe = cn.getValue(ne), Le = V(pe) ? yo.value(!0) : yo.error(t("aria.input.invalid"));
          return Bc.pure(Le);
        },
        validateOnLoad: !1
      }
    }), g = (I, V, ne, pe, Le) => {
      const he = t(HT + "range"), at = Bs.parts.label({
        dom: {
          tag: "label",
          attributes: { "aria-label": pe }
        },
        components: [wa(ne)]
      }), kn = Bs.parts.field({
        data: Le,
        factory: Kv,
        inputAttributes: {
          type: "text",
          ...V === "hex" ? { "aria-live": "polite" } : {}
        },
        inputClasses: [s("textfield")],
        inputBehaviours: qt([
          f(V, I),
          oa.config({})
        ]),
        onSetValue: (Cn) => {
          qf.isInvalid(Cn) && qf.run(Cn).get(ie);
        }
      }), et = [
        at,
        kn
      ], hn = V !== "hex" ? [Bs.parts["aria-descriptor"]({ text: he })] : [], xn = et.concat(hn);
      return {
        dom: {
          tag: "div",
          attributes: { role: "presentation" }
        },
        components: xn
      };
    }, h = (I, V) => {
      const ne = o1(V);
      return Ep.getField(I, "hex").each((pe) => {
        go.isFocused(pe) || cn.setValue(I, { hex: ne.value });
      }), ne;
    }, w = (I, V) => {
      const ne = V.red, pe = V.green, Le = V.blue;
      cn.setValue(I, {
        red: ne,
        green: pe,
        blue: Le
      });
    }, C = wr({
      dom: {
        tag: "div",
        classes: [s("rgba-preview")],
        styles: { "background-color": "white" },
        attributes: { role: "presentation" }
      }
    }), T = (I, V) => {
      C.getOpt(I).each((ne) => {
        Qt(ne.element, "background-color", "#" + V.value);
      });
    };
    return Wa({
      factory: () => {
        const I = {
          red: Xn(z.some(255)),
          green: Xn(z.some(255)),
          blue: Xn(z.some(255)),
          hex: Xn(z.some("ffffff"))
        }, V = (jn, zs) => {
          const io = s1(zs);
          w(jn, io), he(io);
        }, ne = (jn) => I[jn].get(), pe = (jn, zs) => {
          I[jn].set(zs);
        }, Le = () => ne("red").bind((jn) => ne("green").bind((zs) => ne("blue").map((io) => Zf(jn, zs, io, 1)))), he = (jn) => {
          const zs = jn.red, io = jn.green, Mt = jn.blue;
          pe("red", z.some(zs)), pe("green", z.some(io)), pe("blue", z.some(Mt));
        }, at = (jn, zs) => {
          const io = zs.event;
          io.type !== "hex" ? pe(io.type, z.none()) : l(jn);
        }, kn = (jn, zs) => {
          a(jn);
          const io = JA(zs);
          pe("hex", z.some(zs));
          const Mt = s1(io);
          w(jn, Mt), he(Mt), no(jn, FT, { hex: io }), T(jn, io);
        }, et = (jn, zs, io) => {
          const Mt = parseInt(io, 10);
          pe(zs, z.some(Mt)), Le().each((Nn) => {
            const wo = h(jn, Nn);
            no(jn, FT, { hex: wo }), T(jn, wo);
          });
        }, hn = (jn) => jn.type === "hex", xn = (jn, zs) => {
          const io = zs.event;
          hn(io) ? kn(jn, io.value) : et(jn, io.type, io.value);
        }, Cn = (jn) => ({
          label: t(HT + jn + ".label"),
          description: t(HT + jn + ".description")
        }), oo = Cn("red"), so = Cn("green"), us = Cn("blue"), Ms = Cn("hex");
        return sr(Ep.sketch((jn) => ({
          dom: {
            tag: "form",
            classes: [s("rgb-form")],
            attributes: { "aria-label": t("aria.color.picker") }
          },
          components: [
            jn.field("red", Bs.sketch(g(I3, "red", oo.label, oo.description, 255))),
            jn.field("green", Bs.sketch(g(I3, "green", so.label, so.description, 255))),
            jn.field("blue", Bs.sketch(g(I3, "blue", us.label, us.description, 255))),
            jn.field("hex", Bs.sketch(g(ez, "hex", Ms.label, Ms.description, "ffffff"))),
            C.asSpec()
          ],
          formBehaviours: qt([
            qf.config({ invalidClass: s("form-invalid") }),
            ys("rgb-form-events", [
              dt(z6, xn),
              dt(O6, at),
              dt(D6, at)
            ])
          ])
        })), {
          apis: {
            updateHex: (jn, zs) => {
              cn.setValue(jn, { hex: zs.value }), V(jn, zs), T(jn, zs);
            }
          }
        });
      },
      name: "RgbForm",
      configFields: [],
      apis: {
        updateHex: (I, V, ne) => {
          I.updateHex(V, ne);
        }
      },
      extraApis: {}
    });
  }, TB = (t, s) => {
    const a = id.parts.spectrum({
      dom: {
        tag: "canvas",
        attributes: { role: "presentation" },
        classes: [s("sv-palette-spectrum")]
      }
    }), l = id.parts.thumb({
      dom: {
        tag: "div",
        attributes: { role: "presentation" },
        classes: [s("sv-palette-thumb")],
        innerHtml: `<div class=${s("sv-palette-inner-thumb")} role="presentation"></div>`
      }
    }), f = (T, D) => {
      const { width: $, height: I } = T, V = T.getContext("2d");
      if (V === null)
        return;
      V.fillStyle = D, V.fillRect(0, 0, $, I);
      const ne = V.createLinearGradient(0, 0, $, 0);
      ne.addColorStop(0, "rgba(255,255,255,1)"), ne.addColorStop(1, "rgba(255,255,255,0)"), V.fillStyle = ne, V.fillRect(0, 0, $, I);
      const pe = V.createLinearGradient(0, 0, 0, I);
      pe.addColorStop(0, "rgba(0,0,0,0)"), pe.addColorStop(1, "rgba(0,0,0,1)"), V.fillStyle = pe, V.fillRect(0, 0, $, I);
    }, g = (T, D) => {
      const $ = T.components()[0].element.dom, I = ny(D, 100, 100), V = tz(I);
      f($, sz(V));
    }, h = (T, D) => {
      const $ = d2(s1(D));
      id.setValue(T, {
        x: $.saturation,
        y: 100 - $.value
      });
    };
    return Wa({
      factory: (T) => {
        const D = oe({
          x: 0,
          y: 0
        }), $ = (ne, pe, Le) => {
          no(ne, x6, { value: Le });
        }, I = (ne, pe, Le, he) => {
          f(Le.element.dom, sz(ty));
        }, V = qt([
          cs.config({ find: z.some }),
          go.config({})
        ]);
        return id.sketch({
          dom: {
            tag: "div",
            attributes: { role: "presentation" },
            classes: [s("sv-palette")]
          },
          model: {
            mode: "xy",
            getInitialValue: D
          },
          rounded: !1,
          components: [
            a,
            l
          ],
          onChange: $,
          onInit: I,
          sliderBehaviours: V
        });
      },
      name: "SaturationBrightnessPalette",
      configFields: [],
      apis: {
        setHue: (T, D, $) => {
          g(D, $);
        },
        setThumb: (T, D, $) => {
          h(D, $);
        }
      },
      extraApis: {}
    });
  }, EB = (t, s) => {
    const a = (f) => {
      const g = xB(t, s, f.onValidHex, f.onInvalidHex), h = TB(t, s), w = (xn) => (100 - xn) / 100 * 360, C = (xn) => 100 - xn / 360 * 100, T = {
        paletteRgba: Xn(ty),
        paletteHue: Xn(0)
      }, D = wr(SB(t, s)), $ = wr(h.sketch({})), I = wr(g.sketch({})), V = (xn, Cn, oo) => {
        $.getOpt(xn).each((so) => {
          h.setHue(so, oo);
        });
      }, ne = (xn, Cn) => {
        I.getOpt(xn).each((oo) => {
          g.updateHex(oo, Cn);
        });
      }, pe = (xn, Cn, oo) => {
        D.getOpt(xn).each((so) => {
          id.setValue(so, C(oo));
        });
      }, Le = (xn, Cn) => {
        $.getOpt(xn).each((oo) => {
          h.setThumb(oo, Cn);
        });
      }, he = (xn, Cn) => {
        const oo = s1(xn);
        T.paletteRgba.set(oo), T.paletteHue.set(Cn);
      }, at = (xn, Cn, oo, so) => {
        he(Cn, oo), O(so, (us) => {
          us(xn, Cn, oo);
        });
      }, kn = () => {
        const xn = [ne];
        return (Cn, oo) => {
          const so = oo.event.value, us = T.paletteHue.get(), Ms = ny(us, so.x, 100 - so.y), jn = V3(Ms);
          at(Cn, jn, us, xn);
        };
      }, et = () => {
        const xn = [
          V,
          ne
        ];
        return (Cn, oo) => {
          const so = w(oo.event.value), us = T.paletteRgba.get(), Ms = d2(us), jn = ny(so, Ms.saturation, Ms.value), zs = V3(jn);
          at(Cn, zs, so, xn);
        };
      }, hn = () => {
        const xn = [
          V,
          pe,
          Le
        ];
        return (Cn, oo) => {
          const so = oo.event.hex, us = xM(so);
          at(Cn, so, us.hue, xn);
        };
      };
      return {
        uid: f.uid,
        dom: f.dom,
        components: [
          $.asSpec(),
          D.asSpec(),
          I.asSpec()
        ],
        behaviours: qt([
          ys("colour-picker-events", [
            dt(FT, hn()),
            dt(x6, kn()),
            dt(IT, et())
          ]),
          cs.config({ find: (xn) => I.getOpt(xn) }),
          Kn.config({ mode: "acyclic" })
        ])
      };
    };
    return Wa({
      name: "ColourPicker",
      configFields: [
        ut("dom"),
        Te("onValidHex", ie),
        Te("onInvalidHex", ie)
      ],
      factory: a
    });
  }, Di = {
    self: () => cs.config({ find: z.some }),
    memento: (t) => cs.config({ find: t.getOpt }),
    childAt: (t) => cs.config({ find: (s) => Xa(s.element, t).bind((a) => s.getSystem().getByDom(a).toOptional()) })
  }, zB = Pn([
    Te("preprocess", Je),
    Te("postprocess", Je)
  ]), OB = (t, s) => {
    const a = Vc("RepresentingConfigs.memento processors", zB, s);
    return cn.config({
      store: {
        mode: "manual",
        getValue: (l) => {
          const f = t.get(l), g = cn.getValue(f);
          return a.postprocess(g);
        },
        setValue: (l, f) => {
          const g = a.preprocess(f), h = t.get(l);
          cn.setValue(h, g);
        }
      }
    });
  }, VT = (t, s, a) => cn.config({
    store: {
      mode: "manual",
      ...t.map((l) => ({ initialValue: l })).getOr({}),
      getValue: s,
      setValue: a
    }
  }), R2 = (t, s, a) => VT(t, (l) => s(l.element), (l, f) => a(l.element, f)), Fl = {
    memento: OB,
    withElement: R2,
    withComp: VT,
    domValue: (t) => R2(t, Ui, yi),
    domHtml: (t) => R2(t, eh, Ef),
    memory: (t) => cn.config({
      store: {
        mode: "memory",
        initialValue: t
      }
    })
  }, M6 = {
    "colorcustom.rgb.red.label": "R",
    "colorcustom.rgb.red.description": "Red component",
    "colorcustom.rgb.green.label": "G",
    "colorcustom.rgb.green.description": "Green component",
    "colorcustom.rgb.blue.label": "B",
    "colorcustom.rgb.blue.description": "Blue component",
    "colorcustom.rgb.hex.label": "#",
    "colorcustom.rgb.hex.description": "Hex color code",
    "colorcustom.rgb.range": "Range 0 to 255",
    "aria.color.picker": "Color Picker",
    "aria.input.invalid": "Invalid input"
  }, N6 = (t) => (s) => t.translate(M6[s]), DB = (t, s, a) => {
    const l = (C) => "tox-" + C, f = EB(N6(s), l), g = (C) => {
      no(C, qm, {
        name: "hex-valid",
        value: !0
      });
    }, h = (C) => {
      no(C, qm, {
        name: "hex-valid",
        value: !1
      });
    }, w = wr(f.sketch({
      dom: {
        tag: "div",
        classes: [l("color-picker-container")],
        attributes: { role: "presentation" }
      },
      onValidHex: g,
      onInvalidHex: h
    }));
    return {
      dom: { tag: "div" },
      components: [w.asSpec()],
      behaviours: qt([
        Fl.withComp(a, (C) => {
          const T = w.get(C);
          return cs.getCurrent(T).bind((I) => cn.getValue(I).hex).map((I) => "#" + I).getOr("");
        }, (C, T) => {
          const $ = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(T), I = w.get(C);
          cs.getCurrent(I).fold(() => {
            console.log("Can not find form");
          }, (ne) => {
            cn.setValue(ne, { hex: z.from($[1]).getOr("") }), Ep.getField(ne, "hex").each((pe) => {
              Ts(pe, Zc());
            });
          });
        }),
        Di.self()
      ])
    };
  };
  var RB = tinymce.util.Tools.resolve("tinymce.Resource");
  const MB = (t) => qn(t, "init"), NB = (t) => {
    const s = Ar(), a = wr({ dom: { tag: t.tag } }), l = Ar();
    return {
      dom: {
        tag: "div",
        classes: ["tox-custom-editor"]
      },
      behaviours: qt([
        ys("custom-editor-events", [kr((f) => {
          a.getOpt(f).each((g) => {
            (MB(t) ? t.init(g.element.dom) : RB.load(t.scriptId, t.scriptUrl).then((h) => h(g.element.dom, t.settings))).then((h) => {
              l.on((w) => {
                h.setValue(w);
              }), l.clear(), s.set(h);
            });
          });
        })]),
        Fl.withComp(z.none(), () => s.get().fold(() => l.get().getOr(""), (f) => f.getValue()), (f, g) => {
          s.get().fold(() => l.set(g), (h) => h.setValue(g));
        }),
        Di.self()
      ]),
      components: [a.asSpec()]
    };
  };
  var ly = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const BB = (t, s) => {
    const a = ly.explode(s.getOption("images_file_types")), l = (f) => Sn(a, (g) => Z(f.name.toLowerCase(), `.${g.toLowerCase()}`));
    return Pt(ds(t), l);
  }, $B = (t, s, a) => {
    const l = (I, V) => {
      V.stop();
    }, f = (I) => (V, ne) => {
      O(I, (pe) => {
        pe(V, ne);
      });
    }, g = (I, V) => {
      if (!ao.isDisabled(I)) {
        const ne = V.event.raw;
        w(I, ne.dataTransfer.files);
      }
    }, h = (I, V) => {
      const ne = V.event.raw.target;
      w(I, ne.files);
    }, w = (I, V) => {
      cn.setValue(I, BB(V, s)), no(I, ei, { name: t.name });
    }, C = wr({
      dom: {
        tag: "input",
        attributes: {
          type: "file",
          accept: "image/*"
        },
        styles: { display: "none" }
      },
      behaviours: qt([ys("input-file-events", [
        Ad(yg()),
        Ad(bg())
      ])])
    }), T = (I) => ({
      uid: I.uid,
      dom: {
        tag: "div",
        classes: ["tox-dropzone-container"]
      },
      behaviours: qt([
        Fl.memory(a.getOr([])),
        Di.self(),
        ao.config({}),
        Qo.config({
          toggleClass: "dragenter",
          toggleOnExecute: !1
        }),
        ys("dropzone-events", [
          dt("dragenter", f([
            l,
            Qo.toggle
          ])),
          dt("dragleave", f([
            l,
            Qo.toggle
          ])),
          dt("dragover", l),
          dt("drop", f([
            l,
            g
          ])),
          dt(Gl(), h)
        ])
      ]),
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dropzone"],
          styles: {}
        },
        components: [
          {
            dom: { tag: "p" },
            components: [wa(s.translate("Drop an image here"))]
          },
          $l.sketch({
            dom: {
              tag: "button",
              styles: { position: "relative" },
              classes: [
                "tox-button",
                "tox-button--secondary"
              ]
            },
            components: [
              wa(s.translate("Browse for an image")),
              C.asSpec()
            ],
            action: (V) => {
              C.get(V).element.dom.click();
            },
            buttonBehaviours: qt([
              oa.config({}),
              rd.button(s.isDisabled),
              ma()
            ])
          })
        ]
      }]
    }), D = t.label.map((I) => _p(I, s)), $ = Bs.parts.field({ factory: { sketch: T } });
    return qv(D, $, ["tox-form__group--stretched"], []);
  }, B6 = (t, s) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-form__grid",
        `tox-form__grid--${t.columns}col`
      ]
    },
    components: Xe(t.items, s.interpreter)
  }), N2 = $n("alloy-fake-before-tabstop"), UT = $n("alloy-fake-after-tabstop"), WT = (t) => ({
    dom: {
      tag: "div",
      styles: {
        width: "1px",
        height: "1px",
        outline: "none"
      },
      attributes: { tabindex: "0" },
      classes: t
    },
    behaviours: qt([
      go.config({ ignore: !0 }),
      oa.config({})
    ])
  }), $6 = (t) => ({
    dom: {
      tag: "div",
      classes: ["tox-navobj"]
    },
    components: [
      WT([N2]),
      t,
      WT([UT])
    ],
    behaviours: qt([Di.childAt(1)])
  }), ZT = (t, s) => {
    no(t, xd(), {
      raw: {
        which: 9,
        shiftKey: s
      }
    });
  }, ok = (t, s) => {
    const a = s.element;
    oc(a, N2) ? ZT(t, !0) : oc(a, UT) && ZT(t, !1);
  }, sk = (t) => Zv(t, [
    "." + N2,
    "." + UT
  ].join(","), Ot), P6 = (t) => {
    const s = Xn(t.getOr(""));
    return {
      getValue: (a) => s.get(),
      setValue: (a, l) => {
        s.get() !== l && to(a.element, "srcdoc", l), s.set(l);
      }
    };
  }, PB = (t, s, a) => {
    const l = t.sandboxed, f = t.transparent, g = "tox-dialog__iframe", h = {
      ...t.label.map(($) => ({ title: $ })).getOr({}),
      ...a.map(($) => ({ srcdoc: $ })).getOr({}),
      ...l ? { sandbox: "allow-scripts allow-same-origin" } : {}
    }, w = P6(a), C = t.label.map(($) => _p($, s)), T = ($) => $6({
      uid: $.uid,
      dom: {
        tag: "iframe",
        attributes: h,
        classes: f ? [g] : [
          g,
          `${g}--opaque`
        ]
      },
      behaviours: qt([
        oa.config({}),
        go.config({}),
        Fl.withComp(a, w.getValue, w.setValue)
      ])
    }), D = Bs.parts.field({ factory: { sketch: T } });
    return qv(C, D, ["tox-form__group--stretched"], []);
  }, FB = (t) => new Promise((s, a) => {
    const l = () => {
      g(), s(t);
    }, f = [
      Va(t, "load", l),
      Va(t, "error", () => {
        g(), a("Unable to load data from image: " + t.dom.src);
      })
    ], g = () => O(f, (h) => h.unbind());
    t.dom.complete && l();
  }), IB = (t, s, a, l, f) => {
    const g = a * f, h = l * f, w = Math.max(0, t / 2 - g / 2), C = Math.max(0, s / 2 - h / 2);
    return {
      left: w.toString() + "px",
      top: C.toString() + "px",
      width: g.toString() + "px",
      height: h.toString() + "px"
    };
  }, LB = (t, s, a) => {
    const l = Wo(t), f = hs(t);
    return Math.min(l / s, f / a, 1);
  }, HB = (t, s) => {
    const a = Xn(s.getOr({ url: "" })), l = wr({
      dom: {
        tag: "img",
        classes: ["tox-imagepreview__image"],
        attributes: s.map((C) => ({ src: C.url })).getOr({})
      }
    }), f = wr({
      dom: {
        tag: "div",
        classes: ["tox-imagepreview__container"],
        attributes: { role: "presentation" }
      },
      components: [l.asSpec()]
    }), g = (C, T) => {
      const D = { url: T.url };
      T.zoom.each((I) => D.zoom = I), T.cachedWidth.each((I) => D.cachedWidth = I), T.cachedHeight.each((I) => D.cachedHeight = I), a.set(D);
      const $ = () => {
        const I = D.cachedWidth, V = D.cachedHeight;
        if (mt(D.zoom)) {
          const pe = LB(C.element, I, V);
          D.zoom = pe;
        }
        const ne = IB(Wo(C.element), hs(C.element), I, V, D.zoom);
        f.getOpt(C).each((pe) => {
          Zr(pe.element, ne);
        });
      };
      l.getOpt(C).each((I) => {
        const V = I.element;
        T.url !== Vo(V, "src") && (to(V, "src", T.url), Yr(C.element, "tox-imagepreview__loaded")), !mt(D.cachedWidth) && !mt(D.cachedHeight) && $(), FB(V).then((ne) => {
          C.getSystem().isConnected() && (Ea(C.element, "tox-imagepreview__loaded"), D.cachedWidth = ne.dom.naturalWidth, D.cachedHeight = ne.dom.naturalHeight, $());
        });
      });
    }, h = {};
    t.height.each((C) => h.height = C);
    const w = s.map((C) => ({
      url: C.url,
      zoom: z.from(C.zoom),
      cachedWidth: z.from(C.cachedWidth),
      cachedHeight: z.from(C.cachedHeight)
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-imagepreview"],
        styles: h,
        attributes: { role: "presentation" }
      },
      components: [f.asSpec()],
      behaviours: qt([
        Di.self(),
        Fl.withComp(w, () => a.get(), g)
      ])
    };
  }, F6 = (t, s) => {
    const a = {
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [wa(s.providers.translate(t.label))]
    }, l = Xe(t.items, s.interpreter);
    return {
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [
        a,
        ...l
      ],
      behaviours: qt([
        Di.self(),
        Uo.config({}),
        Fl.domHtml(z.none()),
        Kn.config({ mode: "acyclic" })
      ])
    };
  }, B2 = $n("toolbar.button.execute"), Jm = (t) => zd((s, a) => {
    l2(t, s)((l) => {
      no(s, B2, { buttonApi: l }), t.onAction(l);
    });
  }), $2 = {
    [Kl()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "toolbar-button-events"
    ]
  }, qT = (t, s, a) => Vd(t, {
    tag: "span",
    classes: [
      "tox-icon",
      "tox-tbtn__icon-wrap"
    ],
    behaviours: a
  }, s), rk = (t, s) => qT(t, s, []), P2 = (t, s) => qT(t, s, [Uo.config({})]), F2 = (t, s, a) => ({
    dom: {
      tag: "span",
      classes: [`${s}__select-label`]
    },
    components: [wa(a.translate(t))],
    behaviours: qt([Uo.config({})])
  }), Qm = $n("update-menu-text"), GT = $n("update-menu-icon"), I2 = (t, s, a) => {
    const l = Xn(ie), f = t.text.map(($) => wr(F2($, s, a.providers))), g = t.icon.map(($) => wr(P2($, a.providers.icons))), h = ($, I) => {
      const V = cn.getValue($);
      return go.focus(V), no(V, "keydown", { raw: I.event.raw }), cd.close(V), z.some(!0);
    }, w = t.role.fold(() => ({}), ($) => ({ role: $ })), C = t.tooltip.fold(() => ({}), ($) => {
      const I = a.providers.translate($);
      return {
        title: I,
        "aria-label": I
      };
    }), T = Vd("chevron-down", {
      tag: "div",
      classes: [`${s}__select-chevron`]
    }, a.providers.icons);
    return wr(cd.sketch({
      ...t.uid ? { uid: t.uid } : {},
      ...w,
      dom: {
        tag: "button",
        classes: [
          s,
          `${s}--select`
        ].concat(Xe(t.classes, ($) => `${s}--${$}`)),
        attributes: { ...C }
      },
      components: Vv([
        g.map(($) => $.asSpec()),
        f.map(($) => $.asSpec()),
        z.some(T)
      ]),
      matchWidth: !0,
      useMinWidth: !0,
      dropdownBehaviours: qt([
        ...t.dropdownBehaviours,
        rd.button(() => t.disabled || a.providers.isDisabled()),
        ma(),
        Kd.config({}),
        Uo.config({}),
        ys("dropdown-events", [
          Lv(t, l),
          Hv(t, l)
        ]),
        ys("menubutton-update-display-text", [
          dt(Qm, ($, I) => {
            f.bind((V) => V.getOpt($)).each((V) => {
              Uo.set(V, [wa(a.providers.translate(I.event.text))]);
            });
          }),
          dt(GT, ($, I) => {
            g.bind((V) => V.getOpt($)).each((V) => {
              Uo.set(V, [P2(I.event.icon, a.providers.icons)]);
            });
          })
        ])
      ]),
      eventOrder: sr($2, {
        mousedown: [
          "focusing",
          "alloy.base.behaviour",
          "item-type-events",
          "normal-dropdown-events"
        ]
      }),
      sandboxBehaviours: qt([Kn.config({
        mode: "special",
        onLeft: h,
        onRight: h
      })]),
      lazySink: a.getSink,
      toggleClass: `${s}--active`,
      parts: { menu: J_(!1, t.columns, t.presets) },
      fetch: ($) => Bc.nu(lt(t.fetch, $))
    })).asSpec();
  }, VB = (t) => Kt(t), KT = (t) => t.type === "separator", jB = (t) => qn(t, "getSubmenuItems"), UB = { type: "separator" }, WB = (t, s) => {
    const a = We(t, (l, f) => VB(f) ? f === "" ? l : f === "|" ? l.length > 0 && !KT(l[l.length - 1]) ? l.concat([UB]) : l : qn(s, f.toLowerCase()) ? l.concat([s[f.toLowerCase()]]) : l : l.concat([f]), []);
    return a.length > 0 && KT(a[a.length - 1]) && a.pop(), a;
  }, I6 = (t, s) => {
    const a = t.getSubmenuItems(), l = H6(a, s), f = sr(l.menus, ge(t.value, l.items)), g = sr(l.expansions, ge(t.value, t.value));
    return {
      item: t,
      menus: f,
      expansions: g
    };
  }, L6 = (t, s) => jB(t) ? I6(t, s) : {
    item: t,
    menus: {},
    expansions: {}
  }, ZB = (t) => {
    if (KT(t))
      return t;
    {
      const s = ht(t, "value").getOrThunk(() => $n("generated-menu-item"));
      return sr({ value: s }, t);
    }
  }, H6 = (t, s) => {
    const a = WB(Kt(t) ? t.split(" ") : t, s);
    return Ne(a, (l, f) => {
      const g = ZB(f), h = L6(g, s);
      return {
        menus: sr(l.menus, h.menus),
        items: [h.item].concat(l.items),
        expansions: sr(l.expansions, h.expansions)
      };
    }, {
      menus: {},
      expansions: {},
      items: []
    });
  }, u1 = (t, s, a, l) => {
    const f = $n("primary-menu"), g = H6(t, a.shared.providers.menuItems());
    if (g.items.length === 0)
      return z.none();
    const h = Cz(f, g.items, s, a, l), w = Ln(g.menus, (T, D) => Cz(D, T, s, a, !1)), C = sr(w, ge(f, h));
    return z.from(Wh.tieredData(f, C, g.expansions));
  }, d1 = (t) => !qn(t, "items"), V6 = "data-value", j6 = (t, s, a, l) => Xe(a, (f) => d1(f) ? {
    type: "togglemenuitem",
    text: f.text,
    value: f.value,
    active: f.value === l,
    onAction: () => {
      cn.setValue(t, f.value), no(t, ei, { name: s }), go.focus(t);
    }
  } : {
    type: "nestedmenuitem",
    text: f.text,
    getSubmenuItems: () => j6(t, s, f.items, l)
  }), L2 = (t, s) => Ho(t, (a) => d1(a) ? er(a.value === s, a) : L2(a.items, s)), U6 = (t, s, a) => {
    const l = s.shared.providers, f = a.bind((C) => L2(t.items, C)).orThunk(() => fo(t.items).filter(d1)), g = t.label.map((C) => _p(C, l)), h = Bs.parts.field({
      dom: {},
      factory: {
        sketch: (C) => I2({
          uid: C.uid,
          text: f.map((T) => T.text),
          icon: z.none(),
          tooltip: t.label,
          role: z.none(),
          fetch: (T, D) => {
            const $ = j6(T, t.name, t.items, cn.getValue(T));
            D(u1($, jd.CLOSE_ON_EXECUTE, s, !1));
          },
          onSetup: oe(ie),
          getApi: oe({}),
          columns: 1,
          presets: "normal",
          classes: [],
          dropdownBehaviours: [
            oa.config({}),
            Fl.withComp(f.map((T) => T.value), (T) => Vo(T.element, V6), (T, D) => {
              L2(t.items, D).each(($) => {
                to(T.element, V6, $.value), no(T, Qm, { text: $.text });
              });
            })
          ]
        }, "tox-listbox", s.shared)
      }
    }), w = {
      dom: {
        tag: "div",
        classes: ["tox-listboxfield"]
      },
      components: [h]
    };
    return Bs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: X([
        g.toArray(),
        [w]
      ]),
      fieldBehaviours: qt([ao.config({
        disabled: oe(!t.enabled),
        onDisabled: (C) => {
          Bs.getField(C).each(ao.disable);
        },
        onEnabled: (C) => {
          Bs.getField(C).each(ao.enable);
        }
      })])
    });
  }, qB = (t, s) => ({
    dom: {
      tag: "div",
      classes: t.classes
    },
    components: Xe(t.items, s.shared.interpreter)
  }), GB = (t, s) => {
    const a = Xe(t.options, (f) => ({
      dom: {
        tag: "option",
        value: f.value,
        innerHtml: f.text
      }
    })), l = t.data.map((f) => ge("initialValue", f)).getOr({});
    return {
      uid: t.uid,
      dom: {
        tag: "select",
        classes: t.selectClasses,
        attributes: t.selectAttributes
      },
      components: a,
      behaviours: Ua(t.selectBehaviours, [
        go.config({}),
        cn.config({
          store: {
            mode: "manual",
            getValue: (f) => Ui(f.element),
            setValue: (f, g) => {
              Oe(t.options, (w) => w.value === g).isSome() && yi(f.element, g);
            },
            ...l
          }
        })
      ])
    };
  }, YT = Wa({
    name: "HtmlSelect",
    configFields: [
      ut("options"),
      Oa("selectBehaviours", [
        go,
        cn
      ]),
      Te("selectClasses", []),
      Te("selectAttributes", {}),
      xs("data")
    ],
    factory: GB
  }), KB = (t, s, a) => {
    const l = Xe(t.items, (C) => ({
      text: s.translate(C.text),
      value: C.value
    })), f = t.label.map((C) => _p(C, s)), g = Bs.parts.field({
      dom: {},
      ...a.map((C) => ({ data: C })).getOr({}),
      selectAttributes: { size: t.size },
      options: l,
      factory: YT,
      selectBehaviours: qt([
        ao.config({ disabled: () => !t.enabled || s.isDisabled() }),
        oa.config({}),
        ys("selectbox-change", [dt(Gl(), (C, T) => {
          no(C, ei, { name: t.name });
        })])
      ])
    }), h = t.size > 1 ? z.none() : z.some(Vd("chevron-down", {
      tag: "div",
      classes: ["tox-selectfield__icon-js"]
    }, s.icons)), w = {
      dom: {
        tag: "div",
        classes: ["tox-selectfield"]
      },
      components: X([
        [g],
        h.toArray()
      ])
    };
    return Bs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: X([
        f.toArray(),
        [w]
      ]),
      fieldBehaviours: qt([
        ao.config({
          disabled: () => !t.enabled || s.isDisabled(),
          onDisabled: (C) => {
            Bs.getField(C).each(ao.disable);
          },
          onEnabled: (C) => {
            Bs.getField(C).each(ao.enable);
          }
        }),
        ma()
      ])
    });
  }, YB = oe([
    Te("field1Name", "field1"),
    Te("field2Name", "field2"),
    Ng("onLockedChange"),
    Mf(["lockClass"]),
    Te("locked", !1),
    Bl.field("coupledFieldBehaviours", [
      cs,
      cn
    ])
  ]), XB = (t, s, a) => Ds(t, s, a).bind(cs.getCurrent), W6 = (t, s) => Cc({
    factory: Bs,
    name: t,
    overrides: (a) => ({
      fieldBehaviours: qt([ys("coupled-input-behaviour", [dt(Zc(), (l) => {
        XB(l, a, s).each((f) => {
          Ds(l, a, "lock").each((g) => {
            Qo.isOn(g) && a.onLockedChange(l, f, g);
          });
        });
      })])])
    })
  }), XT = oe([
    W6("field1", "field2"),
    W6("field2", "field1"),
    Cc({
      factory: $l,
      schema: [ut("dom")],
      name: "lock",
      overrides: (t) => ({
        buttonBehaviours: qt([Qo.config({
          selected: t.locked,
          toggleClass: t.markers.lockClass,
          aria: { mode: "pressed" }
        })])
      })
    })
  ]), JT = (t, s, a, l) => ({
    uid: t.uid,
    dom: t.dom,
    components: s,
    behaviours: Bl.augment(t.coupledFieldBehaviours, [
      cs.config({ find: z.some }),
      cn.config({
        store: {
          mode: "manual",
          getValue: (f) => {
            const g = G0(f, t, [
              "field1",
              "field2"
            ]);
            return {
              [t.field1Name]: cn.getValue(g.field1()),
              [t.field2Name]: cn.getValue(g.field2())
            };
          },
          setValue: (f, g) => {
            const h = G0(f, t, [
              "field1",
              "field2"
            ]);
            pr(g, t.field1Name) && cn.setValue(h.field1(), g[t.field1Name]), pr(g, t.field2Name) && cn.setValue(h.field2(), g[t.field2Name]);
          }
        }
      })
    ]),
    apis: {
      getField1: (f) => Ds(f, t, "field1"),
      getField2: (f) => Ds(f, t, "field2"),
      getLock: (f) => Ds(f, t, "lock")
    }
  }), eu = Jc({
    name: "FormCoupledInputs",
    configFields: YB(),
    partFields: XT(),
    factory: JT,
    apis: {
      getField1: (t, s) => t.getField1(s),
      getField2: (t, s) => t.getField2(s),
      getLock: (t, s) => t.getLock(s)
    }
  }), JB = (t) => {
    const s = {
      "": 0,
      px: 0,
      pt: 1,
      mm: 1,
      pc: 2,
      ex: 2,
      em: 2,
      ch: 2,
      rem: 2,
      cm: 3,
      in: 4,
      "%": 4
    }, a = (f) => f in s ? s[f] : 1;
    let l = t.value.toFixed(a(t.unit));
    return l.indexOf(".") !== -1 && (l = l.replace(/\.?0*$/, "")), l + t.unit;
  }, ak = (t) => {
    const a = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t);
    if (a !== null) {
      const l = parseFloat(a[1]), f = a[2];
      return yo.value({
        value: l,
        unit: f
      });
    } else
      return yo.error(t);
  }, Z6 = (t, s) => {
    const a = {
      "": 96,
      px: 96,
      pt: 72,
      cm: 2.54,
      pc: 12,
      mm: 25.4,
      in: 1
    }, l = (f) => qn(a, f);
    return t.unit === s ? z.some(t.value) : l(t.unit) && l(s) ? a[t.unit] === a[s] ? z.some(t.value) : z.some(t.value / a[t.unit] * a[s]) : z.none();
  }, ck = (t) => z.none(), q6 = (t, s) => (a) => Z6(a, s).map((l) => ({
    value: l * t,
    unit: s
  })), QB = (t, s) => {
    const a = ak(t).toOptional(), l = ak(s).toOptional();
    return Tr(a, l, (f, g) => Z6(f, g.unit).map((h) => g.value / h).map((h) => q6(h, g.unit)).getOr(ck)).getOr(ck);
  }, e$ = (t, s) => {
    let a = ck;
    const l = $n("ratio-event"), f = ($) => Vd($, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-lock-icon__" + $
      ]
    }, s.icons), g = eu.parts.lock({
      dom: {
        tag: "button",
        classes: [
          "tox-lock",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ],
        attributes: { title: s.translate(t.label.getOr("Constrain proportions")) }
      },
      components: [
        f("lock"),
        f("unlock")
      ],
      buttonBehaviours: qt([
        ao.config({ disabled: () => !t.enabled || s.isDisabled() }),
        ma(),
        oa.config({})
      ])
    }), h = ($) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: $
    }), w = ($) => Bs.parts.field({
      factory: Kv,
      inputClasses: ["tox-textfield"],
      inputBehaviours: qt([
        ao.config({ disabled: () => !t.enabled || s.isDisabled() }),
        ma(),
        oa.config({}),
        ys("size-input-events", [
          dt(Ta(), (I, V) => {
            no(I, l, { isField1: $ });
          }),
          dt(Gl(), (I, V) => {
            no(I, ei, { name: t.name });
          })
        ])
      ]),
      selectOnFocus: !1
    }), C = ($) => ({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [wa(s.translate($))]
    }), T = eu.parts.field1(h([
      Bs.parts.label(C("Width")),
      w(!0)
    ])), D = eu.parts.field2(h([
      Bs.parts.label(C("Height")),
      w(!1)
    ]));
    return eu.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: [
          T,
          D,
          h([
            C(y0),
            g
          ])
        ]
      }],
      field1Name: "width",
      field2Name: "height",
      locked: !0,
      markers: { lockClass: "tox-locked" },
      onLockedChange: ($, I, V) => {
        ak(cn.getValue($)).each((ne) => {
          a(ne).each((pe) => {
            cn.setValue(I, JB(pe));
          });
        });
      },
      coupledFieldBehaviours: qt([
        ao.config({
          disabled: () => !t.enabled || s.isDisabled(),
          onDisabled: ($) => {
            eu.getField1($).bind(Bs.getField).each(ao.disable), eu.getField2($).bind(Bs.getField).each(ao.disable), eu.getLock($).each(ao.disable);
          },
          onEnabled: ($) => {
            eu.getField1($).bind(Bs.getField).each(ao.enable), eu.getField2($).bind(Bs.getField).each(ao.enable), eu.getLock($).each(ao.enable);
          }
        }),
        ma(),
        ys("size-input-events2", [dt(l, ($, I) => {
          const V = I.event.isField1, ne = V ? eu.getField1($) : eu.getField2($), pe = V ? eu.getField2($) : eu.getField1($), Le = ne.map(cn.getValue).getOr(""), he = pe.map(cn.getValue).getOr("");
          a = QB(Le, he);
        })])
      ])
    });
  }, G6 = (t, s, a) => {
    const l = id.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [wa(s.translate(t.label))]
    }), f = id.parts.spectrum({
      dom: {
        tag: "div",
        classes: ["tox-slider__rail"],
        attributes: { role: "presentation" }
      }
    }), g = id.parts.thumb({
      dom: {
        tag: "div",
        classes: ["tox-slider__handle"],
        attributes: { role: "presentation" }
      }
    });
    return id.sketch({
      dom: {
        tag: "div",
        classes: ["tox-slider"],
        attributes: { role: "presentation" }
      },
      model: {
        mode: "x",
        minX: t.min,
        maxX: t.max,
        getInitialValue: oe(a.getOrThunk(() => (Math.abs(t.max) - Math.abs(t.min)) / 2))
      },
      components: [
        l,
        f,
        g
      ],
      sliderBehaviours: qt([
        Di.self(),
        go.config({})
      ]),
      onChoose: (h, w, C) => {
        no(h, ei, {
          name: t.name,
          value: C
        });
      }
    });
  }, K6 = (t, s) => {
    const a = (w) => ({
      dom: {
        tag: "th",
        innerHtml: s.translate(w)
      }
    }), l = (w) => ({
      dom: { tag: "thead" },
      components: [{
        dom: { tag: "tr" },
        components: Xe(w, a)
      }]
    }), f = (w) => ({
      dom: {
        tag: "td",
        innerHtml: s.translate(w)
      }
    }), g = (w) => ({
      dom: { tag: "tr" },
      components: Xe(w, f)
    }), h = (w) => ({
      dom: { tag: "tbody" },
      components: Xe(w, g)
    });
    return {
      dom: {
        tag: "table",
        classes: ["tox-dialog__table"]
      },
      components: [
        l(t.header),
        h(t.cells)
      ],
      behaviours: qt([
        oa.config({}),
        go.config({})
      ])
    };
  }, Y6 = (t, s) => {
    const a = t.label.map((I) => _p(I, s)), l = [
      ao.config({ disabled: () => t.disabled || s.isDisabled() }),
      ma(),
      Kn.config({
        mode: "execution",
        useEnter: t.multiline !== !0,
        useControlEnter: t.multiline === !0,
        execute: (I) => (Ts(I, r1), z.some(!0))
      }),
      ys("textfield-change", [
        dt(Zc(), (I, V) => {
          no(I, ei, { name: t.name });
        }),
        dt(Ay(), (I, V) => {
          no(I, ei, { name: t.name });
        })
      ]),
      oa.config({})
    ], f = t.validation.map((I) => qf.config({
      getRoot: (V) => Ma(V.element),
      invalidClass: "tox-invalid",
      validator: {
        validate: (V) => {
          const ne = cn.getValue(V), pe = I.validator(ne);
          return Bc.pure(pe === !0 ? yo.value(ne) : yo.error(pe));
        },
        validateOnLoad: I.validateOnLoad
      }
    })).toArray(), g = t.placeholder.fold(oe({}), (I) => ({ placeholder: s.translate(I) })), h = t.inputMode.fold(oe({}), (I) => ({ inputmode: I })), w = {
      ...g,
      ...h
    }, C = Bs.parts.field({
      tag: t.multiline === !0 ? "textarea" : "input",
      ...t.data.map((I) => ({ data: I })).getOr({}),
      inputAttributes: w,
      inputClasses: [t.classname],
      inputBehaviours: qt(X([
        l,
        f
      ])),
      selectOnFocus: !1,
      factory: Kv
    }), D = (t.flex ? ["tox-form__group--stretched"] : []).concat(t.maximized ? ["tox-form-group--maximize"] : []), $ = [
      ao.config({
        disabled: () => t.disabled || s.isDisabled(),
        onDisabled: (I) => {
          Bs.getField(I).each(ao.disable);
        },
        onEnabled: (I) => {
          Bs.getField(I).each(ao.enable);
        }
      }),
      ma()
    ];
    return qv(a, C, D, $);
  }, X6 = (t, s, a) => Y6({
    name: t.name,
    multiline: !1,
    label: t.label,
    inputMode: t.inputMode,
    placeholder: t.placeholder,
    flex: !1,
    disabled: !t.enabled,
    classname: "tox-textfield",
    validation: z.none(),
    maximized: t.maximized,
    data: a
  }, s), J6 = (t, s, a) => Y6({
    name: t.name,
    multiline: !0,
    label: t.label,
    inputMode: z.none(),
    placeholder: t.placeholder,
    flex: !0,
    disabled: !t.enabled,
    classname: "tox-textarea",
    validation: z.none(),
    maximized: t.maximized,
    data: a
  }, s);
  var Q6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => {
      const l = t.stream.streams.setup(t, s);
      return Ls([
        dt(t.event, l),
        Hi(() => s.cancel())
      ].concat(t.cancelEvent.map((f) => [dt(f, () => s.cancel())]).getOr([])));
    }
  });
  const eO = (t, s) => {
    let a = null;
    return {
      cancel: () => {
        Ao(a) || (clearTimeout(a), a = null);
      },
      throttle: (...g) => {
        Ao(a) && (a = setTimeout(() => {
          a = null, t.apply(null, g);
        }, s));
      }
    };
  }, QT = (t, s) => {
    let a = null;
    const l = () => {
      Ao(a) || (clearTimeout(a), a = null);
    };
    return {
      cancel: l,
      throttle: (...g) => {
        l(), a = setTimeout(() => {
          a = null, t.apply(null, g);
        }, s);
      }
    };
  }, tO = (t) => {
    const s = Xn(null);
    return Ol({
      readState: () => ({ timer: s.get() !== null ? "set" : "unset" }),
      setTimer: (g) => {
        s.set(g);
      },
      cancel: () => {
        const g = s.get();
        g !== null && g.cancel();
      }
    });
  };
  var t$ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    throttle: tO,
    init: (t) => t.stream.streams.state(t)
  });
  const nO = (t, s) => {
    const a = t.stream, l = QT(t.onStream, a.delay);
    return s.setTimer(l), (f, g) => {
      l.throttle(f, g), a.stopEvent && g.stop();
    };
  };
  var n$ = [
    Ac("stream", rr("mode", {
      throttle: [
        ut("delay"),
        Te("stopEvent", !0),
        fr("streams", {
          setup: nO,
          state: tO
        })
      ]
    })),
    Te("event", "input"),
    xs("cancelEvent"),
    Ng("onStream")
  ];
  const e4 = Ha({
    fields: n$,
    name: "streaming",
    active: Q6,
    state: t$
  }), H2 = (t, s, a) => {
    const l = cn.getValue(a);
    cn.setValue(s, l), V2(s);
  }, oO = (t, s) => {
    const a = t.element, l = Ui(a), f = a.dom;
    Vo(a, "type") !== "number" && s(f, l);
  }, V2 = (t) => {
    oO(t, (s, a) => s.setSelectionRange(a.length, a.length));
  }, o$ = (t, s) => {
    oO(t, (a, l) => a.setSelectionRange(s, l.length));
  }, s$ = (t, s, a) => {
    if (t.selectsOver) {
      const l = cn.getValue(s), f = t.getDisplayText(l), g = cn.getValue(a);
      return t.getDisplayText(g).indexOf(f) === 0 ? z.some(() => {
        H2(t, s, a), o$(s, f.length);
      }) : z.none();
    } else
      return z.none();
  }, t4 = oe("alloy.typeahead.itemexecute"), sO = (t, s, a, l) => {
    const f = (C, T, D) => {
      t.previewing.set(!1);
      const $ = Hr.getCoupled(C, "sandbox");
      if (Yo.isOpen($))
        cs.getCurrent($).each((I) => {
          Hs.getHighlighted(I).fold(() => {
            D(I);
          }, () => {
            $C($, I.element, "keydown", T);
          });
        });
      else {
        const I = (V) => {
          cs.getCurrent(V).each(D);
        };
        Cp(t, h(C), C, $, l, I, Gd.HighlightFirst).get(ie);
      }
    }, g = cT(t), h = (C) => (T) => T.map((D) => {
      const $ = Jt(D.menus), I = je($, (ne) => Pt(ne.items, (pe) => pe.type === "item"));
      return cn.getState(C).update(Xe(I, (ne) => ne.data)), D;
    }), w = [
      go.config({}),
      cn.config({
        onSetValue: t.onSetValue,
        store: {
          mode: "dataset",
          getDataKey: (C) => Ui(C.element),
          getFallbackEntry: (C) => ({
            value: C,
            meta: {}
          }),
          setValue: (C, T) => {
            yi(C.element, t.model.getDisplayText(T));
          },
          ...t.initialData.map((C) => ge("initialValue", C)).getOr({})
        }
      }),
      e4.config({
        stream: {
          mode: "throttle",
          delay: t.responseTime,
          stopEvent: !1
        },
        onStream: (C, T) => {
          const D = Hr.getCoupled(C, "sandbox");
          if (go.isFocused(C) && Ui(C.element).length >= t.minChars) {
            const I = cs.getCurrent(D).bind((ne) => Hs.getHighlighted(ne).map(cn.getValue));
            t.previewing.set(!0);
            const V = (ne) => {
              cs.getCurrent(D).each((pe) => {
                I.fold(() => {
                  t.model.selectsOver && Hs.highlightFirst(pe);
                }, (Le) => {
                  Hs.highlightBy(pe, (he) => cn.getValue(he).value === Le.value), Hs.getHighlighted(pe).orThunk(() => (Hs.highlightFirst(pe), z.none()));
                });
              });
            };
            Cp(t, h(C), C, D, l, V, Gd.HighlightFirst).get(ie);
          }
        },
        cancelEvent: vg()
      }),
      Kn.config({
        mode: "special",
        onDown: (C, T) => (f(C, T, Hs.highlightFirst), z.some(!0)),
        onEscape: (C) => {
          const T = Hr.getCoupled(C, "sandbox");
          return Yo.isOpen(T) ? (Yo.close(T), z.some(!0)) : z.none();
        },
        onUp: (C, T) => (f(C, T, Hs.highlightLast), z.some(!0)),
        onEnter: (C) => {
          const T = Hr.getCoupled(C, "sandbox"), D = Yo.isOpen(T);
          if (D && !t.previewing.get())
            return cs.getCurrent(T).bind(($) => Hs.getHighlighted($)).map(($) => (no(C, t4(), { item: $ }), !0));
          {
            const $ = cn.getValue(C);
            return Ts(C, vg()), t.onExecute(T, C, $), D && Yo.close(T), z.some(!0);
          }
        }
      }),
      Qo.config({
        toggleClass: t.markers.openClass,
        aria: { mode: "expanded" }
      }),
      Hr.config({
        others: {
          sandbox: (C) => mT(t, C, {
            onOpen: () => Qo.on(C),
            onClose: () => Qo.off(C)
          })
        }
      }),
      ys("typeaheadevents", [
        zd((C) => {
          const T = ie;
          sy(t, h(C), C, l, T, Gd.HighlightFirst).get(ie);
        }),
        dt(t4(), (C, T) => {
          const D = Hr.getCoupled(C, "sandbox");
          H2(t.model, C, T.event.item), Ts(C, vg()), t.onItemExecute(C, D, T.event.item, cn.getValue(C)), Yo.close(D), V2(C);
        })
      ].concat(t.dismissOnBlur ? [dt(D1(), (C) => {
        const T = Hr.getCoupled(C, "sandbox");
        _i(T.element).isNone() && Yo.close(T);
      })] : []))
    ];
    return {
      uid: t.uid,
      dom: lT(sr(t, {
        inputAttributes: {
          role: "combobox",
          "aria-autocomplete": "list",
          "aria-haspopup": "true"
        }
      })),
      behaviours: {
        ...g,
        ...Ua(t.typeaheadBehaviours, w)
      },
      eventOrder: t.eventOrder
    };
  }, r$ = oe([
    xs("lazySink"),
    ut("fetch"),
    Te("minChars", 5),
    Te("responseTime", 1e3),
    Es("onOpen"),
    Te("getHotspot", z.some),
    Te("getAnchorOverrides", oe({})),
    Te("layouts", z.none()),
    Te("eventOrder", {}),
    qp("model", {}, [
      Te("getDisplayText", (t) => t.meta !== void 0 && t.meta.text !== void 0 ? t.meta.text : t.value),
      Te("selectsOver", !0),
      Te("populateFromBrowse", !0)
    ]),
    Es("onSetValue"),
    il("onExecute"),
    Es("onItemExecute"),
    Te("inputClasses", []),
    Te("inputAttributes", {}),
    Te("inputStyles", {}),
    Te("matchWidth", !0),
    Te("useMinWidth", !1),
    Te("dismissOnBlur", !0),
    Mf(["openClass"]),
    xs("initialData"),
    Oa("typeaheadBehaviours", [
      go,
      cn,
      e4,
      Kn,
      Qo,
      Hr
    ]),
    va("previewing", () => Xn(!0))
  ].concat(Fz()).concat(gT())), rO = oe([Ki({
    schema: [Mg()],
    name: "menu",
    overrides: (t) => ({
      fakeFocus: !0,
      onHighlight: (s, a) => {
        t.previewing.get() ? s.getSystem().getByUid(t.uid).each((l) => {
          s$(t.model, l, a).fold(() => Hs.dehighlight(s, a), (f) => f());
        }) : s.getSystem().getByUid(t.uid).each((l) => {
          t.model.populateFromBrowse && H2(t.model, l, a);
        }), t.previewing.set(!1);
      },
      onExecute: (s, a) => s.getSystem().getByUid(t.uid).toOptional().map((l) => (no(l, t4(), { item: a }), !0)),
      onHover: (s, a) => {
        t.previewing.set(!1), s.getSystem().getByUid(t.uid).each((l) => {
          t.model.populateFromBrowse && H2(t.model, l, a);
        });
      }
    })
  })]), a$ = Jc({
    name: "Typeahead",
    configFields: r$(),
    partFields: rO(),
    factory: sO
  }), Eu = (t) => ({
    ...t,
    toCached: () => Eu(t.toCached()),
    bindFuture: (C) => Eu(t.bind((T) => T.fold((D) => Bc.pure(yo.error(D)), (D) => C(D)))),
    bindResult: (C) => Eu(t.map((T) => T.bind(C))),
    mapResult: (C) => Eu(t.map((T) => T.map(C))),
    mapError: (C) => Eu(t.map((T) => T.mapError(C))),
    foldResult: (C, T) => t.map((D) => D.fold(C, T)),
    withTimeout: (C, T) => Eu(Bc.nu((D) => {
      let $ = !1;
      const I = setTimeout(() => {
        $ = !0, D(yo.error(T()));
      }, C);
      t.get((V) => {
        $ || (clearTimeout(I), D(V));
      });
    }))
  }), aO = (t) => Eu(Bc.nu(t)), cO = (t) => Eu(Bc.pure(yo.value(t))), l$ = {
    nu: aO,
    wrap: Eu,
    pure: cO,
    value: cO,
    error: (t) => Eu(Bc.pure(yo.error(t))),
    fromResult: (t) => Eu(Bc.pure(t)),
    fromFuture: (t) => Eu(t.map(yo.value)),
    fromPromise: (t) => aO((s) => {
      t.then((a) => {
        s(yo.value(a));
      }, (a) => {
        s(yo.error(a));
      });
    })
  }, lO = (t) => ({
    isEnabled: () => !ao.isDisabled(t),
    setEnabled: (s) => ao.set(t, !s),
    setActive: (s) => {
      const a = t.element;
      s ? (Ea(a, "tox-tbtn--enabled"), to(a, "aria-pressed", !0)) : (Yr(a, "tox-tbtn--enabled"), nr(a, "aria-pressed"));
    },
    isActive: () => oc(t.element, "tox-tbtn--enabled")
  }), n4 = (t, s, a, l) => I2({
    text: t.text,
    icon: t.icon,
    tooltip: t.tooltip,
    role: l,
    fetch: (f, g) => {
      t.fetch((h) => {
        g(u1(h, jd.CLOSE_ON_EXECUTE, a, !1));
      });
    },
    onSetup: t.onSetup,
    getApi: lO,
    columns: 1,
    presets: "normal",
    classes: [],
    dropdownBehaviours: [oa.config({})]
  }, s, a.shared), i$ = (t, s, a) => {
    const l = (g) => (h) => {
      const w = !h.isActive();
      h.setActive(w), g.storage.set(w), a.shared.getSink().each((C) => {
        s().getOpt(C).each((T) => {
          Xu(T.element), no(T, qm, {
            name: g.name,
            value: g.storage.get()
          });
        });
      });
    }, f = (g) => (h) => {
      h.setActive(g.storage.get());
    };
    return (g) => {
      g(Xe(t, (h) => {
        const w = h.text.fold(() => ({}), (C) => ({ text: C }));
        return {
          type: h.type,
          active: !1,
          ...w,
          onAction: l(h),
          onSetup: f(h)
        };
      }));
    };
  }, iO = (t, s, a = [], l, f, g) => {
    const h = s.fold(() => ({}), (T) => ({ action: T })), w = {
      buttonBehaviours: qt([
        rd.button(() => !t.enabled || g.isDisabled()),
        ma(),
        oa.config({}),
        ys("button press", [
          Tf("click"),
          Tf("mousedown")
        ])
      ].concat(a)),
      eventOrder: {
        click: [
          "button press",
          "alloy.base.behaviour"
        ],
        mousedown: [
          "button press",
          "alloy.base.behaviour"
        ]
      },
      ...h
    }, C = sr(w, { dom: l });
    return sr(C, { components: f });
  }, uO = (t, s, a, l = []) => {
    const f = t.tooltip.map((C) => ({
      "aria-label": a.translate(C),
      title: a.translate(C)
    })).getOr({}), g = {
      tag: "button",
      classes: ["tox-tbtn"],
      attributes: f
    }, h = t.icon.map((C) => rk(C, a.icons)), w = Vv([h]);
    return iO(t, s, l, g, w, a);
  }, u$ = (t) => {
    switch (t) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      case "secondary":
      default:
        return [
          "tox-button",
          "tox-button--secondary"
        ];
    }
  }, dO = (t, s, a, l = [], f = []) => {
    const g = a.translate(t.text), h = t.icon.map((I) => rk(I, a.icons)), w = [h.getOrThunk(() => wa(g))], C = t.buttonType.getOr(!t.primary && !t.borderless ? "secondary" : "primary"), D = [
      ...u$(C),
      ...h.isSome() ? ["tox-button--icon"] : [],
      ...t.borderless ? ["tox-button--naked"] : [],
      ...f
    ];
    return iO(t, s, l, {
      tag: "button",
      classes: D,
      attributes: { title: g }
    }, w, a);
  }, o4 = (t, s, a, l = [], f = []) => {
    const g = dO(t, z.some(s), a, l, f);
    return $l.sketch(g);
  }, s4 = (t, s) => (a) => {
    s === "custom" ? no(a, qm, {
      name: t,
      value: {}
    }) : s === "submit" ? Ts(a, r1) : s === "cancel" ? Ts(a, oy) : console.error("Unknown button type: ", s);
  }, fO = (t, s) => s === "menu", j2 = (t, s) => s === "custom" || s === "cancel" || s === "submit", U2 = (t, s, a) => {
    if (fO(t, s)) {
      const l = () => h, g = {
        ...t,
        onSetup: (w) => (w.setEnabled(t.enabled), ie),
        fetch: i$(t.items, l, a)
      }, h = wr(n4(g, "tox-tbtn", a, z.none()));
      return h.asSpec();
    } else if (j2(t, s)) {
      const l = s4(t.name, s), f = {
        ...t,
        borderless: !1
      };
      return o4(f, l, a.shared.providers, []);
    } else
      console.error("Unknown footer button type: ", s);
  }, d$ = (t, s) => {
    const a = s4(t.name, "custom");
    return gN(z.none(), Bs.parts.field({
      factory: $l,
      ...dO(t, z.some(a), s, [
        Fl.memory(""),
        Di.self()
      ])
    }));
  }, f$ = { type: "separator" }, m$ = (t) => ({
    type: "menuitem",
    value: t.url,
    text: t.title,
    meta: { attach: t.attach },
    onAction: ie
  }), W2 = (t, s) => ({
    type: "menuitem",
    value: s,
    text: t,
    meta: { attach: void 0 },
    onAction: ie
  }), mO = (t) => Xe(t, m$), g$ = (t, s) => Pt(s, (a) => a.type === t), gO = (t, s) => mO(g$(t, s)), pO = (t) => gO("header", t.targets), p$ = (t) => gO("anchor", t.targets), h$ = (t) => z.from(t.anchorTop).map((s) => W2("<top>", s)).toArray(), es = (t) => z.from(t.anchorBottom).map((s) => W2("<bottom>", s)).toArray(), lk = (t) => Xe(t, (s) => W2(s, s)), hO = (t) => We(t, (s, a) => s.length === 0 || a.length === 0 ? s.concat(a) : s.concat(f$, a), []), Z2 = (t, s) => {
    const a = t.toLowerCase();
    return Pt(s, (l) => {
      const f = l.meta !== void 0 && l.meta.text !== void 0 ? l.meta.text : l.text;
      return rs(f.toLowerCase(), a) || rs(l.value.toLowerCase(), a);
    });
  }, yO = (t, s, a) => {
    const l = cn.getValue(s), f = l.meta.text !== void 0 ? l.meta.text : l.value;
    return a.getLinkInformation().fold(() => [], (h) => {
      const w = Z2(f, lk(a.getHistory(t)));
      return t === "file" ? hO([
        w,
        Z2(f, pO(h)),
        Z2(f, X([
          h$(h),
          p$(h),
          es(h)
        ]))
      ]) : w;
    });
  }, r4 = $n("aria-invalid"), bO = (t, s, a, l) => {
    const f = s.shared.providers, g = (he) => {
      const at = cn.getValue(he);
      a.addToHistory(at.value, t.filetype);
    }, h = Bs.parts.field({
      factory: a$,
      ...l.map((he) => ({ initialData: he })).getOr({}),
      dismissOnBlur: !0,
      inputClasses: ["tox-textfield"],
      sandboxClasses: ["tox-dialog__popups"],
      inputAttributes: {
        "aria-errormessage": r4,
        type: "url"
      },
      minChars: 0,
      responseTime: 0,
      fetch: (he) => {
        const at = yO(t.filetype, he, a), kn = u1(at, jd.BUBBLE_TO_SANDBOX, s, !1);
        return Bc.pure(kn);
      },
      getHotspot: (he) => V.getOpt(he),
      onSetValue: (he, at) => {
        he.hasConfigured(qf) && qf.run(he).get(ie);
      },
      typeaheadBehaviours: qt(X([
        a.getValidationHandler().map((he) => qf.config({
          getRoot: (at) => Ma(at.element),
          invalidClass: "tox-control-wrap--status-invalid",
          notify: {
            onInvalid: (at, kn) => {
              T.getOpt(at).each((et) => {
                to(et.element, "title", f.translate(kn));
              });
            }
          },
          validator: {
            validate: (at) => {
              const kn = cn.getValue(at);
              return l$.nu((et) => {
                he({
                  type: t.filetype,
                  url: kn.value
                }, (hn) => {
                  if (hn.status === "invalid") {
                    const xn = yo.error(hn.message);
                    et(xn);
                  } else {
                    const xn = yo.value(hn.message);
                    et(xn);
                  }
                });
              });
            },
            validateOnLoad: !1
          }
        })).toArray(),
        [
          ao.config({ disabled: () => !t.enabled || f.isDisabled() }),
          oa.config({}),
          ys("urlinput-events", X([
            t.filetype === "file" ? [dt(Zc(), (he) => {
              no(he, ei, { name: t.name });
            })] : [],
            [
              dt(Gl(), (he) => {
                no(he, ei, { name: t.name }), g(he);
              }),
              dt(Ay(), (he) => {
                no(he, ei, { name: t.name }), g(he);
              })
            ]
          ]))
        ]
      ])),
      eventOrder: {
        [Zc()]: [
          "streaming",
          "urlinput-events",
          "invalidating"
        ]
      },
      model: {
        getDisplayText: (he) => he.value,
        selectsOver: !1,
        populateFromBrowse: !1
      },
      markers: { openClass: "tox-textfield--popup-open" },
      lazySink: s.shared.getSink,
      parts: { menu: J_(!1, 1, "normal") },
      onExecute: (he, at, kn) => {
        no(at, r1, {});
      },
      onItemExecute: (he, at, kn, et) => {
        g(he), no(he, ei, { name: t.name });
      }
    }), w = t.label.map((he) => _p(he, f)), T = wr(((he, at, kn = he, et = he) => Vd(kn, {
      tag: "div",
      classes: [
        "tox-icon",
        "tox-control-wrap__status-icon-" + he
      ],
      attributes: {
        title: f.translate(et),
        "aria-live": "polite",
        ...at.fold(() => ({}), (hn) => ({ id: hn }))
      }
    }, f.icons))("invalid", z.some(r4), "warning")), D = wr({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap__status-icon-wrap"]
      },
      components: [T.asSpec()]
    }), $ = a.getUrlPicker(t.filetype), I = $n("browser.url.event"), V = wr({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap"]
      },
      components: [
        h,
        D.asSpec()
      ],
      behaviours: qt([ao.config({ disabled: () => !t.enabled || f.isDisabled() })])
    }), ne = wr(o4({
      name: t.name,
      icon: z.some("browse"),
      text: t.label.getOr(""),
      enabled: t.enabled,
      primary: !1,
      buttonType: z.none(),
      borderless: !0
    }, (he) => Ts(he, I), f, [], ["tox-browse-url"])), pe = () => ({
      dom: {
        tag: "div",
        classes: ["tox-form__controls-h-stack"]
      },
      components: X([
        [V.asSpec()],
        $.map(() => ne.asSpec()).toArray()
      ])
    }), Le = (he) => {
      cs.getCurrent(he).each((at) => {
        const kn = cn.getValue(at), et = {
          fieldname: t.name,
          ...kn
        };
        $.each((hn) => {
          hn(et).get((xn) => {
            cn.setValue(at, xn), no(he, ei, { name: t.name });
          });
        });
      });
    };
    return Bs.sketch({
      dom: pN(),
      components: w.toArray().concat([pe()]),
      fieldBehaviours: qt([
        ao.config({
          disabled: () => !t.enabled || f.isDisabled(),
          onDisabled: (he) => {
            Bs.getField(he).each(ao.disable), ne.getOpt(he).each(ao.disable);
          },
          onEnabled: (he) => {
            Bs.getField(he).each(ao.enable), ne.getOpt(he).each(ao.enable);
          }
        }),
        ma(),
        ys("url-input-events", [dt(I, Le)])
      ])
    });
  }, EL = (t, s) => Zm.sketch({
    dom: {
      tag: "div",
      attributes: { role: "alert" },
      classes: [
        "tox-notification",
        "tox-notification--in",
        `tox-notification--${t.level}`
      ]
    },
    components: [
      {
        dom: {
          tag: "div",
          classes: ["tox-notification__icon"]
        },
        components: [$l.sketch({
          dom: {
            tag: "button",
            classes: [
              "tox-button",
              "tox-button--naked",
              "tox-button--icon"
            ],
            innerHtml: Yx(t.icon, s.icons),
            attributes: { title: s.translate(t.iconTooltip) }
          },
          action: (a) => {
            no(a, qm, {
              name: "alert-banner",
              value: t.url
            });
          },
          buttonBehaviours: qt([Yb()])
        })]
      },
      {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"],
          innerHtml: s.translate(t.text)
        }
      }
    ]
  }), ik = (t, s) => {
    t.dom.checked = s;
  }, y$ = (t) => t.dom.checked, vO = (t, s, a) => {
    const l = (C) => (C.element.dom.click(), z.some(!0)), f = Bs.parts.field({
      factory: { sketch: Je },
      dom: {
        tag: "input",
        classes: ["tox-checkbox__input"],
        attributes: { type: "checkbox" }
      },
      behaviours: qt([
        Di.self(),
        ao.config({ disabled: () => !t.enabled || s.isDisabled() }),
        oa.config({}),
        go.config({}),
        Fl.withElement(a, y$, ik),
        Kn.config({
          mode: "special",
          onEnter: l,
          onSpace: l,
          stopSpaceKeyup: !0
        }),
        ys("checkbox-events", [dt(Gl(), (C, T) => {
          no(C, ei, { name: t.name });
        })])
      ])
    }), g = Bs.parts.label({
      dom: {
        tag: "span",
        classes: ["tox-checkbox__label"]
      },
      components: [wa(s.translate(t.label))],
      behaviours: qt([Kd.config({})])
    }), h = (C) => Vd(C === "checked" ? "selected" : "unselected", {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-checkbox-icon__" + C
      ]
    }, s.icons), w = wr({
      dom: {
        tag: "div",
        classes: ["tox-checkbox__icons"]
      },
      components: [
        h("checked"),
        h("unchecked")
      ]
    });
    return Bs.sketch({
      dom: {
        tag: "label",
        classes: ["tox-checkbox"]
      },
      components: [
        f,
        w.asSpec(),
        g
      ],
      fieldBehaviours: qt([
        ao.config({
          disabled: () => !t.enabled || s.isDisabled(),
          disableClass: "tox-checkbox--disabled",
          onDisabled: (C) => {
            Bs.getField(C).each(ao.disable);
          },
          onEnabled: (C) => {
            Bs.getField(C).each(ao.enable);
          }
        }),
        ma()
      ])
    });
  }, b$ = (t) => t.presets === "presentation" ? Zm.sketch({
    dom: {
      tag: "div",
      classes: ["tox-form__group"],
      innerHtml: t.html
    }
  }) : Zm.sketch({
    dom: {
      tag: "div",
      classes: ["tox-form__group"],
      innerHtml: t.html,
      attributes: { role: "document" }
    },
    containerBehaviours: qt([
      oa.config({}),
      go.config({})
    ])
  }), Za = (t) => (s, a, l, f) => ht(a, "name").fold(() => t(a, f, z.none()), (g) => s.field(g, t(a, f, ht(l, g)))), v$ = (t) => (s, a, l, f) => {
    const g = sr(a, { source: "dynamic" });
    return Za(t)(s, g, l, f);
  }, kO = {
    bar: Za((t, s) => cN(t, s.shared)),
    collection: Za((t, s, a) => Pz(t, s.shared.providers, a)),
    alertbanner: Za((t, s) => EL(t, s.shared.providers)),
    input: Za((t, s, a) => X6(t, s.shared.providers, a)),
    textarea: Za((t, s, a) => J6(t, s.shared.providers, a)),
    label: Za((t, s) => F6(t, s.shared)),
    iframe: v$((t, s, a) => PB(t, s.shared.providers, a)),
    button: Za((t, s) => d$(t, s.shared.providers)),
    checkbox: Za((t, s, a) => vO(t, s.shared.providers, a)),
    colorinput: Za((t, s, a) => MN(t, s.shared, s.colorinput, a)),
    colorpicker: Za((t, s, a) => DB(t, s.shared.providers, a)),
    dropzone: Za((t, s, a) => $B(t, s.shared.providers, a)),
    grid: Za((t, s) => B6(t, s.shared)),
    listbox: Za((t, s, a) => U6(t, s, a)),
    selectbox: Za((t, s, a) => KB(t, s.shared.providers, a)),
    sizeinput: Za((t, s) => e$(t, s.shared.providers)),
    slider: Za((t, s, a) => G6(t, s.shared.providers, a)),
    urlinput: Za((t, s, a) => bO(t, s, s.urlinput, a)),
    customeditor: Za(NB),
    htmlpanel: Za(b$),
    imagepreview: Za((t, s, a) => HB(t, a)),
    table: Za((t, s) => K6(t, s.shared.providers)),
    panel: Za((t, s) => qB(t, s))
  }, a4 = {
    field: (t, s) => s,
    record: oe([])
  }, c4 = (t, s, a, l) => {
    const f = sr(l, { shared: { interpreter: (g) => l4(t, g, a, f) } });
    return l4(t, s, a, f);
  }, l4 = (t, s, a, l) => ht(kO, s.type).fold(() => (console.error(`Unknown factory type "${s.type}", defaulting to container: `, s), s), (f) => f(t, s, a, l)), k$ = (t, s, a) => l4(a4, t, s, a), Ap = "layout-inset", q2 = (t) => t.x, wO = (t, s) => t.x + t.width / 2 - s.width / 2, i4 = (t, s) => t.x + t.width - s.width, u4 = (t) => t.y, d4 = (t, s) => t.y + t.height - s.height, f4 = (t, s) => t.y + t.height / 2 - s.height / 2, G2 = (t, s, a) => La(i4(t, s), d4(t, s), a.insetSouthwest(), Bg(), "southwest", rc(t, {
    right: 0,
    bottom: 3
  }), Ap), K2 = (t, s, a) => La(q2(t), d4(t, s), a.insetSoutheast(), Qy(), "southeast", rc(t, {
    left: 1,
    bottom: 3
  }), Ap), uk = (t, s, a) => La(i4(t, s), u4(t), a.insetNorthwest(), Jy(), "northwest", rc(t, {
    right: 0,
    top: 2
  }), Ap), dk = (t, s, a) => La(q2(t), u4(t), a.insetNortheast(), vi(), "northeast", rc(t, {
    left: 1,
    top: 2
  }), Ap), Gf = (t, s, a) => La(wO(t, s), u4(t), a.insetNorth(), fw(), "north", rc(t, { top: 2 }), Ap), fk = (t, s, a) => La(wO(t, s), d4(t, s), a.insetSouth(), mw(), "south", rc(t, { bottom: 3 }), Ap), _O = (t, s, a) => La(i4(t, s), f4(t, s), a.insetEast(), $g(), "east", rc(t, { right: 0 }), Ap), CO = (t, s, a) => La(q2(t), f4(t, s), a.insetWest(), Gc(), "west", rc(t, { left: 1 }), Ap), w$ = (t) => {
    switch (t) {
      case "north":
        return Gf;
      case "northeast":
        return dk;
      case "northwest":
        return uk;
      case "south":
        return fk;
      case "southeast":
        return K2;
      case "southwest":
        return G2;
      case "east":
        return _O;
      case "west":
        return CO;
    }
  }, SO = (t, s, a, l, f) => l0(l).map(w$).getOr(Gf)(t, s, a, l, f), _$ = (t) => {
    switch (t) {
      case "north":
        return fk;
      case "northeast":
        return K2;
      case "northwest":
        return G2;
      case "south":
        return Gf;
      case "southeast":
        return dk;
      case "southwest":
        return uk;
      case "east":
        return CO;
      case "west":
        return _O;
    }
  }, xO = (t, s, a, l, f) => l0(l).map(_$).getOr(Gf)(t, s, a, l, f), TO = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: [],
    alignRight: [],
    right: [],
    left: [],
    bottom: [],
    top: []
  }, C$ = (t, s, a) => {
    const f = { maxHeightFunction: Lg() }, g = () => ({
      type: "node",
      root: U(t()),
      node: z.from(t()),
      bubble: Hg(12, 12, TO),
      layouts: {
        onRtl: () => [dk],
        onLtr: () => [uk]
      },
      overrides: f
    }), h = () => ({
      type: "hotspot",
      hotspot: s(),
      bubble: Hg(-12, 12, TO),
      layouts: {
        onRtl: () => [vc],
        onLtr: () => [kc]
      },
      overrides: f
    });
    return () => a() ? g() : h();
  }, S$ = (t, s, a) => {
    const l = () => ({
      type: "node",
      root: U(t()),
      node: z.from(t()),
      layouts: {
        onRtl: () => [Gf],
        onLtr: () => [Gf]
      }
    }), f = () => ({
      type: "hotspot",
      hotspot: s(),
      layouts: {
        onRtl: () => [ua],
        onLtr: () => [ua]
      }
    });
    return () => a() ? l() : f();
  }, x$ = (t, s) => () => ({
    type: "selection",
    root: s(),
    getSelection: () => {
      const a = t.selection.getRng();
      return z.some(Zi.range(bt.fromDom(a.startContainer), a.startOffset, bt.fromDom(a.endContainer), a.endOffset));
    }
  }), T$ = (t) => (s) => ({
    type: "node",
    root: t(),
    node: s
  }), E$ = (t, s, a) => {
    const l = Sv(t), f = () => bt.fromDom(t.getBody()), g = () => bt.fromDom(t.getContentAreaContainer()), h = () => l || !a();
    return {
      inlineDialog: C$(g, s, h),
      banner: S$(g, s, h),
      cursor: x$(t, f),
      node: T$(f)
    };
  }, EO = (t) => (s, a) => {
    bz(t)(s, a);
  }, A$ = (t) => () => dz(t), AO = (t) => () => W3(t), z$ = (t) => () => uz(t), zO = (t) => ({
    colorPicker: EO(t),
    hasCustomColors: A$(t),
    getColors: AO(t),
    getColorCols: z$(t)
  }), OO = (t) => () => lA(t), DO = (t) => ({ isDraggableModal: OO(t) }), O$ = (t) => {
    const s = Xn(l3(t) ? "bottom" : "top");
    return {
      isPositionedAtTop: () => s.get() === "top",
      getDockingMode: s.get,
      setDockingMode: s.set
    };
  }, m4 = [
    {
      title: "Headings",
      items: [
        {
          title: "Heading 1",
          format: "h1"
        },
        {
          title: "Heading 2",
          format: "h2"
        },
        {
          title: "Heading 3",
          format: "h3"
        },
        {
          title: "Heading 4",
          format: "h4"
        },
        {
          title: "Heading 5",
          format: "h5"
        },
        {
          title: "Heading 6",
          format: "h6"
        }
      ]
    },
    {
      title: "Inline",
      items: [
        {
          title: "Bold",
          format: "bold"
        },
        {
          title: "Italic",
          format: "italic"
        },
        {
          title: "Underline",
          format: "underline"
        },
        {
          title: "Strikethrough",
          format: "strikethrough"
        },
        {
          title: "Superscript",
          format: "superscript"
        },
        {
          title: "Subscript",
          format: "subscript"
        },
        {
          title: "Code",
          format: "code"
        }
      ]
    },
    {
      title: "Blocks",
      items: [
        {
          title: "Paragraph",
          format: "p"
        },
        {
          title: "Blockquote",
          format: "blockquote"
        },
        {
          title: "Div",
          format: "div"
        },
        {
          title: "Pre",
          format: "pre"
        }
      ]
    },
    {
      title: "Align",
      items: [
        {
          title: "Left",
          format: "alignleft"
        },
        {
          title: "Center",
          format: "aligncenter"
        },
        {
          title: "Right",
          format: "alignright"
        },
        {
          title: "Justify",
          format: "alignjustify"
        }
      ]
    }
  ], RO = (t) => qn(t, "items"), D$ = (t) => qn(t, "block"), MO = (t) => qn(t, "inline"), R$ = (t) => qn(t, "selector"), NO = (t) => We(t, (s, a) => {
    if (RO(a)) {
      const l = NO(a.items);
      return {
        customFormats: s.customFormats.concat(l.customFormats),
        formats: s.formats.concat([{
          title: a.title,
          items: l.formats
        }])
      };
    } else if (MO(a) || D$(a) || R$(a)) {
      const f = `custom-${Kt(a.name) ? a.name : a.title.toLowerCase()}`;
      return {
        customFormats: s.customFormats.concat([{
          name: f,
          format: a
        }]),
        formats: s.formats.concat([{
          title: a.title,
          format: f,
          icon: a.icon
        }])
      };
    } else
      return {
        ...s,
        formats: s.formats.concat(a)
      };
  }, {
    customFormats: [],
    formats: []
  }), Jd = (t, s) => {
    const a = NO(s), l = (f) => {
      O(f, (g) => {
        t.formatter.has(g.name) || t.formatter.register(g.name, g.format);
      });
    };
    return t.formatter ? l(a.customFormats) : t.on("init", () => {
      l(a.customFormats);
    }), a.formats;
  }, mk = (t) => V_(t).map((s) => {
    const a = Jd(t, s);
    return j_(t) ? m4.concat(a) : a;
  }).getOr(m4), gk = (t, s, a) => {
    const l = {
      type: "formatter",
      isSelected: s(t.format),
      getStylePreview: a(t.format)
    };
    return sr(t, l);
  }, BO = (t, s, a, l) => {
    const f = (C) => gk(C, a, l), g = (C) => sr(C, { type: "submenu" }), h = (C) => {
      const T = Kt(C.name) ? C.name : $n(C.title), D = `custom-${T}`, $ = {
        type: "formatter",
        format: D,
        isSelected: a(D),
        getStylePreview: l(D)
      }, I = sr(C, $);
      return t.formatter.register(T, I), I;
    }, w = (C) => Xe(C, (T) => {
      const D = mn(T);
      if (pr(T, "items")) {
        const $ = w(T.items);
        return sr(g(T), { getStyleItems: oe($) });
      } else
        return pr(T, "format") ? f(T) : D.length === 1 && Fn(D, "title") ? sr(T, { type: "separator" }) : h(T);
    });
    return w(s);
  }, g4 = (t) => {
    const s = ($) => () => t.formatter.match($), a = ($) => () => {
      const I = t.formatter.get($);
      return I !== void 0 ? z.some({
        tag: I.length > 0 && (I[0].inline || I[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText($))
      }) : z.none();
    }, l = ($) => {
      const I = $.items;
      return I !== void 0 && I.length > 0 ? je(I, l) : [$.format];
    }, f = Xn([]), g = Xn([]), h = Xn([]), w = Xn([]), C = Xn(!1);
    return t.on("PreInit", ($) => {
      const I = mk(t), V = BO(t, I, s, a);
      f.set(V), g.set(je(V, l));
    }), t.on("addStyleModifications", ($) => {
      const I = BO(t, $.items, s, a);
      h.set(I), C.set($.replace), w.set(je(I, l));
    }), {
      getData: () => {
        const $ = C.get() ? [] : f.get(), I = h.get();
        return $.concat(I);
      },
      getFlattenedKeys: () => {
        const $ = C.get() ? [] : g.get(), I = w.get();
        return $.concat(I);
      }
    };
  }, M$ = (t) => Ge(t) && t.nodeType === 1, p4 = ly.trim, h4 = (t) => (s) => !!(M$(s) && (s.contentEditable === t || s.getAttribute("data-mce-contenteditable") === t)), y4 = h4("true"), N$ = h4("false"), b4 = (t, s, a, l, f) => ({
    type: t,
    title: s,
    url: a,
    level: l,
    attach: f
  }), $O = (t) => {
    for (; t = t.parentNode; ) {
      const s = t.contentEditable;
      if (s && s !== "inherit")
        return y4(t);
    }
    return !1;
  }, v4 = (t, s) => Xe(Mc(bt.fromDom(s), t), (a) => a.dom), PO = (t) => t.innerText || t.textContent, B$ = (t) => t.id ? t.id : $n("h"), FO = (t) => t && t.nodeName === "A" && (t.id || t.name) !== void 0, $$ = (t) => FO(t) && k4(t), IO = (t) => t && /^(H[1-6])$/.test(t.nodeName), k4 = (t) => $O(t) && !N$(t), LO = (t) => IO(t) && k4(t), P$ = (t) => IO(t) ? parseInt(t.nodeName.substr(1), 10) : 0, F$ = (t) => {
    const s = B$(t), a = () => {
      t.id = s;
    };
    return b4("header", PO(t), "#" + s, P$(t), a);
  }, I$ = (t) => {
    const s = t.id || t.name, a = PO(t);
    return b4("anchor", a || "#" + s, "#" + s, 0, ie);
  }, L$ = (t) => Xe(Pt(t, LO), F$), HO = (t) => Xe(Pt(t, $$), I$), Qd = (t) => v4("h1,h2,h3,h4,h5,h6,a:not([href])", t), w4 = (t) => p4(t.title).length > 0, H$ = { find: (t) => {
    const s = Qd(t);
    return Pt(L$(s).concat(HO(s)), w4);
  } }, Y2 = "tinymce-url-history", VO = 5, jO = (t) => Kt(t) && /^https?/.test(t), UO = (t) => Un(t) && t.length <= VO && ke(t, jO), _4 = (t) => Bt(t) && Vt(t, (s) => !UO(s)).isNone(), V$ = () => {
    const t = f2.getItem(Y2);
    if (t === null)
      return {};
    let s;
    try {
      s = JSON.parse(t);
    } catch (a) {
      if (a instanceof SyntaxError)
        return console.log("Local storage " + Y2 + " was not valid JSON", a), {};
      throw a;
    }
    return _4(s) ? s : (console.log("Local storage " + Y2 + " was not valid format", s), {});
  }, zL = (t) => {
    if (!_4(t))
      throw new Error(`Bad format for history:
` + JSON.stringify(t));
    f2.setItem(Y2, JSON.stringify(t));
  }, $c = (t) => {
    const s = V$();
    return ht(s, t).getOr([]);
  }, C4 = (t, s) => {
    if (!jO(t))
      return;
    const a = V$(), l = ht(a, s).getOr([]), f = Pt(l, (g) => g !== t);
    a[s] = [t].concat(f).slice(0, VO), zL(a);
  }, WO = (t) => !!t, X2 = (t) => Ln(ly.makeMap(t, /[, ]/), WO), S4 = (t) => z.from(oA(t)), j$ = (t) => {
    const s = z.from(rA(t)).filter(WO).map(X2);
    return S4(t).fold(Ot, (a) => s.fold(Se, (l) => mn(l).length > 0 ? l : !1));
  }, U$ = (t, s) => {
    const a = j$(t);
    return tn(a) ? a ? S4(t) : z.none() : a[s] ? S4(t) : z.none();
  }, W$ = (t, s) => U$(t, s).map((a) => (l) => Bc.nu((f) => {
    const g = (w, C) => {
      if (!Kt(w))
        throw new Error("Expected value to be string");
      if (C !== void 0 && !Bt(C))
        throw new Error("Expected meta to be a object");
      f({
        value: w,
        meta: C
      });
    }, h = {
      filetype: s,
      fieldname: l.fieldname,
      ...z.from(l.meta).getOr({})
    };
    a.call(t, g, l.value, h);
  })), ZO = (t) => z.from(t).filter(Kt).getOrUndefined(), Z$ = (t) => Z_(t) ? z.some({
    targets: H$.find(t.getBody()),
    anchorTop: ZO(aA(t)),
    anchorBottom: ZO(cA(t))
  }) : z.none(), q$ = (t) => z.from(sA(t)), G$ = (t) => ({
    getHistory: $c,
    addToHistory: C4,
    getLinkInformation: () => Z$(t),
    getValidationHandler: () => q$(t),
    getUrlPicker: (s) => W$(t, s)
  }), qO = (t, s, a) => {
    const l = Xn(!1), f = O$(s), g = {
      shared: {
        providers: {
          icons: () => s.ui.registry.getAll().icons,
          menuItems: () => s.ui.registry.getAll().menuItems,
          translate: Su.translate,
          isDisabled: () => s.mode.isReadOnly() || !s.ui.isEnabled(),
          getOption: s.options.get
        },
        interpreter: (h) => k$(h, {}, g),
        anchors: E$(s, a, f.isPositionedAtTop),
        header: f,
        getSink: t
      },
      urlinput: G$(s),
      styles: g4(s),
      colorinput: zO(s),
      dialog: DO(s),
      isContextMenuOpen: () => l.get(),
      setContextMenuState: (h) => l.set(h)
    };
    return g;
  }, J2 = (t, s, a) => {
    const l = (et, hn) => {
      O([
        s,
        a
      ], (xn) => {
        xn.broadcastEvent(et, hn);
      });
    }, f = (et, hn) => {
      O([
        s,
        a
      ], (xn) => {
        xn.broadcastOn([et], hn);
      });
    }, g = (et) => f(xi(), { target: et.target }), h = M(), w = Va(h, "touchstart", g), C = Va(h, "touchmove", (et) => l(Dy(), et)), T = Va(h, "touchend", (et) => l(BC(), et)), D = Va(h, "mousedown", g), $ = Va(h, "mouseup", (et) => {
      et.raw.button === 0 && f(Tb(), { target: et.target });
    }), I = (et) => f(xi(), { target: bt.fromDom(et.target) }), V = (et) => {
      et.button === 0 && f(Tb(), { target: bt.fromDom(et.target) });
    }, ne = () => {
      O(t.editorManager.get(), (et) => {
        t !== et && et.dispatch("DismissPopups", { relatedTarget: t });
      });
    }, pe = (et) => l(Sf(), u0(et)), Le = (et) => {
      f(Id(), {}), l(Ry(), u0(et));
    }, he = () => f(Id(), {}), at = (et) => {
      et.state && f(xi(), { target: bt.fromDom(t.getContainer()) });
    }, kn = (et) => {
      f(xi(), { target: bt.fromDom(et.relatedTarget.getContainer()) });
    };
    t.on("PostRender", () => {
      t.on("click", I), t.on("tap", I), t.on("mouseup", V), t.on("mousedown", ne), t.on("ScrollWindow", pe), t.on("ResizeWindow", Le), t.on("ResizeEditor", he), t.on("AfterProgressState", at), t.on("DismissPopups", kn);
    }), t.on("remove", () => {
      t.off("click", I), t.off("tap", I), t.off("mouseup", V), t.off("mousedown", ne), t.off("ScrollWindow", pe), t.off("ResizeWindow", Le), t.off("ResizeEditor", he), t.off("AfterProgressState", at), t.off("DismissPopups", kn), D.unbind(), w.unbind(), C.unbind(), T.unbind(), $.unbind();
    }), t.on("detach", () => {
      Ql(s), Ql(a), s.destroy(), a.destroy();
    });
  }, ni = lx, zp = rx, K$ = oe([
    Te("shell", !1),
    ut("makeItem"),
    Te("setupItem", ie),
    Bl.field("listBehaviours", [Uo])
  ]), X$ = vu({
    name: "items",
    overrides: () => ({ behaviours: qt([Uo.config({})]) })
  }), J$ = oe([X$]), GO = oe("CustomList"), OL = (t, s, a, l) => {
    const f = (w, C) => {
      h(w).fold(() => {
        throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (T) => {
        const D = Uo.contents(T), $ = C.length, I = $ - D.length, V = I > 0 ? Dn(I, () => t.makeItem()) : [], ne = D.slice($);
        O(ne, (Le) => Uo.remove(T, Le)), O(V, (Le) => Uo.append(T, Le));
        const pe = Uo.contents(T);
        O(pe, (Le, he) => {
          t.setupItem(w, Le, C[he], he);
        });
      });
    }, g = t.shell ? {
      behaviours: [Uo.config({})],
      components: []
    } : {
      behaviours: [],
      components: s
    }, h = (w) => t.shell ? z.some(w) : Ds(w, t, "items");
    return {
      uid: t.uid,
      dom: t.dom,
      components: g.components,
      behaviours: Ua(t.listBehaviours, g.behaviours),
      apis: { setItems: f }
    };
  }, Q$ = Jc({
    name: GO(),
    configFields: K$(),
    partFields: J$(),
    factory: OL,
    apis: {
      setItems: (t, s, a) => {
        t.setItems(s, a);
      }
    }
  }), f1 = oe([
    ut("dom"),
    Te("shell", !0),
    Oa("toolbarBehaviours", [Uo])
  ]), eP = oe([vu({
    name: "groups",
    overrides: () => ({ behaviours: qt([Uo.config({})]) })
  })]), KO = (t, s, a, l) => {
    const f = (w, C) => {
      g(w).fold(() => {
        throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (T) => {
        Uo.set(T, C);
      });
    }, g = (w) => t.shell ? z.some(w) : Ds(w, t, "groups"), h = t.shell ? {
      behaviours: [Uo.config({})],
      components: []
    } : {
      behaviours: [],
      components: s
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: h.components,
      behaviours: Ua(t.toolbarBehaviours, h.behaviours),
      apis: { setGroups: f },
      domModification: { attributes: { role: "group" } }
    };
  }, Au = Jc({
    name: "Toolbar",
    configFields: f1(),
    partFields: eP(),
    factory: KO,
    apis: {
      setGroups: (t, s, a) => {
        t.setGroups(s, a);
      }
    }
  }), tP = ie, nP = Ot, x4 = oe([]);
  var oP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: tP,
    isDocked: nP,
    getBehaviours: x4
  });
  const YO = (t) => (zr(j(t, "position"), "fixed") ? z.none() : ci(t)).orThunk(() => {
    const l = bt.fromTag("span");
    return Wr(t).bind((f) => {
      Ec(f, l);
      const g = ci(l);
      return rl(l), g;
    });
  }), XO = (t) => YO(t).map(Me).getOrThunk(() => as(0, 0)), T4 = Pa.generate([
    { static: [] },
    { absolute: ["positionCss"] },
    { fixed: ["positionCss"] }
  ]), E4 = (t, s) => {
    const a = t.element;
    Ea(a, s.transitionClass), Yr(a, s.fadeOutClass), Ea(a, s.fadeInClass), s.onShow(t);
  }, JO = (t, s) => {
    const a = t.element;
    Ea(a, s.transitionClass), Yr(a, s.fadeInClass), Ea(a, s.fadeOutClass), s.onHide(t);
  }, sP = (t, s) => t.y < s.bottom && t.bottom > s.y, rP = (t, s) => t.y >= s.y, aP = (t, s) => t.bottom <= s.bottom, QO = (t, s, a) => ke(t, (l) => {
    switch (l) {
      case "bottom":
        return aP(s, a);
      case "top":
        return rP(s, a);
    }
  }), A4 = (t, s) => s.getInitialPos().map((a) => ws(a.bounds.x, a.bounds.y, Wo(t), hs(t))), cP = (t, s, a) => {
    a.setInitialPos({
      style: ce(t),
      position: qr(t, "position") || "static",
      bounds: s
    });
  }, pk = (t, s, a) => a.getInitialPos().bind((l) => {
    switch (a.clearInitialPos(), l.position) {
      case "static":
        return z.some(T4.static());
      case "absolute":
        const f = YO(t).map(Or).getOrThunk(() => Or(js()));
        return z.some(T4.absolute(Rl("absolute", ht(l.style, "left").map((g) => s.x - f.x), ht(l.style, "top").map((g) => s.y - f.y), ht(l.style, "right").map((g) => f.right - s.right), ht(l.style, "bottom").map((g) => f.bottom - s.bottom))));
      default:
        return z.none();
    }
  }), lP = (t, s, a) => A4(t, a).filter((l) => QO(a.getModes(), l, s)).bind((l) => pk(t, l, a)), Q2 = (t, s, a) => {
    const l = Or(t);
    if (QO(a.getModes(), l, s))
      return z.none();
    {
      cP(t, l, a);
      const f = ui(), g = l.x - f.x, h = s.y - f.y, w = f.bottom - s.bottom, C = l.y <= s.y;
      return z.some(T4.fixed(Rl("fixed", z.some(g), C ? z.some(h) : z.none(), z.none(), C ? z.none() : z.some(w))));
    }
  }, iP = (t, s, a) => {
    const l = t.element;
    return zr(j(l, "position"), "fixed") ? lP(l, s, a) : Q2(l, s, a);
  }, z4 = (t, s) => {
    const a = t.element;
    return A4(a, s).bind((l) => pk(a, l, s));
  }, m1 = (t, s, a) => {
    a.setDocked(!1), O([
      "left",
      "right",
      "top",
      "bottom",
      "position"
    ], (l) => Dt(t.element, l)), s.onUndocked(t);
  }, eC = (t, s, a, l) => {
    const f = l.position === "fixed";
    a.setDocked(f), Sw(t.element, l), (f ? s.onDocked : s.onUndocked)(t);
  }, eD = (t, s, a, l, f = !1) => {
    s.contextual.each((g) => {
      g.lazyContext(t).each((h) => {
        const w = sP(h, l);
        w !== a.isVisible() && (a.setVisible(w), f && !w ? (ji(t.element, [g.fadeOutClass]), g.onHide(t)) : (w ? E4 : JO)(t, g));
      });
    });
  }, tD = (t, s, a) => {
    const l = s.lazyViewport(t);
    a.isDocked() && eD(t, s, a, l), iP(t, l, a).each((g) => {
      g.fold(() => m1(t, s, a), (h) => eC(t, s, a, h), (h) => {
        eD(t, s, a, l, !0), eC(t, s, a, h);
      });
    });
  }, nD = (t, s, a) => {
    const l = t.element;
    a.setDocked(!1), z4(t, a).each((f) => {
      f.fold(() => m1(t, s, a), (g) => eC(t, s, a, g), ie);
    }), a.setVisible(!0), s.contextual.each((f) => {
      qc(l, [
        f.fadeInClass,
        f.fadeOutClass,
        f.transitionClass
      ]), f.onShow(t);
    }), tC(t, s, a);
  }, tC = (t, s, a) => {
    t.getSystem().isConnected() && tD(t, s, a);
  }, oD = (t, s, a) => {
    a.isDocked() && nD(t, s, a);
  };
  var uP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: tC,
    reset: oD,
    isDocked: (t, s, a) => a.isDocked(),
    getModes: (t, s, a) => a.getModes(),
    setModes: (t, s, a, l) => a.setModes(l)
  }), rD = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => Ls([
      pi(Gp(), (a, l) => {
        t.contextual.each((f) => {
          oc(a.element, f.transitionClass) && (qc(a.element, [
            f.transitionClass,
            f.fadeInClass
          ]), (s.isVisible() ? f.onShown : f.onHidden)(a)), l.stop();
        });
      }),
      dt(Sf(), (a, l) => {
        tC(a, t, s);
      }),
      dt(Ry(), (a, l) => {
        oD(a, t, s);
      })
    ])
  }), dP = [
    zc("contextual", [
      la("fadeInClass"),
      la("fadeOutClass"),
      la("transitionClass"),
      xa("lazyContext"),
      Es("onShow"),
      Es("onShown"),
      Es("onHide"),
      Es("onHidden")
    ]),
    Fr("lazyViewport", ui),
    ju("modes", [
      "top",
      "bottom"
    ], Pr),
    Es("onDocked"),
    Es("onUndocked")
  ], D4 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const s = Xn(!1), a = Xn(!0), l = Ar(), f = Xn(t.modes), g = () => `docked:  ${s.get()}, visible: ${a.get()}, modes: ${f.get().join(",")}`;
      return Ol({
        isDocked: s.get,
        setDocked: s.set,
        getInitialPos: l.get,
        setInitialPos: l.set,
        clearInitialPos: l.clear,
        isVisible: a.get,
        setVisible: a.set,
        getModes: f.get,
        setModes: f.set,
        readState: g
      });
    }
  });
  const Pc = Ha({
    fields: dP,
    name: "docking",
    active: rD,
    apis: uP,
    state: D4
  }), R4 = oe($n("toolbar-height-change")), Kf = {
    fadeInClass: "tox-editor-dock-fadein",
    fadeOutClass: "tox-editor-dock-fadeout",
    transitionClass: "tox-editor-dock-transition"
  }, aD = "tox-tinymce--toolbar-sticky-on", nC = "tox-tinymce--toolbar-sticky-off", mP = (t, s) => {
    const a = Er(s), l = a.dom.defaultView.innerHeight, f = al(a), g = bt.fromDom(t.elm), h = Gr(g), w = hs(g), C = h.y, T = C + w, D = Me(s), $ = hs(s), I = D.top, V = I + $, ne = Math.abs(I - f.top) < 2, pe = Math.abs(V - (f.top + l)) < 2;
    if (ne && C < V)
      lm(f.left, C - $, a);
    else if (pe && T > I) {
      const Le = C - l + w + $;
      lm(f.left, Le, a);
    }
  }, M4 = (t, s) => Fn(Pc.getModes(t), s), N4 = (t) => {
    const s = (l) => Ca(l) + (parseInt(qr(l, "margin-top"), 10) || 0) + (parseInt(qr(l, "margin-bottom"), 10) || 0), a = t.element;
    Wr(a).each((l) => {
      const f = "padding-" + Pc.getModes(t)[0];
      if (Pc.isDocked(t)) {
        const g = Wo(l);
        Qt(a, "width", g + "px"), Qt(l, f, s(a) + "px");
      } else
        Dt(a, "width"), Dt(l, f);
    });
  }, cD = (t, s) => {
    s ? (Yr(t, Kf.fadeOutClass), ji(t, [
      Kf.transitionClass,
      Kf.fadeInClass
    ])) : (Yr(t, Kf.fadeInClass), ji(t, [
      Kf.fadeOutClass,
      Kf.transitionClass
    ]));
  }, lD = (t, s) => {
    const a = bt.fromDom(t.getContainer());
    s ? (Ea(a, aD), Yr(a, nC)) : (Ea(a, nC), Yr(a, aD));
  }, gP = (t, s) => {
    const a = Er(s);
    Nd(a).filter((l) => !Lo(s, l)).filter((l) => Lo(l, bt.fromDom(a.dom.body)) || br(t, l)).each(() => Xu(s));
  }, pP = (t, s) => _i(t).orThunk(() => s().toOptional().bind((a) => _i(a.element))), iD = (t, s, a) => {
    t.inline || (s.header.isPositionedAtTop() || t.on("ResizeEditor", () => {
      a().each(Pc.reset);
    }), t.on("ResizeWindow ResizeEditor", () => {
      a().each(N4);
    }), t.on("SkinLoaded", () => {
      a().each((l) => {
        Pc.isDocked(l) ? Pc.reset(l) : Pc.refresh(l);
      });
    }), t.on("FullscreenStateChanged", () => {
      a().each(Pc.reset);
    })), t.on("AfterScrollIntoView", (l) => {
      a().each((f) => {
        Pc.refresh(f);
        const g = f.element;
        gl(g) && mP(l, g);
      });
    }), t.on("PostRender", () => {
      lD(t, !1);
    });
  }, hP = (t) => t().map(Pc.isDocked).getOr(!1), yk = () => [wi.config({ channels: { [R4()]: { onReceive: N4 } } })], uD = (t, s) => {
    const a = Ar(), l = s.getSink, f = (w) => {
      l().each((C) => w(C.element));
    }, g = (w) => {
      t.inline || N4(w), lD(t, Pc.isDocked(w)), w.getSystem().broadcastOn([Id()], {}), l().each((C) => C.getSystem().broadcastOn([Id()], {}));
    }, h = t.inline ? [] : yk();
    return [
      go.config({}),
      Pc.config({
        contextual: {
          lazyContext: (w) => {
            const C = Ca(w.element), T = t.inline ? t.getContentAreaContainer() : t.getContainer(), D = Or(bt.fromDom(T)), $ = D.height - C, I = D.y + (M4(w, "top") ? 0 : C);
            return z.some(ws(D.x, I, D.width, $));
          },
          onShow: () => {
            f((w) => cD(w, !0));
          },
          onShown: (w) => {
            f((C) => qc(C, [
              Kf.transitionClass,
              Kf.fadeInClass
            ])), a.get().each((C) => {
              gP(w.element, C), a.clear();
            });
          },
          onHide: (w) => {
            pP(w.element, l).fold(a.clear, a.set), f((C) => cD(C, !1));
          },
          onHidden: () => {
            f((w) => qc(w, [Kf.transitionClass]));
          },
          ...Kf
        },
        lazyViewport: (w) => {
          const C = ui(), T = tA(t), D = C.y + (M4(w, "top") ? T : 0), $ = C.height - (M4(w, "bottom") ? T : 0);
          return ws(C.x, D, C.width, $);
        },
        modes: [s.header.getDockingMode()],
        onDocked: g,
        onUndocked: g
      }),
      ...h
    ];
  };
  var yP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: iD,
    isDocked: hP,
    getBehaviours: uD
  });
  const B4 = (t) => {
    const s = t.editor, a = t.sticky ? uD : x4;
    return {
      uid: t.uid,
      dom: t.dom,
      components: t.components,
      behaviours: qt(a(s, t.sharedBackstage))
    };
  }, dD = Pn([
    fa,
    Ac("items", Up([
      yd([
        Rv,
        jc("items", Pr)
      ]),
      Pr
    ]))
  ].concat(Bv)), bP = (t) => Js("GroupToolbarButton", dD, t), vP = [
    pc("text"),
    pc("tooltip"),
    pc("icon"),
    xa("fetch"),
    Fr("onSetup", () => ie)
  ], kP = Pn([
    fa,
    ...vP
  ]), fD = (t) => Js("menubutton", kP, t), wP = Pn([
    fa,
    Q_,
    Ji,
    kp,
    OA,
    v3,
    Wd,
    ia("presets", "normal", [
      "normal",
      "color",
      "listpreview"
    ]),
    k3(1),
    Kh,
    AA
  ]), _P = (t) => Js("SplitButton", wP, t);
  var $4 = Wa({
    factory: (t, s) => {
      const a = (f, g) => {
        const h = Xe(g, (w) => {
          const C = {
            type: "menubutton",
            text: w.text,
            fetch: (D) => {
              D(w.getItems());
            }
          }, T = fD(C).mapError((D) => wd(D)).getOrDie();
          return n4(T, "tox-mbtn", s.backstage, z.some("menuitem"));
        });
        Uo.set(f, h);
      }, l = {
        focus: Kn.focusIn,
        setMenus: a
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: [],
        behaviours: qt([
          Uo.config({}),
          ys("menubar-events", [
            kr((f) => {
              t.onSetup(f);
            }),
            dt(Br(), (f, g) => {
              sc(f.element, ".tox-mbtn--active").each((h) => {
                Wi(g.event.target, ".tox-mbtn").each((w) => {
                  Lo(h, w) || f.getSystem().getByDom(h).each((C) => {
                    f.getSystem().getByDom(w).each((T) => {
                      cd.expand(T), cd.close(C), go.focus(T);
                    });
                  });
                });
              });
            }),
            dt(Uk(), (f, g) => {
              g.event.prevFocus.bind((h) => f.getSystem().getByDom(h).toOptional()).each((h) => {
                g.event.newFocus.bind((w) => f.getSystem().getByDom(w).toOptional()).each((w) => {
                  cd.isOpen(h) && (cd.expand(w), cd.close(h));
                });
              });
            })
          ]),
          Kn.config({
            mode: "flow",
            selector: ".tox-mbtn",
            onEscape: (f) => (t.onEscape(f), z.some(!0))
          }),
          oa.config({})
        ]),
        apis: l,
        domModification: { attributes: { role: "menubar" } }
      };
    },
    name: "silver.Menubar",
    configFields: [
      ut("dom"),
      ut("uid"),
      ut("onEscape"),
      ut("backstage"),
      Te("onSetup", ie)
    ],
    apis: {
      focus: (t, s) => {
        t.focus(s);
      },
      setMenus: (t, s, a) => {
        t.setMenus(s, a);
      }
    }
  });
  const bk = (t, s) => s.getAnimationRoot.fold(() => t.element, (a) => a(t)), Yf = (t) => t.dimension.property, eg = (t, s) => t.dimension.getDimension(s), g1 = (t, s) => {
    const a = bk(t, s);
    qc(a, [
      s.shrinkingClass,
      s.growingClass
    ]);
  }, P4 = (t, s) => {
    Yr(t.element, s.openClass), Ea(t.element, s.closedClass), Qt(t.element, Yf(s), "0px"), $o(t.element);
  }, F4 = (t, s) => {
    Yr(t.element, s.closedClass), Ea(t.element, s.openClass), Dt(t.element, Yf(s));
  }, mD = (t, s, a, l) => {
    a.setCollapsed(), Qt(t.element, Yf(s), eg(s, t.element)), g1(t, s), P4(t, s), s.onStartShrink(t), s.onShrunk(t);
  }, CP = (t, s, a, l) => {
    const f = l.getOrThunk(() => eg(s, t.element));
    a.setCollapsed(), Qt(t.element, Yf(s), f), $o(t.element);
    const g = bk(t, s);
    Yr(g, s.growingClass), Ea(g, s.shrinkingClass), P4(t, s), s.onStartShrink(t);
  }, p1 = (t, s, a) => {
    const l = eg(s, t.element);
    (l === "0px" ? mD : CP)(t, s, a, z.some(l));
  }, gD = (t, s, a) => {
    const l = bk(t, s), f = oc(l, s.shrinkingClass), g = eg(s, t.element);
    F4(t, s);
    const h = eg(s, t.element);
    (f ? () => {
      Qt(t.element, Yf(s), g), $o(t.element);
    } : () => {
      P4(t, s);
    })(), Yr(l, s.shrinkingClass), Ea(l, s.growingClass), F4(t, s), Qt(t.element, Yf(s), h), a.setExpanded(), s.onStartGrow(t);
  }, I4 = (t, s, a) => {
    if (a.isExpanded()) {
      Dt(t.element, Yf(s));
      const l = eg(s, t.element);
      Qt(t.element, Yf(s), l);
    }
  }, SP = (t, s, a) => {
    a.isExpanded() || gD(t, s, a);
  }, xP = (t, s, a) => {
    a.isExpanded() && p1(t, s, a);
  }, TP = (t, s, a) => {
    a.isExpanded() && mD(t, s, a);
  }, EP = (t, s, a) => a.isExpanded(), pD = (t, s, a) => a.isCollapsed(), L4 = (t, s, a) => {
    const l = bk(t, s);
    return oc(l, s.growingClass) === !0;
  }, hD = (t, s, a) => {
    const l = bk(t, s);
    return oc(l, s.shrinkingClass) === !0;
  };
  var AP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: I4,
    grow: SP,
    shrink: xP,
    immediateShrink: TP,
    hasGrown: EP,
    hasShrunk: pD,
    isGrowing: L4,
    isShrinking: hD,
    isTransitioning: (t, s, a) => L4(t, s) || hD(t, s),
    toggleGrow: (t, s, a) => {
      (a.isExpanded() ? p1 : gD)(t, s, a);
    },
    disableTransitions: g1,
    immediateGrow: (t, s, a) => {
      a.isExpanded() || (F4(t, s), Qt(t.element, Yf(s), eg(s, t.element)), g1(t, s), a.setExpanded(), s.onStartGrow(t), s.onGrown(t));
    }
  }), j4 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, s, a) => {
      const l = s.expanded;
      return Ku(l ? {
        classes: [s.openClass],
        styles: {}
      } : {
        classes: [s.closedClass],
        styles: ge(s.dimension.property, "0px")
      });
    },
    events: (t, s) => Ls([pi(Gp(), (a, l) => {
      l.event.raw.propertyName === t.dimension.property && (g1(a, t), s.isExpanded() && Dt(a.element, t.dimension.property), (s.isExpanded() ? t.onGrown : t.onShrunk)(a));
    })])
  }), U4 = [
    ut("closedClass"),
    ut("openClass"),
    ut("shrinkingClass"),
    ut("growingClass"),
    xs("getAnimationRoot"),
    Es("onShrunk"),
    Es("onStartShrink"),
    Es("onGrown"),
    Es("onStartGrow"),
    Te("expanded", !1),
    Ac("dimension", rr("property", {
      width: [
        fr("property", "width"),
        fr("getDimension", (t) => Wo(t) + "px")
      ],
      height: [
        fr("property", "height"),
        fr("getDimension", (t) => hs(t) + "px")
      ]
    }))
  ], OP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const s = Xn(t.expanded), a = () => "expanded: " + s.get();
      return Ol({
        isExpanded: () => s.get() === !0,
        isCollapsed: () => s.get() === !1,
        setCollapsed: lt(s.set, !1),
        setExpanded: lt(s.set, !0),
        readState: a
      });
    }
  });
  const tu = Ha({
    fields: U4,
    name: "sliding",
    active: j4,
    apis: AP,
    state: OP
  }), yD = "container", DP = [Oa("slotBehaviours", [])], W4 = (t) => "<alloy.field." + t + ">", RP = (t) => {
    const s = (() => {
      const g = [];
      return {
        slot: (w, C) => (g.push(w), b_(yD, W4(w), C)),
        record: oe(g)
      };
    })(), a = t(s), l = s.record(), f = Xe(l, (g) => Cc({
      name: g,
      pname: W4(g)
    }));
    return Ib(yD, DP, f, vk, a);
  }, vk = (t, s) => {
    const a = (pe) => __(t), l = (pe, Le) => Ds(pe, t, Le), f = (pe, Le) => (he, at) => Ds(he, t, at).map((kn) => pe(kn, at)).getOr(Le), g = (pe) => (Le, he) => {
      O(he, (at) => pe(Le, at));
    }, h = (pe, Le) => Vo(pe.element, "aria-hidden") !== "true", w = (pe, Le) => {
      if (!h(pe)) {
        const he = pe.element;
        Dt(he, "display"), nr(he, "aria-hidden"), no(pe, Td(), {
          name: Le,
          visible: !0
        });
      }
    }, C = (pe, Le) => {
      if (h(pe)) {
        const he = pe.element;
        Qt(he, "display", "none"), to(he, "aria-hidden", "true"), no(pe, Td(), {
          name: Le,
          visible: !1
        });
      }
    }, T = f(h, !1), D = f(C), $ = g(D), I = (pe) => $(pe, a()), V = f(w), ne = {
      getSlotNames: a,
      getSlot: l,
      isShowing: T,
      hideSlot: D,
      hideAllSlots: I,
      showSlot: V
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Db(t.slotBehaviours),
      apis: ne
    };
  }, ef = {
    ...Ln({
      getSlotNames: (t, s) => t.getSlotNames(s),
      getSlot: (t, s, a) => t.getSlot(s, a),
      isShowing: (t, s, a) => t.isShowing(s, a),
      hideSlot: (t, s, a) => t.hideSlot(s, a),
      hideAllSlots: (t, s) => t.hideAllSlots(s),
      showSlot: (t, s, a) => t.showSlot(s, a)
    }, (t) => oh(t)),
    sketch: RP
  }, MP = Pn([
    Ji,
    Q_,
    Fr("onShow", ie),
    Fr("onHide", ie),
    Wd
  ]), FL = (t) => Js("sidebar", MP, t), IL = (t) => {
    const { sidebars: s } = t.ui.registry.getAll();
    O(mn(s), (a) => {
      const l = s[a], f = () => zr(z.from(t.queryCommandValue("ToggleSidebar")), a);
      t.ui.registry.addToggleButton(a, {
        icon: l.icon,
        tooltip: l.tooltip,
        onAction: (g) => {
          t.execCommand("ToggleSidebar", !1, a), g.setActive(f());
        },
        onSetup: (g) => {
          g.setActive(f());
          const h = () => g.setActive(f());
          return t.on("ToggleSidebar", h), () => {
            t.off("ToggleSidebar", h);
          };
        }
      });
    });
  }, bD = (t) => ({ element: () => t.element.dom }), NP = (t, s) => {
    const a = Xe(mn(s), (l) => {
      const f = s[l], g = gi(FL(f));
      return {
        name: l,
        getApi: bD,
        onSetup: g.onSetup,
        onShow: g.onShow,
        onHide: g.onHide
      };
    });
    return Xe(a, (l) => {
      const f = Xn(ie);
      return t.slot(l.name, {
        dom: {
          tag: "div",
          classes: ["tox-sidebar__pane"]
        },
        behaviours: qd.unnamedEvents([
          Lv(l, f),
          Hv(l, f),
          dt(Td(), (g, h) => {
            const w = h.event;
            Oe(a, (T) => T.name === w.name).each((T) => {
              (w.visible ? T.onShow : T.onHide)(T.getApi(g));
            });
          })
        ])
      });
    });
  }, vD = (t) => ef.sketch((s) => ({
    dom: {
      tag: "div",
      classes: ["tox-sidebar__pane-container"]
    },
    components: NP(s, t),
    slotBehaviours: qd.unnamedEvents([kr((a) => ef.hideAllSlots(a))])
  })), BP = (t, s, a) => {
    cs.getCurrent(t).each((f) => {
      Uo.set(f, [vD(s)]);
      const g = a == null ? void 0 : a.toLowerCase();
      Kt(a) && qn(s, g) && cs.getCurrent(f).each((h) => {
        ef.showSlot(h, g), tu.immediateGrow(f), Dt(f.element, "width");
      });
    });
  }, $P = (t, s) => {
    cs.getCurrent(t).each((l) => {
      cs.getCurrent(l).each((g) => {
        tu.hasGrown(l) ? ef.isShowing(g, s) ? tu.shrink(l) : (ef.hideAllSlots(g), ef.showSlot(g, s)) : (ef.hideAllSlots(g), ef.showSlot(g, s), tu.grow(l));
      });
    });
  }, PP = (t) => cs.getCurrent(t).bind((a) => tu.isGrowing(a) || tu.hasGrown(a) ? cs.getCurrent(a).bind((g) => Oe(ef.getSlotNames(g), (h) => ef.isShowing(g, h))) : z.none()), Z4 = $n("FixSizeEvent"), q4 = $n("AutoSizeEvent"), kD = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-sidebar"],
      attributes: { role: "complementary" }
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-sidebar__slider"]
      },
      components: [],
      behaviours: qt([
        oa.config({}),
        go.config({}),
        tu.config({
          dimension: { property: "width" },
          closedClass: "tox-sidebar--sliding-closed",
          openClass: "tox-sidebar--sliding-open",
          shrinkingClass: "tox-sidebar--sliding-shrinking",
          growingClass: "tox-sidebar--sliding-growing",
          onShrunk: (s) => {
            cs.getCurrent(s).each(ef.hideAllSlots), Ts(s, q4);
          },
          onGrown: (s) => {
            Ts(s, q4);
          },
          onStartGrow: (s) => {
            no(s, Z4, { width: j(s.element, "width").getOr("") });
          },
          onStartShrink: (s) => {
            no(s, Z4, { width: Wo(s.element) + "px" });
          }
        }),
        Uo.config({}),
        cs.config({
          find: (s) => {
            const a = Uo.contents(s);
            return fo(a);
          }
        })
      ])
    }],
    behaviours: qt([
      Di.childAt(0),
      ys("sidebar-sliding-events", [
        dt(Z4, (s, a) => {
          Qt(s.element, "width", a.event.width);
        }),
        dt(q4, (s, a) => {
          Dt(s.element, "width");
        })
      ])
    ])
  });
  var FP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: (t, s, a, l) => {
      to(t.element, "aria-busy", !0);
      const f = s.getRoot(t).getOr(t), g = qt([
        Kn.config({
          mode: "special",
          onTab: () => z.some(!0),
          onShiftTab: () => z.some(!0)
        }),
        go.config({})
      ]), h = l(f, g), w = f.getSystem().build(h);
      Uo.append(f, bi(w)), w.hasConfigured(Kn) && s.focus && Kn.focusIn(w), a.isBlocked() || s.onBlock(t), a.blockWith(() => Uo.remove(f, w));
    },
    unblock: (t, s, a) => {
      nr(t.element, "aria-busy"), a.isBlocked() && s.onUnblock(t), a.clear();
    }
  }), VL = [
    Fr("getRoot", z.none),
    Oc("focus", !0),
    Es("onBlock"),
    Es("onUnblock")
  ], wD = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Ow(), s = (a) => {
        t.set({ destroy: a });
      };
      return Ol({
        readState: t.isSet,
        blockWith: s,
        clear: t.clear,
        isBlocked: t.isSet
      });
    }
  });
  const Xf = Ha({
    fields: VL,
    name: "blocking",
    apis: FP,
    state: wD
  }), IP = (t) => {
    const s = t.dom.attributes !== void 0 ? t.dom.attributes : [];
    return We(s, (a, l) => l.name === "class" ? a : {
      ...a,
      [l.name]: l.value
    }, {});
  }, LP = (t) => Array.prototype.slice.call(t.dom.classList, 0), tl = (t) => {
    const s = bt.fromHtml(t), a = aa(s), l = IP(s), f = LP(s), g = a.length === 0 ? {} : { innerHtml: eh(s) };
    return {
      tag: zt(s),
      classes: f,
      attributes: l,
      ...g
    };
  }, HP = (t) => (s, a) => ({
    dom: {
      tag: "div",
      attributes: {
        "aria-label": t.translate("Loading..."),
        tabindex: "0"
      },
      classes: ["tox-throbber__busy-spinner"]
    },
    components: [{ dom: tl('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), G4 = (t) => cs.getCurrent(t).each((s) => Xu(s.element)), _D = (t, s) => {
    const a = "tabindex", l = `data-mce-${a}`;
    z.from(t.iframeElement).map(bt.fromDom).each((f) => {
      s ? (ha(f, a).each((g) => to(f, l, g)), to(f, a, -1)) : (nr(f, a), ha(f, l).each((g) => {
        to(f, a, g), nr(f, l);
      }));
    });
  }, oC = (t, s, a, l) => {
    const f = s.element;
    if (_D(t, a), a)
      Xf.block(s, HP(l)), Dt(f, "display"), nr(f, "aria-hidden"), t.hasFocus() && G4(s);
    else {
      const g = cs.getCurrent(s).exists((h) => Am(h.element));
      Xf.unblock(s), Qt(f, "display", "none"), to(f, "aria-hidden", "true"), g && t.focus();
    }
  }, VP = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      attributes: { "aria-hidden": "true" },
      classes: ["tox-throbber"],
      styles: { display: "none" }
    },
    behaviours: qt([
      Uo.config({}),
      Xf.config({ focus: !1 }),
      cs.config({ find: (s) => fo(s.components()) })
    ]),
    components: []
  }), sC = (t) => t.type === "focusin", jP = (t) => sC(t) ? (t.composed ? fo(t.composedPath()) : z.from(t.target)).map(bt.fromDom).filter(Yt).exists((a) => oc(a, "mce-pastebin")) : !1, rC = (t, s, a) => {
    const l = Xn(!1), f = Ar(), g = (w) => {
      l.get() && !jP(w) && (w.preventDefault(), G4(s()), t.editorManager.setActive(t));
    };
    t.inline || t.on("PreInit", () => {
      t.dom.bind(t.getWin(), "focusin", g), t.on("BeforeExecCommand", (w) => {
        w.command.toLowerCase() === "mcefocus" && w.value !== !0 && g(w);
      });
    });
    const h = (w) => {
      w !== l.get() && (l.set(w), oC(t, s(), w, a.providers), t.dispatch("AfterProgressState", { state: w }));
    };
    t.on("ProgressState", (w) => {
      if (f.on(clearTimeout), He(w.time)) {
        const C = Kb.setEditorTimeout(t, () => h(w.state), w.time);
        f.set(C);
      } else
        h(w.state), f.clear();
    });
  }, UP = (t, s) => We(t, (f, g) => s(g, f.len).fold(oe(f), (w) => ({
    len: w.finish,
    list: f.list.concat([w])
  })), {
    len: 0,
    list: []
  }).list, zu = (t, s, a) => ({
    within: t,
    extra: s,
    withinWidth: a
  }), CD = (t, s, a) => {
    const l = UP(t, (w, C) => {
      const T = a(w);
      return z.some({
        element: w,
        start: C,
        finish: C + T,
        width: T
      });
    }), f = Pt(l, (w) => w.finish <= s), g = Ne(f, (w, C) => w + C.width, 0), h = l.slice(f.length);
    return {
      within: f,
      extra: h,
      withinWidth: g
    };
  }, iy = (t) => Xe(t, (s) => s.element), SD = (t, s, a) => {
    const l = iy(t.concat(s));
    return zu(l, [], a);
  }, WP = (t, s, a, l) => {
    const f = iy(t).concat([a]);
    return zu(f, iy(s), l);
  }, ZP = (t, s, a) => zu(iy(t), [], a), qP = (t, s, a) => {
    const l = CD(s, t, a);
    return l.extra.length === 0 ? z.some(l) : z.none();
  }, GP = (t, s, a, l) => {
    const f = qP(t, s, a).getOrThunk(() => CD(s, t - a(l), a)), g = f.within, h = f.extra, w = f.withinWidth;
    return h.length === 1 && h[0].width <= a(l) ? SD(g, h, w) : h.length >= 1 ? WP(g, h, l, w) : ZP(g, h, w);
  }, xD = (t, s) => {
    const a = Xe(s, (l) => bi(l));
    Au.setGroups(t, a);
  }, KP = (t) => Ho(t, (s) => _i(s.element).bind((a) => s.getSystem().getByDom(a).toOptional())), TD = (t, s, a) => {
    const l = s.builtGroups.get();
    if (l.length === 0)
      return;
    const f = Ti(t, s, "primary"), g = Hr.getCoupled(t, "overflowGroup");
    Qt(f.element, "visibility", "hidden");
    const h = l.concat([g]), w = KP(h);
    a([]), xD(f, h);
    const C = Wo(f.element), T = GP(C, s.builtGroups.get(), (D) => Wo(D.element), g);
    T.extra.length === 0 ? (Uo.remove(f, g), a([])) : (xD(f, T.within), a(T.extra)), Dt(f.element, "visibility"), $o(f.element), w.each(go.focus);
  }, K4 = oe([
    Oa("splitToolbarBehaviours", [Hr]),
    va("builtGroups", () => Xn([]))
  ]), ED = oe([
    Mf(["overflowToggledClass"]),
    _f("getOverflowBounds"),
    ut("lazySink"),
    va("overflowGroups", () => Xn([]))
  ].concat(K4())), AD = oe([
    Cc({
      factory: Au,
      schema: f1(),
      name: "primary"
    }),
    Ki({
      schema: f1(),
      name: "overflow"
    }),
    Ki({ name: "overflow-button" }),
    Ki({ name: "overflow-group" })
  ]), Y4 = oe((t, s) => {
    ic(t, Math.floor(s));
  }), zD = oe([
    Mf(["toggledClass"]),
    ut("lazySink"),
    xa("fetch"),
    _f("getBounds"),
    zc("fireDismissalEventInstead", [Te("event", kg())]),
    ed()
  ]), YP = oe([
    Ki({
      name: "button",
      overrides: (t) => ({
        dom: { attributes: { "aria-haspopup": "true" } },
        buttonBehaviours: qt([Qo.config({
          toggleClass: t.markers.toggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1
        })])
      })
    }),
    Ki({
      factory: Au,
      schema: f1(),
      name: "toolbar",
      overrides: (t) => ({
        toolbarBehaviours: qt([Kn.config({
          mode: "cyclic",
          onEscape: (s) => (Ds(s, t, "button").each(go.focus), z.none())
        })])
      })
    })
  ]), OD = (t, s) => {
    const a = Hr.getCoupled(t, "toolbarSandbox");
    Yo.isOpen(a) ? Yo.close(a) : Yo.open(a, s.toolbar());
  }, X4 = (t, s, a, l) => {
    const f = a.getBounds.map((h) => h()), g = a.lazySink(t).getOrDie();
    dl.positionWithinBounds(g, s, {
      anchor: {
        type: "hotspot",
        hotspot: t,
        layouts: l,
        overrides: { maxWidthFunction: Y4() }
      }
    }, f);
  }, DD = (t, s, a, l, f) => {
    Au.setGroups(s, f), X4(t, s, a, l), Qo.on(t);
  }, XP = (t, s, a) => {
    const l = Rf(), f = (h, w) => {
      a.fetch().get((C) => {
        DD(t, w, a, s.layouts, C), l.link(t.element), Kn.focusIn(w);
      });
    }, g = () => {
      Qo.off(t), go.focus(t), l.unlink(t.element);
    };
    return {
      dom: {
        tag: "div",
        attributes: { id: l.id }
      },
      behaviours: qt([
        Kn.config({
          mode: "special",
          onEscape: (h) => (Yo.close(h), z.some(!0))
        }),
        Yo.config({
          onOpen: f,
          onClose: g,
          isPartOf: (h, w, C) => Md(w, C) || Md(t, C),
          getAttachPoint: () => a.lazySink(t).getOrDie()
        }),
        wi.config({
          channels: {
            ...B0({
              isExtraPart: Ot,
              ...a.fireDismissalEventInstead.map((h) => ({ fireEventInstead: { event: h.event } })).getOr({})
            }),
            ...Sh({
              doReposition: () => {
                Yo.getState(Hr.getCoupled(t, "toolbarSandbox")).each((h) => {
                  X4(t, h, a, s.layouts);
                });
              }
            })
          }
        })
      ])
    };
  }, uy = Jc({
    name: "FloatingToolbarButton",
    factory: (t, s, a, l) => ({
      ...$l.sketch({
        ...l.button(),
        action: (f) => {
          OD(f, l);
        },
        buttonBehaviours: Bl.augment({ dump: l.button().buttonBehaviours }, [Hr.config({
          others: {
            toolbarSandbox: (f) => XP(f, a, t)
          }
        })])
      }),
      apis: {
        setGroups: (f, g) => {
          Yo.getState(Hr.getCoupled(f, "toolbarSandbox")).each((h) => {
            DD(f, h, t, a.layouts, g);
          });
        },
        reposition: (f) => {
          Yo.getState(Hr.getCoupled(f, "toolbarSandbox")).each((g) => {
            X4(f, g, t, a.layouts);
          });
        },
        toggle: (f) => {
          OD(f, l);
        },
        getToolbar: (f) => Yo.getState(Hr.getCoupled(f, "toolbarSandbox")),
        isOpen: (f) => Yo.isOpen(Hr.getCoupled(f, "toolbarSandbox"))
      }
    }),
    configFields: zD(),
    partFields: YP(),
    apis: {
      setGroups: (t, s, a) => {
        t.setGroups(s, a);
      },
      reposition: (t, s) => {
        t.reposition(s);
      },
      toggle: (t, s) => {
        t.toggle(s);
      },
      getToolbar: (t, s) => t.getToolbar(s),
      isOpen: (t, s) => t.isOpen(s)
    }
  }), JP = oe([
    ut("items"),
    Mf(["itemSelector"]),
    Oa("tgroupBehaviours", [Kn])
  ]), QP = oe([ku({
    name: "items",
    unit: "item"
  })]), eF = (t, s, a, l) => ({
    uid: t.uid,
    dom: t.dom,
    components: s,
    behaviours: Ua(t.tgroupBehaviours, [Kn.config({
      mode: "flow",
      selector: t.markers.itemSelector
    })]),
    domModification: { attributes: { role: "toolbar" } }
  }), aC = Jc({
    name: "ToolbarGroup",
    configFields: JP(),
    partFields: QP(),
    factory: eF
  }), RD = (t) => Xe(t, (s) => bi(s)), MD = (t, s, a) => {
    TD(t, a, (l) => {
      a.overflowGroups.set(l), s.getOpt(t).each((f) => {
        uy.setGroups(f, RD(l));
      });
    });
  }, ND = (t, s, a, l) => {
    const f = wr(uy.sketch({
      fetch: () => Bc.nu((g) => {
        g(RD(t.overflowGroups.get()));
      }),
      layouts: {
        onLtr: () => [
          kc,
          vc
        ],
        onRtl: () => [
          vc,
          kc
        ],
        onBottomLtr: () => [
          wc,
          Kc
        ],
        onBottomRtl: () => [
          Kc,
          wc
        ]
      },
      getBounds: a.getOverflowBounds,
      lazySink: t.lazySink,
      fireDismissalEventInstead: {},
      markers: { toggledClass: t.markers.overflowToggledClass },
      parts: {
        button: l["overflow-button"](),
        toolbar: l.overflow()
      }
    }));
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Ua(t.splitToolbarBehaviours, [Hr.config({
        others: {
          overflowGroup: () => aC.sketch({
            ...l["overflow-group"](),
            items: [f.asSpec()]
          })
        }
      })]),
      apis: {
        setGroups: (g, h) => {
          t.builtGroups.set(Xe(h, g.getSystem().build)), MD(g, f, t);
        },
        refresh: (g) => MD(g, f, t),
        toggle: (g) => {
          f.getOpt(g).each((h) => {
            uy.toggle(h);
          });
        },
        isOpen: (g) => f.getOpt(g).map(uy.isOpen).getOr(!1),
        reposition: (g) => {
          f.getOpt(g).each((h) => {
            uy.reposition(h);
          });
        },
        getOverflow: (g) => f.getOpt(g).bind(uy.getToolbar)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, kk = Jc({
    name: "SplitFloatingToolbar",
    configFields: ED(),
    partFields: AD(),
    factory: ND,
    apis: {
      setGroups: (t, s, a) => {
        t.setGroups(s, a);
      },
      refresh: (t, s) => {
        t.refresh(s);
      },
      reposition: (t, s) => {
        t.reposition(s);
      },
      toggle: (t, s) => {
        t.toggle(s);
      },
      isOpen: (t, s) => t.isOpen(s),
      getOverflow: (t, s) => t.getOverflow(s)
    }
  }), J4 = oe([
    Mf([
      "closedClass",
      "openClass",
      "shrinkingClass",
      "growingClass",
      "overflowToggledClass"
    ]),
    Es("onOpened"),
    Es("onClosed")
  ].concat(K4())), tF = oe([
    Cc({
      factory: Au,
      schema: f1(),
      name: "primary"
    }),
    Cc({
      factory: Au,
      schema: f1(),
      name: "overflow",
      overrides: (t) => ({
        toolbarBehaviours: qt([
          tu.config({
            dimension: { property: "height" },
            closedClass: t.markers.closedClass,
            openClass: t.markers.openClass,
            shrinkingClass: t.markers.shrinkingClass,
            growingClass: t.markers.growingClass,
            onShrunk: (s) => {
              Ds(s, t, "overflow-button").each((a) => {
                Qo.off(a), go.focus(a);
              }), t.onClosed(s);
            },
            onGrown: (s) => {
              Kn.focusIn(s), t.onOpened(s);
            },
            onStartGrow: (s) => {
              Ds(s, t, "overflow-button").each(Qo.on);
            }
          }),
          Kn.config({
            mode: "acyclic",
            onEscape: (s) => (Ds(s, t, "overflow-button").each(go.focus), z.some(!0))
          })
        ])
      })
    }),
    Ki({
      name: "overflow-button",
      overrides: (t) => ({
        buttonBehaviours: qt([Qo.config({
          toggleClass: t.markers.overflowToggledClass,
          aria: { mode: "pressed" },
          toggleOnExecute: !1
        })])
      })
    }),
    Ki({ name: "overflow-group" })
  ]), nF = (t, s) => Ds(t, s, "overflow").map(tu.hasGrown).getOr(!1), Q4 = (t, s) => {
    Ds(t, s, "overflow-button").bind(() => Ds(t, s, "overflow")).each((a) => {
      eE(t, s), tu.toggleGrow(a);
    });
  }, eE = (t, s) => {
    Ds(t, s, "overflow").each((a) => {
      TD(t, s, (l) => {
        const f = Xe(l, (g) => bi(g));
        Au.setGroups(a, f);
      }), Ds(t, s, "overflow-button").each((l) => {
        tu.hasGrown(a) && Qo.on(l);
      }), tu.refresh(a);
    });
  }, oF = (t, s, a, l) => {
    const f = "alloy.toolbar.toggle", g = (h, w) => {
      const C = Xe(w, h.getSystem().build);
      t.builtGroups.set(C);
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Ua(t.splitToolbarBehaviours, [
        Hr.config({
          others: {
            overflowGroup: (h) => aC.sketch({
              ...l["overflow-group"](),
              items: [$l.sketch({
                ...l["overflow-button"](),
                action: (w) => {
                  Ts(h, f);
                }
              })]
            })
          }
        }),
        ys("toolbar-toggle-events", [dt(f, (h) => {
          Q4(h, t);
        })])
      ]),
      apis: {
        setGroups: (h, w) => {
          g(h, w), eE(h, t);
        },
        refresh: (h) => eE(h, t),
        toggle: (h) => Q4(h, t),
        isOpen: (h) => nF(h, t)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, tE = Jc({
    name: "SplitSlidingToolbar",
    configFields: J4(),
    partFields: tF(),
    factory: oF,
    apis: {
      setGroups: (t, s, a) => {
        t.setGroups(s, a);
      },
      refresh: (t, s) => {
        t.refresh(s);
      },
      toggle: (t, s) => {
        t.toggle(s);
      },
      isOpen: (t, s) => t.isOpen(s)
    }
  }), nE = (t) => {
    const s = t.title.fold(() => ({}), (a) => ({ attributes: { title: a } }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-toolbar__group"],
        ...s
      },
      components: [aC.parts.items({})],
      items: t.items,
      markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])" },
      tgroupBehaviours: qt([
        oa.config({}),
        go.config({})
      ])
    };
  }, cC = (t) => aC.sketch(nE(t)), BD = (t, s) => {
    const a = kr((l) => {
      const f = Xe(t.initGroups, cC);
      Au.setGroups(l, f);
    });
    return qt([
      rd.toolbarButton(t.providers.isDisabled),
      ma(),
      Kn.config({
        mode: s,
        onEscape: t.onEscape,
        selector: ".tox-toolbar__group"
      }),
      ys("toolbar-events", [a])
    ]);
  }, lC = (t) => {
    const s = t.cyclicKeying ? "cyclic" : "acyclic";
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar-overlord"]
      },
      parts: {
        "overflow-group": nE({
          title: z.none(),
          items: []
        }),
        "overflow-button": uO({
          name: "more",
          icon: z.some("more-drawer"),
          enabled: !0,
          tooltip: z.some("More..."),
          primary: !1,
          buttonType: z.none(),
          borderless: !1
        }, z.none(), t.providers)
      },
      splitToolbarBehaviours: BD(t, s)
    };
  }, sF = (t) => {
    const s = lC(t), a = 4, l = kk.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    return kk.sketch({
      ...s,
      lazySink: t.getSink,
      getOverflowBounds: () => {
        const f = t.moreDrawerData.lazyHeader().element, g = Gr(f), h = nl(f), w = Gr(h), C = Math.max(h.dom.scrollHeight, w.height);
        return ws(g.x + a, w.y, g.width - a * 2, C);
      },
      parts: {
        ...s.parts,
        overflow: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: t.attributes
          }
        }
      },
      components: [l],
      markers: { overflowToggledClass: "tox-tbtn--enabled" }
    });
  }, rF = (t) => {
    const s = tE.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    }), a = tE.parts.overflow({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__overflow"]
      }
    }), l = lC(t);
    return tE.sketch({
      ...l,
      components: [
        s,
        a
      ],
      markers: {
        openClass: "tox-toolbar__overflow--open",
        closedClass: "tox-toolbar__overflow--closed",
        growingClass: "tox-toolbar__overflow--growing",
        shrinkingClass: "tox-toolbar__overflow--shrinking",
        overflowToggledClass: "tox-tbtn--enabled"
      },
      onOpened: (f) => {
        f.getSystem().broadcastOn([R4()], { type: "opened" });
      },
      onClosed: (f) => {
        f.getSystem().broadcastOn([R4()], { type: "closed" });
      }
    });
  }, wk = (t) => {
    const s = t.cyclicKeying ? "cyclic" : "acyclic";
    return Au.sketch({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar"].concat(t.type === hl.scrolling ? ["tox-toolbar--scrolling"] : [])
      },
      components: [Au.parts.groups({})],
      toolbarBehaviours: BD(t, s)
    });
  }, aF = (t, s, a) => {
    const l = {
      getSocket: (f) => ni.getPart(f, t, "socket"),
      setSidebar: (f, g, h) => {
        ni.getPart(f, t, "sidebar").each((w) => BP(w, g, h));
      },
      toggleSidebar: (f, g) => {
        ni.getPart(f, t, "sidebar").each((h) => $P(h, g));
      },
      whichSidebar: (f) => ni.getPart(f, t, "sidebar").bind(PP).getOrNull(),
      getHeader: (f) => ni.getPart(f, t, "header"),
      getToolbar: (f) => ni.getPart(f, t, "toolbar"),
      setToolbar: (f, g) => {
        ni.getPart(f, t, "toolbar").each((h) => {
          h.getApis().setGroups(h, g);
        });
      },
      setToolbars: (f, g) => {
        ni.getPart(f, t, "multiple-toolbar").each((h) => {
          Q$.setItems(h, g);
        });
      },
      refreshToolbar: (f) => {
        ni.getPart(f, t, "toolbar").each((h) => h.getApis().refresh(h));
      },
      toggleToolbarDrawer: (f) => {
        ni.getPart(f, t, "toolbar").each((g) => {
          Gn(g.getApis().toggle, (h) => h(g));
        });
      },
      isToolbarDrawerToggled: (f) => ni.getPart(f, t, "toolbar").bind((g) => z.from(g.getApis().isOpen).map((h) => h(g))).getOr(!1),
      getThrobber: (f) => ni.getPart(f, t, "throbber"),
      focusToolbar: (f) => {
        ni.getPart(f, t, "toolbar").orThunk(() => ni.getPart(f, t, "multiple-toolbar")).each((h) => {
          Kn.focusIn(h);
        });
      },
      setMenubar: (f, g) => {
        ni.getPart(f, t, "menubar").each((h) => {
          $4.setMenus(h, g);
        });
      },
      focusMenubar: (f) => {
        ni.getPart(f, t, "menubar").each((g) => {
          $4.focus(g);
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      apis: l,
      behaviours: t.behaviours
    };
  }, $D = zp.optional({
    factory: $4,
    name: "menubar",
    schema: [ut("backstage")]
  }), cF = (t) => t.type === hl.sliding ? rF : t.type === hl.floating ? sF : wk, PD = zp.optional({
    factory: {
      sketch: (t) => Q$.sketch({
        uid: t.uid,
        dom: t.dom,
        listBehaviours: qt([Kn.config({
          mode: "acyclic",
          selector: ".tox-toolbar"
        })]),
        makeItem: () => wk({
          type: t.type,
          uid: $n("multiple-toolbar-item"),
          cyclicKeying: !1,
          initGroups: [],
          providers: t.providers,
          onEscape: () => (t.onEscape(), z.some(!0))
        }),
        setupItem: (s, a, l, f) => {
          Au.setGroups(a, l);
        },
        shell: !0
      })
    },
    name: "multiple-toolbar",
    schema: [
      ut("dom"),
      ut("onEscape")
    ]
  }), lF = zp.optional({
    factory: {
      sketch: (t) => {
        const s = cF(t), a = {
          type: t.type,
          uid: t.uid,
          onEscape: () => (t.onEscape(), z.some(!0)),
          cyclicKeying: !1,
          initGroups: [],
          getSink: t.getSink,
          providers: t.providers,
          moreDrawerData: {
            lazyToolbar: t.lazyToolbar,
            lazyMoreButton: t.lazyMoreButton,
            lazyHeader: t.lazyHeader
          },
          attributes: t.attributes
        };
        return s(a);
      }
    },
    name: "toolbar",
    schema: [
      ut("dom"),
      ut("onEscape"),
      ut("getSink")
    ]
  }), iF = zp.optional({
    factory: { sketch: B4 },
    name: "header",
    schema: [ut("dom")]
  }), uF = zp.optional({
    name: "socket",
    schema: [ut("dom")]
  }), FD = zp.optional({
    factory: { sketch: kD },
    name: "sidebar",
    schema: [ut("dom")]
  }), dF = zp.optional({
    factory: { sketch: VP },
    name: "throbber",
    schema: [ut("dom")]
  });
  var Xr = Jc({
    name: "OuterContainer",
    factory: aF,
    configFields: [
      ut("dom"),
      ut("behaviours")
    ],
    partFields: [
      iF,
      $D,
      lF,
      PD,
      uF,
      FD,
      dF
    ],
    apis: {
      getSocket: (t, s) => t.getSocket(s),
      setSidebar: (t, s, a, l) => {
        t.setSidebar(s, a, l);
      },
      toggleSidebar: (t, s, a) => {
        t.toggleSidebar(s, a);
      },
      whichSidebar: (t, s) => t.whichSidebar(s),
      getHeader: (t, s) => t.getHeader(s),
      getToolbar: (t, s) => t.getToolbar(s),
      setToolbar: (t, s, a) => {
        const l = Xe(a, (f) => cC(f));
        t.setToolbar(s, l);
      },
      setToolbars: (t, s, a) => {
        const l = Xe(a, (f) => Xe(f, cC));
        t.setToolbars(s, l);
      },
      refreshToolbar: (t, s) => t.refreshToolbar(s),
      toggleToolbarDrawer: (t, s) => {
        t.toggleToolbarDrawer(s);
      },
      isToolbarDrawerToggled: (t, s) => t.isToolbarDrawerToggled(s),
      getThrobber: (t, s) => t.getThrobber(s),
      setMenubar: (t, s, a) => {
        t.setMenubar(s, a);
      },
      focusMenubar: (t, s) => {
        t.focusMenubar(s);
      },
      focusToolbar: (t, s) => {
        t.focusToolbar(s);
      }
    }
  });
  const fF = "file edit view insert format tools table help", iC = {
    file: {
      title: "File",
      items: "newdocument restoredraft | preview | export print | deleteallconversations"
    },
    edit: {
      title: "Edit",
      items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
    },
    view: {
      title: "View",
      items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
    },
    insert: {
      title: "Insert",
      items: "image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents | insertdatetime"
    },
    format: {
      title: "Format",
      items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
    },
    tools: {
      title: "Tools",
      items: "spellchecker spellcheckerlanguage | a11ycheck code wordcount"
    },
    table: {
      title: "Table",
      items: "inserttable | cell row column | advtablesort | tableprops deletetable"
    },
    help: {
      title: "Help",
      items: "help"
    }
  }, oE = (t, s, a) => {
    const l = U_(a).split(/[ ,]/);
    return {
      text: t.title,
      getItems: () => je(t.items, (f) => {
        const g = f.toLowerCase();
        return g.trim().length === 0 ? [] : Sn(l, (h) => h === g) ? [] : g === "separator" || g === "|" ? [{ type: "separator" }] : s.menuItems[g] ? [s.menuItems[g]] : [];
      })
    };
  }, sE = (t) => typeof t == "string" ? t.split(" ") : t, ID = (t, s) => {
    const a = {
      ...iC,
      ...s.menus
    }, l = mn(s.menus).length > 0, f = s.menubar === void 0 || s.menubar === !0 ? sE(fF) : sE(s.menubar === !1 ? "" : s.menubar), g = Pt(f, (w) => {
      const C = qn(iC, w);
      return l ? C || ht(s.menus, w).exists((T) => qn(T, "items")) : C;
    }), h = Xe(g, (w) => {
      const C = a[w];
      return oE({
        title: C.title,
        items: sE(C.items)
      }, s, t);
    });
    return Pt(h, (w) => {
      const C = (T) => T.type !== "separator";
      return w.getItems().length > 0 && Sn(w.getItems(), C);
    });
  }, LD = (t) => {
    const s = () => {
      t._skinLoaded = !0, SM(t);
    };
    return () => {
      t.initialized ? s() : t.on("init", s);
    };
  }, mF = (t, s) => () => rz(t, { message: s }), HD = (t, s, a) => (t.on("remove", () => a.unload(s)), a.load(s)), gF = (t, s) => {
    const a = s + "/skin.min.css";
    return HD(t, a, t.ui.styleSheetLoader);
  }, pF = (t, s) => {
    if (fe(bt.fromDom(t.getElement()))) {
      const l = s + "/skin.shadowdom.min.css";
      return HD(t, l, kv.DOM.styleSheetLoader);
    } else
      return Promise.resolve();
  }, VD = (t, s) => {
    const a = gA(s);
    a && s.contentCSS.push(a + (t ? "/content.inline" : "/content") + ".min.css"), !a3(s) && Kt(a) ? Promise.all([
      gF(s, a),
      pF(s, a)
    ]).then(LD(s), mF(s, "Skin could not be loaded")) : LD(s)();
  }, jD = lt(VD, !1), uC = lt(VD, !0), h1 = (t, s) => (a) => {
    const l = Bf(), f = () => {
      a.setActive(t.formatter.match(s));
      const g = t.formatter.formatChanged(s, a.setActive);
      l.set(g);
    };
    return t.initialized ? f() : t.once("init", f), () => {
      t.off("init", f), l.clear();
    };
  }, _k = (t, s, a) => (l) => {
    const f = () => a(l), g = () => {
      a(l), t.on(s, f);
    };
    return t.initialized ? g() : t.once("init", g), () => {
      t.off("init", g), t.off(s, f);
    };
  }, dy = (t) => (s) => () => {
    t.undoManager.transact(() => {
      t.focus(), t.execCommand("mceToggleFormat", !1, s.format);
    });
  }, nu = (t, s) => () => t.execCommand(s), hF = (t, s, a) => {
    const l = (w, C, T, D) => {
      const $ = s.shared.providers.translate(w.title);
      if (w.type === "separator")
        return z.some({
          type: "separator",
          text: $
        });
      if (w.type === "submenu") {
        const I = je(w.getStyleItems(), (V) => f(V, C, D));
        return C === 0 && I.length <= 0 ? z.none() : z.some({
          type: "nestedmenuitem",
          text: $,
          enabled: I.length > 0,
          getSubmenuItems: () => je(w.getStyleItems(), (V) => f(V, C, D))
        });
      } else
        return z.some({
          type: "togglemenuitem",
          text: $,
          icon: w.icon,
          active: w.isSelected(D),
          enabled: !T,
          onAction: a.onAction(w),
          ...w.getStylePreview().fold(() => ({}), (I) => ({ meta: { style: I } }))
        });
    }, f = (w, C, T) => {
      const D = w.type === "formatter" && a.isInvalid(w);
      return C === 0 ? D ? [] : l(w, C, !1, T).toArray() : l(w, C, D, T).toArray();
    }, g = (w) => {
      const C = a.getCurrentValue(), T = a.shouldHide ? 0 : 1;
      return je(w, (D) => f(D, T, C));
    };
    return {
      validateItems: g,
      getFetch: (w, C) => (T, D) => {
        const $ = C(), I = g($), V = u1(I, jd.CLOSE_ON_EXECUTE, w, !1);
        D(V);
      }
    };
  }, y1 = (t, s, a) => {
    const l = a.dataset, f = l.type === "basic" ? () => Xe(l.data, (g) => gk(g, a.isSelectedFor, a.getPreviewFor)) : l.getData;
    return {
      items: hF(t, s, a),
      getStyleItems: f
    };
  }, Ck = (t, s, a) => {
    const { items: l, getStyleItems: f } = y1(t, s, a), g = (w) => ({ getComponent: oe(w) }), h = _k(t, "NodeChange", (w) => {
      const C = w.getComponent();
      a.updateText(C);
    });
    return I2({
      text: a.icon.isSome() ? z.none() : a.text,
      icon: a.icon,
      tooltip: z.from(a.tooltip),
      role: z.none(),
      fetch: l.getFetch(s, f),
      onSetup: h,
      getApi: g,
      columns: 1,
      presets: "normal",
      classes: a.icon.isSome() ? [] : ["bespoke"],
      dropdownBehaviours: []
    }, "tox-tbtn", s.shared);
  }, yF = (t) => Xe(t, (s) => {
    let a = s, l = s;
    const f = s.split("=");
    return f.length > 1 && (a = f[0], l = f[1]), {
      title: a,
      format: l
    };
  }), bF = (t) => ({
    type: "basic",
    data: t
  });
  var b1;
  (function(t) {
    t[t.SemiColon = 0] = "SemiColon", t[t.Space = 1] = "Space";
  })(b1 || (b1 = {}));
  const vF = (t, s) => s === b1.SemiColon ? t.replace(/;$/, "").split(";") : t.split(" "), dC = (t, s, a) => {
    const l = t.options.get(s), f = yF(vF(l, a));
    return {
      type: "basic",
      data: f
    };
  }, rE = [
    {
      title: "Left",
      icon: "align-left",
      format: "alignleft",
      command: "JustifyLeft"
    },
    {
      title: "Center",
      icon: "align-center",
      format: "aligncenter",
      command: "JustifyCenter"
    },
    {
      title: "Right",
      icon: "align-right",
      format: "alignright",
      command: "JustifyRight"
    },
    {
      title: "Justify",
      icon: "align-justify",
      format: "alignjustify",
      command: "JustifyFull"
    }
  ], UD = (t) => {
    const s = () => Oe(rE, (w) => t.formatter.match(w.format)), a = (w) => () => t.formatter.match(w), l = (w) => z.none, f = (w) => {
      const T = s().fold(oe("left"), (D) => D.title.toLowerCase());
      no(w, GT, { icon: `align-${T}` });
    }, g = bF(rE), h = (w) => () => Oe(rE, (C) => C.format === w.format).each((C) => t.execCommand(C.command));
    return {
      tooltip: "Align",
      text: z.none(),
      icon: z.some("align-left"),
      isSelectedFor: a,
      getCurrentValue: z.none,
      getPreviewFor: l,
      onAction: h,
      updateText: f,
      dataset: g,
      shouldHide: !1,
      isInvalid: (w) => !t.formatter.canApply(w.format)
    };
  }, WD = (t, s) => Ck(t, s, UD(t)), kF = (t, s) => {
    const a = y1(t, s, UD(t));
    t.ui.registry.addNestedMenuItem("align", {
      text: s.shared.providers.translate("Align"),
      getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
    });
  }, ZD = (t, s) => {
    const a = s(), l = Xe(a, (f) => f.format);
    return z.from(t.formatter.closest(l)).bind((f) => Oe(a, (g) => g.format === f)).orThunk(() => er(t.formatter.match("p"), {
      title: "Paragraph",
      format: "p"
    }));
  }, qD = (t) => {
    const s = "Paragraph", a = (h) => () => t.formatter.match(h), l = (h) => () => {
      const w = t.formatter.get(h);
      return z.some({
        tag: w.length > 0 && (w[0].inline || w[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(h))
      });
    }, f = (h) => {
      const C = ZD(t, () => g.data).fold(oe(s), (T) => T.title);
      no(h, Qm, { text: C });
    }, g = dC(t, "block_formats", b1.SemiColon);
    return {
      tooltip: "Blocks",
      text: z.some(s),
      icon: z.none(),
      isSelectedFor: a,
      getCurrentValue: z.none,
      getPreviewFor: l,
      onAction: dy(t),
      updateText: f,
      dataset: g,
      shouldHide: !1,
      isInvalid: (h) => !t.formatter.canApply(h.format)
    };
  }, wF = (t, s) => Ck(t, s, qD(t)), _F = (t, s) => {
    const a = y1(t, s, qD(t));
    t.ui.registry.addNestedMenuItem("blocks", {
      text: "Blocks",
      getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
    });
  }, CF = [
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Helvetica Neue",
    "sans-serif"
  ], aE = (t) => {
    const s = t.split(/\s*,\s*/);
    return Xe(s, (a) => a.replace(/^['"]+|['"]+$/g, ""));
  }, GD = (t) => {
    const s = () => {
      const a = aE(t.toLowerCase());
      return ke(CF, (l) => a.indexOf(l.toLowerCase()) > -1);
    };
    return t.indexOf("-apple-system") === 0 && s();
  }, cE = (t) => {
    const s = "System Font", a = () => {
      const T = (ne) => ne ? aE(ne)[0] : "", D = t.queryCommandValue("FontName"), $ = C.data, I = D ? D.toLowerCase() : "";
      return {
        matchOpt: Oe($, (ne) => {
          const pe = ne.format;
          return pe.toLowerCase() === I || T(pe).toLowerCase() === T(I).toLowerCase();
        }).orThunk(() => er(GD(I), {
          title: s,
          format: I
        })),
        font: D
      };
    }, l = (T) => (D) => D.exists(($) => $.format === T), f = () => {
      const { matchOpt: T } = a();
      return T;
    }, g = (T) => () => z.some({
      tag: "div",
      styles: T.indexOf("dings") === -1 ? { "font-family": T } : {}
    }), h = (T) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontName", !1, T.format);
      });
    }, w = (T) => {
      const { matchOpt: D, font: $ } = a(), I = D.fold(oe($), (V) => V.title);
      no(T, Qm, { text: I });
    }, C = dC(t, "font_family_formats", b1.SemiColon);
    return {
      tooltip: "Fonts",
      text: z.some(s),
      icon: z.none(),
      isSelectedFor: l,
      getCurrentValue: f,
      getPreviewFor: g,
      onAction: h,
      updateText: w,
      dataset: C,
      shouldHide: !1,
      isInvalid: Ot
    };
  }, SF = (t, s) => Ck(t, s, cE(t)), KD = (t, s) => {
    const a = y1(t, s, cE(t));
    t.ui.registry.addNestedMenuItem("fontfamily", {
      text: s.shared.providers.translate("Fonts"),
      getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
    });
  }, xF = {
    "8pt": "1",
    "10pt": "2",
    "12pt": "3",
    "14pt": "4",
    "18pt": "5",
    "24pt": "6",
    "36pt": "7"
  }, TF = {
    "xx-small": "7pt",
    "x-small": "8pt",
    small: "10pt",
    medium: "12pt",
    large: "14pt",
    "x-large": "18pt",
    "xx-large": "24pt"
  }, EF = (t, s) => {
    const a = Math.pow(10, s);
    return Math.round(t * a) / a;
  }, YD = (t, s) => /[0-9.]+px$/.test(t) ? EF(parseInt(t, 10) * 72 / 96, s || 0) + "pt" : ht(TF, t).getOr(t), AF = (t) => ht(xF, t).getOr(""), lE = (t) => {
    const s = () => {
      let C = z.none();
      const T = w.data, D = t.queryCommandValue("FontSize");
      if (D)
        for (let $ = 3; C.isNone() && $ >= 0; $--) {
          const I = YD(D, $), V = AF(I);
          C = Oe(T, (ne) => ne.format === D || ne.format === I || ne.format === V);
        }
      return {
        matchOpt: C,
        size: D
      };
    }, a = (C) => (T) => T.exists((D) => D.format === C), l = () => {
      const { matchOpt: C } = s();
      return C;
    }, f = oe(z.none), g = (C) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontSize", !1, C.format);
      });
    }, h = (C) => {
      const { matchOpt: T, size: D } = s(), $ = T.fold(oe(D), (I) => I.title);
      no(C, Qm, { text: $ });
    }, w = dC(t, "font_size_formats", b1.Space);
    return {
      tooltip: "Font sizes",
      text: z.some("12pt"),
      icon: z.none(),
      isSelectedFor: a,
      getPreviewFor: f,
      getCurrentValue: l,
      onAction: g,
      updateText: h,
      dataset: w,
      shouldHide: !1,
      isInvalid: Ot
    };
  }, zF = (t, s) => Ck(t, s, lE(t)), OF = (t, s) => {
    const a = y1(t, s, lE(t));
    t.ui.registry.addNestedMenuItem("fontsize", {
      text: "Font sizes",
      getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
    });
  }, XD = (t, s) => {
    const a = "Paragraph", l = (h) => () => t.formatter.match(h), f = (h) => () => {
      const w = t.formatter.get(h);
      return w !== void 0 ? z.some({
        tag: w.length > 0 && (w[0].inline || w[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(h))
      }) : z.none();
    }, g = (h) => {
      const w = ($) => {
        const I = $.items;
        return I !== void 0 && I.length > 0 ? je(I, w) : [{
          title: $.title,
          format: $.format
        }];
      }, C = je(mk(t), w), D = ZD(t, oe(C)).fold(oe(a), ($) => $.title);
      no(h, Qm, { text: D });
    };
    return {
      tooltip: "Formats",
      text: z.some(a),
      icon: z.none(),
      isSelectedFor: l,
      getCurrentValue: z.none,
      getPreviewFor: f,
      onAction: dy(t),
      updateText: g,
      shouldHide: X5(t),
      isInvalid: (h) => !t.formatter.canApply(h.format),
      dataset: s
    };
  }, DF = (t, s) => {
    const a = {
      type: "advanced",
      ...s.styles
    };
    return Ck(t, s, XD(t, a));
  }, RF = (t, s) => {
    const a = {
      type: "advanced",
      ...s.styles
    }, l = y1(t, s, XD(t, a));
    t.ui.registry.addNestedMenuItem("styles", {
      text: "Formats",
      getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
    });
  };
  var NF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, s) => {
      const a = (l, f) => {
        t.updateState.each((g) => {
          const h = g(l, f);
          s.set(h);
        }), t.renderComponents.each((g) => {
          const h = g(f, s.get());
          (t.reuseDom ? P_ : x5)(l, h);
        });
      };
      return Ls([
        dt(_m(), (l, f) => {
          const g = f;
          if (!g.universal) {
            const h = t.channel;
            Fn(g.channels, h) && a(l, g.data);
          }
        }),
        kr((l, f) => {
          t.initialData.each((g) => {
            a(l, g);
          });
        })
      ]);
    }
  }), BF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getState: (t, s, a) => a
  }), $F = [
    ut("channel"),
    xs("renderComponents"),
    xs("updateState"),
    xs("initialData"),
    Oc("reuseDom", !0)
  ], PF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Xn(z.none()), s = () => t.set(z.none());
      return {
        readState: () => t.get().getOr("none"),
        get: t.get,
        set: t.set,
        clear: s
      };
    }
  });
  const Ri = Ha({
    fields: $F,
    name: "reflecting",
    active: NF,
    apis: BF,
    state: PF
  }), JD = oe([
    ut("toggleClass"),
    ut("fetch"),
    Ng("onExecute"),
    Te("getHotspot", z.some),
    Te("getAnchorOverrides", oe({})),
    ed(),
    Ng("onItemExecute"),
    xs("lazySink"),
    ut("dom"),
    Es("onOpen"),
    Oa("splitDropdownBehaviours", [
      Hr,
      Kn,
      go
    ]),
    Te("matchWidth", !1),
    Te("useMinWidth", !1),
    Te("eventOrder", {}),
    xs("role")
  ].concat(gT())), FF = Cc({
    factory: $l,
    schema: [ut("dom")],
    name: "arrow",
    defaults: () => ({ buttonBehaviours: qt([go.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (s) => {
        s.getSystem().getByUid(t.uid).each(Zu);
      },
      buttonBehaviours: qt([Qo.config({
        toggleOnExecute: !1,
        toggleClass: t.toggleClass
      })])
    })
  }), IF = Cc({
    factory: $l,
    schema: [ut("dom")],
    name: "button",
    defaults: () => ({ buttonBehaviours: qt([go.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (s) => {
        s.getSystem().getByUid(t.uid).each((a) => {
          t.onExecute(a, s);
        });
      }
    })
  }), QD = oe([
    FF,
    IF,
    vu({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [ut("text")],
      name: "aria-descriptor"
    }),
    Ki({
      schema: [Mg()],
      name: "menu",
      defaults: (t) => ({
        onExecute: (s, a) => {
          s.getSystem().getByUid(t.uid).each((l) => {
            t.onItemExecute(l, s, a);
          });
        }
      })
    }),
    Uz()
  ]), LF = (t, s, a, l) => {
    const f = (D) => {
      cs.getCurrent(D).each(($) => {
        Hs.highlightFirst($), Kn.focusIn($);
      });
    }, g = (D) => {
      sy(t, Je, D, l, f, Gd.HighlightFirst).get(ie);
    }, h = (D) => (g(D), z.some(!0)), w = (D) => {
      const $ = Ti(D, t, "button");
      return Zu($), z.some(!0);
    }, C = {
      ...Ls([kr((D, $) => {
        Ds(D, t, "aria-descriptor").each((V) => {
          const ne = $n("aria");
          to(V.element, "id", ne), to(D.element, "aria-describedby", ne);
        });
      })]),
      ...I_(z.some(g))
    }, T = {
      repositionMenus: (D) => {
        Qo.isOn(D) && Kz(D);
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      apis: T,
      eventOrder: {
        ...t.eventOrder,
        [Kl()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      events: C,
      behaviours: Ua(t.splitDropdownBehaviours, [
        Hr.config({
          others: {
            sandbox: (D) => {
              const $ = Ti(D, t, "arrow");
              return mT(t, D, {
                onOpen: () => {
                  Qo.on($), Qo.on(D);
                },
                onClose: () => {
                  Qo.off($), Qo.off(D);
                }
              });
            }
          }
        }),
        Kn.config({
          mode: "special",
          onSpace: w,
          onEnter: w,
          onDown: h
        }),
        go.config({}),
        Qo.config({
          toggleOnExecute: !1,
          aria: { mode: "expanded" }
        })
      ]),
      domModification: {
        attributes: {
          role: t.role.getOr("button"),
          "aria-haspopup": !0
        }
      }
    };
  }, Sk = Jc({
    name: "SplitDropdown",
    configFields: JD(),
    partFields: QD(),
    factory: LF,
    apis: { repositionMenus: (t, s) => t.repositionMenus(s) }
  }), e8 = (t) => ({
    isEnabled: () => !ao.isDisabled(t),
    setEnabled: (s) => ao.set(t, !s)
  }), HF = (t) => ({
    setActive: (s) => {
      Qo.set(t, s);
    },
    isActive: () => Qo.isOn(t),
    isEnabled: () => !ao.isDisabled(t),
    setEnabled: (s) => ao.set(t, !s)
  }), t8 = (t, s) => t.map((a) => ({
    "aria-label": s.translate(a),
    title: s.translate(a)
  })).getOr({}), n8 = $n("focus-button"), fy = (t, s, a, l, f, g) => ({
    dom: {
      tag: "button",
      classes: ["tox-tbtn"].concat(s.isSome() ? ["tox-tbtn--select"] : []),
      attributes: t8(a, g)
    },
    components: Vv([
      t.map((h) => rk(h, g.icons)),
      s.map((h) => F2(h, "tox-tbtn", g))
    ]),
    eventOrder: {
      [ql()]: [
        "focusing",
        "alloy.base.behaviour",
        "common-button-display-events"
      ]
    },
    buttonBehaviours: qt([
      rd.toolbarButton(g.isDisabled),
      ma(),
      ys("common-button-display-events", [dt(ql(), (h, w) => {
        w.event.prevent(), Ts(h, n8);
      })])
    ].concat(l.map((h) => Ri.config({
      channel: h,
      initialData: {
        icon: t,
        text: s
      },
      renderComponents: (w, C) => Vv([
        w.icon.map((T) => rk(T, g.icons)),
        w.text.map((T) => F2(T, "tox-tbtn", g))
      ])
    })).toArray()).concat(f.getOr([])))
  }), VF = (t, s, a, l) => {
    const f = s.shared;
    return uy.sketch({
      lazySink: f.getSink,
      fetch: () => Bc.nu((g) => {
        g(Xe(a(t.items), cC));
      }),
      markers: { toggledClass: "tox-tbtn--enabled" },
      parts: {
        button: fy(t.icon, t.text, t.tooltip, z.none(), z.none(), f.providers),
        toolbar: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: l
          }
        }
      }
    });
  }, o8 = (t, s, a) => {
    const l = Xn(ie), f = fy(t.icon, t.text, t.tooltip, z.none(), z.none(), a);
    return $l.sketch({
      dom: f.dom,
      components: f.components,
      eventOrder: $2,
      buttonBehaviours: qt([
        ys("toolbar-button-events", [
          Jm({
            onAction: t.onAction,
            getApi: s.getApi
          }),
          Lv(s, l),
          Hv(s, l)
        ]),
        rd.toolbarButton(() => !t.enabled || a.isDisabled()),
        ma()
      ].concat(s.toolbarButtonBehaviours))
    });
  }, jF = (t, s) => s8(t, s, []), s8 = (t, s, a) => o8(t, {
    toolbarButtonBehaviours: [].concat(a.length > 0 ? [ys("toolbarButtonWith", a)] : []),
    getApi: e8,
    onSetup: t.onSetup
  }, s), UF = (t, s) => r8(t, s, []), r8 = (t, s, a) => sr(o8(t, {
    toolbarButtonBehaviours: [
      Uo.config({}),
      Qo.config({
        toggleClass: "tox-tbtn--enabled",
        aria: { mode: "pressed" },
        toggleOnExecute: !1
      })
    ].concat(a.length > 0 ? [ys("toolbarToggleButtonWith", a)] : []),
    getApi: HF,
    onSetup: t.onSetup
  }, s)), WF = (t, s, a) => (l) => Bc.nu((f) => s.fetch(f)).map((f) => z.from(oT(sr(K3($n("menu-value"), f, (g) => {
    s.onItemAction(t(l), g);
  }, s.columns, s.presets, jd.CLOSE_ON_EXECUTE, s.select.getOr(Ot), a), {
    movement: m2(s.columns, s.presets),
    menuBehaviours: qd.unnamedEvents(s.columns !== "auto" ? [] : [kr((g, h) => {
      Jh(g, 4, X_(s.presets)).each(({ numRows: w, numColumns: C }) => {
        Kn.setGridSize(g, w, C);
      });
    })])
  })))), ZF = (t, s) => {
    const a = $n("channel-update-split-dropdown-display"), l = (h) => ({
      isEnabled: () => !ao.isDisabled(h),
      setEnabled: (w) => ao.set(h, !w),
      setIconFill: (w, C) => {
        sc(h.element, 'svg path[id="' + w + '"], rect[id="' + w + '"]').each((T) => {
          to(T, "fill", C);
        });
      },
      setActive: (w) => {
        to(h.element, "aria-pressed", w), sc(h.element, "span").each((C) => {
          h.getSystem().getByDom(C).each((T) => Qo.set(T, w));
        });
      },
      isActive: () => sc(h.element, "span").exists((w) => h.getSystem().getByDom(w).exists(Qo.isOn))
    }), f = Xn(ie), g = {
      getApi: l,
      onSetup: t.onSetup
    };
    return Sk.sketch({
      dom: {
        tag: "div",
        classes: ["tox-split-button"],
        attributes: {
          "aria-pressed": !1,
          ...t8(t.tooltip, s.providers)
        }
      },
      onExecute: (h) => {
        t.onAction(l(h));
      },
      onItemExecute: (h, w, C) => {
      },
      splitDropdownBehaviours: qt([
        rd.splitButton(s.providers.isDisabled),
        ma(),
        ys("split-dropdown-events", [
          dt(n8, go.focus),
          Lv(g, f),
          Hv(g, f)
        ]),
        Kd.config({})
      ]),
      eventOrder: {
        [Wu()]: [
          "alloy.base.behaviour",
          "split-dropdown-events"
        ]
      },
      toggleClass: "tox-tbtn--enabled",
      lazySink: s.getSink,
      fetch: WF(l, t, s.providers),
      parts: { menu: J_(!1, t.columns, t.presets) },
      components: [
        Sk.parts.button(fy(t.icon, t.text, z.none(), z.some(a), z.some([Qo.config({
          toggleClass: "tox-tbtn--enabled",
          toggleOnExecute: !1
        })]), s.providers)),
        Sk.parts.arrow({
          dom: {
            tag: "button",
            classes: [
              "tox-tbtn",
              "tox-split-button__chevron"
            ],
            innerHtml: Yx("chevron-down", s.providers.icons)
          },
          buttonBehaviours: qt([
            rd.splitButton(s.providers.isDisabled),
            ma(),
            Yb()
          ])
        }),
        Sk.parts["aria-descriptor"]({ text: s.providers.translate("To open the popup, press Shift+Enter") })
      ]
    });
  }, iE = [
    {
      name: "history",
      items: [
        "undo",
        "redo"
      ]
    },
    {
      name: "styles",
      items: ["styles"]
    },
    {
      name: "formatting",
      items: [
        "bold",
        "italic"
      ]
    },
    {
      name: "alignment",
      items: [
        "alignleft",
        "aligncenter",
        "alignright",
        "alignjustify"
      ]
    },
    {
      name: "indentation",
      items: [
        "outdent",
        "indent"
      ]
    },
    {
      name: "permanent pen",
      items: ["permanentpen"]
    },
    {
      name: "comments",
      items: ["addcomment"]
    }
  ], xk = (t, s) => (a, l, f) => {
    const g = t(a).mapError((h) => wd(h)).getOrDie();
    return s(g, l, f);
  }, v1 = {
    button: xk(MA, (t, s) => jF(t, s.backstage.shared.providers)),
    togglebutton: xk(x3, (t, s) => UF(t, s.backstage.shared.providers)),
    menubutton: xk(fD, (t, s) => n4(t, "tox-tbtn", s.backstage, z.none())),
    splitbutton: xk(_P, (t, s) => ZF(t, s.backstage.shared)),
    grouptoolbarbutton: xk(bP, (t, s, a) => {
      const l = a.ui.registry.getAll().buttons, f = (h) => fC(a, {
        buttons: l,
        toolbar: h,
        allowToolbarGroups: !1
      }, s, z.none()), g = { [db]: s.backstage.shared.header.isPositionedAtTop() ? Qu.TopToBottom : Qu.BottomToTop };
      switch (Xb(a)) {
        case hl.floating:
          return VF(t, s.backstage, f, g);
        default:
          throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      }
    }),
    styleSelectButton: (t, s) => DF(t, s.backstage),
    fontsizeSelectButton: (t, s) => zF(t, s.backstage),
    fontSelectButton: (t, s) => SF(t, s.backstage),
    formatButton: (t, s) => wF(t, s.backstage),
    alignMenuButton: (t, s) => WD(t, s.backstage)
  }, qF = (t, s, a) => ht(v1, t.type).fold(() => (console.error("skipping button defined by", t), z.none()), (l) => z.some(l(t, s, a))), uE = {
    styles: v1.styleSelectButton,
    fontsize: v1.fontsizeSelectButton,
    fontfamily: v1.fontSelectButton,
    blocks: v1.formatButton,
    align: v1.alignMenuButton
  }, GF = (t) => {
    const s = Xe(iE, (a) => {
      const l = Pt(a.items, (f) => qn(t, f) || qn(uE, f));
      return {
        name: a.name,
        items: l
      };
    });
    return Pt(s, (a) => a.items.length > 0);
  }, KF = (t) => {
    const s = t.split("|");
    return Xe(s, (a) => ({ items: a.trim().split(" ") }));
  }, YF = (t) => Ue(t, (s) => qn(s, "name") && qn(s, "items")), XF = (t) => {
    const s = t.toolbar, a = t.buttons;
    return s === !1 ? [] : s === void 0 || s === !0 ? GF(a) : Kt(s) ? KF(s) : YF(s) ? s : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
  }, JF = (t, s, a, l, f, g) => ht(s, a.toLowerCase()).orThunk(() => g.bind((h) => Ho(h, (w) => ht(s, w + a.toLowerCase())))).fold(() => ht(uE, a.toLowerCase()).map((h) => h(t, f)).orThunk(() => z.none()), (h) => h.type === "grouptoolbarbutton" && !l ? (console.warn(`Ignoring the '${a}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), z.none()) : qF(h, f, t)), fC = (t, s, a, l) => {
    const f = XF(s), g = Xe(f, (h) => {
      const w = je(h.items, (C) => C.trim().length === 0 ? [] : JF(t, s.buttons, C, s.allowToolbarGroups, a, l).toArray());
      return {
        title: z.from(t.translate(h.name)),
        items: w
      };
    });
    return Pt(g, (h) => h.items.length > 0);
  }, mC = (t, s, a, l) => {
    const f = s.outerContainer, g = a.toolbar, h = a.buttons;
    if (Ue(g, Kt)) {
      const w = g.map((C) => {
        const T = {
          toolbar: C,
          buttons: h,
          allowToolbarGroups: a.allowToolbarGroups
        };
        return fC(t, T, { backstage: l }, z.none());
      });
      Xr.setToolbars(f, w);
    } else
      Xr.setToolbar(f, fC(t, a, { backstage: l }, z.none()));
  }, a8 = Ul(), QF = a8.os.isiOS() && a8.os.version.major <= 12, e9 = (t, s) => {
    const a = t.dom;
    let l = t.getWin();
    const f = t.getDoc().documentElement, g = Xn(as(l.innerWidth, l.innerHeight)), h = Xn(as(f.offsetWidth, f.offsetHeight)), w = () => {
      const I = g.get();
      (I.left !== l.innerWidth || I.top !== l.innerHeight) && (g.set(as(l.innerWidth, l.innerHeight)), u2(t));
    }, C = () => {
      const I = t.getDoc().documentElement, V = h.get();
      (V.left !== I.offsetWidth || V.top !== I.offsetHeight) && (h.set(as(I.offsetWidth, I.offsetHeight)), u2(t));
    }, T = (I) => L3(t, I);
    a.bind(l, "resize", w), a.bind(l, "scroll", T);
    const D = Dw(bt.fromDom(t.getBody()), "load", C), $ = s.uiMothership.element;
    t.on("hide", () => {
      Qt($, "display", "none");
    }), t.on("show", () => {
      Dt($, "display");
    }), t.on("NodeChange", C), t.on("remove", () => {
      D.unbind(), a.unbind(l, "resize", w), a.unbind(l, "scroll", T), l = null;
    });
  };
  var t9 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, s, a, l, f) => {
      const g = Xn(0), h = s.outerContainer;
      jD(t);
      const w = bt.fromDom(f.targetNode), C = U(or(w));
      US(w, s.mothership), ep(C, s.uiMothership), t.on("PostRender", () => {
        Xr.setSidebar(h, a.sidebar, mA(t)), mC(t, s, a, l), g.set(t.getWin().innerWidth), Xr.setMenubar(h, ID(t, a)), e9(t, s);
      });
      const T = Xr.getSocket(h).getOrDie("Could not find expected socket element");
      if (QF) {
        Zr(T.element, {
          overflow: "scroll",
          "-webkit-overflow-scrolling": "touch"
        });
        const V = eO(() => {
          t.dispatch("ScrollContent");
        }, 20), ne = Va(T.element, "scroll", V.throttle);
        t.on("remove", ne.unbind);
      }
      O3(t, s), t.addCommand("ToggleSidebar", (V, ne) => {
        Xr.toggleSidebar(h, ne), t.dispatch("ToggleSidebar");
      }), t.addQueryValueHandler("ToggleSidebar", () => Xr.whichSidebar(h));
      const D = Xb(t), $ = () => {
        Xr.refreshToolbar(s.outerContainer);
      };
      (D === hl.sliding || D === hl.floating) && t.on("ResizeWindow ResizeEditor ResizeContent", () => {
        const V = t.getWin().innerWidth;
        V !== g.get() && ($(), g.set(V));
      });
      const I = {
        setEnabled: (V) => {
          Iv(s, !V);
        },
        isEnabled: () => !ao.isDisabled(h)
      };
      return {
        iframeContainer: T.element.dom,
        editorContainer: h.element.dom,
        api: I
      };
    }
  });
  const dE = (t) => /^[0-9\.]+(|px)$/i.test("" + t) ? z.some(parseInt("" + t, 10)) : z.none(), fE = (t) => He(t) ? t + "px" : t, Tk = (t, s, a) => {
    const l = s.filter((g) => t < g), f = a.filter((g) => t > g);
    return l.or(f).getOr(t);
  }, n9 = (t) => {
    const s = _v(t), a = n3(t), l = o3(t);
    return dE(s).map((f) => Tk(f, a, l));
  }, o9 = (t) => n9(t).getOr(_v(t)), c8 = (t) => {
    const s = t3(t), a = H_(t), l = bp(t);
    return dE(s).map((f) => Tk(f, a, l));
  }, s9 = (t) => c8(t).getOr(t3(t)), { ToolbarLocation: mE, ToolbarMode: l8 } = xR, r9 = (t, s, a, l, f) => {
    const { uiMothership: g, outerContainer: h } = a, w = kv.DOM, C = Sv(t), T = xv(t), D = bp(t).or(c8(t)), $ = l.shared.header, I = $.isPositionedAtTop, V = Xb(t), ne = V === l8.sliding || V === l8.floating, pe = Xn(!1), Le = () => pe.get() && !t.removed, he = (Ms) => ne ? Ms.fold(oe(0), (jn) => jn.components().length > 1 ? hs(jn.components()[1].element) : 0) : 0, at = (Ms) => {
      switch (s3(t)) {
        case mE.auto:
          const jn = Xr.getToolbar(h), zs = he(jn), io = hs(Ms.element) - zs, Mt = Or(s);
          if (Mt.y > io)
            return "top";
          {
            const wo = nl(s), ts = Math.max(wo.dom.scrollHeight, hs(wo));
            return Mt.bottom < ts - io || ui().bottom < Mt.bottom - io ? "bottom" : "top";
          }
        case mE.bottom:
          return "bottom";
        case mE.top:
        default:
          return "top";
      }
    }, kn = (Ms) => {
      const jn = f.get();
      Pc.setModes(jn, [Ms]), $.setDockingMode(Ms);
      const zs = I() ? Qu.TopToBottom : Qu.BottomToTop;
      to(jn.element, db, zs);
    }, et = () => {
      const Ms = D.getOrThunk(() => {
        const jn = dE(qr(js(), "margin-left")).getOr(0);
        return Wo(js()) - Me(s).left + jn;
      });
      Qt(f.get().element, "max-width", Ms + "px");
    }, hn = () => {
      const Ms = Xr.getToolbar(h), jn = he(Ms), zs = Or(s), io = I() ? Math.max(zs.y - hs(f.get().element) + jn, 0) : zs.bottom;
      Zr(h.element, {
        position: "absolute",
        top: Math.round(io) + "px",
        left: Math.round(zs.x) + "px"
      });
    }, xn = () => {
      g.broadcastOn([Id()], {});
    }, Cn = (Ms = !1) => {
      if (!!Le()) {
        if (C || et(), ne && Xr.refreshToolbar(h), C || hn(), T) {
          const jn = f.get();
          Ms ? Pc.reset(jn) : Pc.refresh(jn);
        }
        xn();
      }
    }, oo = (Ms = !0) => {
      if (C || !T || !Le())
        return;
      const jn = $.getDockingMode(), zs = at(f.get());
      zs !== jn && (kn(zs), Ms && Cn(!0));
    };
    return {
      isVisible: Le,
      isPositionedAtTop: I,
      show: () => {
        pe.set(!0), Qt(h.element, "display", "flex"), w.addClass(t.getBody(), "mce-edit-focus"), Dt(g.element, "display"), oo(!1), Cn();
      },
      hide: () => {
        pe.set(!1), a.outerContainer && (Qt(h.element, "display", "none"), w.removeClass(t.getBody(), "mce-edit-focus")), Qt(g.element, "display", "none");
      },
      update: Cn,
      updateMode: oo,
      repositionPopups: xn
    };
  }, gE = (t, s) => {
    const a = Or(t);
    return {
      pos: s ? a.y : a.bottom,
      bounds: a
    };
  }, a9 = (t, s, a, l) => {
    const f = Xn(gE(s, a.isPositionedAtTop())), g = (w) => {
      const { pos: C, bounds: T } = gE(s, a.isPositionedAtTop()), {
        pos: D,
        bounds: $
      } = f.get(), I = T.height !== $.height || T.width !== $.width;
      f.set({
        pos: C,
        bounds: T
      }), I && u2(t, w), a.isVisible() && (D !== C ? a.update(!0) : I && (a.updateMode(), a.repositionPopups()));
    };
    l || (t.on("activate", a.show), t.on("deactivate", a.hide)), t.on("SkinLoaded ResizeWindow", () => a.update(!0)), t.on("NodeChange keydown", (w) => {
      requestAnimationFrame(() => g(w));
    }), t.on("ScrollWindow", () => a.updateMode());
    const h = Bf();
    h.set(Dw(bt.fromDom(t.getBody()), "load", g)), t.on("remove", () => {
      h.clear();
    });
  };
  var c9 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, s, a, l, f) => {
      const { mothership: g, uiMothership: h, outerContainer: w } = s, C = Xn(null), T = bt.fromDom(f.targetNode), D = r9(t, T, s, l, C), $ = eA(t);
      uC(t);
      const I = () => {
        if (C.get()) {
          D.show();
          return;
        }
        C.set(Xr.getHeader(w).getOrDie());
        const ne = i3(t);
        ep(ne, g), ep(ne, h), mC(t, s, a, l), Xr.setMenubar(w, ID(t, a)), D.show(), a9(t, T, D, $), t.nodeChanged();
      };
      t.on("show", I), t.on("hide", D.hide), $ || (t.on("focus", I), t.on("blur", D.hide)), t.on("init", () => {
        (t.hasFocus() || $) && I();
      }), O3(t, s);
      const V = {
        show: () => {
          I();
        },
        hide: () => {
          D.hide();
        },
        setEnabled: (ne) => {
          Iv(s, !ne);
        },
        isEnabled: () => !ao.isDisabled(w)
      };
      return {
        editorContainer: w.element.dom,
        api: V
      };
    }
  });
  const l9 = "contexttoolbar-show", i8 = "contexttoolbar-hide", k1 = (t) => ({
    hide: () => Ts(t, zy()),
    getValue: () => cn.getValue(t)
  }), gC = (t, s) => dt(B2, (a, l) => {
    const f = t.get(a), g = k1(f);
    s.onAction(g, l.event.buttonApi);
  }), i9 = (t, s, a) => {
    const { primary: l, ...f } = s.original, g = gi(MA({
      ...f,
      type: "button",
      onAction: ie
    }));
    return s8(g, a.backstage.shared.providers, [gC(t, s)]);
  }, u8 = (t, s, a) => {
    const { primary: l, ...f } = s.original, g = gi(x3({
      ...f,
      type: "togglebutton",
      onAction: ie
    }));
    return r8(g, a.backstage.shared.providers, [gC(t, s)]);
  }, pE = (t, s, a) => {
    const l = { backstage: { shared: { providers: a } } };
    return s.type === "contextformtogglebutton" ? u8(t, s, l) : i9(t, s, l);
  }, d8 = (t, s, a) => {
    const l = Xe(s, (h) => wr(pE(t, h, a)));
    return {
      asSpecs: () => Xe(l, (h) => h.asSpec()),
      findPrimary: (h) => Ho(s, (w, C) => w.primary ? z.from(l[C]).bind((T) => T.getOpt(h)).filter(Q(ao.isDisabled)) : z.none())
    };
  }, hE = (t, s) => {
    const a = t.label.fold(() => ({}), (g) => ({ "aria-label": g })), l = wr(Kv.sketch({
      inputClasses: [
        "tox-toolbar-textfield",
        "tox-toolbar-nav-js"
      ],
      data: t.initValue(),
      inputAttributes: a,
      selectOnFocus: !0,
      inputBehaviours: qt([Kn.config({
        mode: "special",
        onEnter: (g) => f.findPrimary(g).map((h) => (Zu(h), !0)),
        onLeft: (g, h) => (h.cut(), z.none()),
        onRight: (g, h) => (h.cut(), z.none())
      })])
    })), f = d8(l, t.commands, s);
    return [
      {
        title: z.none(),
        items: [l.asSpec()]
      },
      {
        title: z.none(),
        items: f.asSpecs()
      }
    ];
  }, w1 = {
    renderContextForm: (t, s, a) => wk({
      type: t,
      uid: $n("context-toolbar"),
      initGroups: hE(s, a),
      onEscape: z.none,
      cyclicKeying: !0,
      providers: a
    }),
    buildInitGroups: hE
  }, Ek = (t, s, a = 0.01) => s.bottom - t.y >= a && t.bottom - s.y >= a, yE = (t) => {
    const s = t.getBoundingClientRect();
    if (s.height <= 0 && s.width <= 0) {
      const a = li(bt.fromDom(t.startContainer), t.startOffset).element;
      return (On(a) ? Wr(a) : z.some(a)).filter(Yt).map((f) => f.dom.getBoundingClientRect()).getOr(s);
    } else
      return s;
  }, pC = (t) => {
    const s = t.selection.getRng(), a = yE(s);
    if (t.inline) {
      const l = al();
      return ws(l.left + a.left, l.top + a.top, a.width, a.height);
    } else {
      const l = Gr(bt.fromDom(t.getBody()));
      return ws(l.x + a.left, l.y + a.top, a.width, a.height);
    }
  }, u9 = (t, s) => s.filter(Ko).map(Gr).getOrThunk(() => pC(t)), d9 = (t, s, a) => {
    const l = Math.max(t.x + a, s.x), f = Math.min(t.right - a, s.right);
    return {
      x: l,
      width: f - l
    };
  }, f9 = (t, s, a, l, f, g) => {
    const h = bt.fromDom(t.getContainer()), w = sc(h, ".tox-editor-header").getOr(h), C = Or(w), T = C.y >= s.bottom, D = l && !T;
    if (t.inline && D)
      return {
        y: Math.max(C.bottom + g, a.y),
        bottom: a.bottom
      };
    if (t.inline && !D)
      return {
        y: a.y,
        bottom: Math.min(C.y - g, a.bottom)
      };
    const $ = f === "line" ? Or(h) : s;
    return D ? {
      y: Math.max(C.bottom + g, a.y),
      bottom: Math.min($.bottom - g, a.bottom)
    } : {
      y: Math.max($.y + g, a.y),
      bottom: Math.min(C.y - g, a.bottom)
    };
  }, f8 = (t, s, a, l = 0) => {
    const f = E(window), g = Or(bt.fromDom(t.getContentAreaContainer())), h = Jb(t) || q_(t) || Cv(t), { x: w, width: C } = d9(g, f, l);
    if (t.inline && !h)
      return ws(w, f.y, C, f.height);
    {
      const T = s.header.isPositionedAtTop(), { y: D, bottom: $ } = f9(t, g, f, T, a, l);
      return ws(w, D, C, $ - D);
    }
  }, Ak = 12, zk = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"],
    inset: ["tox-pop--inset"]
  }, bE = {
    maxHeightFunction: Lg(),
    maxWidthFunction: Y4()
  }, m8 = (t, s) => {
    const a = t.selection.getRng(), l = li(bt.fromDom(a.startContainer), a.startOffset);
    return a.startContainer === a.endContainer && a.startOffset === a.endOffset - 1 && Lo(l.element, s);
  }, vE = (t, s, a) => {
    const l = j(t, "position");
    Qt(t, "position", s);
    const f = a(t);
    return l.each((g) => Qt(t, "position", g)), f;
  }, g8 = (t) => t === "node", p8 = (t, s, a, l, f) => {
    const g = pC(t), h = l.lastElement().exists((w) => Lo(a, w));
    if (m8(t, a))
      return h ? SO : Gf;
    if (h)
      return vE(s, l.getMode(), () => Ek(g, Or(s)) && !l.isReposition() ? xO : SO);
    {
      const w = l.getMode() === "fixed" ? f.y + al().top : f.y, C = hs(s) + Ak;
      return w + C <= g.y ? Gf : fk;
    }
  }, m9 = (t, s, a, l) => {
    const f = (C) => (T, D, $, I, V) => {
      const ne = p8(t, I, C, a, V), pe = {
        ...T,
        y: V.y,
        height: V.height
      };
      return {
        ...ne(pe, D, $, I, V),
        alwaysFit: !0
      };
    }, g = (C) => g8(l) ? [f(C)] : [];
    return s ? {
      onLtr: (C) => [
        ua,
        vc,
        kc,
        Kc,
        wc,
        Ir
      ].concat(g(C)),
      onRtl: (C) => [
        ua,
        kc,
        vc,
        wc,
        Kc,
        Ir
      ].concat(g(C))
    } : {
      onLtr: (C) => [
        Ir,
        ua,
        Kc,
        vc,
        wc,
        kc
      ].concat(g(C)),
      onRtl: (C) => [
        Ir,
        ua,
        wc,
        kc,
        Kc,
        vc
      ].concat(g(C))
    };
  }, g9 = (t, s, a, l) => s === "line" ? {
    bubble: Hg(Ak, 0, zk),
    layouts: {
      onLtr: () => [e0],
      onRtl: () => [t0]
    },
    overrides: bE
  } : {
    bubble: Hg(0, Ak, zk, 1 / Ak),
    layouts: m9(t, a, l, s),
    overrides: bE
  }, hC = (t, s) => {
    const a = Pt(s, (g) => g.predicate(t.dom)), { pass: l, fail: f } = en(a, (g) => g.type === "contexttoolbar");
    return {
      contextToolbars: l,
      contextForms: f
    };
  }, h8 = (t) => {
    if (t.length <= 1)
      return t;
    {
      const s = (g) => Sn(t, (h) => h.position === g), a = (g) => Pt(t, (h) => h.position === g), l = s("selection"), f = s("node");
      if (l || f)
        if (f && l) {
          const g = a("node"), h = Xe(a("selection"), (w) => ({
            ...w,
            position: "node"
          }));
          return g.concat(h);
        } else
          return a(l ? "selection" : "node");
      else
        return a("line");
    }
  }, p9 = (t) => {
    if (t.length <= 1)
      return t;
    {
      const s = (l) => Oe(t, (f) => f.position === l);
      return s("selection").orThunk(() => s("node")).orThunk(() => s("line")).map((l) => l.position).fold(() => [], (l) => Pt(t, (f) => f.position === l));
    }
  }, h9 = (t, s, a) => {
    const l = hC(t, s);
    if (l.contextForms.length > 0)
      return z.some({
        elem: t,
        toolbars: [l.contextForms[0]]
      });
    {
      const f = hC(t, a);
      if (f.contextForms.length > 0)
        return z.some({
          elem: t,
          toolbars: [f.contextForms[0]]
        });
      if (l.contextToolbars.length > 0 || f.contextToolbars.length > 0) {
        const g = h8(l.contextToolbars.concat(f.contextToolbars));
        return z.some({
          elem: t,
          toolbars: g
        });
      } else
        return z.none();
    }
  }, y9 = (t, s, a) => t(s) ? z.none() : Rr(s, (l) => {
    if (Yt(l)) {
      const { contextToolbars: f, contextForms: g } = hC(l, a.inNodeScope), h = g.length > 0 ? g : p9(f);
      return h.length > 0 ? z.some({
        elem: l,
        toolbars: h
      }) : z.none();
    } else
      return z.none();
  }, t), y8 = (t, s) => {
    const a = bt.fromDom(s.getBody()), l = (h) => Lo(h, a), f = (h) => !l(h) && !br(a, h), g = bt.fromDom(s.selection.getNode());
    return f(g) ? z.none() : h9(g, t.inNodeScope, t.inEditorScope).orThunk(() => y9(l, g, t));
  }, b8 = (t, s) => {
    const a = {}, l = [], f = [], g = {}, h = {}, w = (D, $) => {
      const I = gi(UR($));
      a[D] = I, I.launch.map((V) => {
        g["form:" + D] = {
          ...$.launch,
          type: V.type === "contextformtogglebutton" ? "togglebutton" : "button",
          onAction: () => {
            s(I);
          }
        };
      }), I.scope === "editor" ? f.push(I) : l.push(I), h[D] = I;
    }, C = (D, $) => {
      Xh($).each((I) => {
        $.scope === "editor" ? f.push(I) : l.push(I), h[D] = I;
      });
    }, T = mn(t);
    return O(T, (D) => {
      const $ = t[D];
      $.type === "contextform" ? w(D, $) : $.type === "contexttoolbar" && C(D, $);
    }), {
      forms: a,
      inNodeScope: l,
      inEditorScope: f,
      lookupTable: h,
      formNavigators: g
    };
  }, v8 = $n("forward-slide"), k8 = $n("backward-slide"), yC = $n("change-slide-event"), bC = "tox-pop--resizing", b9 = (t) => {
    const s = Xn([]);
    return na.sketch({
      dom: {
        tag: "div",
        classes: ["tox-pop"]
      },
      fireDismissalEventInstead: { event: "doNotDismissYet" },
      onShow: (a) => {
        s.set([]), na.getContent(a).each((l) => {
          Dt(l.element, "visibility");
        }), Yr(a.element, bC), Dt(a.element, "width");
      },
      inlineBehaviours: qt([
        ys("context-toolbar-events", [
          pi(Gp(), (a, l) => {
            l.event.raw.propertyName === "width" && (Yr(a.element, bC), Dt(a.element, "width"));
          }),
          dt(yC, (a, l) => {
            const f = a.element;
            Dt(f, "width");
            const g = Wo(f);
            na.setContent(a, l.event.contents), Ea(f, bC);
            const h = Wo(f);
            Qt(f, "width", g + "px"), na.getContent(a).each((w) => {
              l.event.focus.bind((C) => (Xu(C), _i(f))).orThunk(() => (Kn.focusIn(w), Nd(or(f))));
            }), setTimeout(() => {
              Qt(a.element, "width", h + "px");
            }, 0);
          }),
          dt(v8, (a, l) => {
            na.getContent(a).each((f) => {
              s.set(s.get().concat([{
                bar: f,
                focus: Nd(or(a.element))
              }]));
            }), no(a, yC, {
              contents: l.event.forwardContents,
              focus: z.none()
            });
          }),
          dt(k8, (a, l) => {
            yn(s.get()).each((f) => {
              s.set(s.get().slice(0, s.get().length - 1)), no(a, yC, {
                contents: bi(f.bar),
                focus: f.focus
              });
            });
          })
        ]),
        Kn.config({
          mode: "special",
          onEscape: (a) => yn(s.get()).fold(() => t.onEscape(), (l) => (Ts(a, k8), z.some(!0)))
        })
      ]),
      lazySink: () => yo.value(t.sink)
    });
  }, kE = "tox-pop--transition", v9 = (t, s, a, l) => {
    const f = l.backstage, g = f.shared, h = Ul().deviceType.isTouch, w = Ar(), C = Ar(), T = Ar(), D = bc(b9({
      sink: a,
      onEscape: () => (t.focus(), z.some(!0))
    })), $ = () => {
      const so = T.get().getOr("node"), us = g8(so) ? 1 : 0;
      return f8(t, g, so, us);
    }, I = () => !t.removed && !(h() && f.isContextMenuOpen()), V = (so) => zr(Tr(so, w.get(), Lo), !0), ne = () => {
      if (I()) {
        const so = $(), us = zr(T.get(), "node") ? u9(t, w.get()) : pC(t);
        return so.height <= 0 || !Ek(us, so);
      } else
        return !0;
    }, pe = () => {
      w.clear(), C.clear(), T.clear(), na.hide(D);
    }, Le = () => {
      if (na.isOpen(D)) {
        const so = D.element;
        Dt(so, "display"), ne() ? Qt(so, "display", "none") : (C.set(0), na.reposition(D));
      }
    }, he = (so) => ({
      dom: {
        tag: "div",
        classes: ["tox-pop__dialog"]
      },
      components: [so],
      behaviours: qt([
        Kn.config({ mode: "acyclic" }),
        ys("pop-dialog-wrap-events", [
          kr((us) => {
            t.shortcuts.add("ctrl+F9", "focus statusbar", () => Kn.focusIn(us));
          }),
          Hi((us) => {
            t.shortcuts.remove("ctrl+F9");
          })
        ])
      ])
    }), at = Oo(() => b8(s, (so) => {
      const us = hn([so]);
      no(D, v8, { forwardContents: he(us) });
    })), kn = (so, us) => fC(t, {
      buttons: so,
      toolbar: us.items,
      allowToolbarGroups: !1
    }, l, z.some(["form:"])), et = (so, us) => w1.buildInitGroups(so, us), hn = (so) => {
      const { buttons: us } = t.ui.registry.getAll(), Ms = at(), jn = {
        ...us,
        ...Ms.formNavigators
      }, zs = Xb(t) === hl.scrolling ? hl.scrolling : hl.default, io = X(Xe(so, (Mt) => Mt.type === "contexttoolbar" ? kn(jn, Mt) : et(Mt, g.providers)));
      return wk({
        type: zs,
        uid: $n("context-toolbar"),
        initGroups: io,
        onEscape: z.none,
        cyclicKeying: !0,
        providers: g.providers
      });
    }, xn = (so, us) => {
      const Ms = so === "node" ? g.anchors.node(us) : g.anchors.cursor(), jn = g9(t, so, h(), {
        lastElement: w.get,
        isReposition: () => zr(C.get(), 0),
        getMode: () => dl.getMode(a)
      });
      return sr(Ms, jn);
    }, Cn = (so, us) => {
      if (oo.cancel(), !I())
        return;
      const Ms = hn(so), jn = so[0].position, zs = xn(jn, us);
      T.set(jn), C.set(1);
      const io = D.element;
      Dt(io, "display"), V(us) || (Yr(io, kE), dl.reset(a, D)), na.showWithinBounds(D, he(Ms), {
        anchor: zs,
        transition: {
          classes: [kE],
          mode: "placement"
        }
      }, () => z.some($())), us.fold(w.clear, w.set), ne() && Qt(io, "display", "none");
    }, oo = QT(() => {
      if (!(!t.hasFocus() || t.removed))
        if (oc(D.element, kE))
          oo.throttle();
        else {
          const so = at();
          y8(so, t).fold(pe, (us) => {
            Cn(us.toolbars, z.some(us.elem));
          });
        }
    }, 17);
    t.on("init", () => {
      t.on("remove", pe), t.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", Le), t.on("click keyup focus SetContent", oo.throttle), t.on(i8, pe), t.on(l9, (so) => {
        const us = at();
        ht(us.lookupTable, so.toolbarKey).each((Ms) => {
          Cn([Ms], er(so.target !== t, so.target)), na.getContent(D).each(Kn.focusIn);
        });
      }), t.on("focusout", (so) => {
        Kb.setEditorTimeout(t, () => {
          _i(a.element).isNone() && _i(D.element).isNone() && pe();
        }, 0);
      }), t.on("SwitchMode", () => {
        t.mode.isReadOnly() && pe();
      }), t.on("AfterProgressState", (so) => {
        so.state ? pe() : t.hasFocus() && oo.throttle();
      }), t.on("NodeChange", (so) => {
        _i(D.element).fold(oo.throttle, ie);
      });
    });
  }, k9 = (t) => {
    O([
      {
        name: "alignleft",
        text: "Align left",
        cmd: "JustifyLeft",
        icon: "align-left"
      },
      {
        name: "aligncenter",
        text: "Align center",
        cmd: "JustifyCenter",
        icon: "align-center"
      },
      {
        name: "alignright",
        text: "Align right",
        cmd: "JustifyRight",
        icon: "align-right"
      },
      {
        name: "alignjustify",
        text: "Justify",
        cmd: "JustifyFull",
        icon: "align-justify"
      }
    ], (a) => {
      t.ui.registry.addToggleButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onAction: nu(t, a.cmd),
        onSetup: h1(t, a.name)
      });
    }), t.ui.registry.addButton("alignnone", {
      tooltip: "No alignment",
      icon: "align-none",
      onAction: nu(t, "JustifyNone")
    });
  }, w9 = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, wE = (() => {
    const t = "[0-9]+", s = "[+-]?" + t, a = "[eE]" + s, l = "\\.", f = (w) => `(?:${w})?`, h = `[+-]?(?:${[
      "Infinity",
      t + l + f(t) + f(a),
      l + t + f(a),
      t + f(a)
    ].join("|")})`;
    return new RegExp(`^(${h})(.*)$`);
  })(), _9 = (t, s) => Sn(s, (a) => Sn(w9[a], (l) => t === l)), C9 = (t, s) => z.from(wE.exec(t)).bind((l) => {
    const f = Number(l[1]), g = l[2];
    return _9(g, s) ? z.some({
      value: f,
      unit: g
    }) : z.none();
  }), _E = (t, s) => C9(t, s).map(({ value: a, unit: l }) => a + l), CE = (t, s) => {
    const a = () => {
      const l = s.getOptions(t), f = s.getCurrent(t).map(s.hash), g = Ar();
      return Xe(l, (h) => ({
        type: "togglemenuitem",
        text: s.display(h),
        onSetup: (w) => {
          const C = (D) => {
            D && (g.on(($) => $.setActive(!1)), g.set(w)), w.setActive(D);
          };
          C(zr(f, s.hash(h)));
          const T = s.watcher(t, h, C);
          return () => {
            g.clear(), T();
          };
        },
        onAction: () => s.setCurrent(t, h)
      }));
    };
    t.ui.registry.addMenuButton(s.name, {
      tooltip: s.text,
      icon: s.icon,
      fetch: (l) => l(a()),
      onSetup: s.onToolbarSetup
    }), t.ui.registry.addNestedMenuItem(s.name, {
      type: "nestedmenuitem",
      text: s.text,
      getSubmenuItems: a,
      onSetup: s.onMenuSetup
    });
  }, w8 = {
    name: "lineheight",
    text: "Line height",
    icon: "line-height",
    getOptions: pA,
    hash: (t) => _E(t, [
      "fixed",
      "relative",
      "empty"
    ]).getOr(t),
    display: Je,
    watcher: (t, s, a) => t.formatter.formatChanged("lineheight", a, !1, { value: s }).unbind,
    getCurrent: (t) => z.from(t.queryCommandValue("LineHeight")),
    setCurrent: (t, s) => t.execCommand("LineHeight", !1, s)
  }, S9 = (t) => z.from(J5(t)).map((a) => ({
    name: "language",
    text: "Language",
    icon: "language",
    getOptions: oe(a),
    hash: (l) => mt(l.customCode) ? l.code : `${l.code}/${l.customCode}`,
    display: (l) => l.title,
    watcher: (l, f, g) => l.formatter.formatChanged("lang", g, !1, {
      value: f.code,
      customValue: f.customCode
    }).unbind,
    getCurrent: (l) => {
      const f = bt.fromDom(l.selection.getNode());
      return ks(f, (g) => z.some(g).filter(Yt).bind((h) => ha(h, "lang").map((C) => {
        const T = ha(h, "data-mce-lang").getOrUndefined();
        return {
          code: C,
          customCode: T,
          title: ""
        };
      })));
    },
    setCurrent: (l, f) => l.execCommand("Lang", !1, f),
    onToolbarSetup: (l) => {
      const f = Bf();
      return l.setActive(t.formatter.match("lang", {}, void 0, !0)), f.set(t.formatter.formatChanged("lang", l.setActive, !0)), f.clear;
    }
  })), x9 = (t) => {
    CE(t, w8), S9(t).each((s) => CE(t, s));
  }, T9 = (t, s) => {
    kF(t, s), KD(t, s), RF(t, s), _F(t, s), OF(t, s);
  }, E9 = (t) => _k(t, "NodeChange", (s) => {
    s.setEnabled(t.queryCommandState("outdent"));
  }), A9 = (t) => {
    t.ui.registry.addButton("outdent", {
      tooltip: "Decrease indent",
      icon: "outdent",
      onSetup: E9(t),
      onAction: nu(t, "outdent")
    }), t.ui.registry.addButton("indent", {
      tooltip: "Increase indent",
      icon: "indent",
      onAction: nu(t, "indent")
    });
  }, _8 = (t) => {
    A9(t);
  }, C8 = (t, s) => (a) => {
    a.setActive(s.get());
    const l = (f) => {
      s.set(f.state), a.setActive(f.state);
    };
    return t.on("PastePlainTextToggle", l), () => t.off("PastePlainTextToggle", l);
  }, S8 = (t) => {
    const s = Xn(fA(t)), a = () => t.execCommand("mceTogglePlainTextPaste");
    t.ui.registry.addToggleButton("pastetext", {
      active: !1,
      icon: "paste-text",
      tooltip: "Paste as text",
      onAction: a,
      onSetup: C8(t, s)
    }), t.ui.registry.addToggleMenuItem("pastetext", {
      text: "Paste as text",
      icon: "paste-text",
      onAction: a,
      onSetup: C8(t, s)
    });
  }, SE = (t, s) => () => {
    t.execCommand("mceToggleFormat", !1, s);
  }, z9 = (t) => {
    ly.each([
      {
        name: "bold",
        text: "Bold",
        icon: "bold"
      },
      {
        name: "italic",
        text: "Italic",
        icon: "italic"
      },
      {
        name: "underline",
        text: "Underline",
        icon: "underline"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        icon: "superscript"
      }
    ], (s, a) => {
      t.ui.registry.addToggleButton(s.name, {
        tooltip: s.text,
        icon: s.icon,
        onSetup: h1(t, s.name),
        onAction: SE(t, s.name)
      });
    });
    for (let s = 1; s <= 6; s++) {
      const a = "h" + s;
      t.ui.registry.addToggleButton(a, {
        text: a.toUpperCase(),
        tooltip: "Heading " + s,
        onSetup: h1(t, a),
        onAction: SE(t, a)
      });
    }
  }, xE = (t) => {
    ly.each([
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste"
      },
      {
        name: "help",
        text: "Help",
        action: "mceHelp",
        icon: "help"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "remove",
        text: "Remove",
        action: "Delete",
        icon: "remove"
      },
      {
        name: "print",
        text: "Print",
        action: "mcePrint",
        icon: "print"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (s) => {
      t.ui.registry.addButton(s.name, {
        tooltip: s.text,
        icon: s.icon,
        onAction: nu(t, s.action)
      });
    });
  }, x8 = (t) => {
    ly.each([{
      name: "blockquote",
      text: "Blockquote",
      action: "mceBlockQuote",
      icon: "quote"
    }], (s) => {
      t.ui.registry.addToggleButton(s.name, {
        tooltip: s.text,
        icon: s.icon,
        onAction: nu(t, s.action),
        onSetup: h1(t, s.name)
      });
    });
  }, T8 = (t) => {
    z9(t), xE(t), x8(t);
  }, vC = (t) => {
    ly.each([
      {
        name: "bold",
        text: "Bold",
        action: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        action: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        action: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        action: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        action: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        action: "Superscript",
        icon: "superscript"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut",
        shortcut: "Meta+X"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy",
        shortcut: "Meta+C"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste",
        shortcut: "Meta+V"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "print",
        text: "Print...",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (s) => {
      t.ui.registry.addMenuItem(s.name, {
        text: s.text,
        icon: s.icon,
        shortcut: s.shortcut,
        onAction: nu(t, s.action)
      });
    }), t.ui.registry.addMenuItem("codeformat", {
      text: "Code",
      icon: "sourcecode",
      onAction: SE(t, "code")
    });
  }, O9 = (t) => {
    T8(t), vC(t);
  }, kC = (t, s) => _k(t, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (a) => {
    a.setEnabled(!t.mode.isReadOnly() && t.undoManager[s]());
  }), D9 = (t) => {
    t.ui.registry.addMenuItem("undo", {
      text: "Undo",
      icon: "undo",
      shortcut: "Meta+Z",
      onSetup: kC(t, "hasUndo"),
      onAction: nu(t, "undo")
    }), t.ui.registry.addMenuItem("redo", {
      text: "Redo",
      icon: "redo",
      shortcut: "Meta+Y",
      onSetup: kC(t, "hasRedo"),
      onAction: nu(t, "redo")
    });
  }, R9 = (t) => {
    t.ui.registry.addButton("undo", {
      tooltip: "Undo",
      icon: "undo",
      enabled: !1,
      onSetup: kC(t, "hasUndo"),
      onAction: nu(t, "undo")
    }), t.ui.registry.addButton("redo", {
      tooltip: "Redo",
      icon: "redo",
      enabled: !1,
      onSetup: kC(t, "hasRedo"),
      onAction: nu(t, "redo")
    });
  }, E8 = (t) => {
    D9(t), R9(t);
  }, M9 = (t) => _k(t, "VisualAid", (s) => {
    s.setActive(t.hasVisual);
  }), N9 = (t) => {
    t.ui.registry.addToggleMenuItem("visualaid", {
      text: "Visual aids",
      onSetup: M9(t),
      onAction: nu(t, "mceToggleVisualAid")
    });
  }, B9 = (t) => {
    t.ui.registry.addButton("visualaid", {
      tooltip: "Visual aids",
      text: "Visual aids",
      onAction: nu(t, "mceToggleVisualAid")
    });
  }, $9 = (t) => {
    B9(t), N9(t);
  }, P9 = (t, s) => {
    k9(t), O9(t), T9(t, s), E8(t), MM(t), $9(t), _8(t), x9(t), S8(t);
  }, F9 = (t) => Kt(t) ? t.split(/[ ,]/) : t, A8 = (t) => (s) => s.options.get(t), I9 = (t) => {
    const s = t.options.register;
    s("contextmenu_avoid_overlap", {
      processor: "string",
      default: ""
    }), s("contextmenu_never_use_native", {
      processor: "boolean",
      default: !1
    }), s("contextmenu", {
      processor: (a) => a === !1 ? {
        value: [],
        valid: !0
      } : Kt(a) || Ue(a, Kt) ? {
        value: F9(a),
        valid: !0
      } : {
        valid: !1,
        message: "Must be false or a string."
      },
      default: "link linkchecker image editimage table spellchecker configurepermanentpen"
    });
  }, TE = A8("contextmenu_never_use_native"), L9 = A8("contextmenu_avoid_overlap"), H9 = (t) => z8(t).length === 0, z8 = (t) => {
    const s = t.ui.registry.getAll().contextMenus, a = t.options.get("contextmenu");
    return t.options.isSet("contextmenu") ? a : Pt(a, (l) => qn(s, l));
  }, Ok = (t, s) => ({
    type: "makeshift",
    x: t,
    y: s
  }), V9 = (t, s, a) => Ok(t.x + s, t.y + a), Op = (t) => t.type === "longpress" || t.type.indexOf("touch") === 0, O8 = (t) => {
    if (Op(t)) {
      const s = t.touches[0];
      return Ok(s.pageX, s.pageY);
    } else
      return Ok(t.pageX, t.pageY);
  }, j9 = (t) => {
    if (Op(t)) {
      const s = t.touches[0];
      return Ok(s.clientX, s.clientY);
    } else
      return Ok(t.clientX, t.clientY);
  }, U9 = (t, s) => {
    const a = kv.DOM.getPos(t);
    return V9(s, a.x, a.y);
  }, W9 = (t, s) => s.type === "contextmenu" || s.type === "longpress" ? t.inline ? O8(s) : U9(t.getContentAreaContainer(), j9(s)) : D8(t), D8 = (t) => ({
    type: "selection",
    root: bt.fromDom(t.selection.getNode())
  }), R8 = (t) => ({
    type: "node",
    node: z.some(bt.fromDom(t.selection.getNode())),
    root: bt.fromDom(t.getBody())
  }), M8 = (t, s, a) => {
    switch (a) {
      case "node":
        return R8(t);
      case "point":
        return W9(t, s);
      case "selection":
        return D8(t);
    }
  }, Z9 = (t, s, a, l, f, g) => {
    const h = a(), w = M8(t, s, g);
    u1(h, jd.CLOSE_ON_EXECUTE, l, !1).map((C) => {
      s.preventDefault(), na.showMenuAt(f, { anchor: w }, {
        menu: { markers: vp("normal") },
        data: C
      });
    });
  }, q9 = {
    onLtr: () => [
      ua,
      vc,
      kc,
      Kc,
      wc,
      Ir,
      Gf,
      fk,
      dk,
      K2,
      uk,
      G2
    ],
    onRtl: () => [
      ua,
      kc,
      vc,
      wc,
      Kc,
      Ir,
      Gf,
      fk,
      uk,
      G2,
      dk,
      K2
    ]
  }, G9 = 12, K9 = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"]
  }, Y9 = (t, s) => {
    const a = t.selection;
    if (a.isCollapsed() || s.touches.length < 1)
      return !1;
    {
      const l = s.touches[0], f = a.getRng();
      return qi(t.getWin(), Zi.domRange(f)).exists((h) => h.left <= l.clientX && h.right >= l.clientX && h.top <= l.clientY && h.bottom >= l.clientY);
    }
  }, X9 = (t) => {
    const s = t.selection.getRng(), a = () => {
      Kb.setEditorTimeout(t, () => {
        t.selection.setRng(s);
      }, 10), g();
    };
    t.once("touchend", a);
    const l = (h) => {
      h.preventDefault(), h.stopImmediatePropagation();
    };
    t.on("mousedown", l, !0);
    const f = () => g();
    t.once("longpresscancel", f);
    const g = () => {
      t.off("touchend", a), t.off("longpresscancel", f), t.off("mousedown", l);
    };
  }, J9 = (t, s, a) => {
    const l = M8(t, s, a);
    return {
      bubble: Hg(0, a === "point" ? G9 : 0, K9),
      layouts: q9,
      overrides: {
        maxWidthFunction: Y4(),
        maxHeightFunction: Lg()
      },
      ...l
    };
  }, N8 = (t, s, a, l, f, g, h) => {
    const w = J9(t, s, g);
    u1(a, jd.CLOSE_ON_EXECUTE, l, !0).map((C) => {
      s.preventDefault(), na.showMenuWithinBounds(f, { anchor: w }, {
        menu: {
          markers: vp("normal"),
          highlightImmediately: h
        },
        data: C,
        type: "horizontal"
      }, () => z.some(f8(t, l.shared, g === "node" ? "node" : "selection"))), t.dispatch(i8);
    });
  }, B8 = (t, s, a, l, f, g) => {
    const h = Ul(), w = h.os.isiOS(), C = h.os.isMacOS(), T = h.os.isAndroid(), D = h.deviceType.isTouch(), $ = () => !(T || w || C && D), I = () => {
      const V = a();
      N8(t, s, V, l, f, g, $());
    };
    if ((C || w) && g !== "node") {
      const V = () => {
        X9(t), I();
      };
      Y9(t, s) ? V() : (t.once("selectionchange", V), t.once("touchend", () => t.off("selectionchange", V)));
    } else
      I();
  }, $8 = (t) => Kt(t) ? t === "|" : t.type === "separator", my = { type: "separator" }, P8 = (t) => {
    const s = (a) => ({
      text: a.text,
      icon: a.icon,
      enabled: a.enabled,
      shortcut: a.shortcut
    });
    if (Kt(t))
      return t;
    switch (t.type) {
      case "separator":
        return my;
      case "submenu":
        return {
          type: "nestedmenuitem",
          ...s(t),
          getSubmenuItems: () => {
            const a = t.getSubmenuItems();
            return Kt(a) ? a : Xe(a, P8);
          }
        };
      default:
        return {
          type: "menuitem",
          ...s(t),
          onAction: dn(t.onAction)
        };
    }
  }, F8 = (t, s) => {
    if (s.length === 0)
      return t;
    const l = yn(t).filter((f) => !$8(f)).fold(() => [], (f) => [my]);
    return t.concat(l).concat(s).concat([my]);
  }, EE = (t, s, a) => {
    const l = We(s, (f, g) => ht(t, g.toLowerCase()).map((h) => {
      const w = h.update(a);
      if (Kt(w))
        return F8(f, w.split(" "));
      if (w.length > 0) {
        const C = Xe(w, P8);
        return F8(f, C);
      } else
        return f;
    }).getOrThunk(() => f.concat([g])), []);
    return l.length > 0 && $8(l[l.length - 1]) && l.pop(), l;
  }, Q9 = (t, s) => s.ctrlKey && !TE(t), I8 = (t, s) => s.type !== "longpress" && (s.button !== 2 || s.target === t.getBody() && s.pointerType === ""), L8 = (t, s) => I8(t, s) ? t.selection.getStart(!0) : s.target, eI = (t, s) => {
    const a = L9(t), l = I8(t, s) ? "selection" : "point";
    if (wt(a)) {
      const f = L8(t, s);
      return Zv(bt.fromDom(f), a) ? "node" : l;
    } else
      return l;
  }, tI = (t, s, a) => {
    const f = Ul().deviceType.isTouch, g = bc(na.sketch({
      dom: { tag: "div" },
      lazySink: s,
      onEscape: () => t.focus(),
      onShow: () => a.setContextMenuState(!0),
      onHide: () => a.setContextMenuState(!1),
      fireDismissalEventInstead: {},
      inlineBehaviours: qt([ys("dismissContextMenu", [dt(kg(), (C, T) => {
        Yo.close(C), t.focus();
      })])])
    })), h = (C) => na.hide(g), w = (C) => {
      if (TE(t) && C.preventDefault(), Q9(t, C) || H9(t))
        return;
      const T = eI(t, C), D = () => {
        const I = L8(t, C), V = t.ui.registry.getAll(), ne = z8(t);
        return EE(V.contextMenus, ne, I);
      };
      (f() ? B8 : Z9)(t, C, D, a, g, T);
    };
    t.on("init", () => {
      const C = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (f() ? "" : " ResizeWindow");
      t.on(C, h), t.on("longpress contextmenu", w);
    });
  }, AE = Pa.generate([
    {
      offset: [
        "x",
        "y"
      ]
    },
    {
      absolute: [
        "x",
        "y"
      ]
    },
    {
      fixed: [
        "x",
        "y"
      ]
    }
  ]), wC = (t) => (s) => s.translate(-t.left, -t.top), _C = (t) => (s) => s.translate(t.left, t.top), tg = (t) => (s, a) => We(t, (l, f) => f(l), as(s, a)), CC = (t, s, a) => t.fold(tg([
    _C(a),
    wC(s)
  ]), tg([wC(s)]), tg([])), _1 = (t, s, a) => t.fold(tg([_C(a)]), tg([]), tg([_C(s)])), H8 = (t, s, a) => t.fold(tg([]), tg([wC(a)]), tg([
    _C(s),
    wC(a)
  ])), nI = (t, s, a, l, f, g) => {
    const h = _1(t, f, g), w = _1(s, f, g);
    return Math.abs(h.left - w.left) <= a && Math.abs(h.top - w.top) <= l;
  }, oI = (t, s, a, l, f, g) => {
    const h = _1(t, f, g), w = _1(s, f, g), C = Math.abs(h.left - w.left), T = Math.abs(h.top - w.top);
    return as(C, T);
  }, V8 = (t, s, a) => {
    const l = t.fold((f, g) => ({
      position: z.some("absolute"),
      left: z.some(f + "px"),
      top: z.some(g + "px")
    }), (f, g) => ({
      position: z.some("absolute"),
      left: z.some(f - a.left + "px"),
      top: z.some(g - a.top + "px")
    }), (f, g) => ({
      position: z.some("fixed"),
      left: z.some(f + "px"),
      top: z.some(g + "px")
    }));
    return {
      right: z.none(),
      bottom: z.none(),
      ...l
    };
  }, sI = (t, s, a) => t.fold((l, f) => gy(l + s, f + a), (l, f) => Dp(l + s, f + a), (l, f) => py(l + s, f + a)), zE = (t, s, a, l) => {
    const f = (g, h) => (w, C) => {
      const T = g(s, a, l);
      return h(w.getOr(T.left), C.getOr(T.top));
    };
    return t.fold(f(H8, gy), f(_1, Dp), f(CC, py));
  }, gy = AE.offset, Dp = AE.absolute, py = AE.fixed, j8 = (t, s) => {
    const a = Vo(t, s);
    return mt(a) ? NaN : parseInt(a, 10);
  }, rI = (t, s) => {
    const a = t.element, l = j8(a, s.leftAttr), f = j8(a, s.topAttr);
    return isNaN(l) || isNaN(f) ? z.none() : z.some(as(l, f));
  }, aI = (t, s, a) => {
    const l = t.element;
    to(l, s.leftAttr, a.left + "px"), to(l, s.topAttr, a.top + "px");
  }, U8 = (t, s) => {
    const a = t.element;
    nr(a, s.leftAttr), nr(a, s.topAttr);
  }, cI = (t, s, a, l) => rI(t, s).fold(() => a, (f) => py(f.left + l.left, f.top + l.top)), lI = (t, s, a, l, f, g) => {
    const h = cI(t, s, a, l), w = s.mustSnap ? uI(t, s, h, f, g) : OE(t, s, h, f, g), C = CC(h, f, g);
    return aI(t, s, C), w.fold(() => ({
      coord: py(C.left, C.top),
      extra: z.none()
    }), (T) => ({
      coord: T.output,
      extra: T.extra
    }));
  }, iI = (t, s) => {
    U8(t, s);
  }, W8 = (t, s, a, l) => Ho(t, (f) => {
    const g = f.sensor;
    return nI(s, g, f.range.left, f.range.top, a, l) ? z.some({
      output: zE(f.output, s, a, l),
      extra: f.extra
    }) : z.none();
  }), uI = (t, s, a, l, f) => {
    const g = s.getSnapPoints(t);
    return W8(g, a, l, f).orThunk(() => We(g, (C, T) => {
      const D = T.sensor, $ = oI(a, D, T.range.left, T.range.top, l, f);
      return C.deltas.fold(() => ({
        deltas: z.some($),
        snap: z.some(T)
      }), (I) => {
        const V = ($.left + $.top) / 2, ne = (I.left + I.top) / 2;
        return V <= ne ? {
          deltas: z.some($),
          snap: z.some(T)
        } : C;
      });
    }, {
      deltas: z.none(),
      snap: z.none()
    }).snap.map((C) => ({
      output: zE(C.output, a, l, f),
      extra: C.extra
    })));
  }, OE = (t, s, a, l, f) => {
    const g = s.getSnapPoints(t);
    return W8(g, a, l, f);
  }, Z8 = (t, s, a) => ({
    coord: zE(t.output, t.output, s, a),
    extra: t.extra
  });
  var dI = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    snapTo: (t, s, a, l) => {
      const f = s.getTarget(t.element);
      if (s.repositionTarget) {
        const g = Er(t.element), h = al(g), w = XO(f), C = Z8(l, h, w), T = V8(C.coord, h, w);
        wl(f, T);
      }
    }
  });
  const DE = "data-initial-z-index", fI = (t) => {
    Wr(t.element).filter(Yt).each((s) => {
      ha(s, DE).fold(() => Dt(s, "z-index"), (a) => Qt(s, "z-index", a)), nr(s, DE);
    });
  }, mI = (t) => {
    Wr(t.element).filter(Yt).each((s) => {
      j(s, "z-index").each((a) => {
        to(s, DE, a);
      }), Qt(s, "z-index", qr(t.element, "z-index"));
    });
  }, q8 = (t, s) => {
    t.getSystem().addToGui(s), mI(s);
  }, gI = (t) => {
    fI(t), t.getSystem().removeFromGui(t);
  }, G8 = (t, s, a) => t.getSystem().build(Zm.sketch({
    dom: {
      styles: {
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%",
        position: "fixed",
        "z-index": "1000000000000000"
      },
      classes: [s]
    },
    events: a
  }));
  var pI = zc("snaps", [
    ut("getSnapPoints"),
    Es("onSensor"),
    ut("leftAttr"),
    ut("topAttr"),
    Te("lazyViewport", ui),
    Te("mustSnap", !1)
  ]);
  const RE = [
    Te("useFixed", Ot),
    ut("blockerClass"),
    Te("getTarget", Je),
    Te("onDrag", ie),
    Te("repositionTarget", !0),
    Te("onDrop", ie),
    Fr("getBounds", ui),
    pI
  ], hI = (t) => Xo(j(t, "left"), j(t, "top"), j(t, "position"), (s, a, l) => (l === "fixed" ? py : gy)(parseInt(s, 10), parseInt(a, 10))).getOrThunk(() => {
    const s = Me(t);
    return Dp(s.left, s.top);
  }), yI = (t, s, a, l, f) => {
    const g = f.bounds, h = _1(s, a, l), w = ki(h.left, g.x, g.x + g.width - f.width), C = ki(h.top, g.y, g.y + g.height - f.height), T = Dp(w, C);
    return s.fold(() => {
      const D = H8(T, a, l);
      return gy(D.left, D.top);
    }, oe(T), () => {
      const D = CC(T, a, l);
      return py(D.left, D.top);
    });
  }, bI = (t, s, a, l, f, g, h) => {
    const w = s.fold(() => {
      const C = sI(a, g.left, g.top), T = CC(C, l, f);
      return py(T.left, T.top);
    }, (C) => {
      const T = lI(t, C, a, g, l, f);
      return T.extra.each((D) => {
        C.onSensor(t, D);
      }), T.coord;
    });
    return yI(t, w, l, f, h);
  }, vI = (t, s, a, l) => {
    const f = s.getTarget(t.element);
    if (s.repositionTarget) {
      const g = Er(t.element), h = al(g), w = XO(f), C = hI(f), T = bI(t, s.snaps, C, h, w, l, a), D = V8(T, h, w);
      wl(f, D);
    }
    s.onDrag(t, f, l);
  }, K8 = (t, s) => ({
    bounds: t.getBounds(),
    height: Ca(s.element),
    width: Xs(s.element)
  }), ME = (t, s, a, l, f) => {
    const g = a.update(l, f), h = a.getStartData().getOrThunk(() => K8(s, t));
    g.each((w) => {
      vI(t, s, h, w);
    });
  }, Y8 = (t, s, a, l) => {
    s.each(gI), a.snaps.each((g) => {
      iI(t, g);
    });
    const f = a.getTarget(t.element);
    l.reset(), a.onDrop(t, f);
  }, NE = (t) => (s, a) => {
    const l = (f) => {
      a.setStartData(K8(s, f));
    };
    return Ls([
      dt(Sf(), (f) => {
        a.getStartData().each(() => l(f));
      }),
      ...t(s, a, l)
    ]);
  }, kI = (t) => Ls([
    dt(ql(), t.forceDrop),
    dt(dr(), t.drop),
    dt(hg(), (s, a) => {
      t.move(a.event);
    }),
    dt(Do(), t.delayDrop)
  ]);
  var hy = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => z.from(as(t.x, t.y)),
    getDelta: (t, s) => as(s.left - t.left, s.top - t.top)
  });
  const X8 = (t, s, a) => [dt(ql(), (l, f) => {
    if (f.event.raw.button !== 0)
      return;
    f.stop();
    const h = () => Y8(l, z.some(T), t, s), w = Sz(h, 200), C = {
      drop: h,
      delayDrop: w.schedule,
      forceDrop: h,
      move: ($) => {
        w.cancel(), ME(l, t, s, hy, $);
      }
    }, T = G8(l, t.blockerClass, kI(C));
    (() => {
      a(l), q8(l, T);
    })();
  })], BE = [
    ...RE,
    fr("dragger", { handlers: NE(X8) })
  ], SC = (t) => Ls([
    dt(Wc(), t.forceDrop),
    dt(uu(), t.drop),
    dt(Cf(), t.drop),
    dt(Uu(), (s, a) => {
      t.move(a.event);
    })
  ]), _I = (t) => {
    const s = t[0];
    return z.some(as(s.clientX, s.clientY));
  };
  var J8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => {
      const a = t.raw.touches;
      return a.length === 1 ? _I(a) : z.none();
    },
    getDelta: (t, s) => as(s.left - t.left, s.top - t.top)
  });
  const Q8 = (t, s, a) => {
    const l = Ar(), f = (g) => {
      Y8(g, l.get(), t, s), l.clear();
    };
    return [
      dt(Wc(), (g, h) => {
        h.stop();
        const w = () => f(g), C = {
          drop: w,
          delayDrop: ie,
          forceDrop: w,
          move: ($) => {
            ME(g, t, s, J8, $);
          }
        }, T = G8(g, t.blockerClass, SC(C));
        l.set(T), (() => {
          a(g), q8(g, T);
        })();
      }),
      dt(Uu(), (g, h) => {
        h.stop(), ME(g, t, s, J8, h.event);
      }),
      dt(uu(), (g, h) => {
        h.stop(), f(g);
      }),
      dt(Cf(), f)
    ];
  }, yy = [
    ...RE,
    fr("dragger", { handlers: NE(Q8) })
  ], e7 = (t, s, a) => [
    ...X8(t, s, a),
    ...Q8(t, s, a)
  ], CI = [
    ...RE,
    fr("dragger", { handlers: NE(e7) })
  ];
  var SI = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    mouse: BE,
    touch: yy,
    mouseOrTouch: CI
  }), xI = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = z.none(), s = z.none();
      const a = () => {
        t = z.none(), s = z.none();
      }, l = (C, T) => {
        const D = t.map(($) => C.getDelta($, T));
        return t = z.some(T), D;
      }, f = (C, T) => C.getData(T).bind((D) => l(C, D)), g = (C) => {
        s = z.some(C);
      }, h = () => s, w = oe({});
      return Ol({
        readState: w,
        reset: a,
        update: f,
        getStartData: h,
        setStartData: g
      });
    }
  });
  const by = Cw({
    branchKey: "mode",
    branches: SI,
    name: "dragging",
    active: {
      events: (t, s) => t.dragger.handlers(t, s)
    },
    extra: {
      snap: (t) => ({
        sensor: t.sensor,
        range: t.range,
        output: t.output,
        extra: z.from(t.extra)
      })
    },
    state: xI,
    apis: dI
  }), Dk = 40, Rp = Dk / 2, xC = (t, s, a, l, f, g) => t.fold(() => by.snap({
    sensor: Dp(a - Rp, l - Rp),
    range: as(f, g),
    output: Dp(z.some(a), z.some(l)),
    extra: { td: s }
  }), (h) => {
    const w = a - Rp, C = l - Rp, T = Dk, D = Dk, $ = h.element.dom.getBoundingClientRect();
    return by.snap({
      sensor: Dp(w, C),
      range: as(T, D),
      output: Dp(z.some(a - $.width / 2), z.some(l - $.height / 2)),
      extra: { td: s }
    });
  }), Rk = (t, s, a) => {
    const l = (f, g) => f.exists((h) => Lo(h, g));
    return {
      getSnapPoints: t,
      leftAttr: "data-drag-left",
      topAttr: "data-drag-top",
      onSensor: (f, g) => {
        const h = g.td;
        l(s.get(), h) || (s.set(h), a(h));
      },
      mustSnap: !0
    };
  }, Mp = (t) => wr($l.sketch({
    dom: {
      tag: "div",
      classes: ["tox-selector"]
    },
    buttonBehaviours: qt([
      by.config({
        mode: "mouseOrTouch",
        blockerClass: "blocker",
        snaps: t
      }),
      Kd.config({})
    ]),
    eventOrder: {
      mousedown: [
        "dragging",
        "alloy.base.behaviour"
      ],
      touchstart: [
        "dragging",
        "alloy.base.behaviour"
      ]
    }
  })), TC = (t, s) => {
    const a = Xn([]), l = Xn([]), f = Xn(!1), g = Ar(), h = Ar(), w = (Cn) => {
      const oo = Gr(Cn);
      return xC(V.getOpt(s), Cn, oo.x, oo.y, oo.width, oo.height);
    }, C = () => Xe(a.get(), (Cn) => w(Cn)), T = (Cn) => {
      const oo = Gr(Cn);
      return xC(ne.getOpt(s), Cn, oo.right, oo.bottom, oo.width, oo.height);
    }, D = () => Xe(l.get(), (Cn) => T(Cn)), $ = Rk(C, g, (Cn) => {
      h.get().each((oo) => {
        t.dispatch("TableSelectorChange", {
          start: Cn,
          finish: oo
        });
      });
    }), I = Rk(D, h, (Cn) => {
      g.get().each((oo) => {
        t.dispatch("TableSelectorChange", {
          start: oo,
          finish: Cn
        });
      });
    }), V = Mp($), ne = Mp(I), pe = bc(V.asSpec()), Le = bc(ne.asSpec()), he = (Cn, oo, so, us) => {
      const Ms = oo.dom.getBoundingClientRect();
      Dt(Cn.element, "display");
      const jn = pa(bt.fromDom(t.getBody())).dom.innerHeight, zs = so(Ms), io = us(Ms, jn);
      (zs || io) && Qt(Cn.element, "display", "none");
    }, at = (Cn, oo, so, us) => {
      const Ms = so(oo);
      by.snapTo(Cn, Ms), he(Cn, oo, (io) => io[us] < 0, (io, Mt) => io[us] > Mt);
    }, kn = (Cn) => at(pe, Cn, w, "top"), et = () => g.get().each(kn), hn = (Cn) => at(Le, Cn, T, "bottom"), xn = () => h.get().each(hn);
    Ul().deviceType.isTouch() && (t.on("TableSelectionChange", (Cn) => {
      f.get() || (Ml(s, pe), Ml(s, Le), f.set(!0)), g.set(Cn.start), h.set(Cn.finish), Cn.otherCells.each((oo) => {
        a.set(oo.upOrLeftCells), l.set(oo.downOrRightCells), kn(Cn.start), hn(Cn.finish);
      });
    }), t.on("ResizeEditor ResizeWindow ScrollContent", () => {
      et(), xn();
    }), t.on("TableSelectionClear", () => {
      f.get() && (Nl(pe), Nl(Le), f.set(!1)), g.clear(), h.clear();
    }));
  };
  var TI = `<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>
</svg>
`;
  const t7 = (t) => t.nodeName === "BR" || !!t.getAttribute("data-mce-bogus") || t.getAttribute("data-mce-type") === "bookmark", n7 = (t, s, a) => {
    var l;
    const f = (l = s.delimiter) !== null && l !== void 0 ? l : "\u203A", g = (T, D, $) => $l.sketch({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-item"],
        attributes: {
          "data-index": $,
          "aria-level": $ + 1
        }
      },
      components: [wa(T)],
      action: (I) => {
        t.focus(), t.selection.select(D), t.nodeChanged();
      },
      buttonBehaviours: qt([
        rd.button(a.isDisabled),
        ma()
      ])
    }), h = () => ({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-divider"],
        attributes: { "aria-hidden": !0 }
      },
      components: [wa(` ${f} `)]
    }), w = (T) => We(T, (D, $, I) => {
      const V = g($.name, $.element, I);
      return I === 0 ? D.concat([V]) : D.concat([
        h(),
        V
      ]);
    }, []), C = (T) => {
      const D = [];
      let $ = T.length;
      for (; $-- > 0; ) {
        const I = T[$];
        if (I.nodeType === 1 && !t7(I)) {
          const V = t.dispatch("ResolveName", {
            name: I.nodeName.toLowerCase(),
            target: I
          });
          if (V.isDefaultPrevented() || D.push({
            name: V.name,
            element: I
          }), V.isPropagationStopped())
            break;
        }
      }
      return D;
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path"],
        attributes: { role: "navigation" }
      },
      behaviours: qt([
        Kn.config({
          mode: "flow",
          selector: "div[role=button]"
        }),
        ao.config({ disabled: a.isDisabled }),
        ma(),
        oa.config({}),
        Uo.config({}),
        ys("elementPathEvents", [kr((T, D) => {
          t.shortcuts.add("alt+F11", "focus statusbar elementpath", () => Kn.focusIn(T)), t.on("NodeChange", ($) => {
            const I = C($.parents), V = I.length > 0 ? w(I) : [];
            Uo.set(T, V);
          });
        })])
      ]),
      components: []
    };
  };
  var Np;
  (function(t) {
    t[t.None = 0] = "None", t[t.Both = 1] = "Both", t[t.Vertical = 2] = "Vertical";
  })(Np || (Np = {}));
  const EI = (t, s, a, l, f) => {
    const g = {};
    return g.height = Tk(l + s.top, n3(t), o3(t)), a === Np.Both && (g.width = Tk(f + s.left, H_(t), bp(t))), g;
  }, o7 = (t, s, a) => {
    const l = bt.fromDom(t.getContainer()), f = EI(t, s, a, hs(l), Wo(l));
    ro(f, (g, h) => Qt(l, h, fE(g))), az(t);
  }, AI = (t) => {
    const s = dA(t);
    return s === !1 ? Np.None : s === "both" ? Np.Both : Np.Vertical;
  }, Mk = (t, s, a, l) => {
    const g = as(a * 20, l * 20);
    return o7(t, g, s), z.some(!0);
  }, s7 = (t, s) => {
    const a = AI(t);
    return a === Np.None ? z.none() : z.some(Vd("resize-handle", {
      tag: "div",
      classes: ["tox-statusbar__resize-handle"],
      attributes: { title: s.translate("Resize") },
      behaviours: [
        by.config({
          mode: "mouse",
          repositionTarget: !1,
          onDrag: (l, f, g) => o7(t, g, a),
          blockerClass: "tox-blocker"
        }),
        Kn.config({
          mode: "special",
          onLeft: () => Mk(t, a, -1, 0),
          onRight: () => Mk(t, a, 1, 0),
          onUp: () => Mk(t, a, 0, -1),
          onDown: () => Mk(t, a, 0, 1)
        }),
        oa.config({}),
        go.config({})
      ]
    }, s.icons));
  }, $E = (t, s) => {
    const a = (l, f, g) => Uo.set(l, [wa(s.translate([
      "{0} " + g,
      f[g]
    ]))]);
    return $l.sketch({
      dom: {
        tag: "button",
        classes: ["tox-statusbar__wordcount"]
      },
      components: [],
      buttonBehaviours: qt([
        rd.button(s.isDisabled),
        ma(),
        oa.config({}),
        Uo.config({}),
        cn.config({
          store: {
            mode: "memory",
            initialValue: {
              mode: "words",
              count: {
                words: 0,
                characters: 0
              }
            }
          }
        }),
        ys("wordcount-events", [
          zd((l) => {
            const f = cn.getValue(l), g = f.mode === "words" ? "characters" : "words";
            cn.setValue(l, {
              mode: g,
              count: f.count
            }), a(l, f.count, g);
          }),
          kr((l) => {
            t.on("wordCountUpdate", (f) => {
              const { mode: g } = cn.getValue(l);
              cn.setValue(l, {
                mode: g,
                count: f.wordCount
              }), a(l, f.wordCount, g);
            });
          })
        ])
      ]),
      eventOrder: {
        [Kl()]: [
          "disabling",
          "alloy.base.behaviour",
          "wordcount-events"
        ]
      }
    });
  }, zI = (t, s) => {
    const a = () => ({
      dom: {
        tag: "span",
        classes: ["tox-statusbar__branding"]
      },
      components: [{
        dom: {
          tag: "a",
          attributes: {
            href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6",
            rel: "noopener",
            target: "_blank",
            "aria-label": Su.translate([
              "Powered by {0}",
              "Tiny"
            ])
          },
          innerHtml: TI.trim()
        },
        behaviours: qt([go.config({})])
      }]
    }), l = () => {
      const g = [];
      return iA(t) && g.push(n7(t, {}, s)), t.hasPlugin("wordcount") && g.push($E(t, s)), uA(t) && g.push(a()), g.length > 0 ? [{
        dom: {
          tag: "div",
          classes: ["tox-statusbar__text-container"]
        },
        components: g
      }] : [];
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar"]
      },
      components: (() => {
        const g = l(), h = s7(t, s);
        return g.concat(h.toArray());
      })()
    };
  }, r7 = (t) => t.get().getOrDie("UI has not been rendered"), OI = (t) => {
    const s = t.inline, a = s ? c9 : t9, l = xv(t) ? yP : oP, f = Ar(), g = Ar(), h = Ar(), w = Ar(), $ = Ul().deviceType.isTouch() ? ["tox-platform-touch"] : [], I = l3(t), V = Xb(t), ne = wr({
      dom: {
        tag: "div",
        classes: ["tox-anchorbar"]
      }
    }), pe = () => g.get().bind(Xr.getHeader), Le = () => yo.fromOption(f.get(), "UI has not been rendered"), he = () => g.get().bind((io) => ne.getOpt(io)).getOrDie("Could not find a anchor bar element"), at = () => g.get().bind((io) => Xr.getToolbar(io)).getOrDie("Could not find more toolbar element"), kn = () => g.get().bind((io) => Xr.getThrobber(io)).getOrDie("Could not find throbber element"), et = qO(Le, t, he), hn = () => {
      const io = { attributes: { [db]: I ? Qu.BottomToTop : Qu.TopToBottom } }, Mt = Xr.parts.menubar({
        dom: {
          tag: "div",
          classes: ["tox-menubar"]
        },
        backstage: et,
        onEscape: () => {
          t.focus();
        }
      }), Nn = Xr.parts.toolbar({
        dom: {
          tag: "div",
          classes: ["tox-toolbar"]
        },
        getSink: Le,
        providers: et.shared.providers,
        onEscape: () => {
          t.focus();
        },
        type: V,
        lazyToolbar: at,
        lazyHeader: () => pe().getOrDie("Could not find header element"),
        ...io
      }), wo = Xr.parts["multiple-toolbar"]({
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        providers: et.shared.providers,
        onEscape: () => {
          t.focus();
        },
        type: V
      }), ts = Cv(t), ar = q_(t), jr = Jb(t), Ru = () => ts ? [wo] : ar ? [Nn] : [];
      return Xr.parts.header({
        dom: {
          tag: "div",
          classes: ["tox-editor-header"],
          ...io
        },
        components: X([
          jr ? [Mt] : [],
          Ru(),
          Sv(t) ? [] : [ne.asSpec()]
        ]),
        sticky: xv(t),
        editor: t,
        sharedBackstage: et.shared
      });
    }, xn = () => {
      const io = Xr.parts.socket({
        dom: {
          tag: "div",
          classes: ["tox-edit-area"]
        }
      }), Mt = Xr.parts.sidebar({
        dom: {
          tag: "div",
          classes: ["tox-sidebar"]
        }
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-sidebar-wrap"]
        },
        components: [
          io,
          Mt
        ]
      };
    }, Cn = () => {
      const io = i3(t), Mt = Lo(js(), io) && qr(io, "display") === "grid", Nn = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-tinymce-aux"
          ].concat($),
          attributes: { ...Su.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: qt([dl.config({ useFixed: () => l.isDocked(pe) })])
      }, wo = {
        dom: { styles: { width: document.body.clientWidth + "px" } },
        events: Ls([dt(Ry(), (jr) => {
          Qt(jr.element, "width", document.body.clientWidth + "px");
        })])
      }, ts = bc(sr(Nn, Mt ? wo : {})), ar = Rz(ts);
      return f.set(ts), w.set(ar), {
        sink: ts,
        uiMothership: ar
      };
    }, oo = () => {
      const io = hn(), Mt = xn(), Nn = Xr.parts.throbber({
        dom: {
          tag: "div",
          classes: ["tox-throbber"]
        },
        backstage: et
      }), wo = r3(t) && !s ? z.some(zI(t, et.shared.providers)) : z.none(), ts = X([
        I ? [] : [io],
        s ? [] : [Mt],
        I ? [io] : []
      ]), jr = X([
        [{
          dom: {
            tag: "div",
            classes: ["tox-editor-container"]
          },
          components: ts
        }],
        s ? [] : wo.toArray(),
        [Nn]
      ]), Ru = u3(t), of = {
        role: "application",
        ...Su.isRtl() ? { dir: "rtl" } : {},
        ...Ru ? { "aria-hidden": "true" } : {}
      }, qE = bc(Xr.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-tinymce"
          ].concat(s ? ["tox-tinymce-inline"] : []).concat(I ? ["tox-tinymce--toolbar-bottom"] : []).concat($),
          styles: {
            visibility: "hidden",
            ...Ru ? {
              opacity: "0",
              border: "0"
            } : {}
          },
          attributes: of
        },
        components: jr,
        behaviours: qt([
          ma(),
          ao.config({ disableClass: "tox-tinymce--disabled" }),
          Kn.config({
            mode: "cyclic",
            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
          })
        ])
      })), b7 = Rz(qE);
      return g.set(qE), h.set(b7), {
        mothership: b7,
        outerContainer: qE
      };
    }, so = (io) => {
      const Mt = fE(o9(t)), Nn = fE(s9(t));
      return t.inline || (Fe("div", "width", Nn) && Qt(io.element, "width", Nn), Fe("div", "height", Mt) ? Qt(io.element, "height", Mt) : Qt(io.element, "height", "400px")), Mt;
    }, us = (io) => {
      t.addShortcut("alt+F9", "focus menubar", () => {
        Xr.focusMenubar(io);
      }), t.addShortcut("alt+F10", "focus toolbar", () => {
        Xr.focusToolbar(io);
      }), t.addCommand("ToggleToolbarDrawer", () => {
        Xr.toggleToolbarDrawer(io);
      }), t.addQueryStateHandler("ToggleToolbarDrawer", () => Xr.isToolbarDrawerToggled(io));
    };
    return {
      getMothership: () => r7(h),
      getUiMothership: () => r7(w),
      backstage: et,
      renderUI: () => {
        const { mothership: io, outerContainer: Mt } = oo(), { uiMothership: Nn, sink: wo } = Cn();
        Ln(Q5(t), (IH, LH) => {
          t.ui.registry.addGroupToolbarButton(LH, IH);
        });
        const { buttons: ts, menuItems: ar, contextToolbars: jr, sidebars: Ru } = t.ui.registry.getAll(), of = c3(t), qE = {
          menuItems: ar,
          menus: Tv(t),
          menubar: nA(t),
          toolbar: of.getOrThunk(() => W_(t)),
          allowToolbarGroups: V === hl.floating,
          buttons: ts,
          sidebar: Ru
        };
        us(Mt), J2(t, io, Nn), l.setup(t, et.shared, pe), P9(t, et), tI(t, Le, et), IL(t), rC(t, kn, et.shared), v9(t, jr, wo, { backstage: et }), TC(t, wo);
        const b7 = t.getElement(), $H = so(Mt), PH = {
          mothership: io,
          uiMothership: Nn,
          outerContainer: Mt,
          sink: wo
        }, FH = {
          targetNode: b7,
          height: $H
        };
        return a.render(t, PH, qE, et, FH);
      }
    };
  }, a7 = (t, s) => {
    const a = z.from(Vo(t, "id")).fold(() => {
      const l = $n("dialog-describe");
      return to(s, "id", l), l;
    }, Je);
    to(t, "aria-describedby", a);
  }, DI = (t, s) => {
    const a = ha(t, "id").fold(() => {
      const l = $n("dialog-label");
      return to(s, "id", l), l;
    }, Je);
    to(t, "aria-labelledby", a);
  }, RI = oe([
    ut("lazySink"),
    xs("dragBlockClass"),
    Fr("getBounds", ui),
    Te("useTabstopAt", Se),
    Te("eventOrder", {}),
    Oa("modalBehaviours", [Kn]),
    il("onExecute"),
    Rc("onEscape")
  ]), PE = { sketch: Je }, FE = oe([
    vu({
      name: "draghandle",
      overrides: (t, s) => ({
        behaviours: qt([by.config({
          mode: "mouse",
          getTarget: (a) => Df(a, '[role="dialog"]').getOr(a),
          blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(s, null, 2)).message),
          getBounds: t.getDragBounds
        })])
      })
    }),
    Cc({
      schema: [ut("dom")],
      name: "title"
    }),
    Cc({
      factory: PE,
      schema: [ut("dom")],
      name: "close"
    }),
    Cc({
      factory: PE,
      schema: [ut("dom")],
      name: "body"
    }),
    vu({
      factory: PE,
      schema: [ut("dom")],
      name: "footer"
    }),
    Ki({
      factory: {
        sketch: (t, s) => ({
          ...t,
          dom: s.dom,
          components: s.components
        })
      },
      schema: [
        Te("dom", {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0px",
            top: "0px",
            right: "0px",
            bottom: "0px"
          }
        }),
        Te("components", [])
      ],
      name: "blocker"
    })
  ]), IE = (t, s, a, l) => {
    const f = Ar(), g = (V) => {
      f.set(V);
      const ne = t.lazySink(V).getOrDie(), pe = l.blocker(), Le = ne.getSystem().build({
        ...pe,
        components: pe.components.concat([bi(V)]),
        behaviours: qt([
          go.config({}),
          ys("dialog-blocker-events", [pi(Ta(), () => {
            Kn.focusIn(V);
          })])
        ])
      });
      Ml(ne, Le), Kn.focusIn(V);
    }, h = (V) => {
      f.clear(), Wr(V.element).each((ne) => {
        V.getSystem().getByDom(ne).each((pe) => {
          Nl(pe);
        });
      });
    }, w = (V) => Ti(V, t, "body"), C = (V) => Ti(V, t, "footer"), T = (V, ne) => {
      Xf.block(V, ne);
    }, D = (V) => {
      Xf.unblock(V);
    }, $ = $n("modal-events"), I = {
      ...t.eventOrder,
      [Wu()]: [$].concat(t.eventOrder["alloy.system.attached"] || [])
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      apis: {
        show: g,
        hide: h,
        getBody: w,
        getFooter: C,
        setIdle: D,
        setBusy: T
      },
      eventOrder: I,
      domModification: {
        attributes: {
          role: "dialog",
          "aria-modal": "true"
        }
      },
      behaviours: Ua(t.modalBehaviours, [
        Uo.config({}),
        Kn.config({
          mode: "cyclic",
          onEnter: t.onExecute,
          onEscape: t.onEscape,
          useTabstopAt: t.useTabstopAt
        }),
        Xf.config({ getRoot: f.get }),
        ys($, [kr((V) => {
          DI(V.element, Ti(V, t, "title").element), a7(V.element, Ti(V, t, "body").element);
        })])
      ])
    };
  }, Da = Jc({
    name: "ModalDialog",
    configFields: RI(),
    partFields: FE(),
    factory: IE,
    apis: {
      show: (t, s) => {
        t.show(s);
      },
      hide: (t, s) => {
        t.hide(s);
      },
      getBody: (t, s) => t.getBody(s),
      getFooter: (t, s) => t.getFooter(s),
      setBusy: (t, s, a) => {
        t.setBusy(s, a);
      },
      setIdle: (t, s) => {
        t.setIdle(s);
      }
    }
  }), c7 = Pn([
    fa,
    Rv
  ].concat(e1)), MI = bf, LE = [
    _3("button"),
    Ji,
    ia("align", "end", [
      "start",
      "end"
    ]),
    t2,
    sd,
    vm("buttonType", [
      "primary",
      "secondary"
    ])
  ], l7 = [
    ...LE,
    Um
  ], HE = [
    bm("type", [
      "submit",
      "cancel",
      "custom"
    ]),
    ...l7
  ], vy = [
    bm("type", ["menu"]),
    kp,
    Q_,
    Ji,
    jc("items", c7),
    ...LE
  ], i7 = rr("type", {
    submit: HE,
    cancel: HE,
    custom: HE,
    menu: vy
  }), NI = [
    fa,
    Um,
    bm("level", [
      "info",
      "warn",
      "error",
      "success"
    ]),
    b3,
    Te("url", "")
  ], EC = Pn(NI), C1 = (t) => [
    fa,
    t
  ], AC = [
    fa,
    Um,
    sd,
    _3("button"),
    Ji,
    DA,
    vm("buttonType", [
      "primary",
      "secondary",
      "toolbar"
    ]),
    t2
  ], u7 = Pn(AC), ng = [
    fa,
    Rv
  ], ga = ng.concat([e2]), zC = ng.concat([
    Mv,
    sd
  ]), d7 = Pn(zC), f7 = bf, BI = ga.concat([k3("auto")]), $I = Pn(BI), Bp = yd([
    Nv,
    Um,
    b3
  ]), PI = Pn(ga), m7 = Pr, OC = Pn(ga), g7 = Pr, FI = ng.concat([
    lu("tag", "textarea"),
    la("scriptId"),
    la("scriptUrl"),
    Cd("settings", void 0)
  ]), II = ng.concat([
    lu("tag", "textarea"),
    xa("init")
  ]), LI = kf((t) => Js("customeditor.old", gc(II), t).orThunk(() => Js("customeditor.new", gc(FI), t))), HI = Pr, oH = Pn(ga), VI = x1(), jI = (t) => [
    fa,
    Ey("columns"),
    t
  ], sH = [
    fa,
    la("html"),
    ia("presets", "presentation", [
      "presentation",
      "document"
    ])
  ], UI = Pn(sH), WI = ga.concat([
    Oc("sandboxed", !0),
    Oc("transparent", !0)
  ]), $k = Pn(WI), ZI = Pr, qI = Pn(ng.concat([pc("height")])), p7 = Pn([
    la("url"),
    wf("zoom"),
    wf("cachedWidth"),
    wf("cachedHeight")
  ]), GI = ga.concat([
    pc("inputMode"),
    pc("placeholder"),
    Oc("maximized", !1),
    sd
  ]), rH = Pn(GI), e = Pr, n = (t) => [
    fa,
    Mv,
    t
  ], o = [
    Um,
    Nv
  ], r = [
    Um,
    jc("items", T1("items", () => c))
  ], c = Up([
    Pn(o),
    Pn(r)
  ]), u = ga.concat([
    jc("items", c),
    sd
  ]), m = Pn(u), y = Pr, v = ga.concat([
    _d("items", [
      Um,
      Nv
    ]),
    gg("size", 1),
    sd
  ]), x = Pn(v), R = Pr, F = ga.concat([
    Oc("constrain", !0),
    sd
  ]), W = Pn(F), K = Pn([
    la("width"),
    la("height")
  ]), ee = ng.concat([
    Mv,
    gg("min", 0),
    gg("max", 0)
  ]), J = Pn(ee), te = Pi, ve = [
    fa,
    jc("header", Pr),
    jc("cells", Cr(Pr))
  ], De = Pn(ve), Be = ga.concat([
    pc("placeholder"),
    Oc("maximized", !1),
    sd
  ]), qe = Pn(Be), pt = Pr, pn = ga.concat([
    ia("filetype", "file", [
      "image",
      "media",
      "file"
    ]),
    sd
  ]), vt = Pn(pn), xt = Pn([
    Nv,
    wp
  ]), Zt = (t) => ba("items", "items", di(), Cr(kf((s) => Js(`Checking item of ${t}`, Xt, s).fold((a) => yo.error(wd(a)), (a) => yo.value(a))))), Xt = jp(() => fg("type", {
    alertbanner: EC,
    bar: Pn(C1(Zt("bar"))),
    button: u7,
    checkbox: d7,
    colorinput: PI,
    colorpicker: OC,
    dropzone: oH,
    grid: Pn(jI(Zt("grid"))),
    iframe: $k,
    input: rH,
    listbox: m,
    selectbox: x,
    sizeinput: W,
    slider: J,
    textarea: qe,
    urlinput: vt,
    customeditor: LI,
    htmlpanel: UI,
    imagepreview: qI,
    collection: $I,
    label: Pn(n(Zt("label"))),
    table: De,
    panel: En
  })), Qn = [
    fa,
    Te("classes", []),
    jc("items", Xt)
  ], En = Pn(Qn), fn = [
    _3("tab"),
    EA,
    jc("items", Xt)
  ], As = [
    fa,
    _d("tabs", fn)
  ], Us = Pn(As), lr = l7, qa = i7, Gt = Pn([
    la("title"),
    Ac("body", fg("type", {
      panel: En,
      tabpanel: Us
    })),
    lu("size", "normal"),
    jc("buttons", qa),
    Te("initialData", {}),
    Fr("onAction", ie),
    Fr("onChange", ie),
    Fr("onSubmit", ie),
    Fr("onClose", ie),
    Fr("onCancel", ie),
    Fr("onTabChange", ie)
  ]), Hn = (t) => Js("dialog", Gt, t), ps = Pn([
    bm("type", [
      "cancel",
      "custom"
    ]),
    ...lr
  ]), ss = Pn([
    la("title"),
    la("url"),
    wf("height"),
    wf("width"),
    mg("buttons", ps),
    Fr("onAction", ie),
    Fr("onCancel", ie),
    Fr("onClose", ie),
    Fr("onMessage", ie)
  ]), ac = (t) => Js("dialog", ss, t), ln = (t) => Bt(t) ? [t].concat(je(Jt(t), ln)) : Un(t) ? je(t, ln) : [], lo = (t) => Kt(t.type) && Kt(t.name), zn = {
    checkbox: f7,
    colorinput: m7,
    colorpicker: g7,
    dropzone: VI,
    input: e,
    iframe: ZI,
    imagepreview: p7,
    selectbox: R,
    sizeinput: K,
    slider: te,
    listbox: y,
    size: K,
    textarea: pt,
    urlinput: xt,
    customeditor: HI,
    collection: Bp,
    togglemenuitem: MI
  }, nn = (t) => z.from(zn[t.type]), is = (t) => Pt(ln(t), lo), _s = (t) => {
    const s = is(t), a = je(s, (l) => nn(l).fold(() => [], (f) => [Ac(l.name, f)]));
    return Pn(a);
  }, po = (t) => {
    const s = gi(Hn(t)), a = _s(t), l = t.initialData;
    return {
      internalDialog: s,
      dataValidator: a,
      initialData: l
    };
  }, eo = {
    open: (t, s) => {
      const a = po(s);
      return t(a.internalDialog, a.initialData, a.dataValidator);
    },
    openUrl: (t, s) => {
      const a = gi(ac(s));
      return t(a);
    },
    redial: (t) => po(t)
  }, Vs = (t) => {
    const s = [], a = {};
    return ro(t, (l, f) => {
      l.fold(() => {
        s.push(f);
      }, (g) => {
        a[f] = g;
      });
    }), s.length > 0 ? yo.error(s) : yo.value(a);
  }, Ws = (t, s, a) => {
    const l = wr(Ep.sketch((f) => ({
      dom: {
        tag: "div",
        classes: ["tox-form"].concat(t.classes)
      },
      components: Xe(t.items, (g) => c4(f, g, s, a))
    })));
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [l.asSpec()]
      }],
      behaviours: qt([
        Kn.config({
          mode: "acyclic",
          useTabstopAt: Q(sk)
        }),
        Di.memento(l),
        Fl.memento(l, {
          postprocess: (f) => Vs(f).fold((g) => (console.error(g), {}), Je)
        })
      ])
    };
  }, Ga = (t, s) => ({
    uid: t.uid,
    dom: t.dom,
    components: t.components,
    events: I_(t.action),
    behaviours: Ua(t.tabButtonBehaviours, [
      go.config({}),
      Kn.config({
        mode: "execution",
        useSpace: !0,
        useEnter: !0
      }),
      cn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      })
    ]),
    domModification: t.domModification
  }), mr = Wa({
    name: "TabButton",
    configFields: [
      Te("uid", void 0),
      ut("value"),
      ba("dom", "dom", cu(() => ({
        attributes: {
          role: "tab",
          id: $n("aria"),
          "aria-selected": "false"
        }
      })), tc()),
      xs("action"),
      Te("domModification", {}),
      Oa("tabButtonBehaviours", [
        go,
        Kn,
        cn
      ]),
      ut("view")
    ],
    factory: Ga
  }), bs = oe([
    ut("tabs"),
    ut("dom"),
    Te("clickToDismiss", !1),
    Oa("tabbarBehaviours", [
      Hs,
      Kn
    ]),
    Mf([
      "tabClass",
      "selectedClass"
    ])
  ]), gr = ku({
    factory: mr,
    name: "tabs",
    unit: "tab",
    overrides: (t) => {
      const s = (l, f) => {
        Hs.dehighlight(l, f), no(l, R1(), {
          tabbar: l,
          button: f
        });
      }, a = (l, f) => {
        Hs.highlight(l, f), no(l, Wk(), {
          tabbar: l,
          button: f
        });
      };
      return {
        action: (l) => {
          const f = l.getSystem().getByUid(t.uid).getOrDie(), g = Hs.isHighlighted(f, l);
          (() => g && t.clickToDismiss ? s : g ? ie : a)()(f, l);
        },
        domModification: { classes: [t.markers.tabClass] }
      };
    }
  }), yl = oe([gr]), bl = (t, s, a, l) => ({
    uid: t.uid,
    dom: t.dom,
    components: s,
    "debug.sketcher": "Tabbar",
    domModification: { attributes: { role: "tablist" } },
    behaviours: Ua(t.tabbarBehaviours, [
      Hs.config({
        highlightClass: t.markers.selectedClass,
        itemClass: t.markers.tabClass,
        onHighlight: (f, g) => {
          to(g.element, "aria-selected", "true");
        },
        onDehighlight: (f, g) => {
          to(g.element, "aria-selected", "false");
        }
      }),
      Kn.config({
        mode: "flow",
        getInitial: (f) => Hs.getHighlighted(f).map((g) => g.element),
        selector: "." + t.markers.tabClass,
        executeOnMove: !0
      })
    ])
  }), Tc = Jc({
    name: "Tabbar",
    configFields: bs(),
    partFields: yl(),
    factory: bl
  }), tf = (t, s) => ({
    uid: t.uid,
    dom: t.dom,
    behaviours: Ua(t.tabviewBehaviours, [Uo.config({})]),
    domModification: { attributes: { role: "tabpanel" } }
  }), oi = Wa({
    name: "Tabview",
    configFields: [Oa("tabviewBehaviours", [Uo])],
    factory: tf
  }), Il = oe([
    Te("selectFirst", !0),
    Es("onChangeTab"),
    Es("onDismissTab"),
    Te("tabs", []),
    Oa("tabSectionBehaviours", [])
  ]), Ou = Cc({
    factory: Tc,
    schema: [
      ut("dom"),
      Fi("markers", [
        ut("tabClass"),
        ut("selectedClass")
      ])
    ],
    name: "tabbar",
    defaults: (t) => ({ tabs: t.tabs })
  }), $p = Cc({
    factory: oi,
    name: "tabview"
  }), Jf = oe([
    Ou,
    $p
  ]), Qf = (t, s, a, l) => {
    const f = (h) => {
      const w = cn.getValue(h);
      Ds(h, t, "tabview").each((C) => {
        Oe(t.tabs, (D) => D.value === w).each((D) => {
          const $ = D.view();
          ha(h.element, "id").each((I) => {
            to(C.element, "aria-labelledby", I);
          }), Uo.set(C, $), t.onChangeTab(C, h, $);
        });
      });
    }, g = (h, w) => {
      Ds(h, t, "tabbar").each((C) => {
        w(C).each(Zu);
      });
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: s,
      behaviours: Db(t.tabSectionBehaviours),
      events: Ls(X([
        t.selectFirst ? [kr((h, w) => {
          g(h, Hs.getFirst);
        })] : [],
        [
          dt(Wk(), (h, w) => {
            const C = w.event.button;
            f(C);
          }),
          dt(R1(), (h, w) => {
            const C = w.event.button;
            t.onDismissTab(h, C);
          })
        ]
      ])),
      apis: {
        getViewItems: (h) => Ds(h, t, "tabview").map((w) => Uo.contents(w)).getOr([]),
        showTab: (h, w) => {
          g(h, (T) => {
            const D = Hs.getCandidates(T);
            return Oe(D, (I) => cn.getValue(I) === w).filter((I) => !Hs.isHighlighted(T, I));
          });
        }
      }
    };
  }, si = Jc({
    name: "TabSection",
    configFields: Il(),
    partFields: Jf(),
    factory: Qf,
    apis: {
      getViewItems: (t, s) => t.getViewItems(s),
      showTab: (t, s, a) => {
        t.showTab(s, a);
      }
    }
  }), ky = (t, s, a) => Xe(t, (l, f) => {
    Uo.set(a, t[f].view());
    const g = s.dom.getBoundingClientRect();
    return Uo.set(a, []), g.height;
  }), Pp = (t) => fo(Wn(t, (s, a) => s > a ? -1 : s < a ? 1 : 0)), Du = (t, s, a) => {
    const l = nl(t).dom, f = Df(t, ".tox-dialog-wrap").getOr(t), g = qr(f, "position") === "fixed";
    let h;
    g ? h = Math.max(l.clientHeight, window.innerHeight) : h = Math.max(l.offsetHeight, l.scrollHeight);
    const w = hs(s), T = s.dom.offsetLeft >= a.dom.offsetLeft + Wo(a) ? Math.max(hs(a), w) : w, D = parseInt(qr(t, "margin-top"), 10) || 0, $ = parseInt(qr(t, "margin-bottom"), 10) || 0, V = hs(t) + D + $ - T;
    return h - V;
  }, nf = (t, s) => {
    fo(t).each((a) => si.showTab(s, a.value));
  }, Fp = (t, s) => {
    Qt(t, "height", s + "px"), Qt(t, "flex-basis", s + "px");
  }, ou = (t, s, a) => {
    Df(t, '[role="dialog"]').each((l) => {
      sc(l, '[role="tablist"]').each((f) => {
        a.get().map((g) => (Qt(s, "height", "0"), Qt(s, "flex-basis", "0"), Math.min(g, Du(l, s, f)))).each((g) => {
          Fp(s, g);
        });
      });
    });
  }, S1 = (t) => sc(t, '[role="tabpanel"]'), VE = (t) => {
    const s = (() => {
      const l = Ar();
      return {
        extraEvents: [
          kr((h) => {
            const w = h.element;
            S1(w).each((C) => {
              Qt(C, "visibility", "hidden"), h.getSystem().getByDom(C).toOptional().each((T) => {
                const D = ky(t, C, T);
                Pp(D).fold(l.clear, l.set);
              }), ou(w, C, l), Dt(C, "visibility"), nf(t, h), requestAnimationFrame(() => {
                ou(w, C, l);
              });
            });
          }),
          dt(Ry(), (h) => {
            const w = h.element;
            S1(w).each((C) => {
              ou(w, C, l);
            });
          }),
          dt($z, (h, w) => {
            const C = h.element;
            S1(C).each((T) => {
              const D = Nd(or(T));
              Qt(T, "visibility", "hidden");
              const $ = j(T, "height").map((ne) => parseInt(ne, 10));
              Dt(T, "height"), Dt(T, "flex-basis");
              const I = T.dom.getBoundingClientRect().height;
              $.forall((ne) => I > ne) ? (l.set(I), ou(C, T, l)) : $.each((ne) => {
                Fp(T, ne);
              }), Dt(T, "visibility"), D.each(Xu);
            });
          })
        ],
        selectFirst: !1
      };
    })(), a = (() => ({
      extraEvents: [],
      selectFirst: !0
    }))();
    return {
      smartTabHeight: s,
      naiveTabHeight: a
    };
  }, em = "send-data-to-section", tm = "send-data-to-view", h7 = (t, s, a) => {
    const l = Xn({}), f = (T) => {
      const D = cn.getValue(T), $ = Vs(D).getOr({}), I = l.get(), V = sr(I, $);
      l.set(V);
    }, g = (T) => {
      const D = l.get();
      cn.setValue(T, D);
    }, h = Xn(null), w = Xe(t.tabs, (T) => ({
      value: T.name,
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-nav-item"]
      },
      components: [wa(a.shared.providers.translate(T.title))],
      view: () => [Ep.sketch((D) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"]
        },
        components: Xe(T.items, ($) => c4(D, $, s, a)),
        formBehaviours: qt([
          Kn.config({
            mode: "acyclic",
            useTabstopAt: Q(sk)
          }),
          ys("TabView.form.events", [
            kr(g),
            Hi(f)
          ]),
          wi.config({
            channels: Ze([
              {
                key: em,
                value: { onReceive: f }
              },
              {
                key: tm,
                value: { onReceive: g }
              }
            ])
          })
        ])
      }))]
    })), C = VE(w).smartTabHeight;
    return si.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      onChangeTab: (T, D, $) => {
        const I = cn.getValue(D);
        no(T, Bz, {
          name: I,
          oldName: h.get()
        }), h.set(I);
      },
      tabs: w,
      components: [
        si.parts.tabbar({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-nav"]
          },
          components: [Tc.parts.tabs({})],
          markers: {
            tabClass: "tox-tab",
            selectedClass: "tox-dialog__body-nav-item--active"
          },
          tabbarBehaviours: qt([oa.config({})])
        }),
        si.parts.tabview({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          }
        })
      ],
      selectFirst: C.selectFirst,
      tabSectionBehaviours: qt([
        ys("tabpanel", C.extraEvents),
        Kn.config({ mode: "acyclic" }),
        cs.config({ find: (T) => fo(si.getViewItems(T)) }),
        Fl.withComp(z.none(), (T) => (T.getSystem().broadcastOn([em], {}), l.get()), (T, D) => {
          l.set(D), T.getSystem().broadcastOn([tm], {});
        })
      ])
    });
  }, Pk = $n("update-dialog"), Fk = $n("update-title"), DC = $n("update-body"), nm = $n("update-footer"), Ik = $n("body-send-message"), xe = (t, s, a, l, f) => {
    const g = (C) => {
      const T = C.body;
      switch (T.type) {
        case "tabpanel":
          return [h7(T, C.initialData, l)];
        default:
          return [Ws(T, C.initialData, l)];
      }
    }, h = (C, T) => z.some({ isTabPanel: () => T.body.type === "tabpanel" }), w = { "aria-live": "polite" };
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"],
        attributes: {
          ...a.map((C) => ({ id: C })).getOr({}),
          ...f ? w : {}
        }
      },
      components: [],
      behaviours: qt([
        Di.childAt(0),
        Ri.config({
          channel: `${DC}-${s}`,
          updateState: h,
          renderComponents: g,
          initialData: t
        })
      ])
    };
  }, Ie = (t, s, a, l, f) => xe(t, s, z.some(a), l, f), Tt = (t, s, a) => {
    const l = xe(t, s, z.none(), a, !1);
    return Da.parts.body(l);
  }, kt = (t) => {
    const s = {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-iframe"]
        },
        components: [$6({
          dom: {
            tag: "iframe",
            attributes: { src: t.url }
          },
          behaviours: qt([
            oa.config({}),
            go.config({})
          ])
        })]
      }],
      behaviours: qt([Kn.config({
        mode: "acyclic",
        useTabstopAt: Q(sk)
      })])
    };
    return Da.parts.body(s);
  }, Zn = yp.deviceType.isTouch(), Rs = (t, s) => ({
    dom: {
      tag: "div",
      styles: { display: "none" },
      classes: ["tox-dialog__header"]
    },
    components: [
      t,
      s
    ]
  }), Cs = (t, s) => Da.parts.close($l.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": s.translate("Close")
      }
    },
    action: t,
    buttonBehaviours: qt([oa.config({})])
  })), ri = () => Da.parts.title({
    dom: {
      tag: "div",
      classes: ["tox-dialog__title"],
      innerHtml: "",
      styles: { display: "none" }
    }
  }), ud = (t, s) => Da.parts.body({
    dom: {
      tag: "div",
      classes: ["tox-dialog__body"]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-content"]
      },
      components: [{ dom: tl(`<p>${s.translate(t)}</p>`) }]
    }]
  }), om = (t) => Da.parts.footer({
    dom: {
      tag: "div",
      classes: ["tox-dialog__footer"]
    },
    components: t
  }), jE = (t, s) => [
    Zm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-start"]
      },
      components: t
    }),
    Zm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-end"]
      },
      components: s
    })
  ], RC = (t) => {
    const s = "tox-dialog", a = s + "-wrap", l = a + "__backdrop", f = s + "__disable-scroll";
    return Da.sketch({
      lazySink: t.lazySink,
      onEscape: (g) => (t.onEscape(g), z.some(!0)),
      useTabstopAt: (g) => !sk(g),
      dom: {
        tag: "div",
        classes: [s].concat(t.extraClasses),
        styles: {
          position: "relative",
          ...t.extraStyles
        }
      },
      components: [
        t.header,
        t.body,
        ...t.footer.toArray()
      ],
      parts: {
        blocker: {
          dom: tl(`<div class="${a}"></div>`),
          components: [{
            dom: {
              tag: "div",
              classes: Zn ? [
                l,
                l + "--opaque"
              ] : [l]
            }
          }]
        }
      },
      dragBlockClass: a,
      modalBehaviours: qt([
        go.config({}),
        ys("dialog-events", t.dialogEvents.concat([pi(Ta(), (g, h) => {
          Kn.focusIn(g);
        })])),
        ys("scroll-lock", [
          kr(() => {
            Ea(js(), f);
          }),
          Hi(() => {
            Yr(js(), f);
          })
        ]),
        ...t.extraBehaviours
      ]),
      eventOrder: {
        [Kl()]: ["dialog-events"],
        [Wu()]: [
          "scroll-lock",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [xf()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "scroll-lock"
        ],
        ...t.eventOrder
      }
    });
  }, UE = (t) => $l.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": t.translate("Close"),
        title: t.translate("Close")
      }
    },
    components: [Vd("close", {
      tag: "div",
      classes: ["tox-icon"]
    }, t.icons)],
    action: (s) => {
      Ts(s, oy);
    }
  }), WE = (t, s, a, l) => {
    const f = (g) => [wa(l.translate(g.title))];
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__title"],
        attributes: { ...a.map((g) => ({ id: g })).getOr({}) }
      },
      components: [],
      behaviours: qt([Ri.config({
        channel: `${Fk}-${s}`,
        initialData: t,
        renderComponents: f
      })])
    };
  }, y7 = () => ({ dom: tl('<div class="tox-dialog__draghandle"></div>') }), qo = (t, s, a, l) => Zm.sketch({
    dom: tl('<div class="tox-dialog__header"></div>'),
    components: [
      WE(t, s, z.some(a), l),
      y7(),
      UE(l)
    ],
    containerBehaviours: qt([by.config({
      mode: "mouse",
      blockerClass: "blocker",
      getTarget: (f) => Wi(f, '[role="dialog"]').getOrDie(),
      snaps: {
        getSnapPoints: () => [],
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top"
      }
    })])
  }), Ve = (t, s, a) => {
    const l = Da.parts.title(WE(t, s, z.none(), a)), f = Da.parts.draghandle(y7()), g = Da.parts.close(UE(a)), h = [l].concat(t.draggable ? [f] : []).concat([g]);
    return Zm.sketch({
      dom: tl('<div class="tox-dialog__header"></div>'),
      components: h
    });
  }, vn = (t, s, a) => Ve({
    title: a.shared.providers.translate(t),
    draggable: a.dialog.isDraggableModal()
  }, s, a.shared.providers), bo = (t, s, a) => ({
    dom: {
      tag: "div",
      classes: ["tox-dialog__busy-spinner"],
      attributes: { "aria-label": a.translate(t) },
      styles: {
        left: "0px",
        right: "0px",
        bottom: "0px",
        top: "0px",
        position: "absolute"
      }
    },
    behaviours: s,
    components: [{ dom: tl('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), Vr = (t, s, a) => ({
    onClose: () => a.closeWindow(),
    onBlock: (l) => {
      Da.setBusy(t(), (f, g) => bo(l.message, g, s));
    },
    onUnblock: () => {
      Da.setIdle(t());
    }
  }), Mi = (t, s, a, l) => {
    const f = (g, h) => z.some(h);
    return bc(RC({
      ...t,
      lazySink: l.shared.getSink,
      extraBehaviours: [
        Ri.config({
          channel: `${Pk}-${t.id}`,
          updateState: f,
          initialData: s
        }),
        Fl.memory({}),
        ...t.extraBehaviours
      ],
      onEscape: (g) => {
        Ts(g, oy);
      },
      dialogEvents: a,
      eventOrder: {
        [_m()]: [
          Ri.name(),
          wi.name()
        ],
        [Wu()]: [
          "scroll-lock",
          Ri.name(),
          "messages",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [xf()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "messages",
          Ri.name(),
          "scroll-lock"
        ]
      }
    }));
  }, Ll = (t) => {
    const s = (a) => {
      const l = Xe(a.items, (f) => {
        const g = Xn(!1);
        return {
          ...f,
          storage: g
        };
      });
      return {
        ...a,
        items: l
      };
    };
    return Xe(t, (a) => a.type === "menu" ? s(a) : a);
  }, vl = (t) => We(t, (s, a) => a.type === "menu" ? We(a.items, (f, g) => (f[g.name] = g.storage, f), s) : s, {}), Lk = (t, s) => [
    Ny(Ta(), ok),
    t(Gv, (a, l) => {
      s.onClose(), l.onClose();
    }),
    t(oy, (a, l, f, g) => {
      l.onCancel(a), Ts(g, Gv);
    }),
    dt(aT, (a, l) => s.onUnblock()),
    dt(rT, (a, l) => s.onBlock(l.event))
  ], ZE = {
    initUrlDialog: (t, s) => {
      const a = (f, g) => dt(f, (h, w) => {
        l(h, (C, T) => {
          g(t(), C, w.event, h);
        });
      }), l = (f, g) => {
        Ri.getState(f).get().each((h) => {
          g(h, f);
        });
      };
      return [
        ...Lk(a, s),
        a(qm, (f, g, h) => {
          g.onAction(f, { name: h.name });
        })
      ];
    },
    initDialog: (t, s, a) => {
      const l = (g, h) => dt(g, (w, C) => {
        f(w, (T, D) => {
          h(t(), T, C.event, w);
        });
      }), f = (g, h) => {
        Ri.getState(g).get().each((w) => {
          h(w.internalDialog, g);
        });
      };
      return [
        ...Lk(l, s),
        l(r1, (g, h) => h.onSubmit(g)),
        l(ei, (g, h, w) => {
          h.onChange(g, { name: w.name });
        }),
        l(qm, (g, h, w, C) => {
          const T = () => Kn.focusIn(C), D = (V) => Vl(V, "disabled") || ha(V, "aria-disabled").exists((ne) => ne === "true"), $ = or(C.element), I = Nd($);
          h.onAction(g, {
            name: w.name,
            value: w.value
          }), Nd($).fold(T, (V) => {
            D(V) || I.exists((ne) => br(V, ne) && D(ne)) ? T() : a().toOptional().filter((ne) => !br(ne.element, V)).each(T);
          });
        }),
        l(Bz, (g, h, w) => {
          h.onTabChange(g, {
            newTabName: w.name,
            oldTabName: w.oldName
          });
        }),
        Hi((g) => {
          const h = t();
          cn.setValue(g, h.getData());
        })
      ];
    }
  }, YI = (t, s) => U2(t, t.type, s), aH = (t, s, a) => Oe(s, (l) => l.name === a).bind((l) => l.memento.getOpt(t)), yH = (t, s) => {
    const a = s.map((w) => w.footerButtons).getOr([]), l = en(a, (w) => w.align === "start"), f = (w, C) => Zm.sketch({
      dom: {
        tag: "div",
        classes: [`tox-dialog__footer-${w}`]
      },
      components: Xe(C, (T) => T.memento.asSpec())
    }), g = f("start", l.pass), h = f("end", l.fail);
    return [
      g,
      h
    ];
  }, cH = (t, s, a) => {
    const l = (f, g) => {
      const h = Xe(g.buttons, (C) => {
        const T = wr(YI(C, a));
        return {
          name: C.name,
          align: C.align,
          memento: T
        };
      }), w = (C) => aH(f, h, C);
      return z.some({
        lookupByName: w,
        footerButtons: h
      });
    };
    return {
      dom: tl('<div class="tox-dialog__footer"></div>'),
      components: [],
      behaviours: qt([Ri.config({
        channel: `${nm}-${s}`,
        initialData: t,
        updateState: l,
        renderComponents: yH
      })])
    };
  }, bH = (t, s, a) => cH(t, s, a), lH = (t, s, a) => Da.parts.footer(cH(t, s, a)), iH = (t, s) => {
    if (t.getRoot().getSystem().isConnected()) {
      const l = cs.getCurrent(t.getFormWrapper()).getOr(t.getFormWrapper());
      return Ep.getField(l, s).orThunk(() => {
        const f = t.getFooter();
        return Ri.getState(f).get().bind((h) => h.lookupByName(s));
      });
    } else
      return z.none();
  }, vH = (t, s) => {
    const a = t.getRoot();
    return Ri.getState(a).get().map((l) => gi(Js("data", l.dataValidator, s))).getOr(s);
  }, uH = (t, s, a) => {
    const l = (ne) => {
      const pe = t.getRoot();
      pe.getSystem().isConnected() && ne(pe);
    }, V = {
      getData: () => {
        const ne = t.getRoot(), pe = ne.getSystem().isConnected() ? t.getFormWrapper() : ne, Le = cn.getValue(pe), he = Ln(a, (at) => at.get());
        return {
          ...Le,
          ...he
        };
      },
      setData: (ne) => {
        l((pe) => {
          const Le = V.getData(), he = sr(Le, ne), at = vH(t, he), kn = t.getFormWrapper();
          cn.setValue(kn, at), ro(a, (et, hn) => {
            qn(he, hn) && et.set(he[hn]);
          });
        });
      },
      setEnabled: (ne, pe) => {
        iH(t, ne).each(pe ? ao.enable : ao.disable);
      },
      focus: (ne) => {
        iH(t, ne).each(go.focus);
      },
      block: (ne) => {
        if (!Kt(ne))
          throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        l((pe) => {
          no(pe, rT, { message: ne });
        });
      },
      unblock: () => {
        l((ne) => {
          Ts(ne, aT);
        });
      },
      showTab: (ne) => {
        l((pe) => {
          const Le = t.getBody();
          Ri.getState(Le).get().exists((at) => at.isTabPanel()) && cs.getCurrent(Le).each((at) => {
            si.showTab(at, ne);
          });
        });
      },
      redial: (ne) => {
        l((pe) => {
          const Le = t.getId(), he = s(ne);
          pe.getSystem().broadcastOn([`${Pk}-${Le}`], he), pe.getSystem().broadcastOn([`${Fk}-${Le}`], he.internalDialog), pe.getSystem().broadcastOn([`${DC}-${Le}`], he.internalDialog), pe.getSystem().broadcastOn([`${nm}-${Le}`], he.internalDialog), V.setData(he.initialData);
        });
      },
      close: () => {
        l((ne) => {
          Ts(ne, Gv);
        });
      }
    };
    return V;
  }, kH = (t) => {
    switch (t) {
      case "large":
        return ["tox-dialog--width-lg"];
      case "medium":
        return ["tox-dialog--width-md"];
      default:
        return [];
    }
  }, wH = (t, s, a) => {
    const l = $n("dialog"), f = t.internalDialog, g = vn(f.title, l, a), h = Tt({
      body: f.body,
      initialData: f.initialData
    }, l, a), w = Ll(f.buttons), C = vl(w), T = lH({ buttons: w }, l, a), D = ZE.initDialog(() => pe, Vr(() => V, a.shared.providers, s), a.shared.getSink), $ = kH(f.size), I = {
      id: l,
      header: g,
      body: h,
      footer: z.some(T),
      extraClasses: $,
      extraBehaviours: [],
      extraStyles: {}
    }, V = Mi(I, t, D, a), ne = (() => {
      const Le = () => {
        const he = Da.getBody(V);
        return cs.getCurrent(he).getOr(he);
      };
      return {
        getId: oe(l),
        getRoot: oe(V),
        getBody: () => Da.getBody(V),
        getFooter: () => Da.getFooter(V),
        getFormWrapper: Le
      };
    })(), pe = uH(ne, s.redial, C);
    return {
      dialog: V,
      instanceApi: pe
    };
  }, _H = (t, s, a, l) => {
    const f = $n("dialog"), g = $n("dialog-label"), h = $n("dialog-content"), w = t.internalDialog, C = (he, at) => z.some(at), T = wr(qo({
      title: w.title,
      draggable: !0
    }, f, g, a.shared.providers)), D = wr(Ie({
      body: w.body,
      initialData: w.initialData
    }, f, h, a, l)), $ = Ll(w.buttons), I = vl($), V = wr(bH({ buttons: $ }, f, a)), ne = ZE.initDialog(() => Le, {
      onBlock: (he) => {
        Xf.block(pe, (at, kn) => bo(he.message, kn, a.shared.providers));
      },
      onUnblock: () => {
        Xf.unblock(pe);
      },
      onClose: () => s.closeWindow()
    }, a.shared.getSink), pe = bc({
      dom: {
        tag: "div",
        classes: [
          "tox-dialog",
          "tox-dialog-inline"
        ],
        attributes: {
          role: "dialog",
          ["aria-labelledby"]: g,
          ["aria-describedby"]: h
        }
      },
      eventOrder: {
        [_m()]: [
          Ri.name(),
          wi.name()
        ],
        [Kl()]: ["execute-on-form"],
        [Wu()]: [
          "reflecting",
          "execute-on-form"
        ]
      },
      behaviours: qt([
        Kn.config({
          mode: "cyclic",
          onEscape: (he) => (Ts(he, Gv), z.some(!0)),
          useTabstopAt: (he) => !sk(he) && (zt(he) !== "button" || Vo(he, "disabled") !== "disabled")
        }),
        Ri.config({
          channel: `${Pk}-${f}`,
          updateState: C,
          initialData: t
        }),
        go.config({}),
        ys("execute-on-form", ne.concat([pi(Ta(), (he, at) => {
          Kn.focusIn(he);
        })])),
        Xf.config({ getRoot: () => z.some(pe) }),
        Uo.config({}),
        Fl.memory({})
      ]),
      components: [
        T.asSpec(),
        D.asSpec(),
        V.asSpec()
      ]
    }), Le = uH({
      getId: oe(f),
      getRoot: oe(pe),
      getFooter: () => V.get(pe),
      getBody: () => D.get(pe),
      getFormWrapper: () => {
        const he = D.get(pe);
        return cs.getCurrent(he).getOr(he);
      }
    }, s.redial, I);
    return {
      dialog: pe,
      instanceApi: Le
    };
  };
  var XI = tinymce.util.Tools.resolve("tinymce.util.URI");
  const CH = (t) => {
    const s = (h) => {
      t.getSystem().isConnected() && h(t);
    };
    return {
      block: (h) => {
        if (!Kt(h))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        s((w) => {
          no(w, rT, { message: h });
        });
      },
      unblock: () => {
        s((h) => {
          Ts(h, aT);
        });
      },
      close: () => {
        s((h) => {
          Ts(h, Gv);
        });
      },
      sendMessage: (h) => {
        s((w) => {
          w.getSystem().broadcastOn([Ik], h);
        });
      }
    };
  }, SH = [
    "insertContent",
    "setContent",
    "execCommand",
    "close",
    "block",
    "unblock"
  ], dH = (t) => Bt(t) && SH.indexOf(t.mceAction) !== -1, xH = (t) => !dH(t) && Bt(t) && qn(t, "mceAction"), TH = (t, s, a) => {
    switch (a.mceAction) {
      case "insertContent":
        t.insertContent(a.content);
        break;
      case "setContent":
        t.setContent(a.content);
        break;
      case "execCommand":
        const l = tn(a.ui) ? a.ui : !1;
        t.execCommand(a.cmd, l, a.value);
        break;
      case "close":
        s.close();
        break;
      case "block":
        s.block(a.message);
        break;
      case "unblock":
        s.unblock();
        break;
    }
  }, EH = (t, s, a, l) => {
    const f = $n("dialog"), g = vn(t.title, f, l), h = kt(t), w = t.buttons.bind((at) => at.length === 0 ? z.none() : z.some(lH({ buttons: at }, f, l))), C = ZE.initUrlDialog(() => he, Vr(() => Le, l.shared.providers, s)), T = {
      ...t.height.fold(() => ({}), (at) => ({
        height: at + "px",
        "max-height": at + "px"
      })),
      ...t.width.fold(() => ({}), (at) => ({
        width: at + "px",
        "max-width": at + "px"
      }))
    }, D = t.width.isNone() && t.height.isNone() ? ["tox-dialog--width-lg"] : [], $ = new XI(t.url, { base_uri: new XI(window.location.href) }), I = `${$.protocol}://${$.host}${$.port ? ":" + $.port : ""}`, V = Bf(), ne = [
      ys("messages", [
        kr(() => {
          const at = Va(bt.fromDom(window), "message", (kn) => {
            if ($.isSameOrigin(new XI(kn.raw.origin))) {
              const et = kn.raw.data;
              dH(et) ? TH(a, he, et) : xH(et) && t.onMessage(he, et);
            }
          });
          V.set(at);
        }),
        Hi(V.clear)
      ]),
      wi.config({
        channels: {
          [Ik]: {
            onReceive: (at, kn) => {
              sc(at.element, "iframe").each((et) => {
                et.dom.contentWindow.postMessage(kn, I);
              });
            }
          }
        }
      })
    ], Le = Mi({
      id: f,
      header: g,
      body: h,
      footer: w,
      extraClasses: D,
      extraBehaviours: ne,
      extraStyles: T
    }, t, C, l), he = CH(Le);
    return {
      dialog: Le,
      instanceApi: he
    };
  }, AH = (t) => {
    const s = t.backstage.shared;
    return { open: (l, f) => {
      const g = () => {
        Da.hide(T), f();
      }, h = wr(U2({
        name: "close-alert",
        text: "OK",
        primary: !0,
        buttonType: z.some("primary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "cancel", t.backstage)), w = ri(), C = Cs(g, s.providers), T = bc(RC({
        lazySink: () => s.getSink(),
        header: Rs(w, C),
        body: ud(l, s.providers),
        footer: z.some(om(jE([], [h.asSpec()]))),
        onEscape: g,
        extraClasses: ["tox-alert-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [dt(oy, g)],
        eventOrder: {}
      }));
      Da.show(T);
      const D = h.get(T);
      go.focus(D);
    } };
  }, zH = (t) => {
    const s = t.backstage.shared;
    return { open: (l, f) => {
      const g = (I) => {
        Da.hide(D), f(I);
      }, h = wr(U2({
        name: "yes",
        text: "Yes",
        primary: !0,
        buttonType: z.some("primary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "submit", t.backstage)), w = U2({
        name: "no",
        text: "No",
        primary: !1,
        buttonType: z.some("secondary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "cancel", t.backstage), C = ri(), T = Cs(() => g(!1), s.providers), D = bc(RC({
        lazySink: () => s.getSink(),
        header: Rs(C, T),
        body: ud(l, s.providers),
        footer: z.some(om(jE([], [
          w,
          h.asSpec()
        ]))),
        onEscape: () => g(!1),
        extraClasses: ["tox-confirm-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [
          dt(oy, () => g(!1)),
          dt(r1, () => g(!0))
        ],
        eventOrder: {}
      }));
      Da.show(D);
      const $ = h.get(D);
      go.focus($);
    } };
  }, OH = (t, s) => gi(Js("data", s, t)), DH = (t) => Zv(t, ".tox-alert-dialog") || Zv(t, ".tox-confirm-dialog"), RH = (t, s, a) => s && a ? [] : [Pc.config({
    contextual: {
      lazyContext: () => z.some(Or(bt.fromDom(t.getContentAreaContainer()))),
      fadeInClass: "tox-dialog-dock-fadein",
      fadeOutClass: "tox-dialog-dock-fadeout",
      transitionClass: "tox-dialog-dock-transition"
    },
    modes: ["top"]
  })], MH = (t) => {
    const s = t.backstage, a = t.editor, l = xv(a), f = AH(t), g = zH(t), h = (ne, pe, Le) => pe !== void 0 && pe.inline === "toolbar" ? D(ne, s.shared.anchors.inlineDialog(), Le, pe.ariaAttrs) : pe !== void 0 && pe.inline === "cursor" ? D(ne, s.shared.anchors.cursor(), Le, pe.ariaAttrs) : T(ne, Le), w = (ne, pe) => C(ne, pe), C = (ne, pe) => {
      const Le = (he) => {
        const at = EH(he, {
          closeWindow: () => {
            Da.hide(at.dialog), pe(at.instanceApi);
          }
        }, a, s);
        return Da.show(at.dialog), at.instanceApi;
      };
      return eo.openUrl(Le, ne);
    }, T = (ne, pe) => {
      const Le = (he, at, kn) => {
        const et = at, xn = wH({
          dataValidator: kn,
          initialData: et,
          internalDialog: he
        }, {
          redial: eo.redial,
          closeWindow: () => {
            Da.hide(xn.dialog), pe(xn.instanceApi);
          }
        }, s);
        return Da.show(xn.dialog), xn.instanceApi.setData(et), xn.instanceApi;
      };
      return eo.open(Le, ne);
    }, D = (ne, pe, Le, he) => {
      const at = (kn, et, hn) => {
        const xn = OH(et, hn), Cn = Ar(), oo = s.shared.header.isPositionedAtTop(), so = {
          dataValidator: hn,
          initialData: xn,
          internalDialog: kn
        }, us = () => Cn.on((zs) => {
          na.reposition(zs), Pc.refresh(zs);
        }), Ms = _H(so, {
          redial: eo.redial,
          closeWindow: () => {
            Cn.on(na.hide), a.off("ResizeEditor", us), Cn.clear(), Le(Ms.instanceApi);
          }
        }, s, he), jn = bc(na.sketch({
          lazySink: s.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: {},
          ...oo ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: qt([
            ys("window-manager-inline-events", [dt(kg(), (zs, io) => {
              Ts(Ms.dialog, oy);
            })]),
            ...RH(a, l, oo)
          ]),
          isExtraPart: (zs, io) => DH(io)
        }));
        return Cn.set(jn), na.showWithin(jn, bi(Ms.dialog), { anchor: pe }, z.some(js())), (!l || !oo) && (Pc.refresh(jn), a.on("ResizeEditor", us)), Ms.instanceApi.setData(xn), Kn.focusIn(Ms.dialog), Ms.instanceApi;
      };
      return eo.open(at, ne);
    };
    return {
      open: h,
      openUrl: w,
      alert: (ne, pe) => {
        f.open(ne, () => {
          pe();
        });
      },
      close: (ne) => {
        ne.close();
      },
      confirm: (ne, pe) => {
        g.open(ne, (Le) => {
          pe(Le);
        });
      }
    };
  }, NH = (t) => {
    Qx(t), AM(t), I9(t);
  };
  var BH = () => {
    Qe.add("silver", (t) => {
      NH(t);
      const { getUiMothership: s, backstage: a, renderUI: l } = OI(t);
      KM.register(t, a.shared);
      const f = MH({
        editor: t,
        backstage: a
      });
      return {
        renderUI: l,
        getWindowManagerImpl: oe(f),
        getNotificationManagerImpl: () => Y5(t, { backstage: a }, s())
      };
    });
  };
  BH();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const To = (i, d, p) => {
    var b;
    return p(i, d.prototype) ? !0 : ((b = i.constructor) === null || b === void 0 ? void 0 : b.name) === d.name;
  }, Eo = (i) => {
    const d = typeof i;
    return i === null ? "null" : d === "object" && Array.isArray(i) ? "array" : d === "object" && To(i, String, (p, b) => b.isPrototypeOf(p)) ? "string" : d;
  }, In = (i) => (d) => Eo(d) === i, Jn = (i) => (d) => typeof d === i, uo = (i) => (d) => i === d, ho = In("string"), Kt = In("object"), Bt = In("array"), $t = uo(null), Un = Jn("boolean"), Ao = (i) => i == null, tn = (i) => !Ao(i), mt = Jn("function"), an = Jn("number"), Ge = () => {
  }, At = (i, d) => (...p) => i(d.apply(null, p)), He = (i, d) => (p) => i(d(p)), Ue = (i) => () => i, ie = (i) => i, dn = (i, d) => i === d;
  function _t(i, ...d) {
    return (...p) => {
      const b = d.concat(p);
      return i.apply(null, b);
    };
  }
  const Re = (i) => (d) => !i(d), oe = (i) => () => {
    throw new Error(i);
  }, Je = (i) => i(), rt = Ue(!1), lt = Ue(!0);
  class Q {
    constructor(d, p) {
      this.tag = d, this.value = p;
    }
    static some(d) {
      return new Q(!0, d);
    }
    static none() {
      return Q.singletonNone;
    }
    fold(d, p) {
      return this.tag ? p(this.value) : d();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(d) {
      return this.tag ? Q.some(d(this.value)) : Q.none();
    }
    bind(d) {
      return this.tag ? d(this.value) : Q.none();
    }
    exists(d) {
      return this.tag && d(this.value);
    }
    forall(d) {
      return !this.tag || d(this.value);
    }
    filter(d) {
      return !this.tag || d(this.value) ? this : Q.none();
    }
    getOr(d) {
      return this.tag ? this.value : d;
    }
    or(d) {
      return this.tag ? this : d;
    }
    getOrThunk(d) {
      return this.tag ? this.value : d();
    }
    orThunk(d) {
      return this.tag ? this : d();
    }
    getOrDie(d) {
      if (this.tag)
        return this.value;
      throw new Error(d != null ? d : "Called getOrDie on None");
    }
    static from(d) {
      return tn(d) ? Q.some(d) : Q.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(d) {
      this.tag && d(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Q.singletonNone = new Q(!1);
  const wn = Array.prototype.slice, ft = Array.prototype.indexOf, Ot = Array.prototype.push, Se = (i, d) => ft.call(i, d), Qe = (i, d) => Se(i, d) > -1, z = (i, d) => {
    for (let p = 0, b = i.length; p < b; p++) {
      const _ = i[p];
      if (d(_, p))
        return !0;
    }
    return !1;
  }, Pe = (i, d) => {
    const p = [];
    for (let b = 0; b < i; b++)
      p.push(d(b));
    return p;
  }, Rt = (i, d) => {
    const p = i.length, b = new Array(p);
    for (let _ = 0; _ < p; _++) {
      const A = i[_];
      b[_] = d(A, _);
    }
    return b;
  }, un = (i, d) => {
    for (let p = 0, b = i.length; p < b; p++) {
      const _ = i[p];
      d(_, p);
    }
  }, Ct = (i, d) => {
    for (let p = i.length - 1; p >= 0; p--) {
      const b = i[p];
      d(b, p);
    }
  }, _o = (i, d) => {
    const p = [], b = [];
    for (let _ = 0, A = i.length; _ < A; _++) {
      const N = i[_];
      (d(N, _) ? p : b).push(N);
    }
    return {
      pass: p,
      fail: b
    };
  }, Fn = (i, d) => {
    const p = [];
    for (let b = 0, _ = i.length; b < _; b++) {
      const A = i[b];
      d(A, b) && p.push(A);
    }
    return p;
  }, Sn = (i, d, p) => (Ct(i, (b, _) => {
    p = d(p, b, _);
  }), p), Dn = (i, d, p) => (un(i, (b, _) => {
    p = d(p, b, _);
  }), p), Mn = (i, d, p) => {
    for (let b = 0, _ = i.length; b < _; b++) {
      const A = i[b];
      if (d(A, b))
        return Q.some(A);
      if (p(A, b))
        break;
    }
    return Q.none();
  }, Xe = (i, d) => Mn(i, d, rt), O = (i, d) => {
    for (let p = 0, b = i.length; p < b; p++) {
      const _ = i[p];
      if (d(_, p))
        return Q.some(p);
    }
    return Q.none();
  }, gt = (i) => {
    const d = [];
    for (let p = 0, b = i.length; p < b; ++p) {
      if (!Bt(i[p]))
        throw new Error("Arr.flatten item " + p + " was not an array, input: " + i);
      Ot.apply(d, i[p]);
    }
    return d;
  }, en = (i, d) => gt(Rt(i, d)), Pt = (i, d) => {
    for (let p = 0, b = i.length; p < b; ++p) {
      const _ = i[p];
      if (d(_, p) !== !0)
        return !1;
    }
    return !0;
  }, Ne = (i) => {
    const d = wn.call(i, 0);
    return d.reverse(), d;
  }, We = (i, d) => {
    const p = {};
    for (let b = 0, _ = i.length; b < _; b++) {
      const A = i[b];
      p[String(A)] = d(A, b);
    }
    return p;
  }, Ae = (i, d) => {
    const p = wn.call(i, 0);
    return p.sort(d), p;
  }, Oe = (i, d) => d >= 0 && d < i.length ? Q.some(i[d]) : Q.none(), ae = (i) => Oe(i, 0), X = (i) => Oe(i, i.length - 1), je = (i, d) => {
    for (let p = 0; p < i.length; p++) {
      const b = d(i[p], p);
      if (b.isSome())
        return b;
    }
    return Q.none();
  }, ke = Object.keys, ue = Object.hasOwnProperty, ct = (i, d) => {
    const p = ke(i);
    for (let b = 0, _ = p.length; b < _; b++) {
      const A = p[b], N = i[A];
      d(N, A);
    }
  }, Ht = (i, d) => vo(i, (p, b) => ({
    k: b,
    v: d(p, b)
  })), vo = (i, d) => {
    const p = {};
    return ct(i, (b, _) => {
      const A = d(b, _);
      p[A.k] = A.v;
    }), p;
  }, Wn = (i) => (d, p) => {
    i[p] = d;
  }, ko = (i, d, p, b) => {
    const _ = {};
    return ct(i, (A, N) => {
      (d(A, N) ? p : b)(A, N);
    }), _;
  }, fo = (i, d) => {
    const p = {};
    return ko(i, d, Wn(p), Ge), p;
  }, yn = (i, d) => {
    const p = [];
    return ct(i, (b, _) => {
      p.push(d(b, _));
    }), p;
  }, ds = (i) => yn(i, ie), Ho = (i, d) => mn(i, d) ? Q.from(i[d]) : Q.none(), mn = (i, d) => ue.call(i, d), Io = (i, d) => mn(i, d) && i[d] !== void 0 && i[d] !== null, ro = (i) => {
    for (const d in i)
      if (ue.call(i, d))
        return !1;
    return !0;
  };
  typeof window < "u" || Function("return this;")();
  const Ln = 8, Go = 9, Ro = 11, Os = 1, Qs = 3, we = (i) => i.dom.nodeName.toLowerCase(), $e = (i) => i.dom.nodeType, Vt = (i) => (d) => $e(d) === i, Jt = (i) => $e(i) === Ln || we(i) === "#comment", ht = Vt(Os), qn = Vt(Qs), pr = Vt(Go), zr = Vt(Ro), Zs = (i) => (d) => ht(d) && we(d) === i, hr = (i, d, p) => {
    if (ho(p) || Un(p) || an(p))
      i.setAttribute(d, p + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", d, ":: Value ", p, ":: Element ", i), new Error("Attribute value was not simple");
  }, Fs = (i, d, p) => {
    hr(i.dom, d, p);
  }, Tr = (i, d) => {
    const p = i.dom;
    ct(d, (b, _) => {
      hr(p, _, b);
    });
  }, Xo = (i, d) => {
    ct(d, (p, b) => {
      p.fold(() => {
        Ss(i, b);
      }, (_) => {
        hr(i.dom, b, _);
      });
    });
  }, Gn = (i, d) => {
    const p = i.dom.getAttribute(d);
    return p === null ? void 0 : p;
  }, er = (i, d) => Q.from(Gn(i, d)), Ss = (i, d) => {
    i.dom.removeAttribute(d);
  }, ir = (i) => Dn(i.dom.attributes, (d, p) => (d[p.name] = p.value, d), {}), Ka = (i, d) => {
    const b = (d || document).createElement("div");
    if (b.innerHTML = i, !b.hasChildNodes() || b.childNodes.length > 1) {
      const _ = "HTML does not have a single root node";
      throw console.error(_, i), new Error(_);
    }
    return rs(b.childNodes[0]);
  }, Ra = (i, d) => {
    const b = (d || document).createElement(i);
    return rs(b);
  }, Ur = (i, d) => {
    const b = (d || document).createTextNode(i);
    return rs(b);
  }, rs = (i) => {
    if (i == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: i };
  }, Z = {
    fromHtml: Ka,
    fromTag: Ra,
    fromText: Ur,
    fromDom: rs,
    fromPoint: (i, d, p) => Q.from(i.dom.elementFromPoint(d, p)).map(rs)
  }, le = (i, d) => {
    const p = i.dom;
    if (p.nodeType !== Os)
      return !1;
    {
      const b = p;
      if (b.matches !== void 0)
        return b.matches(d);
      if (b.msMatchesSelector !== void 0)
        return b.msMatchesSelector(d);
      if (b.webkitMatchesSelector !== void 0)
        return b.webkitMatchesSelector(d);
      if (b.mozMatchesSelector !== void 0)
        return b.mozMatchesSelector(d);
      throw new Error("Browser lacks native selectors");
    }
  }, Ce = (i) => i.nodeType !== Os && i.nodeType !== Go && i.nodeType !== Ro || i.childElementCount === 0, wt = (i, d) => {
    const p = d === void 0 ? document : d.dom;
    return Ce(p) ? [] : Rt(p.querySelectorAll(i), Z.fromDom);
  }, Rn = (i, d) => {
    const p = d === void 0 ? document : d.dom;
    return Ce(p) ? Q.none() : Q.from(p.querySelector(i)).map(Z.fromDom);
  }, Ft = (i, d) => i.dom === d.dom, Co = (i, d) => {
    const p = i.dom, b = d.dom;
    return p === b ? !1 : p.contains(b);
  }, tr = le, Bn = (i) => Z.fromDom(i.dom.ownerDocument), No = (i) => pr(i) ? i : Bn(i), yr = (i) => Z.fromDom(No(i).dom.documentElement), bt = (i) => Z.fromDom(No(i).dom.defaultView), se = (i) => Q.from(i.dom.parentNode).map(Z.fromDom), me = (i) => Q.from(i.dom.parentElement).map(Z.fromDom), tt = (i, d) => {
    const p = mt(d) ? d : rt;
    let b = i.dom;
    const _ = [];
    for (; b.parentNode !== null && b.parentNode !== void 0; ) {
      const A = b.parentNode, N = Z.fromDom(A);
      if (_.push(N), p(N) === !0)
        break;
      b = A;
    }
    return _;
  }, Lt = (i) => Q.from(i.dom.previousSibling).map(Z.fromDom), zt = (i) => Q.from(i.dom.nextSibling).map(Z.fromDom), Nt = (i) => Rt(i.dom.childNodes, Z.fromDom), on = (i, d) => {
    const p = i.dom.childNodes;
    return Q.from(p[d]).map(Z.fromDom);
  }, Yt = (i) => on(i, 0), On = (i, d) => {
    se(i).each((b) => {
      b.dom.insertBefore(d.dom, i.dom);
    });
  }, os = (i, d) => {
    zt(i).fold(() => {
      se(i).each((_) => {
        zo(_, d);
      });
    }, (b) => {
      On(b, d);
    });
  }, $s = (i, d) => {
    Yt(i).fold(() => {
      zo(i, d);
    }, (b) => {
      i.dom.insertBefore(d.dom, b.dom);
    });
  }, zo = (i, d) => {
    i.dom.appendChild(d.dom);
  }, Ya = (i, d, p) => {
    on(i, p).fold(() => {
      zo(i, d);
    }, (b) => {
      On(b, d);
    });
  }, sa = (i, d) => {
    On(i, d), zo(d, i);
  }, Bo = (i, d) => {
    un(d, (p, b) => {
      const _ = b === 0 ? i : d[b - 1];
      os(_, p);
    });
  }, fs = (i, d) => {
    un(d, (p) => {
      zo(i, p);
    });
  }, Lo = (i) => {
    i.dom.textContent = "", un(Nt(i), (d) => {
      br(d);
    });
  }, br = (i) => {
    const d = i.dom;
    d.parentNode !== null && d.parentNode.removeChild(d);
  }, Er = (i) => {
    const d = Nt(i);
    d.length > 0 && Bo(i, d), br(i);
  }, ra = (i, d) => Z.fromDom(i.dom.cloneNode(d)), nl = (i) => ra(i, !1), pa = (i) => ra(i, !0), Wr = (i, d) => {
    const p = Z.fromTag(d), b = ir(i);
    return Tr(p, b), p;
  }, Ma = (i, d) => {
    const p = Wr(i, d), b = Nt(pa(i));
    return fs(p, b), p;
  }, ci = (i, d) => {
    const p = Wr(i, d);
    os(i, p);
    const b = Nt(i);
    return fs(p, b), br(i), p;
  }, ol = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], aa = (i) => Qe(ol, i), Xa = (i, d) => ({
    rows: i,
    columns: d
  }), kl = (i, d) => ({
    row: i,
    column: d
  }), Ja = (i, d, p) => ({
    element: i,
    rowspan: d,
    colspan: p
  }), li = (i, d, p, b) => ({
    element: i,
    rowspan: d,
    colspan: p,
    isNew: b
  }), Qa = (i, d, p, b, _, A) => ({
    element: i,
    rowspan: d,
    colspan: p,
    row: b,
    column: _,
    isLocked: A
  }), Fc = (i, d, p) => ({
    element: i,
    cells: d,
    section: p
  }), Hl = (i, d, p, b) => ({
    element: i,
    cells: d,
    section: p,
    isNew: b
  }), or = (i, d, p) => ({
    element: i,
    isNew: d,
    isLocked: p
  }), U = (i, d, p, b) => ({
    element: i,
    cells: d,
    section: p,
    isNew: b
  }), fe = (i, d, p, b) => ({
    startRow: i,
    startCol: d,
    finishRow: p,
    finishCol: b
  }), _e = (i, d, p) => ({
    element: i,
    colspan: d,
    column: p
  }), nt = (i, d) => ({
    element: i,
    columns: d
  }), Et = (i) => zr(i) && tn(i.dom.host), So = mt(Element.prototype.attachShadow) && mt(Node.prototype.getRootNode), Ko = Ue(So), js = So ? (i) => Z.fromDom(i.dom.getRootNode()) : No, Ns = (i) => {
    const d = js(i);
    return Et(d) ? Q.some(d) : Q.none();
  }, Jr = (i) => Z.fromDom(i.dom.host), to = (i) => {
    if (Ko() && tn(i.target)) {
      const d = Z.fromDom(i.target);
      if (ht(d) && Ic(d) && i.composed && i.composedPath) {
        const p = i.composedPath();
        if (p)
          return ae(p);
      }
    }
    return Q.from(i.target);
  }, Ic = (i) => tn(i.dom.shadowRoot), Vo = (i) => {
    const d = qn(i) ? i.dom.parentNode : i.dom;
    if (d == null || d.ownerDocument === null)
      return !1;
    const p = d.ownerDocument;
    return Ns(Z.fromDom(d)).fold(() => p.body.contains(d), He(Vo, Jr));
  }, ha = () => Vl(Z.fromDom(document)), Vl = (i) => {
    const d = i.dom.body;
    if (d == null)
      throw new Error("Body is not available yet");
    return Z.fromDom(d);
  }, nr = (i, d, p) => Fn(tt(i, p), d), ca = (i, d) => Fn(Nt(i), d), lc = (i, d) => {
    let p = [];
    return un(Nt(i), (b) => {
      d(b) && (p = p.concat([b])), p = p.concat(lc(b, d));
    }), p;
  }, Lc = (i, d, p) => nr(i, (b) => le(b, d), p), Qt = (i, d) => ca(i, (p) => le(p, d)), Zr = (i, d) => wt(d, i);
  var wl = (i, d, p, b, _) => i(p, b) ? Q.some(p) : mt(_) && _(p) ? Q.none() : d(p, b, _);
  const qr = (i, d, p) => {
    let b = i.dom;
    const _ = mt(p) ? p : rt;
    for (; b.parentNode; ) {
      b = b.parentNode;
      const A = Z.fromDom(b);
      if (d(A))
        return Q.some(A);
      if (_(A))
        break;
    }
    return Q.none();
  }, B = (i, d, p) => wl((_, A) => A(_), qr, i, d, p), j = (i, d) => {
    const p = (_) => d(Z.fromDom(_));
    return Xe(i.dom.childNodes, p).map(Z.fromDom);
  }, ce = (i, d) => {
    const p = (b) => {
      for (let _ = 0; _ < b.childNodes.length; _++) {
        const A = Z.fromDom(b.childNodes[_]);
        if (d(A))
          return Q.some(A);
        const N = p(b.childNodes[_]);
        if (N.isSome())
          return N;
      }
      return Q.none();
    };
    return p(i.dom);
  }, Fe = (i, d, p) => qr(i, (b) => le(b, d), p), Dt = (i, d) => j(i, (p) => le(p, d)), $o = (i, d) => Rn(d, i), Jo = (i, d, p) => wl((_, A) => le(_, A), Fe, i, d, p), it = (i, d, p = dn) => i.exists((b) => p(b, d)), hs = (i) => {
    const d = [], p = (b) => {
      d.push(b);
    };
    for (let b = 0; b < i.length; b++)
      i[b].each(p);
    return d;
  }, Ca = (i, d) => i != null ? d(i) : Q.none(), qs = (i, d) => i ? Q.some(d) : Q.none(), Hc = (i, d, p) => d === "" || i.length >= d.length && i.substr(p, p + d.length) === d, as = (i, d) => i.indexOf(d) !== -1, G = (i, d) => Hc(i, d, 0), re = (i, d) => Hc(i, d, i.length - d.length), Ye = ((i) => (d) => d.replace(i, ""))(/^\s+|\s+$/g), bn = (i) => i.length > 0, An = (i) => {
    const d = parseFloat(i);
    return isNaN(d) ? Q.none() : Q.some(d);
  }, Wo = (i) => i.style !== void 0 && mt(i.style.getPropertyValue), Xs = (i, d, p) => {
    if (!ho(p))
      throw console.error("Invalid call to CSS.set. Property ", d, ":: Value ", p, ":: Element ", i), new Error("CSS value must be a string: " + p);
    Wo(i) && i.style.setProperty(d, p);
  }, ic = (i, d) => {
    Wo(i) && i.style.removeProperty(d);
  }, Oo = (i, d, p) => {
    const b = i.dom;
    Xs(b, d, p);
  }, Ps = (i, d) => {
    const p = i.dom;
    ct(d, (b, _) => {
      Xs(p, _, b);
    });
  }, uc = (i, d) => {
    const p = i.dom, _ = window.getComputedStyle(p).getPropertyValue(d);
    return _ === "" && !Vo(i) ? dc(p, d) : _;
  }, dc = (i, d) => Wo(i) ? i.style.getPropertyValue(d) : "", su = (i, d) => {
    const p = i.dom, b = dc(p, d);
    return Q.from(b).filter((_) => _.length > 0);
  }, fc = (i, d) => {
    const p = i.dom;
    ic(p, d), it(er(i, "style").map(Ye), "") && Ss(i, "style");
  }, ms = (i, d) => {
    const p = i.dom, b = d.dom;
    Wo(p) && Wo(b) && (b.style.cssText = p.style.cssText);
  }, ur = (i, d, p = 0) => er(i, d).map((b) => parseInt(b, 10)).getOr(p), Na = (i, d) => ur(i, d, 1), _l = (i) => Zs("col")(i) ? ur(i, "span", 1) > 1 : Na(i, "colspan") > 1, Ni = (i) => Na(i, "rowspan") > 1, $r = (i, d) => parseInt(uc(i, d), 10), Cl = Ue(10), Sa = Ue(10), Mu = (i, d) => sm(i, d, lt), sm = (i, d, p) => en(Nt(i), (b) => le(b, d) ? p(b) ? [b] : [] : sm(b, d, p)), Sl = (i, d, p = rt) => {
    if (p(d))
      return Q.none();
    if (Qe(i, we(d)))
      return Q.some(d);
    const b = (_) => le(_, "table") || p(_);
    return Fe(d, i.join(","), b);
  }, xl = (i, d) => Sl([
    "td",
    "th"
  ], i, d), Bi = (i) => Mu(i, "th,td"), ru = (i) => le(i, "colgroup") ? Qt(i, "col") : en(jl(i), (d) => Qt(d, "col")), Ba = (i, d) => Jo(i, "table", d), sf = (i) => Mu(i, "tr"), jl = (i) => Ba(i).fold(Ue([]), (d) => Qt(d, "colgroup")), dd = (i, d) => Rt(i, (p) => {
    if (we(p) === "colgroup") {
      const b = Rt(ru(p), (_) => {
        const A = ur(_, "span", 1);
        return Ja(_, 1, A);
      });
      return Fc(p, b, "colgroup");
    } else {
      const b = Rt(Bi(p), (_) => {
        const A = ur(_, "rowspan", 1), N = ur(_, "colspan", 1);
        return Ja(_, A, N);
      });
      return Fc(p, b, d(p));
    }
  }), Nu = (i) => se(i).map((d) => {
    const p = we(d);
    return aa(p) ? p : "tbody";
  }).getOr("tbody"), fd = (i) => {
    const d = sf(i), b = [
      ...jl(i),
      ...d
    ];
    return dd(b, Nu);
  }, Bu = (i, d) => dd(i, () => d), Tl = (i) => {
    let d = !1, p;
    return (...b) => (d || (d = !0, p = i.apply(null, b)), p);
  }, og = (i, d, p, b) => {
    const _ = i.isiOS() && /ipad/i.test(p) === !0, A = i.isiOS() && !_, N = i.isiOS() || i.isAndroid(), L = N || b("(pointer:coarse)"), Y = _ || !A && N && b("(min-device-width:768px)"), de = A || N && !Y, Ee = d.isSafari() && i.isiOS() && /safari/i.test(p) === !1, yt = !de && !Y && !Ee;
    return {
      isiPad: Ue(_),
      isiPhone: Ue(A),
      isTablet: Ue(Y),
      isPhone: Ue(de),
      isTouch: Ue(L),
      isAndroid: i.isAndroid,
      isiOS: i.isiOS,
      isWebView: Ue(Ee),
      isDesktop: Ue(yt)
    };
  }, $u = (i, d) => {
    for (let p = 0; p < i.length; p++) {
      const b = i[p];
      if (b.test(d))
        return b;
    }
  }, rf = (i, d) => {
    const p = $u(i, d);
    if (!p)
      return {
        major: 0,
        minor: 0
      };
    const b = (_) => Number(d.replace(p, "$" + _));
    return be(b(1), b(2));
  }, mc = (i, d) => {
    const p = String(d).toLowerCase();
    return i.length === 0 ? af() : rf(i, p);
  }, af = () => be(0, 0), be = (i, d) => ({
    major: i,
    minor: d
  }), Pu = {
    nu: be,
    detect: mc,
    unknown: af
  }, El = (i, d) => je(d.brands, (p) => {
    const b = p.brand.toLowerCase();
    return Xe(i, (_) => {
      var A;
      return b === ((A = _.brand) === null || A === void 0 ? void 0 : A.toLowerCase());
    }).map((_) => ({
      current: _.name,
      version: Pu.nu(parseInt(p.version, 10), 0)
    }));
  }), cf = (i, d) => {
    const p = String(d).toLowerCase();
    return Xe(i, (b) => b.search(p));
  }, wy = (i, d) => cf(i, d).map((p) => {
    const b = Pu.detect(p.versionRegexes, d);
    return {
      current: p.name,
      version: b
    };
  }), sg = (i, d) => cf(i, d).map((p) => {
    const b = Pu.detect(p.versionRegexes, d);
    return {
      current: p.name,
      version: b
    };
  }), Is = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ya = (i) => (d) => as(d, i), Ul = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (i) => as(i, "edge/") && as(i, "chrome") && as(i, "safari") && as(i, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Is
      ],
      search: (i) => as(i, "chrome") && !as(i, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (i) => as(i, "msie") || as(i, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Is,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: ya("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: ya("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Is,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (i) => (as(i, "safari") || as(i, "mobile/")) && as(i, "applewebkit")
    }
  ], ii = [
    {
      name: "Windows",
      search: ya("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (i) => as(i, "iphone") || as(i, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: ya("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: ya("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: ya("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: ya("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: ya("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: ya("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], rm = {
    browsers: Ue(Ul),
    oses: Ue(ii)
  }, $i = "Edge", ec = "Chromium", am = "IE", rg = "Opera", cm = "Firefox", sl = "Safari", lf = () => uf({
    current: void 0,
    version: Pu.unknown()
  }), uf = (i) => {
    const d = i.current, p = i.version, b = (_) => () => d === _;
    return {
      current: d,
      version: p,
      isEdge: b($i),
      isChromium: b(ec),
      isIE: b(am),
      isOpera: b(rg),
      isFirefox: b(cm),
      isSafari: b(sl)
    };
  }, Ec = {
    unknown: lf,
    nu: uf,
    edge: Ue($i),
    chromium: Ue(ec),
    ie: Ue(am),
    opera: Ue(rg),
    firefox: Ue(cm),
    safari: Ue(sl)
  }, Qr = "Windows", au = "iOS", md = "Android", rl = "Linux", al = "macOS", lm = "Solaris", im = "FreeBSD", df = "ChromeOS", E = () => M({
    current: void 0,
    version: Pu.unknown()
  }), M = (i) => {
    const d = i.current, p = i.version, b = (_) => () => d === _;
    return {
      current: d,
      version: p,
      isWindows: b(Qr),
      isiOS: b(au),
      isAndroid: b(md),
      isMacOS: b(al),
      isLinux: b(rl),
      isSolaris: b(lm),
      isFreeBSD: b(im),
      isChromeOS: b(df)
    };
  }, H = {
    unknown: E,
    nu: M,
    windows: Ue(Qr),
    ios: Ue(au),
    android: Ue(md),
    linux: Ue(rl),
    macos: Ue(al),
    solaris: Ue(lm),
    freebsd: Ue(im),
    chromeos: Ue(df)
  }, ze = { detect: (i, d, p) => {
    const b = rm.browsers(), _ = rm.oses(), A = d.bind((Y) => El(b, Y)).orThunk(() => wy(b, i)).fold(Ec.unknown, Ec.nu), N = sg(_, i).fold(H.unknown, H.nu), L = og(N, A, i, p);
    return {
      browser: A,
      os: N,
      deviceType: L
    };
  } }, sn = (i) => window.matchMedia(i).matches;
  let Yn = Tl(() => ze.detect(navigator.userAgent, Q.from(navigator.userAgentData), sn));
  const xo = () => Yn(), Zo = (i, d) => {
    const p = (L, Y) => {
      if (!an(Y) && !Y.match(/^[0-9]+$/))
        throw new Error(i + ".set accepts only positive integer values. Value was " + Y);
      const de = L.dom;
      Wo(de) && (de.style[i] = Y + "px");
    }, b = (L) => {
      const Y = d(L);
      if (Y <= 0 || Y === null) {
        const de = uc(L, i);
        return parseFloat(de) || 0;
      }
      return Y;
    }, _ = b, A = (L, Y) => Dn(Y, (de, Ee) => {
      const yt = uc(L, Ee), Ut = yt === void 0 ? 0 : parseInt(yt, 10);
      return isNaN(Ut) ? de : de + Ut;
    }, 0);
    return {
      set: p,
      get: b,
      getOuter: _,
      aggregate: A,
      max: (L, Y, de) => {
        const Ee = A(L, de);
        return Y > Ee ? Y - Ee : 0;
      }
    };
  }, jo = (i, d) => An(i).getOr(d), ws = (i, d, p) => jo(uc(i, d), p), Or = (i, d, p, b) => {
    const _ = ws(i, `padding-${p}`, 0), A = ws(i, `padding-${b}`, 0), N = ws(i, `border-${p}-width`, 0), L = ws(i, `border-${b}-width`, 0);
    return d - _ - A - N - L;
  }, Gr = (i, d) => {
    const p = i.dom, b = p.getBoundingClientRect().width || p.offsetWidth;
    return d === "border-box" ? b : Or(i, b, "left", "right");
  }, ui = (i) => ws(i, "height", i.dom.offsetHeight), gd = (i) => ws(i, "width", i.dom.offsetWidth), Ip = (i) => Gr(i, "content-box"), Lp = Zo("width", (i) => i.dom.offsetWidth), yo = (i) => Lp.get(i), Mr = (i) => Lp.getOuter(i), cl = Ip, _y = gd, Kr = (i, d, p) => {
    const b = i.cells, _ = b.slice(0, d), A = b.slice(d), N = _.concat(p).concat(A);
    return Fu(i, N);
  }, Cy = (i, d, p) => Kr(i, d, [p]), um = (i, d, p) => {
    const b = i.cells;
    b[d] = p;
  }, Fu = (i, d) => U(i.element, d, i.section, i.isNew), ff = (i, d) => {
    const p = i.cells, b = Rt(p, d);
    return U(i.element, b, i.section, i.isNew);
  }, Gs = (i, d) => i.cells[d], $a = (i, d) => Gs(i, d).element, Al = (i) => i.cells.length, vs = (i) => {
    const d = _o(i, (p) => p.section === "colgroup");
    return {
      rows: d.fail,
      cols: d.pass
    };
  }, ag = (i, d, p) => {
    const b = Rt(i.cells, p);
    return U(d(i.element), b, i.section, !0);
  }, mf = "data-snooker-locked-cols", dm = (i) => er(i, mf).bind((d) => Q.from(d.match(/\d+/g))).map((d) => We(d, lt)), Iu = (i) => {
    const d = Dn(vs(i).rows, (b, _) => (un(_.cells, (A, N) => {
      A.isLocked && (b[N] = !0);
    }), b), {}), p = yn(d, (b, _) => parseInt(_, 10));
    return Ae(p);
  }, cg = (i, d) => i + "," + d, Sy = (i, d, p) => Q.from(i.access[cg(d, p)]), sr = (i, d, p) => {
    const b = fm(i, (_) => p(d, _.element));
    return b.length > 0 ? Q.some(b[0]) : Q.none();
  }, fm = (i, d) => {
    const p = en(i.all, (b) => b.cells);
    return Fn(p, d);
  }, di = (i) => {
    const d = {};
    let p = 0;
    return un(i.cells, (b) => {
      const _ = b.colspan;
      Pe(_, (A) => {
        const N = p + A;
        d[N] = _e(b.element, _, N);
      }), p += _;
    }), d;
  }, gf = (i) => {
    const d = {}, p = [], _ = ae(i).map((It) => It.element).bind(Ba).bind(dm).getOr({});
    let A = 0, N = 0, L = 0;
    const {
      pass: Y,
      fail: de
    } = _o(i, (It) => It.section === "colgroup");
    un(de, (It) => {
      const st = [];
      un(It.cells, (Wt) => {
        let ot = 0;
        for (; d[cg(L, ot)] !== void 0; )
          ot++;
        const gn = Io(_, ot.toString()), co = Qa(Wt.element, Wt.rowspan, Wt.colspan, L, ot, gn);
        for (let Mo = 0; Mo < Wt.colspan; Mo++)
          for (let Sr = 0; Sr < Wt.rowspan; Sr++) {
            const da = L + Sr, xr = ot + Mo, gl = cg(da, xr);
            d[gl] = co, N = Math.max(N, xr + 1);
          }
        st.push(co);
      }), A++, p.push(Fc(It.element, st, It.section)), L++;
    });
    const { columns: Ee, colgroups: yt } = X(Y).map((It) => {
      const st = di(It);
      return {
        colgroups: [nt(It.element, ds(st))],
        columns: st
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Xa(A, N),
      access: d,
      all: p,
      columns: Ee,
      colgroups: yt
    };
  }, Po = {
    fromTable: (i) => {
      const d = fd(i);
      return gf(d);
    },
    generate: gf,
    getAt: Sy,
    findItem: sr,
    filterItems: fm,
    justCells: (i) => en(i.all, (d) => d.cells),
    justColumns: (i) => ds(i.columns),
    hasColumns: (i) => ke(i.columns).length > 0,
    getColumnAt: (i, d) => Q.from(i.columns[d])
  }, hd = (i, d = lt) => {
    const p = i.grid, b = Pe(p.columns, ie), _ = Pe(p.rows, ie);
    return Rt(b, (A) => mm(() => en(_, (de) => Po.getAt(i, de, A).filter((Ee) => Ee.column === A).toArray()), (de) => de.colspan === 1 && d(de.element), () => Po.getAt(i, 0, A)));
  }, mm = (i, d, p) => {
    const b = i();
    return Xe(b, d).orThunk(() => Q.from(b[0]).orThunk(p)).map((N) => N.element);
  }, ig = (i) => {
    const d = i.grid, p = Pe(d.rows, ie), b = Pe(d.columns, ie);
    return Rt(p, (_) => mm(() => en(b, (Y) => Po.getAt(i, _, Y).filter((de) => de.row === _).fold(Ue([]), (de) => [de])), (Y) => Y.rowspan === 1, () => Po.getAt(i, _, 0)));
  }, gm = (i, d) => {
    if (d < 0 || d >= i.length - 1)
      return Q.none();
    const p = i[d].fold(() => {
      const _ = Ne(i.slice(0, d));
      return je(_, (A, N) => A.map((L) => ({
        value: L,
        delta: N + 1
      })));
    }, (_) => Q.some({
      value: _,
      delta: 0
    })), b = i[d + 1].fold(() => {
      const _ = i.slice(d + 1);
      return je(_, (A, N) => A.map((L) => ({
        value: L,
        delta: N + 1
      })));
    }, (_) => Q.some({
      value: _,
      delta: 1
    }));
    return p.bind((_) => b.map((A) => {
      const N = A.delta + _.delta;
      return Math.abs(A.value - _.value) / N;
    }));
  }, Hp = (i, d) => (p) => fi(p) === "rtl" ? d : i, fi = (i) => uc(i, "direction") === "rtl" ? "rtl" : "ltr", hf = Zo("height", (i) => {
    const d = i.dom;
    return Vo(i) ? d.getBoundingClientRect().height : d.offsetHeight;
  }), Vn = (i) => hf.get(i), Wl = (i) => hf.getOuter(i), yf = ui, Vp = (i, d) => ({
    left: i,
    top: d,
    translate: (b, _) => Vp(i + b, d + _)
  }), ll = Vp, Hu = (i) => {
    const d = i.getBoundingClientRect();
    return ll(d.left, d.top);
  }, ug = (i, d) => i !== void 0 ? i : d !== void 0 ? d : 0, mi = (i) => {
    const d = i.dom.ownerDocument, p = d.body, b = d.defaultView, _ = d.documentElement;
    if (p === i.dom)
      return ll(p.offsetLeft, p.offsetTop);
    const A = ug(b == null ? void 0 : b.pageYOffset, _.scrollTop), N = ug(b == null ? void 0 : b.pageXOffset, _.scrollLeft), L = ug(_.clientTop, p.clientTop), Y = ug(_.clientLeft, p.clientLeft);
    return xy(i).translate(N - Y, A - L);
  }, xy = (i) => {
    const d = i.dom, b = d.ownerDocument.body;
    return b === d ? ll(b.offsetLeft, b.offsetTop) : Vo(i) ? Hu(d) : ll(0, 0);
  }, pm = (i, d) => ({
    row: i,
    y: d
  }), rn = (i, d) => ({
    col: i,
    x: d
  }), Ty = (i) => mi(i).left + Mr(i), jp = (i) => mi(i).left, hm = (i, d) => rn(i, jp(d)), gc = (i, d) => rn(i, Ty(d)), Pn = (i) => mi(i).top, Cr = (i, d) => pm(i, Pn(d)), Up = (i, d) => pm(i, Pn(d) + Wl(d)), Zl = (i, d, p) => {
    if (p.length === 0)
      return [];
    const b = Rt(p.slice(1), (A, N) => A.map((L) => i(N, L))), _ = p[p.length - 1].map((A) => d(p.length - 1, A));
    return b.concat([_]);
  }, Dr = (i) => -i, yd = {
    delta: ie,
    positions: (i) => Zl(Cr, Up, i),
    edge: Pn
  }, Pi = Hp({
    delta: ie,
    edge: jp,
    positions: (i) => Zl(hm, gc, i)
  }, {
    delta: Dr,
    edge: Ty,
    positions: (i) => Zl(gc, hm, i)
  }), Pr = {
    delta: (i, d) => Pi(d).delta(i, d),
    positions: (i, d) => Pi(d).positions(i, d),
    edge: (i) => Pi(i).edge(i)
  }, bf = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, dg = (() => {
    const i = "[0-9]+", d = "[+-]?" + i, p = "[eE]" + d, b = "\\.", _ = (L) => `(?:${L})?`, N = `[+-]?(?:${[
      "Infinity",
      i + b + _(i) + _(p),
      b + i + _(p),
      i + _(p)
    ].join("|")})`;
    return new RegExp(`^(${N})(.*)$`);
  })(), ym = (i, d) => z(d, (p) => z(bf[p], (b) => i === b)), vf = (i, d) => Q.from(dg.exec(i)).bind((b) => {
    const _ = Number(b[1]), A = b[2];
    return ym(A, d) ? Q.some({
      value: _,
      unit: A
    }) : Q.none();
  }), bd = /(\d+(\.\d+)?)%/, fg = /(\d+(\.\d+)?)px|em/, x1 = Zs("col"), kf = (i, d, p) => {
    const b = me(i).getOrThunk(() => Vl(Bn(i)));
    return d(i) / p(b) * 100;
  }, vd = (i, d) => {
    Oo(i, "width", d + "px");
  }, kd = (i, d) => {
    Oo(i, "width", d + "%");
  }, Js = (i, d) => {
    Oo(i, "height", d + "px");
  }, gi = (i) => yf(i) + "px", Vc = (i, d, p, b) => {
    const _ = Ba(i).map((A) => {
      const N = p(A);
      return Math.floor(d / 100 * N);
    }).getOr(d);
    return b(i, _), _;
  }, wd = (i, d, p, b) => {
    const _ = parseFloat(i);
    return re(i, "%") && we(d) !== "table" ? Vc(d, _, p, b) : _;
  }, rr = (i) => {
    const d = gi(i);
    return d ? wd(d, i, Vn, Js) : Vn(i);
  }, T1 = (i, d, p) => {
    const b = p(i), _ = Na(i, d);
    return b / _;
  }, ba = (i, d) => su(i, d).orThunk(() => er(i, d).map((p) => p + "px")), va = (i) => ba(i, "width"), Zp = (i) => ba(i, "height"), ut = (i) => kf(i, yo, cl), Ac = (i) => x1(i) ? yo(i) : _y(i), Ey = (i) => T1(i, "rowspan", rr), la = (i) => va(i).bind((p) => vf(p, [
    "fixed",
    "relative",
    "empty"
  ])), bm = (i, d, p) => {
    Oo(i, "width", d + p);
  }, Vu = (i) => yo(i) + "px", xa = (i) => kf(i, yo, cl) + "%", E1 = (i) => va(i).exists((d) => bd.test(d)), Fi = (i) => va(i).exists((d) => fg.test(d)), _d = (i) => va(i).isNone(), jc = Ue(bd), xs = Zs("col"), zl = (i) => va(i).getOrThunk(() => Ac(i) + "px"), wf = (i) => Zp(i).getOrThunk(() => Ey(i) + "px"), pc = (i) => Rt(Po.justColumns(i), (d) => Q.from(d.element)), vm = (i) => {
    const d = xo().browser, p = d.isChromium() || d.isFirefox();
    return xs(i) ? p : !0;
  }, _f = (i, d, p, b, _, A) => i.filter(b).fold(() => A(gm(p, d)), (N) => _(N)), mg = (i, d, p, b) => {
    const _ = hd(i), A = Po.hasColumns(i) ? pc(i) : _, N = [Q.some(Pr.edge(d))].concat(Rt(Pr.positions(_, d), (Y) => Y.map((de) => de.x))), L = Re(_l);
    return Rt(A, (Y, de) => _f(Y, de, N, L, (Ee) => {
      if (vm(Ee))
        return p(Ee);
      {
        const yt = Ca(_[de], ie);
        return _f(yt, de, N, L, (Ut) => b(Q.some(yo(Ut))), b);
      }
    }, b));
  }, zc = (i) => i.map((d) => d + "px").getOr(""), km = (i, d) => mg(i, d, zl, zc), Te = (i, d, p) => mg(i, d, ut, (b) => b.fold(() => p.minCellWidth(), (_) => _ / p.pixelWidth() * 100)), Uc = (i, d, p) => mg(i, d, Ac, (b) => b.getOrThunk(p.minCellWidth)), gg = (i, d, p, b, _) => {
    const A = ig(i), N = [Q.some(p.edge(d))].concat(Rt(p.positions(A, d), (L) => L.map((Y) => Y.y)));
    return Rt(A, (L, Y) => _f(L, Y, N, Re(Ni), b, _));
  }, lu = (i, d, p) => gg(i, d, p, Ey, (b) => b.getOrThunk(Sa)), ia = (i, d, p) => gg(i, d, p, wf, zc), Oc = (i, d) => () => Vo(i) ? d(i) : parseFloat(su(i, "width").getOr("0")), Fr = (i) => {
    const d = Oc(i, yo), p = Ue(0);
    return {
      width: d,
      pixelWidth: d,
      getWidths: (_, A) => Uc(_, i, A),
      getCellDelta: p,
      singleColumnWidth: Ue([0]),
      minCellWidth: p,
      setElementWidth: Ge,
      adjustTableWidth: Ge,
      isRelative: !0,
      label: "none"
    };
  }, Cd = (i) => {
    const d = Oc(i, (Y) => parseFloat(xa(Y))), p = Oc(i, yo);
    return {
      width: d,
      pixelWidth: p,
      getWidths: (Y, de) => Te(Y, i, de),
      getCellDelta: (Y) => Y / p() * 100,
      singleColumnWidth: (Y, de) => [100 - Y],
      minCellWidth: () => Cl() / p() * 100,
      setElementWidth: kd,
      adjustTableWidth: (Y) => {
        const de = d(), Ee = Y / 100 * de, yt = de + Ee;
        kd(i, yt);
      },
      isRelative: !0,
      label: "percent"
    };
  }, ju = (i) => {
    const d = Oc(i, yo);
    return {
      width: d,
      pixelWidth: d,
      getWidths: (N, L) => Uc(N, i, L),
      getCellDelta: ie,
      singleColumnWidth: (N, L) => [Math.max(Cl(), N + L) - N],
      minCellWidth: Cl,
      setElementWidth: vd,
      adjustTableWidth: (N) => {
        const L = d() + N;
        vd(i, L);
      },
      isRelative: !1,
      label: "pixel"
    };
  }, qp = (i, d) => jc().exec(d) !== null ? Cd(i) : ju(i), Sd = {
    getTableSize: (i) => va(i).fold(() => Fr(i), (p) => qp(i, p)),
    pixelSize: ju,
    percentageSize: Cd,
    noneSize: Fr
  }, Pa = (i, d, p, b, _, A) => ({
    minRow: i,
    minCol: d,
    maxRow: p,
    maxCol: b,
    allCells: _,
    selectedCells: A
  }), A1 = (i, d) => {
    const p = i.grid.columns;
    let _ = i.grid.rows, A = p, N = 0, L = 0;
    const Y = [], de = [];
    return ct(i.access, (Ee) => {
      if (Y.push(Ee), d(Ee)) {
        de.push(Ee);
        const yt = Ee.row, Ut = yt + Ee.rowspan - 1, It = Ee.column, st = It + Ee.colspan - 1;
        yt < _ ? _ = yt : Ut > N && (N = Ut), It < A ? A = It : st > L && (L = st);
      }
    }), Pa(_, A, N, L, Y, de);
  }, k = (i, d, p) => {
    const b = i[p].element, _ = Z.fromTag("td");
    zo(_, Z.fromTag("br")), (d ? zo : $s)(b, _);
  }, S = (i, d, p, b) => {
    const _ = Fn(i, (L) => L.section !== "colgroup"), A = d.grid.columns, N = d.grid.rows;
    for (let L = 0; L < N; L++) {
      let Y = !1;
      for (let de = 0; de < A; de++)
        L < p.minRow || L > p.maxRow || de < p.minCol || de > p.maxCol || (Po.getAt(d, L, de).filter(b).isNone() ? k(_, Y, L) : Y = !0);
    }
  }, P = (i, d, p, b) => {
    ct(p.columns, (N) => {
      (N.column < d.minCol || N.column > d.maxCol) && br(N.element);
    });
    const _ = Fn(Mu(i, "tr"), (N) => N.dom.childElementCount === 0);
    un(_, br), (d.minCol === d.maxCol || d.minRow === d.maxRow) && un(Mu(i, "th,td"), (N) => {
      Ss(N, "rowspan"), Ss(N, "colspan");
    }), Ss(i, mf), Ss(i, "data-snooker-col-series"), Sd.getTableSize(i).adjustTableWidth(b);
  }, q = (i, d, p, b) => {
    if (b.minCol === 0 && d.grid.columns === b.maxCol + 1)
      return 0;
    const _ = Uc(d, i, p), A = Dn(_, (de, Ee) => de + Ee, 0), Y = Dn(_.slice(b.minCol, b.maxCol + 1), (de, Ee) => de + Ee, 0) / A * p.pixelWidth() - p.pixelWidth();
    return p.getCellDelta(Y);
  }, ge = (i, d) => {
    const p = (Ut) => le(Ut.element, d), b = pa(i), _ = fd(b), A = Sd.getTableSize(i), N = Po.generate(_), L = A1(N, p), Y = "th:not(" + d + "),td:not(" + d + ")", de = sm(b, "th,td", (Ut) => le(Ut, Y));
    un(de, br), S(_, N, L, p);
    const Ee = Po.fromTable(i), yt = q(i, Ee, A, L);
    return P(b, L, N, yt), b;
  }, Ze = "\xA0", jt = ((i, d) => {
    const p = (A) => {
      if (!i(A))
        throw new Error("Can only get " + d + " value of a " + d + " node");
      return b(A).getOr("");
    }, b = (A) => i(A) ? Q.from(A.dom.nodeValue) : Q.none();
    return {
      get: p,
      getOption: b,
      set: (A, N) => {
        if (!i(A))
          throw new Error("Can only set raw " + d + " value of a " + d + " node");
        A.dom.nodeValue = N;
      }
    };
  })(qn, "text"), mo = (i) => jt.get(i), Fo = (i) => jt.getOption(i), Rr = (i, d) => jt.set(i, d), ks = (i) => we(i) === "img" ? 1 : Fo(i).fold(() => Nt(i).length, (d) => d.length), vr = (i) => Fo(i).filter((d) => d.trim().length !== 0 || d.indexOf(Ze) > -1).isSome(), hc = [
    "img",
    "br"
  ], Fa = (i) => vr(i) || Qe(hc, we(i)), iu = (i) => ce(i, Fa), Ii = (i) => pg(i, Fa), pg = (i, d) => {
    const p = (b) => {
      const _ = Nt(b);
      for (let A = _.length - 1; A >= 0; A--) {
        const N = _[A];
        if (d(N))
          return Q.some(N);
        const L = p(N);
        if (L.isSome())
          return L;
      }
      return Q.none();
    };
    return p(i);
  }, wm = {
    scope: [
      "row",
      "col"
    ]
  }, Nr = (i) => () => {
    const d = Z.fromTag("td", i.dom);
    return zo(d, Z.fromTag("br", i.dom)), d;
  }, Wc = (i) => () => Z.fromTag("col", i.dom), Uu = (i) => () => Z.fromTag("colgroup", i.dom), uu = (i) => () => Z.fromTag("tr", i.dom), Cf = (i, d, p) => {
    const b = Ma(i, d);
    return ct(p, (_, A) => {
      _ === null ? Ss(b, A) : Fs(b, A, _);
    }), b;
  }, ql = (i) => i, hg = (i, d, p) => iu(i).map((_) => {
    const A = p.join(","), N = Lc(_, A, (L) => Ft(L, i));
    return Sn(N, (L, Y) => {
      const de = nl(Y);
      return Ss(de, "contenteditable"), zo(L, de), de;
    }, d);
  }).getOr(d), Do = (i, d) => {
    ct(wm, (p, b) => er(i, b).filter((_) => Qe(p, _)).each((_) => Fs(d, b, _)));
  }, dr = (i, d, p) => {
    const b = (N, L) => {
      ms(N.element, L), fc(L, "height"), N.colspan !== 1 && fc(L, "width");
    }, _ = (N) => {
      const L = Z.fromTag(we(N.element), d.dom), Y = p.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]), de = Y.length > 0 ? hg(N.element, L, Y) : L;
      return zo(de, Z.fromTag("br")), b(N, L), Do(N.element, L), i(N.element, L), L;
    };
    return {
      col: (N) => {
        const L = Z.fromTag(we(N.element), d.dom);
        return b(N, L), i(N.element, L), L;
      },
      colgroup: Uu(d),
      row: uu(d),
      cell: _,
      replace: Cf,
      colGap: Wc(d),
      gap: Nr(d)
    };
  }, Br = (i) => ({
    col: Wc(i),
    colgroup: Uu(i),
    row: uu(i),
    cell: Nr(i),
    replace: ql,
    colGap: Wc(i),
    gap: Nr(i)
  }), Ta = (i, d) => {
    const b = (d || document).createElement("div");
    return b.innerHTML = i, Nt(Z.fromDom(b));
  }, z1 = (i) => Rt(i, Z.fromDom), xd = (i) => Z.fromDom(i.getBody()), Li = (i) => (d) => Ft(d, xd(i)), Zc = (i) => {
    Ss(i, "data-mce-style");
    const d = (p) => Ss(p, "data-mce-style");
    un(Bi(i), d), un(ru(i), d), un(sf(i), d);
  }, Gl = (i) => Z.fromDom(i.selection.getStart()), yg = (i) => i.getBoundingClientRect().width, O1 = (i) => i.getBoundingClientRect().height, Gp = (i, d) => {
    const p = i.dom.getStyle(d, "width") || i.dom.getAttrib(d, "width");
    return Q.from(p).filter(bn);
  }, Hk = (i) => /^(\d+(\.\d+)?)%$/.test(i), MC = (i) => /^(\d+(\.\d+)?)px$/.test(i), ea = (i, d) => {
    const p = d.column, b = d.column + d.colspan - 1, _ = d.row, A = d.row + d.rowspan - 1;
    return p <= i.finishCol && b >= i.startCol && _ <= i.finishRow && A >= i.startRow;
  }, NC = (i, d) => d.column >= i.startCol && d.column + d.colspan - 1 <= i.finishCol && d.row >= i.startRow && d.row + d.rowspan - 1 <= i.finishRow, du = (i, d) => {
    let p = !0;
    const b = _t(NC, d);
    for (let _ = d.startRow; _ <= d.finishRow; _++)
      for (let A = d.startCol; A <= d.finishCol; A++)
        p = p && Po.getAt(i, _, A).exists(b);
    return p ? Q.some(d) : Q.none();
  }, D1 = (i, d) => fe(Math.min(i.row, d.row), Math.min(i.column, d.column), Math.max(i.row + i.rowspan - 1, d.row + d.rowspan - 1), Math.max(i.column + i.colspan - 1, d.column + d.colspan - 1)), Ay = (i, d, p) => {
    const b = Po.findItem(i, d, Ft), _ = Po.findItem(i, p, Ft);
    return b.bind((A) => _.map((N) => D1(A, N)));
  }, _m = (i, d, p) => Ay(i, d, p).bind((b) => du(i, b)), Kl = (i, d, p, b) => Po.findItem(i, d, Ft).bind((_) => {
    const A = p > 0 ? _.row + _.rowspan - 1 : _.row, N = b > 0 ? _.column + _.colspan - 1 : _.column;
    return Po.getAt(i, A + p, N + b).map((Y) => Y.element);
  }), ta = (i, d, p) => Ay(i, d, p).map((b) => {
    const _ = Po.filterItems(i, _t(ea, b));
    return Rt(_, (A) => A.element);
  }), bg = (i, d) => {
    const p = (b, _) => Co(_, b);
    return Po.findItem(i, d, p).map((b) => b.element);
  }, Vk = (i, d, p) => Ba(i).bind((b) => {
    const _ = Dy(b);
    return Kl(_, i, d, p);
  }), zy = (i, d, p) => {
    const b = Dy(i);
    return ta(b, d, p);
  }, vg = (i, d, p, b, _) => {
    const A = Dy(i), N = Ft(i, p) ? Q.some(d) : bg(A, d), L = Ft(i, _) ? Q.some(b) : bg(A, b);
    return N.bind((Y) => L.bind((de) => ta(A, Y, de)));
  }, Oy = (i, d, p) => {
    const b = Dy(i);
    return _m(b, d, p);
  }, Dy = Po.fromTable;
  var BC = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Sf = () => {
    const i = (de) => Z.fromDom(de.dom.cloneNode(!1)), d = (de) => No(de).dom, p = (de) => ht(de) ? we(de) === "body" ? !0 : Qe(BC, we(de)) : !1, b = (de) => ht(de) ? Qe([
      "br",
      "img",
      "hr",
      "input"
    ], we(de)) : !1, _ = (de) => ht(de) && Gn(de, "contenteditable") === "false", A = (de, Ee) => de.dom.compareDocumentPosition(Ee.dom), N = (de, Ee) => {
      const yt = ir(de);
      Tr(Ee, yt);
    }, L = (de) => {
      const Ee = we(de);
      return Qe([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], Ee);
    }, Y = (de) => ht(de) ? er(de, "lang") : Q.none();
    return {
      up: Ue({
        selector: Fe,
        closest: Jo,
        predicate: qr,
        all: tt
      }),
      down: Ue({
        selector: Zr,
        predicate: lc
      }),
      styles: Ue({
        get: uc,
        getRaw: su,
        set: Oo,
        remove: fc
      }),
      attrs: Ue({
        get: Gn,
        set: Fs,
        remove: Ss,
        copyTo: N
      }),
      insert: Ue({
        before: On,
        after: os,
        afterAll: Bo,
        append: zo,
        appendAll: fs,
        prepend: $s,
        wrap: sa
      }),
      remove: Ue({
        unwrap: Er,
        remove: br
      }),
      create: Ue({
        nu: Z.fromTag,
        clone: i,
        text: Z.fromText
      }),
      query: Ue({
        comparePosition: A,
        prevSibling: Lt,
        nextSibling: zt
      }),
      property: Ue({
        children: Nt,
        name: we,
        parent: se,
        document: d,
        isText: qn,
        isComment: Jt,
        isElement: ht,
        isSpecial: L,
        getLanguage: Y,
        getText: mo,
        setText: Rr,
        isBoundary: p,
        isEmptyTag: b,
        isNonEditable: _
      }),
      eq: Ft,
      is: tr
    };
  };
  const Ry = (i, d, p, b) => {
    const _ = p[0], A = p.slice(1);
    return b(i, d, _, A);
  }, Wu = (i, d, p) => p.length > 0 ? Ry(i, d, p, xf) : Q.none(), xf = (i, d, p, b) => {
    const _ = d(i, p);
    return Sn(b, (A, N) => {
      const L = d(i, N);
      return kg(i, A, L);
    }, _);
  }, kg = (i, d, p) => d.bind((b) => p.filter(_t(i.eq, b))), jk = (i, d) => _t(i.eq, d), Uk = (i, d, p, b = rt) => {
    const _ = [d].concat(i.up().all(d)), A = [p].concat(i.up().all(p)), N = (Ee) => O(Ee, b).fold(() => Ee, (Ut) => Ee.slice(0, Ut + 1)), L = N(_), Y = N(A), de = Xe(L, (Ee) => z(Y, jk(i, Ee)));
    return {
      firstpath: L,
      secondpath: Y,
      shared: de
    };
  }, Td = Wu, Wk = Uk, R1 = Sf(), Kp = (i, d) => Td(R1, (p, b) => i(b), d), Yp = (i, d, p) => Wk(R1, i, d, p), Ts = (i) => Fe(i, "table"), no = (i, d, p) => {
    const b = (_) => (A) => p !== void 0 && p(A) || Ft(A, _);
    return Ft(i, d) ? Q.some({
      boxes: Q.some([i]),
      start: i,
      finish: d
    }) : Ts(i).bind((_) => Ts(d).bind((A) => {
      if (Ft(_, A))
        return Q.some({
          boxes: zy(_, i, d),
          start: i,
          finish: d
        });
      if (Co(_, A)) {
        const N = Lc(d, "td,th", b(_)), L = N.length > 0 ? N[N.length - 1] : d;
        return Q.some({
          boxes: vg(_, i, _, d, A),
          start: i,
          finish: L
        });
      } else if (Co(A, _)) {
        const N = Lc(i, "td,th", b(A)), L = N.length > 0 ? N[N.length - 1] : i;
        return Q.some({
          boxes: vg(A, i, _, d, A),
          start: i,
          finish: L
        });
      } else
        return Yp(i, d).shared.bind((N) => Jo(N, "table", p).bind((L) => {
          const Y = Lc(d, "td,th", b(L)), de = Y.length > 0 ? Y[Y.length - 1] : d, Ee = Lc(i, "td,th", b(L)), yt = Ee.length > 0 ? Ee[Ee.length - 1] : i;
          return Q.some({
            boxes: vg(L, i, _, d, A),
            start: yt,
            finish: de
          });
        }));
    }));
  }, Zu = (i, d) => {
    const p = Zr(i, d);
    return p.length > 0 ? Q.some(p) : Q.none();
  }, Xp = (i, d) => Xe(i, (p) => le(p, d)), M1 = (i, d, p) => $o(i, d).bind((b) => $o(i, p).bind((_) => Kp(Ts, [
    b,
    _
  ]).map((A) => ({
    first: b,
    last: _,
    table: A
  })))), $C = (i, d) => Fe(i, "table").bind((p) => $o(p, d).bind((b) => no(b, i).bind((_) => _.boxes.map((A) => ({
    boxes: A,
    start: _.start,
    finish: _.finish
  }))))), Ls = (i, d, p, b, _) => Xp(i, _).bind((A) => Vk(A, d, p).bind((N) => $C(N, b))), qu = (i, d) => Zu(i, d), PC = (i, d, p) => M1(i, d, p).bind((b) => {
    const _ = (Y) => Ft(i, Y), A = "thead,tfoot,tbody,table", N = Fe(b.first, A, _), L = Fe(b.last, A, _);
    return N.bind((Y) => L.bind((de) => Ft(Y, de) ? Oy(b.table, b.first, b.last) : Q.none()));
  }), Tf = ie, dt = (i) => {
    const d = (b, _) => er(b, _).exists((A) => parseInt(A, 10) > 1), p = (b) => d(b, "rowspan") || d(b, "colspan");
    return i.length > 0 && Pt(i, p) ? Q.some(i) : Q.none();
  }, Jp = (i, d, p) => d.length <= 1 ? Q.none() : PC(i, p.firstSelectedSelector, p.lastSelectedSelector).map((b) => ({
    bounds: b,
    cells: d
  })), Qp = "data-mce-selected", My = "td[" + Qp + "],th[" + Qp + "]", yc = "[" + Qp + "]", Ed = "data-mce-first-selected", Ny = "td[" + Ed + "],th[" + Ed + "]", Ad = "data-mce-last-selected", N1 = "td[" + Ad + "],th[" + Ad + "]", pi = yc, kr = {
    selected: Qp,
    selectedSelector: My,
    firstSelected: Ed,
    firstSelectedSelector: Ny,
    lastSelected: Ad,
    lastSelectedSelector: N1
  }, Hi = (i, d, p) => ({
    element: p,
    mergable: Jp(d, i, kr),
    unmergable: dt(i),
    selection: Tf(i)
  }), FC = (i, d, p) => ({
    element: i,
    clipboard: d,
    generators: p
  }), zd = (i, d, p, b) => ({
    selection: Tf(i),
    clipboard: p,
    generators: b
  }), IC = (i) => Ba(i).bind((d) => qu(d, kr.firstSelectedSelector)).fold(Ue(i), (d) => d[0]), eh = (i) => (d, p) => {
    const b = we(d), _ = b === "col" || b === "colgroup" ? IC(d) : d;
    return Jo(_, i, p);
  }, Ef = eh("th,td,caption"), B1 = eh("th,td"), Gu = (i) => z1(i.model.table.getSelectedCells()), $1 = (i) => Fn(Gu(i), (d) => le(d, kr.selectedSelector)), By = (i) => Ba(i[0]).map((d) => {
    const p = ge(d, pi);
    return Zc(p), [p];
  }), Af = (i, d) => Rt(d, (p) => i.selection.serializer.serialize(p.dom, {})).join(""), wg = (i) => Rt(i, (d) => d.dom.innerText).join(""), LC = (i, d) => {
    i.on("BeforeGetContent", (p) => {
      const b = (_) => {
        p.preventDefault(), By(_).each((A) => {
          p.content = p.format === "text" ? wg(A) : Af(i, A);
        });
      };
      if (p.selection === !0) {
        const _ = $1(i);
        _.length >= 1 && b(_);
      }
    }), i.on("BeforeSetContent", (p) => {
      if (p.selection === !0 && p.paste === !0) {
        const b = Gu(i);
        ae(b).each((_) => {
          Ba(_).each((A) => {
            const N = Fn(Ta(p.content), (Y) => we(Y) !== "meta"), L = Zs("table");
            if (N.length === 1 && L(N[0])) {
              p.preventDefault();
              const Y = Z.fromDom(i.getDoc()), de = Br(Y), Ee = FC(_, N[0], de);
              d.pasteCells(A, Ee).each(() => {
                i.focus();
              });
            }
          });
        });
      }
    });
  }, fu = (i, d) => ({
    element: i,
    offset: d
  }), th = (i, d, p) => i.property().isText(d) && i.property().getText(d).trim().length === 0 || i.property().isComment(d) ? p(d).bind((b) => th(i, b, p).orThunk(() => Q.some(b))) : Q.none(), $n = (i, d) => i.property().isText(d) ? i.property().getText(d).length : i.property().children(d).length, $y = (i, d) => {
    const p = th(i, d, i.query().prevSibling).getOr(d);
    if (i.property().isText(p))
      return fu(p, $n(i, p));
    const b = i.property().children(p);
    return b.length > 0 ? $y(i, b[b.length - 1]) : fu(p, $n(i, p));
  }, nh = $y, HC = Sf(), Zk = (i) => nh(HC, i), _g = (i, d) => {
    _l(i) || la(i).each((b) => {
      const _ = b.value / 2;
      bm(i, _, b.unit), bm(d, _, b.unit);
    });
  }, Cg = (i) => Rt(i, Ue(0)), Cm = (i, d, p, b, _) => _(i.slice(0, d)).concat(b).concat(_(i.slice(p))), Ks = (i) => (d, p, b, _) => {
    if (i(b)) {
      const A = Math.max(_, d[p] - Math.abs(b)), N = Math.abs(A - d[p]);
      return b >= 0 ? N : -N;
    } else
      return b;
  }, Py = Ks((i) => i < 0), Fy = Ks(lt), qk = () => {
    const i = (L, Y, de, Ee, yt) => {
      const Ut = Py(L, Y, Ee, yt);
      return Cm(L, Y, de + 1, [
        Ut,
        0
      ], Cg);
    }, d = (L, Y, de, Ee) => {
      const yt = (100 + de) / 100, Ut = Math.max(Ee, (L[Y] + de) / yt);
      return Rt(L, (It, st) => (st === Y ? Ut : It / yt) - It);
    }, p = (L, Y, de, Ee, yt, Ut) => Ut ? d(L, Y, Ee, yt) : i(L, Y, de, Ee, yt);
    return {
      resizeTable: (L, Y) => L(Y),
      clampTableDelta: Py,
      calcLeftEdgeDeltas: p,
      calcMiddleDeltas: (L, Y, de, Ee, yt, Ut, It) => p(L, de, Ee, yt, Ut, It),
      calcRightEdgeDeltas: (L, Y, de, Ee, yt, Ut) => {
        if (Ut)
          return d(L, de, Ee, yt);
        {
          const It = Py(L, de, Ee, yt);
          return Cg(L.slice(0, de)).concat([It]);
        }
      },
      calcRedestributedWidths: (L, Y, de, Ee) => {
        if (Ee) {
          const Ut = (Y + de) / Y, It = Rt(L, (st) => st / Ut);
          return {
            delta: Ut * 100 - 100,
            newSizes: It
          };
        } else
          return {
            delta: de,
            newSizes: L
          };
      }
    };
  }, Sg = () => {
    const i = (N, L, Y, de, Ee) => {
      const yt = de >= 0 ? Y : L, Ut = Fy(N, yt, de, Ee);
      return Cm(N, L, Y + 1, [
        Ut,
        -Ut
      ], Cg);
    };
    return {
      resizeTable: (N, L, Y) => {
        Y && N(L);
      },
      clampTableDelta: (N, L, Y, de, Ee) => {
        if (Ee) {
          if (Y >= 0)
            return Y;
          {
            const yt = Dn(N, (Ut, It) => Ut + It - de, 0);
            return Math.max(-yt, Y);
          }
        } else
          return Py(N, L, Y, de);
      },
      calcLeftEdgeDeltas: i,
      calcMiddleDeltas: (N, L, Y, de, Ee, yt) => i(N, Y, de, Ee, yt),
      calcRightEdgeDeltas: (N, L, Y, de, Ee, yt) => {
        if (yt)
          return Cg(N);
        {
          const Ut = de / N.length;
          return Rt(N, Ue(Ut));
        }
      },
      calcRedestributedWidths: (N, L, Y, de) => ({
        delta: 0,
        newSizes: N
      })
    };
  }, xg = (i) => Po.fromTable(i).grid, Yl = Zs("th"), ka = (i) => Pt(i, (d) => Yl(d.element)), Iy = (i, d) => i && d ? "sectionCells" : i ? "section" : "cells", P1 = (i) => {
    const d = i.section === "thead", p = it(Sm(i.cells), "th");
    return i.section === "tfoot" ? { type: "footer" } : d || p ? {
      type: "header",
      subType: Iy(d, p)
    } : { type: "body" };
  }, Sm = (i) => {
    const d = Fn(i, (p) => Yl(p.element));
    return d.length === 0 ? Q.some("td") : d.length === i.length ? Q.some("th") : Q.none();
  }, Ly = (i) => {
    const d = Rt(i, (_) => P1(_).type), p = Qe(d, "header"), b = Qe(d, "footer");
    if (!p && !b)
      return Q.some("body");
    {
      const _ = Qe(d, "body");
      return p && !_ && !b ? Q.some("header") : !p && !_ && b ? Q.some("footer") : Q.none();
    }
  }, oh = (i) => je(i.all, (d) => {
    const p = P1(d);
    return p.type === "header" ? Q.from(p.subType) : Q.none();
  }), Vi = (i, d, p) => or(p(i.element, d), !0, i.isLocked), Ol = (i, d) => i.section !== d ? U(i.element, i.cells, d, i.isNew) : i, VC = () => ({
    transformRow: Ol,
    transformCell: (i, d, p) => {
      const b = p(i.element, d), _ = we(b) !== "td" ? ci(b, "td") : b;
      return or(_, i.isNew, i.isLocked);
    }
  }), jC = () => ({
    transformRow: Ol,
    transformCell: Vi
  }), UC = () => ({
    transformRow: (i, d) => Ol(i, d === "thead" ? "tbody" : d),
    transformCell: Vi
  }), Dl = {
    getTableSectionType: (i, d) => {
      const p = Po.fromTable(i);
      switch (oh(p).getOr(d)) {
        case "section":
          return VC();
        case "sectionCells":
          return jC();
        case "cells":
          return UC();
      }
    },
    section: VC,
    sectionCells: jC,
    cells: UC,
    fallback: () => ({
      transformRow: ie,
      transformCell: Vi
    })
  }, Dc = (i) => Jo(i, "[contenteditable]"), Gk = (i, d = !1) => Vo(i) ? i.dom.isContentEditable : Dc(i).fold(Ue(d), (p) => Od(p) === "true"), Od = (i) => i.dom.contentEditable, zf = (i, d, p, b) => {
    p === b ? Ss(i, d) : Fs(i, d, p);
  }, Hy = (i, d, p) => {
    X(Qt(i, d)).fold(() => $s(i, p), (b) => os(b, p));
  }, xm = (i, d) => {
    const p = Dt(i, d).getOrThunk(() => {
      const b = Z.fromTag(d, Bn(i).dom);
      return d === "thead" ? Hy(i, "caption,colgroup", b) : d === "colgroup" ? Hy(i, "caption", b) : zo(i, b), b;
    });
    return Lo(p), p;
  }, Tm = (i, d) => {
    const p = [], b = [], _ = (It) => Rt(It, (st) => {
      st.isNew && p.push(st.element);
      const Wt = st.element;
      return Lo(Wt), un(st.cells, (ot) => {
        ot.isNew && b.push(ot.element), zf(ot.element, "colspan", ot.colspan, 1), zf(ot.element, "rowspan", ot.rowspan, 1), zo(Wt, ot.element);
      }), Wt;
    }), A = (It) => en(It, (st) => Rt(st.cells, (Wt) => (zf(Wt.element, "span", Wt.colspan, 1), Wt.element))), N = (It, st) => {
      const Wt = xm(i, st), gn = (st === "colgroup" ? A : _)(It);
      fs(Wt, gn);
    }, L = (It) => {
      Dt(i, It).each(br);
    }, Y = (It, st) => {
      It.length > 0 ? N(It, st) : L(st);
    }, de = [], Ee = [], yt = [], Ut = [];
    return un(d, (It) => {
      switch (It.section) {
        case "thead":
          de.push(It);
          break;
        case "tbody":
          Ee.push(It);
          break;
        case "tfoot":
          yt.push(It);
          break;
        case "colgroup":
          Ut.push(It);
          break;
      }
    }), Y(Ut, "colgroup"), Y(de, "thead"), Y(Ee, "tbody"), Y(yt, "tfoot"), {
      newRows: p,
      newCells: b
    };
  }, Tg = (i) => Rt(i, (d) => {
    const p = nl(d.element);
    return un(d.cells, (b) => {
      const _ = pa(b.element);
      zf(_, "colspan", b.colspan, 1), zf(_, "rowspan", b.rowspan, 1), zo(p, _);
    }), p;
  }), sh = (i, d) => Rt(i, (p) => Gs(p, d)), rh = (i, d) => i[d], Eg = (i, d) => {
    if (i.length === 0)
      return 0;
    const p = i[0];
    return O(i, (_) => !d(p.element, _.element)).getOr(i.length);
  }, Kk = (i, d, p, b) => {
    const _ = rh(i, d), A = _.section === "colgroup", N = Eg(_.cells.slice(p), b), L = A ? 1 : Eg(sh(i.slice(d), p), b);
    return {
      colspan: N,
      rowspan: L
    };
  }, Yk = (i, d) => {
    const p = Rt(i, (_) => Rt(_.cells, rt)), b = (_, A, N, L) => {
      for (let Y = _; Y < _ + N; Y++)
        for (let de = A; de < A + L; de++)
          p[Y][de] = !0;
    };
    return Rt(i, (_, A) => {
      const N = en(_.cells, (L, Y) => {
        if (p[A][Y] === !1) {
          const de = Kk(i, A, Y, d);
          return b(A, Y, de.rowspan, de.colspan), [li(L.element, de.rowspan, de.colspan, L.isNew)];
        } else
          return [];
      });
      return Hl(_.element, N, _.section, _.isNew);
    });
  }, ah = (i, d, p) => {
    const b = [];
    un(i.colgroups, (_) => {
      const A = [];
      for (let N = 0; N < i.grid.columns; N++) {
        const L = Po.getColumnAt(i, N).map((Y) => or(Y.element, p, !1)).getOrThunk(() => or(d.colGap(), !0, !1));
        A.push(L);
      }
      b.push(U(_.element, A, "colgroup", p));
    });
    for (let _ = 0; _ < i.grid.rows; _++) {
      const A = [];
      for (let Y = 0; Y < i.grid.columns; Y++) {
        const de = Po.getAt(i, _, Y).map((Ee) => or(Ee.element, p, Ee.isLocked)).getOrThunk(() => or(d.gap(), !0, !1));
        A.push(de);
      }
      const N = i.all[_], L = U(N.element, A, N.section, p);
      b.push(L);
    }
    return b;
  }, Of = (i, d) => ah(i, d, !1), ch = (i) => Yk(i, Ft), Vy = (i, d) => je(i.all, (p) => Xe(p.cells, (b) => Ft(d, b.element))), F1 = (i, d, p) => {
    const b = Rt(d.selection, (A) => xl(A).bind((N) => Vy(i, N)).filter(p)), _ = hs(b);
    return qs(_.length > 0, _);
  }, nc = (i, d, p, b, _) => (A, N, L, Y) => {
    const de = Po.fromTable(A), Ee = Q.from(Y == null ? void 0 : Y.section).getOrThunk(Dl.fallback);
    return d(de, N).map((Ut) => {
      const It = Of(de, L), st = i(It, Ut, Ft, _(L), Ee), Wt = Iu(st.grid), ot = ch(st.grid);
      return {
        info: Ut,
        grid: ot,
        cursor: st.cursor,
        lockedColumns: Wt
      };
    }).bind((Ut) => {
      const It = Tm(A, Ut.grid), st = Q.from(Y == null ? void 0 : Y.sizing).getOrThunk(() => Sd.getTableSize(A)), Wt = Q.from(Y == null ? void 0 : Y.resize).getOrThunk(Sg);
      return p(A, Ut.grid, Ut.info, {
        sizing: st,
        resize: Wt,
        section: Ee
      }), b(A), Ss(A, mf), Ut.lockedColumns.length > 0 && Fs(A, mf, Ut.lockedColumns.join(",")), Q.some({
        cursor: Ut.cursor,
        newRows: It.newRows,
        newCells: It.newCells
      });
    });
  }, WC = (i, d) => xl(d.element).bind((p) => Vy(i, p).map((b) => ({
    ...b,
    generators: d.generators,
    clipboard: d.clipboard
  }))), Ag = (i, d) => F1(i, d, lt).map((p) => ({
    cells: p,
    generators: d.generators,
    clipboard: d.clipboard
  })), Xk = (i, d) => d.mergable, ZC = (i, d) => d.unmergable, hi = (i, d) => F1(i, d, lt), mu = (i, d) => F1(i, d, (p) => !p.isLocked), zg = (i, d) => Vy(i, d).exists((p) => !p.isLocked), I1 = (i, d) => Pt(d, (p) => zg(i, p)), Ea = (i, d) => Xk(i, d).filter((p) => I1(i, p.cells)), qC = (i, d) => ZC(i, d).filter((p) => I1(i, p)), Yr = (i, d, p, b) => {
    const _ = vs(i).rows;
    if (_.length === 0)
      return i;
    for (let A = d.startRow; A <= d.finishRow; A++)
      for (let N = d.startCol; N <= d.finishCol; N++) {
        const L = _[A], Y = Gs(L, N).isLocked;
        um(L, N, or(b(), !1, Y));
      }
    return i;
  }, oc = (i, d, p, b) => {
    const _ = vs(i).rows;
    let A = !0;
    for (let N = 0; N < _.length; N++)
      for (let L = 0; L < Al(_[0]); L++) {
        const Y = _[N], de = Gs(Y, L), Ee = de.element, yt = p(Ee, d);
        yt && !A ? um(Y, L, or(b(), !0, de.isLocked)) : yt && (A = !1);
      }
    return i;
  }, ji = (i, d) => Dn(i, (p, b) => z(p, (_) => d(_.element, b.element)) ? p : p.concat([b]), []), qc = (i, d, p, b) => (d > 0 && d < i[0].cells.length && un(i, (_) => {
    const A = _.cells[d - 1];
    let N = 0;
    const L = b();
    for (; _.cells.length > d + N && p(A.element, _.cells[d + N].element); )
      um(_, d + N, or(L, !0, _.cells[d + N].isLocked)), N++;
  }), i), Jk = (i, d, p, b) => {
    const _ = vs(i).rows;
    if (d > 0 && d < _.length) {
      const A = _[d - 1].cells, N = ji(A, p);
      un(N, (L) => {
        let Y = Q.none();
        for (let de = d; de < _.length; de++)
          for (let Ee = 0; Ee < Al(_[0]); Ee++) {
            const yt = _[de], Ut = Gs(yt, Ee);
            p(Ut.element, L.element) && (Y.isNone() && (Y = Q.some(b())), Y.each((st) => {
              um(yt, Ee, or(st, !0, Ut.isLocked));
            }));
          }
      });
    }
    return i;
  }, Qk = (i) => {
    const d = (A) => A(i), p = Ue(i), b = () => _, _ = {
      tag: !0,
      inner: i,
      fold: (A, N) => N(i),
      isValue: lt,
      isError: rt,
      map: (A) => yi.value(A(i)),
      mapError: b,
      bind: d,
      exists: d,
      forall: d,
      getOr: p,
      or: b,
      getOrThunk: p,
      orThunk: b,
      getOrDie: p,
      each: (A) => {
        A(i);
      },
      toOptional: () => Q.some(i)
    };
    return _;
  }, L1 = (i) => {
    const d = () => p, p = {
      tag: !1,
      inner: i,
      fold: (b, _) => b(i),
      isValue: rt,
      isError: lt,
      map: d,
      mapError: (b) => yi.error(b(i)),
      bind: d,
      exists: rt,
      forall: lt,
      getOr: ie,
      or: ie,
      getOrThunk: Je,
      orThunk: Je,
      getOrDie: oe(String(i)),
      each: Ge,
      toOptional: Q.none
    };
    return p;
  }, yi = {
    value: Qk,
    error: L1,
    fromOption: (i, d) => i.fold(() => L1(d), Qk)
  }, GC = (i, d, p) => {
    if (i.row >= d.length || i.column > Al(d[0]))
      return yi.error("invalid start address out of table bounds, row: " + i.row + ", column: " + i.column);
    const b = d.slice(i.row), _ = b[0].cells.slice(i.column), A = Al(p[0]), N = p.length;
    return yi.value({
      rowDelta: b.length - N,
      colDelta: _.length - A
    });
  }, H1 = (i, d) => {
    const p = Al(i[0]), b = Al(d[0]);
    return {
      rowDelta: 0,
      colDelta: p - b
    };
  }, jy = (i, d) => {
    const p = i.length, b = d.length;
    return {
      rowDelta: p - b,
      colDelta: 0
    };
  }, Uy = (i, d, p, b) => {
    const _ = d.section === "colgroup" ? p.col : p.cell;
    return Pe(i, (A) => or(_(), !0, b(A)));
  }, KC = (i, d, p, b) => {
    const _ = i[i.length - 1];
    return i.concat(Pe(d, () => {
      const A = _.section === "colgroup" ? p.colgroup : p.row, N = ag(_, A, ie), L = Uy(N.cells.length, N, p, (Y) => mn(b, Y.toString()));
      return Fu(N, L);
    }));
  }, Wy = (i, d, p, b) => Rt(i, (_) => {
    const A = Uy(d, _, p, rt);
    return Kr(_, b, A);
  }), Dd = (i, d, p) => Rt(i, (b) => Dn(p, (_, A) => {
    const N = Uy(1, b, d, lt)[0];
    return Cy(_, A, N);
  }, b)), lh = (i, d, p) => {
    const b = d.colDelta < 0 ? Wy : ie, _ = d.rowDelta < 0 ? KC : ie, A = Iu(i), N = Al(i[0]), L = z(A, (Ee) => Ee === N - 1), Y = b(i, Math.abs(d.colDelta), p, L ? N - 1 : N), de = Iu(Y);
    return _(Y, Math.abs(d.rowDelta), p, We(de, lt));
  }, YC = (i, d, p, b) => {
    const _ = Gs(i[d], p), A = _t(b, _.element), N = i[d];
    return i.length > 1 && Al(N) > 1 && (p > 0 && A($a(N, p - 1)) || p < N.cells.length - 1 && A($a(N, p + 1)) || d > 0 && A($a(i[d - 1], p)) || d < i.length - 1 && A($a(i[d + 1], p)));
  }, ew = (i, d, p, b, _, A) => {
    const N = i.row, L = i.column, Y = p.length, de = Al(p[0]), Ee = N + Y, yt = L + de + A.length, Ut = We(A, lt);
    for (let It = N; It < Ee; It++) {
      let st = 0;
      for (let Wt = L; Wt < yt; Wt++) {
        if (Ut[Wt]) {
          st++;
          continue;
        }
        YC(d, It, Wt, _) && oc(d, $a(d[It], Wt), _, b.cell);
        const ot = Wt - L - st, gn = Gs(p[It - N], ot), co = gn.element, Mo = b.replace(co);
        um(d[It], Wt, or(Mo, !0, gn.isLocked));
      }
    }
    return d;
  }, XC = (i, d, p) => {
    const b = Al(d[0]), _ = vs(d).cols.length + i.row, A = Pe(b - i.column, (L) => L + i.column), N = Xe(A, (L) => Pt(p, (Y) => Y !== L)).getOr(b - 1);
    return {
      row: _,
      column: N
    };
  }, tw = (i, d, p) => Fn(p, (b) => b >= i.column && b <= Al(d[0]) + i.column), nw = (i, d, p, b, _) => {
    const A = Iu(d), N = XC(i, d, A), L = vs(p).rows, Y = tw(N, L, A);
    return GC(N, d, L).map((Ee) => {
      const yt = {
        ...Ee,
        colDelta: Ee.colDelta - Y.length
      }, Ut = lh(d, yt, b), It = Iu(Ut), st = tw(N, L, It);
      return ew(N, Ut, L, b, _, st);
    });
  }, ow = (i, d, p, b, _) => {
    qc(d, i, _, b.cell);
    const A = jy(p, d), N = lh(p, A, b), L = jy(d, N), Y = lh(d, L, b);
    return Rt(Y, (de, Ee) => Kr(de, i, N[Ee].cells));
  }, V1 = (i, d, p, b, _) => {
    Jk(d, i, _, b.cell);
    const A = Iu(d), N = H1(d, p), L = {
      ...N,
      colDelta: N.colDelta - A.length
    }, Y = lh(d, L, b), {
      cols: de,
      rows: Ee
    } = vs(Y), yt = Iu(Y), Ut = H1(p, d), It = {
      ...Ut,
      colDelta: Ut.colDelta + yt.length
    }, st = Dd(p, b, yt), Wt = lh(st, It, b);
    return [
      ...de,
      ...Ee.slice(0, i),
      ...Wt,
      ...Ee.slice(i, Ee.length)
    ];
  }, JC = (i, d, p, b) => ag(i, (_) => b(_, p), d), Og = (i, d, p, b, _) => {
    const { rows: A, cols: N } = vs(i), L = A.slice(0, d), Y = A.slice(d), de = JC(A[p], (Ee, yt) => d > 0 && d < A.length && b($a(A[d - 1], yt), $a(A[d], yt)) ? Gs(A[d], yt) : or(_(Ee.element, b), !0, Ee.isLocked), b, _);
    return [
      ...N,
      ...L,
      de,
      ...Y
    ];
  }, QC = (i, d, p, b, _, A, N) => {
    if (p === "colgroup" || !b) {
      const L = Gs(i, _);
      return or(N(L.element, A), !0, !1);
    } else
      return Gs(i, d);
  }, Dg = (i, d, p, b, _) => Rt(i, (A) => {
    const N = d > 0 && d < Al(A) && b($a(A, d - 1), $a(A, d)), L = QC(A, d, A.section, N, p, b, _);
    return Cy(A, d, L);
  }), j1 = (i, d) => en(i, (p) => {
    const b = p.cells, _ = Sn(d, (A, N) => N >= 0 && N < A.length ? A.slice(0, N).concat(A.slice(N + 1)) : A, b);
    return _.length > 0 ? [U(p.element, _, p.section, p.isNew)] : [];
  }), wa = (i, d, p) => {
    const { rows: b, cols: _ } = vs(i);
    return [
      ..._,
      ...b.slice(0, d),
      ...b.slice(p + 1)
    ];
  }, ih = (i, d, p, b) => $a(i[d], p) !== void 0 && d > 0 && b($a(i[d - 1], p), $a(i[d], p)), U1 = (i, d, p) => d > 0 && p($a(i, d - 1), $a(i, d)), Zy = (i, d, p, b) => ih(i, d, p, b) || U1(i[d], p, b), qy = (i, d) => Pt(d, ie) && ka(i.cells) ? lt : (b, _, A) => !(we(b.element) === "th" && d[A]), bc = (i, d) => Pt(d, ie) && ka(i) ? lt : (b, _, A) => !(we(b.element) === "th" && d[_]), bi = (i, d, p, b) => {
    const _ = (N) => N === "row" ? Ni(d) : _l(d), A = (N) => _(N) ? `${N}group` : N;
    return i ? Yl(d) ? A(p) : null : b && Yl(d) ? A(p === "row" ? "col" : "row") : null;
  }, sw = (i, d) => (p, b, _) => Q.some(bi(i, p.element, "col", d[_])), W1 = (i, d) => (p, b) => Q.some(bi(i, p.element, "row", d[b])), Yu = (i, d, p) => or(p(i.element, d), !0, i.isLocked), Rd = (i, d, p, b, _, A, N) => {
    const L = (Y) => z(d, (de) => p(Y.element, de.element));
    return Rt(i, (Y, de) => ff(Y, (Ee, yt) => {
      if (L(Ee)) {
        const Ut = N(Ee, de, yt) ? _(Ee, p, b) : Ee;
        return A(Ut, de, yt).each((It) => {
          Xo(Ut.element, { scope: Q.from(It) });
        }), Ut;
      } else
        return Ee;
    }));
  }, rw = (i, d, p) => en(i, (b, _) => Zy(i, _, d, p) ? [] : [Gs(b, d)]), Ke = (i, d, p) => {
    const b = i[d];
    return en(b.cells, (_, A) => Zy(i, d, A, p) ? [] : [_]);
  }, Df = (i, d, p, b, _) => {
    const A = vs(i).rows, N = en(d, (Ee) => rw(A, Ee, b)), L = Rt(A, (Ee) => ka(Ee.cells)), Y = bc(N, L), de = W1(p, L);
    return Rd(i, N, b, _, Yu, de, Y);
  }, eS = (i, d, p, b, _, A, N) => {
    const { cols: L, rows: Y } = vs(i), de = Y[d[0]], Ee = en(d, (ot) => Ke(Y, ot, _)), yt = Rt(de.cells, (ot, gn) => ka(rw(Y, gn, _))), Ut = [...Y];
    un(d, (ot) => {
      Ut[ot] = N.transformRow(Y[ot], p);
    });
    const It = [
      ...L,
      ...Ut
    ], st = qy(de, yt), Wt = sw(b, yt);
    return Rd(It, Ee, _, A, N.transformCell, Wt, st);
  }, sc = (i, d, p, b) => {
    const _ = vs(i).rows, A = Rt(d, (N) => Gs(_[N.row], N.column));
    return Rd(i, A, p, b, Yu, Q.none, lt);
  }, Ia = { generate: (i) => {
    if (!Bt(i))
      throw new Error("cases must be an array");
    if (i.length === 0)
      throw new Error("there must be at least one case");
    const d = [], p = {};
    return un(i, (b, _) => {
      const A = ke(b);
      if (A.length !== 1)
        throw new Error("one and only one name per case");
      const N = A[0], L = b[N];
      if (p[N] !== void 0)
        throw new Error("duplicate key detected:" + N);
      if (N === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Bt(L))
        throw new Error("case arguments must be an array");
      d.push(N), p[N] = (...Y) => {
        const de = Y.length;
        if (de !== L.length)
          throw new Error("Wrong number of arguments to case " + N + ". Expected " + L.length + " (" + L + "), got " + de);
        return {
          fold: (...yt) => {
            if (yt.length !== i.length)
              throw new Error("Wrong number of arguments to fold. Expected " + i.length + ", got " + yt.length);
            return yt[_].apply(null, Y);
          },
          match: (yt) => {
            const Ut = ke(yt);
            if (d.length !== Ut.length)
              throw new Error("Wrong number of arguments to match. Expected: " + d.join(",") + `
Actual: ` + Ut.join(","));
            if (!Pt(d, (st) => Qe(Ut, st)))
              throw new Error("Not all branches were specified when using match. Specified: " + Ut.join(", ") + `
Required: ` + d.join(", "));
            return yt[N].apply(null, Y);
          },
          log: (yt) => {
            console.log(yt, {
              constructors: d,
              constructor: N,
              params: Y
            });
          }
        };
      };
    }), p;
  } }, Rf = { ...Ia.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) }, aw = (i, d) => i.length === 0 ? Rf.none() : i.length === 1 ? Rf.only(0) : d === 0 ? Rf.left(0, 1) : d === i.length - 1 ? Rf.right(d - 1, d) : d > 0 && d < i.length - 1 ? Rf.middle(d - 1, d, d + 1) : Rf.none(), Md = (i, d, p, b, _) => {
    const A = i.slice(0), N = aw(i, d), L = Ue(Rt(A, Ue(0))), Y = (Ut) => b.singleColumnWidth(A[Ut], p), de = (Ut, It) => _.calcLeftEdgeDeltas(A, Ut, It, p, b.minCellWidth(), b.isRelative), Ee = (Ut, It, st) => _.calcMiddleDeltas(A, Ut, It, st, p, b.minCellWidth(), b.isRelative), yt = (Ut, It) => _.calcRightEdgeDeltas(A, Ut, It, p, b.minCellWidth(), b.isRelative);
    return N.fold(L, Y, de, Ee, yt);
  }, Z1 = (i, d, p) => {
    let b = 0;
    for (let _ = i; _ < d; _++)
      b += p[_] !== void 0 ? p[_] : 0;
    return b;
  }, Em = (i, d) => {
    const p = Po.justCells(i);
    return Rt(p, (b) => {
      const _ = Z1(b.column, b.column + b.colspan, d);
      return {
        element: b.element,
        width: _,
        colspan: b.colspan
      };
    });
  }, q1 = (i, d) => {
    const p = Po.justColumns(i);
    return Rt(p, (b, _) => ({
      element: b.element,
      width: d[_],
      colspan: b.colspan
    }));
  }, cw = (i, d) => {
    const p = Po.justCells(i);
    return Rt(p, (b) => {
      const _ = Z1(b.row, b.row + b.rowspan, d);
      return {
        element: b.element,
        height: _,
        rowspan: b.rowspan
      };
    });
  }, nS = (i, d) => Rt(i.all, (p, b) => ({
    element: p.element,
    height: d[b]
  })), lw = (i) => Sn(i, (d, p) => d + p, 0), oS = (i, d) => Po.hasColumns(i) ? q1(i, d) : Em(i, d), G1 = (i, d, p) => {
    const b = oS(i, d);
    un(b, (_) => {
      p.setElementWidth(_.element, _.width);
    });
  }, uh = (i, d, p, b, _) => {
    const A = Po.fromTable(i), N = _.getCellDelta(d), L = _.getWidths(A, _), Y = p === A.grid.columns - 1, de = b.clampTableDelta(L, p, N, _.minCellWidth(), Y), Ee = Md(L, p, de, _, b), yt = Rt(Ee, (Ut, It) => Ut + L[It]);
    G1(A, yt, _), b.resizeTable(_.adjustTableWidth, de, Y);
  }, Gy = (i, d, p, b) => {
    const _ = Po.fromTable(i), A = lu(_, i, b), N = Rt(A, (Ee, yt) => p === yt ? Math.max(d + Ee, Sa()) : Ee), L = cw(_, N), Y = nS(_, N);
    un(Y, (Ee) => {
      Js(Ee.element, Ee.height);
    }), un(L, (Ee) => {
      Js(Ee.element, Ee.height);
    });
    const de = lw(N);
    Js(i, de);
  }, iw = (i, d, p, b, _) => {
    const A = Po.generate(d), N = b.getWidths(A, b), L = b.pixelWidth(), { newSizes: Y, delta: de } = _.calcRedestributedWidths(N, L, p.pixelDelta, b.isRelative);
    G1(A, Y, b), b.adjustTableWidth(de);
  }, Ky = (i, d, p, b) => {
    const _ = Po.generate(d), A = b.getWidths(_, b);
    G1(_, A, b);
  }, Rg = (i) => Dn(i, (p, b) => z(p, (A) => A.column === b.column) ? p : p.concat([b]), []).sort((p, b) => p.column - b.column), Yy = Zs("col"), K1 = Zs("colgroup"), Mg = (i) => we(i) === "tr" || K1(i), Mf = (i) => {
    const d = ur(i, "colspan", 1), p = ur(i, "rowspan", 1);
    return {
      element: i,
      colspan: d,
      rowspan: p
    };
  }, Xy = (i, d = Mf) => {
    const p = (L) => Yy(L.element) ? i.col(L) : i.cell(L), b = (L) => K1(L.element) ? i.colgroup(L) : i.row(L), _ = (L) => {
      if (Mg(L))
        return b({ element: L });
      {
        const Y = L, de = p(d(Y));
        return A = Q.some({
          item: Y,
          replacement: de
        }), de;
      }
    };
    let A = Q.none();
    return { getOrInit: (L, Y) => A.fold(() => _(L), (de) => Y(L, de.item) ? de.replacement : _(L)) };
  }, Es = (i) => (d) => {
    const p = [], b = (N, L) => Xe(p, (Y) => L(Y.item, N)), _ = (N) => {
      const L = i === "td" ? { scope: null } : {}, Y = d.replace(N, i, L);
      return p.push({
        item: N,
        sub: Y
      }), Y;
    };
    return { replaceOrInit: (N, L) => {
      if (Mg(N) || Yy(N))
        return N;
      {
        const Y = N;
        return b(Y, L).fold(() => _(Y), (de) => L(N, de.item) ? de.sub : _(Y));
      }
    } };
  }, il = (i) => er(i, "scope").map((d) => d.substr(0, 3)), Rc = {
    modification: Xy,
    transform: Es,
    merging: (i) => ({
      unmerge: (b) => {
        const _ = il(b);
        return _.each((A) => Fs(b, "scope", A)), () => {
          const A = i.cell({
            element: b,
            colspan: 1,
            rowspan: 1
          });
          return fc(A, "width"), fc(b, "width"), _.each((N) => Fs(A, "scope", N)), A;
        };
      },
      merge: (b) => {
        const _ = () => {
          const A = hs(Rt(b, il));
          if (A.length === 0)
            return Q.none();
          {
            const N = A[0], L = [
              "row",
              "col"
            ];
            return z(A, (de) => de !== N && Qe(L, de)) ? Q.none() : Q.from(N);
          }
        };
        return fc(b[0], "width"), _().fold(() => Ss(b[0], "scope"), (A) => Fs(b[0], "scope", A + "group")), Ue(b[0]);
      }
    })
  }, fr = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], uw = (i, d) => {
    const p = i.property().name(d);
    return Qe([
      "ol",
      "ul"
    ], p);
  }, Y1 = (i, d) => {
    const p = i.property().name(d);
    return Qe(fr, p);
  }, La = (i, d) => Qe([
    "br",
    "img",
    "hr",
    "input"
  ], i.property().name(d)), gu = Sf(), dw = (i) => Y1(gu, i), ul = (i) => uw(gu, i), KE = (i) => La(gu, i), vi = (i) => {
    const d = Zs("br"), p = (Y) => Pt(Y, (de) => d(de) || qn(de) && mo(de).trim().length === 0), b = (Y) => we(Y) === "li" || qr(Y, ul).isSome(), _ = (Y) => zt(Y).map((de) => dw(de) ? !0 : KE(de) ? we(de) !== "img" : !1).getOr(!1), A = (Y) => Ii(Y).bind((de) => {
      const Ee = _(de);
      return se(de).map((yt) => Ee === !0 || b(yt) || d(de) || dw(yt) && !Ft(Y, yt) ? [] : [Z.fromTag("br")]);
    }).getOr([]), L = (() => {
      const Y = en(i, (de) => {
        const Ee = Nt(de);
        return p(Ee) ? [] : Ee.concat(A(de));
      });
      return Y.length === 0 ? [Z.fromTag("br")] : Y;
    })();
    Lo(i[0]), fs(i[0], L);
  }, Jy = (i) => Gk(i, !0), Qy = (i) => {
    Bi(i).length === 0 && br(i);
  }, Bg = (i, d) => ({
    grid: i,
    cursor: d
  }), fw = (i) => je(i, (d) => je(d.cells, (p) => {
    const b = p.element;
    return qs(Jy(b), b);
  })), mw = (i, d, p) => {
    var b, _;
    const A = vs(i).rows;
    return Q.from((_ = (b = A[d]) === null || b === void 0 ? void 0 : b.cells[p]) === null || _ === void 0 ? void 0 : _.element).filter(Jy).orThunk(() => fw(A));
  }, Gc = (i, d, p) => {
    const b = mw(i, d, p);
    return Bg(i, b);
  }, $g = (i) => Dn(i, (p, b) => z(p, (A) => A.row === b.row) ? p : p.concat([b]), []).sort((p, b) => p.row - b.row), Pg = (i, d, p, b) => {
    const _ = d[0].row, A = $g(d), N = Sn(A, (L, Y) => ({
      grid: Og(L.grid, _, Y.row + L.delta, p, b.getOrInit),
      delta: L.delta + 1
    }), {
      grid: i,
      delta: 0
    }).grid;
    return Gc(N, _, d[0].column);
  }, ki = (i, d, p, b) => {
    const _ = $g(d), A = _[_.length - 1], N = A.row + A.rowspan, L = Sn(_, (Y, de) => Og(Y, N, de.row, p, b.getOrInit), i);
    return Gc(L, N, d[0].column);
  }, X1 = (i, d, p, b) => {
    const _ = d.details, A = Rg(_), N = A[0].column, L = Sn(A, (Y, de) => ({
      grid: Dg(Y.grid, N, de.column + Y.delta, p, b.getOrInit),
      delta: Y.delta + 1
    }), {
      grid: i,
      delta: 0
    }).grid;
    return Gc(L, _[0].row, N);
  }, rc = (i, d, p, b) => {
    const _ = d.details, A = _[_.length - 1], N = A.column + A.colspan, L = Rg(_), Y = Sn(L, (de, Ee) => Dg(de, N, Ee.column, p, b.getOrInit), i);
    return Gc(Y, _[0].row, N);
  }, sS = (i, d, p, b) => {
    const _ = Rg(d), A = Rt(_, (L) => L.column), N = Df(i, A, !0, p, b.replaceOrInit);
    return Gc(N, d[0].row, d[0].column);
  }, Nf = (i, d, p, b) => {
    const _ = sc(i, d, p, b.replaceOrInit);
    return Gc(_, d[0].row, d[0].column);
  }, J1 = (i, d, p, b) => {
    const _ = Rg(d), A = Rt(_, (L) => L.column), N = Df(i, A, !1, p, b.replaceOrInit);
    return Gc(N, d[0].row, d[0].column);
  }, _n = (i, d, p, b) => {
    const _ = sc(i, d, p, b.replaceOrInit);
    return Gc(_, d[0].row, d[0].column);
  }, Fg = (i, d) => (p, b, _, A, N) => {
    const L = $g(b), Y = Rt(L, (Ee) => Ee.row), de = eS(p, Y, i, d, _, A.replaceOrInit, N);
    return Gc(de, b[0].row, b[0].column);
  }, eb = Fg("thead", !0), Q1 = Fg("tbody", !1), gw = Fg("tfoot", !1), rS = (i, d, p, b) => {
    const _ = Rg(d.details), A = j1(i, Rt(_, (L) => L.column)), N = A.length > 0 ? A[0].cells.length - 1 : 0;
    return Gc(A, _[0].row, Math.min(_[0].column, N));
  }, pw = (i, d, p, b) => {
    const _ = $g(d), A = wa(i, _[0].row, _[_.length - 1].row), N = A.length > 0 ? A.length - 1 : 0;
    return Gc(A, Math.min(d[0].row, N), d[0].column);
  }, vc = (i, d, p, b) => {
    const _ = d.cells;
    vi(_);
    const A = Yr(i, d.bounds, p, b.merge(_));
    return Bg(A, Q.from(_[0]));
  }, kc = (i, d, p, b) => {
    const A = Sn(d, (N, L) => oc(N, L, p, b.unmerge(L)), i);
    return Bg(A, Q.from(d[0]));
  }, Kc = (i, d, p, b) => {
    const A = ((Y, de) => {
      const Ee = Po.fromTable(Y);
      return ah(Ee, de, !0);
    })(d.clipboard, d.generators), N = kl(d.row, d.column);
    return nw(N, i, A, d.generators, p).fold(() => Bg(i, Q.some(d.element)), (Y) => Gc(Y, d.row, d.column));
  }, wc = (i, d, p) => {
    const b = Bu(i, p.section), _ = Po.generate(b);
    return ah(_, d, !0);
  }, Ir = (i, d, p, b) => {
    const _ = vs(i).rows, A = d.cells[0].column, N = _[d.cells[0].row], L = wc(d.clipboard, d.generators, N), Y = ow(A, i, L, d.generators, p);
    return Gc(Y, d.cells[0].row, d.cells[0].column);
  }, ua = (i, d, p, b) => {
    const _ = vs(i).rows, A = d.cells[d.cells.length - 1].column + d.cells[d.cells.length - 1].colspan, N = _[d.cells[0].row], L = wc(d.clipboard, d.generators, N), Y = ow(A, i, L, d.generators, p);
    return Gc(Y, d.cells[0].row, d.cells[0].column);
  }, e0 = (i, d, p, b) => {
    const _ = vs(i).rows, A = d.cells[0].row, N = _[A], L = wc(d.clipboard, d.generators, N), Y = V1(A, i, L, d.generators, p);
    return Gc(Y, d.cells[0].row, d.cells[0].column);
  }, t0 = (i, d, p, b) => {
    const _ = vs(i).rows, A = d.cells[d.cells.length - 1].row + d.cells[d.cells.length - 1].rowspan, N = _[d.cells[0].row], L = wc(d.clipboard, d.generators, N), Y = V1(A, i, L, d.generators, p);
    return Gc(Y, d.cells[0].row, d.cells[0].column);
  }, hw = (i, d) => {
    const p = Po.fromTable(i);
    return hi(p, d).bind((_) => {
      const A = _[_.length - 1], N = _[0].column, L = A.column + A.colspan, Y = gt(Rt(p.all, (de) => Fn(de.cells, (Ee) => Ee.column >= N && Ee.column < L)));
      return Sm(Y);
    }).getOr("");
  }, yw = (i, d) => {
    const p = Po.fromTable(i);
    return hi(p, d).bind(Sm).getOr("");
  }, bw = (i, d) => {
    const p = Po.fromTable(i);
    return hi(p, d).bind((_) => {
      const A = _[_.length - 1], N = _[0].row, L = A.row + A.rowspan, Y = p.all.slice(N, L);
      return Ly(Y);
    }).getOr("");
  }, dh = (i, d, p, b) => Ky(i, d, p, b.sizing), Ig = (i, d, p, b) => iw(i, d, p, b.sizing, b.resize), tb = (i, d) => z(d, (p) => p.column === 0 && p.isLocked), n0 = (i, d) => z(d, (p) => p.column + p.colspan >= i.grid.columns && p.isLocked), aS = (i, d) => {
    const p = hd(i), b = Rg(d);
    return Dn(b, (_, A) => {
      const L = p[A.column].map(Mr).getOr(0);
      return _ + L;
    }, 0);
  }, vw = (i) => (d, p) => hi(d, p).filter((b) => !(i ? tb : n0)(d, b)).map((b) => ({
    details: b,
    pixelDelta: aS(d, b)
  })), cS = (i, d) => mu(i, d).map((p) => ({
    details: p,
    pixelDelta: -aS(i, p)
  })), kw = (i) => (d, p) => Ag(d, p).filter((b) => !(i ? tb : n0)(d, b.cells)), fh = Rc.transform("th"), nb = Rc.transform("td"), o0 = nc(Pg, hi, Ge, Ge, Rc.modification), ww = nc(ki, hi, Ge, Ge, Rc.modification), lS = nc(X1, vw(!0), Ig, Ge, Rc.modification), s0 = nc(rc, vw(!1), Ig, Ge, Rc.modification), qt = nc(rS, cS, Ig, Qy, Rc.modification), iS = nc(pw, hi, Ge, Qy, Rc.modification), Ha = nc(sS, mu, Ge, Ge, fh), _w = nc(J1, mu, Ge, Ge, nb), Cw = nc(eb, mu, Ge, Ge, fh), uS = nc(Q1, mu, Ge, Ge, nb), wi = nc(gw, mu, Ge, Ge, nb), YE = nc(Nf, mu, Ge, Ge, fh), dS = nc(_n, mu, Ge, Ge, nb), Xu = nc(vc, Ea, dh, Ge, Rc.merging), fS = nc(kc, qC, dh, Ge, Rc.merging), Am = nc(Kc, WC, dh, Ge, Rc.modification), Nd = nc(Ir, kw(!0), Ge, Ge, Rc.modification), _i = nc(ua, kw(!1), Ge, Ge, Rc.modification), r0 = nc(e0, Ag, Ge, Ge, Rc.modification), Rl = nc(t0, Ag, Ge, Ge, Rc.modification), mS = hw, Sw = yw, a0 = bw, c0 = (i, d) => i.dispatch("NewRow", { node: d }), mh = (i, d) => i.dispatch("NewCell", { node: d }), Bd = (i, d, p) => {
    i.dispatch("TableModified", {
      ...p,
      table: d
    });
  }, gS = (i, d, p, b, _) => {
    i.dispatch("TableSelectionChange", {
      cells: d,
      start: p,
      finish: b,
      otherCells: _
    });
  }, xw = (i) => {
    i.dispatch("TableSelectionClear");
  }, pS = (i, d, p, b, _) => {
    i.dispatch("ObjectResizeStart", {
      target: d,
      width: p,
      height: b,
      origin: _
    });
  }, hS = (i, d, p, b, _) => {
    i.dispatch("ObjectResized", {
      target: d,
      width: p,
      height: b,
      origin: _
    });
  }, ob = {
    structure: !1,
    style: !0
  }, Aa = {
    structure: !0,
    style: !1
  }, yS = {
    structure: !0,
    style: !0
  }, pu = (i) => (d) => d.options.get(i), Tw = "100%", l0 = (i) => {
    var d;
    const p = i.dom, b = (d = p.getParent(i.selection.getStart(), p.isBlock)) !== null && d !== void 0 ? d : i.getBody();
    return cl(Z.fromDom(b)) + "px";
  }, bS = (i, d) => Va(i) || !u0(i) ? d : Ju(i) ? {
    ...d,
    width: l0(i)
  } : {
    ...d,
    width: Tw
  }, sb = (i, d) => Va(i) || u0(i) ? d : Ju(i) ? {
    ...d,
    width: l0(i)
  } : {
    ...d,
    width: Tw
  }, Ew = (i) => {
    const d = i.options.register;
    d("table_clone_elements", { processor: "string[]" }), d("table_use_colgroups", {
      processor: "boolean",
      default: !0
    }), d("table_header_type", {
      processor: (p) => {
        const b = Qe([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], p);
        return b ? {
          value: p,
          valid: b
        } : {
          valid: !1,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    }), d("table_sizing_mode", {
      processor: "string",
      default: "auto"
    }), d("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    }), d("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    }), d("table_column_resizing", {
      processor: (p) => {
        const b = Qe([
          "preservetable",
          "resizetable"
        ], p);
        return b ? {
          value: p,
          valid: b
        } : {
          valid: !1,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    }), d("table_resize_bars", {
      processor: "boolean",
      default: !0
    }), d("table_style_by_css", {
      processor: "boolean",
      default: !0
    });
  }, Aw = (i) => Q.from(i.options.get("table_clone_elements")), vS = (i) => {
    const d = i.options.get("object_resizing");
    return Qe(d.split(","), "table");
  }, zw = pu("table_header_type"), i0 = pu("table_column_resizing"), rb = (i) => i0(i) === "preservetable", Ow = (i) => i0(i) === "resizetable", Bf = pu("table_sizing_mode"), Ar = (i) => Bf(i) === "relative", Ju = (i) => Bf(i) === "fixed", Va = (i) => Bf(i) === "responsive", Dw = pu("table_resize_bars"), u0 = pu("table_style_by_css"), Rw = (i) => {
    const d = i.options, p = d.get("table_default_attributes");
    return d.isSet("table_default_attributes") ? p : sb(i, p);
  }, ab = (i) => {
    const d = i.options, p = d.get("table_default_styles");
    return d.isSet("table_default_styles") ? p : bS(i, p);
  }, kS = pu("table_use_colgroups"), Mw = (i, d) => Ar(i) ? Sd.percentageSize(d) : Ju(i) ? Sd.pixelSize(d) : Sd.getTableSize(d), wS = (i, d, p) => {
    const b = (xc) => we(xd(xc)) === "table", _ = (xc) => b(i) === !1 || xg(xc).rows > 1, A = (xc) => b(i) === !1 || xg(xc).columns > 1, N = Aw(i), L = Ow(i) ? Ge : _g, Y = (xc) => {
      switch (zw(i)) {
        case "section":
          return Dl.section();
        case "sectionCells":
          return Dl.sectionCells();
        case "cells":
          return Dl.cells();
        default:
          return Dl.getTableSectionType(xc, "section");
      }
    }, de = (xc, dv) => dv.cursor.fold(() => {
      const Lh = Bi(xc);
      return ae(Lh).filter(Vo).map((od) => {
        p.clearSelectedCells(xc.dom);
        const _a = i.dom.createRng();
        return _a.selectNode(od.dom), i.selection.setRng(_a), Fs(od, "data-mce-selected", "1"), _a;
      });
    }, (Lh) => {
      const od = Zk(Lh), _a = i.dom.createRng();
      return _a.setStart(od.element.dom, od.offset), _a.setEnd(od.element.dom, od.offset), i.selection.setRng(_a), p.clearSelectedCells(xc.dom), Q.some(_a);
    }), Ee = (xc, dv, Lh, od) => (_a, R_, wx = !1) => {
      Zc(_a);
      const M_ = Z.fromDom(i.getDoc()), fv = dr(Lh, M_, N), _x = {
        sizing: Mw(i, _a),
        resize: Ow(i) ? qk() : Sg(),
        section: Y(_a)
      };
      return dv(_a) ? xc(_a, R_, fv, _x).bind((mv) => {
        d.refresh(_a.dom), un(mv.newRows, (Hh) => {
          c0(i, Hh.dom);
        }), un(mv.newCells, (Hh) => {
          mh(i, Hh.dom);
        });
        const N_ = de(_a, mv);
        return Vo(_a) && (Zc(_a), wx || Bd(i, _a.dom, od)), N_.map((Hh) => ({
          rng: Hh,
          effect: od
        }));
      }) : Q.none();
    }, yt = Ee(iS, _, Ge, Aa), Ut = Ee(qt, A, Ge, Aa), It = Ee(o0, lt, Ge, Aa), st = Ee(ww, lt, Ge, Aa), Wt = Ee(lS, lt, L, Aa), ot = Ee(s0, lt, L, Aa), gn = Ee(Xu, lt, Ge, Aa), co = Ee(fS, lt, Ge, Aa), Mo = Ee(Nd, lt, Ge, Aa), Sr = Ee(_i, lt, Ge, Aa), da = Ee(r0, lt, Ge, Aa), xr = Ee(Rl, lt, Ge, Aa), gl = Ee(Am, lt, Ge, yS), dp = Ee(YE, lt, Ge, Aa), fp = Ee(dS, lt, Ge, Aa), uv = Ee(Ha, lt, Ge, Aa), Ih = Ee(_w, lt, Ge, Aa), Ys = Ee(Cw, lt, Ge, Aa), Sc = Ee(uS, lt, Ge, Aa), Nc = Ee(wi, lt, Ge, Aa);
    return {
      deleteRow: yt,
      deleteColumn: Ut,
      insertRowsBefore: It,
      insertRowsAfter: st,
      insertColumnsBefore: Wt,
      insertColumnsAfter: ot,
      mergeCells: gn,
      unmergeCells: co,
      pasteColsBefore: Mo,
      pasteColsAfter: Sr,
      pasteRowsBefore: da,
      pasteRowsAfter: xr,
      pasteCells: gl,
      makeCellsHeader: dp,
      unmakeCellsHeader: fp,
      makeColumnsHeader: uv,
      unmakeColumnsHeader: Ih,
      makeRowsHeader: Ys,
      makeRowsBody: Sc,
      makeRowsFooter: Nc,
      getTableRowType: a0,
      getTableCellType: Sw,
      getTableColType: mS
    };
  }, Nw = (i, d, p) => {
    const b = ur(i, d, 1);
    p === 1 || b <= 1 ? Ss(i, d) : Fs(i, d, Math.min(p, b));
  }, d0 = (i, d) => (p) => {
    const b = p.column + p.colspan - 1, _ = p.column;
    return b >= i && _ < d;
  }, Bw = (i, d, p) => {
    if (Po.hasColumns(i)) {
      const b = Fn(Po.justColumns(i), d0(d, p)), _ = Rt(b, (N) => {
        const L = pa(N.element);
        return Nw(L, "span", p - d), L;
      }), A = Z.fromTag("colgroup");
      return fs(A, _), [A];
    } else
      return [];
  }, _S = (i, d, p) => Rt(i.all, (b) => {
    const _ = Fn(b.cells, d0(d, p)), A = Rt(_, (L) => {
      const Y = pa(L.element);
      return Nw(Y, "colspan", p - d), Y;
    }), N = Z.fromTag("tr");
    return fs(N, A), N;
  }), CS = (i, d) => {
    const p = Po.fromTable(i);
    return mu(p, d).map((_) => {
      const A = _[_.length - 1], N = _[0].column, L = A.column + A.colspan, Y = Bw(p, N, L), de = _S(p, N, L);
      return [
        ...Y,
        ...de
      ];
    });
  }, SS = (i, d, p) => {
    const b = Po.fromTable(i);
    return hi(b, d).bind((A) => {
      const N = ah(b, p, !1), Y = vs(N).rows.slice(A[0].row, A[A.length - 1].row + A[A.length - 1].rowspan), de = en(Y, (yt) => {
        const Ut = Fn(yt.cells, (It) => !It.isLocked);
        return Ut.length > 0 ? [{
          ...yt,
          cells: Ut
        }] : [];
      }), Ee = ch(de);
      return qs(Ee.length > 0, Ee);
    }).map((A) => Tg(A));
  }, gh = Ia.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]), $w = (i, d, p) => {
    const b = p.substring(0, p.length - i.length), _ = parseFloat(b);
    return b === _.toString() ? d(_) : gh.invalid(p);
  }, zm = {
    ...gh,
    from: (i) => re(i, "%") ? $w("%", gh.percent, i) : re(i, "px") ? $w("px", gh.pixels, i) : gh.invalid(i)
  }, TS = (i, d) => Rt(i, (p) => zm.from(p).fold(() => p, (_) => _ / d * 100 + "%", (_) => _ + "%")), f0 = (i, d, p) => {
    const b = p / d;
    return Rt(i, (_) => zm.from(_).fold(() => _, (N) => N * b + "px", (N) => N / 100 * p + "px"));
  }, Pw = (i, d) => {
    const p = i.fold(() => Ue(""), (b) => {
      const _ = b / d;
      return Ue(_ + "px");
    }, () => {
      const b = 100 / d;
      return Ue(b + "%");
    });
    return Pe(d, p);
  }, Lg = (i, d, p) => i.fold(() => d, (b) => f0(d, p, b), (b) => TS(d, p)), cb = (i, d, p) => {
    const b = zm.from(p), _ = Pt(i, (A) => A === "0px") ? Pw(b, i.length) : Lg(b, i, d);
    return Hg(_);
  }, lb = (i, d) => i.length === 0 ? d : Sn(i, (p, b) => zm.from(b).fold(Ue(0), ie, ie) + p, 0), ES = (i, d) => {
    const p = Math.floor(i);
    return {
      value: p + d,
      remainder: i - p
    };
  }, AS = (i, d) => zm.from(i).fold(Ue(i), (p) => p + d + "px", (p) => p + d + "%"), Hg = (i) => {
    if (i.length === 0)
      return i;
    const d = Sn(i, (b, _) => {
      const A = zm.from(_).fold(() => ({
        value: _,
        remainder: 0
      }), (N) => ES(N, "px"), (N) => ({
        value: N + "%",
        remainder: 0
      }));
      return {
        output: [A.value].concat(b.output),
        remainder: b.remainder + A.remainder
      };
    }, {
      output: [],
      remainder: 0
    }), p = d.output;
    return p.slice(0, p.length - 1).concat([AS(p[p.length - 1], Math.round(d.remainder))]);
  }, ib = zm.from, ub = (i, d, p) => {
    un(d, (b) => {
      const _ = i.slice(b.column, b.colspan + b.column), A = lb(_, Cl());
      Oo(b.element, "width", A + p);
    });
  }, $d = (i, d, p) => {
    un(d, (b, _) => {
      const A = lb([i[_]], Cl());
      Oo(b.element, "width", A + p);
    });
  }, zS = (i, d, p, b) => {
    un(p, (_) => {
      const A = i.slice(_.row, _.rowspan + _.row), N = lb(A, Sa());
      Oo(_.element, "height", N + b);
    }), un(d, (_, A) => {
      Oo(_.element, "height", i[A]);
    });
  }, Qu = (i) => ib(i).fold(Ue("px"), Ue("px"), Ue("%")), db = (i, d, p) => {
    const b = Po.fromTable(i), _ = b.all, A = Po.justCells(b), N = Po.justColumns(b);
    d.each((L) => {
      const Y = Qu(L), de = yo(i), Ee = km(b, i), yt = cb(Ee, de, L);
      Po.hasColumns(b) ? $d(yt, N, Y) : ub(yt, A, Y), Oo(i, "width", L);
    }), p.each((L) => {
      const Y = Qu(L), de = Vn(i), Ee = ia(b, i, yd), yt = cb(Ee, de, L);
      zS(yt, _, A, Y), Oo(i, "height", L);
    });
  }, Fw = E1, ed = Fi, ph = _d, fb = (i) => {
    Ss(i, "width");
  }, Vg = (i) => {
    const d = xa(i);
    db(i, Q.some(d), Q.none()), fb(i);
  }, Om = (i) => {
    const d = Vu(i);
    db(i, Q.some(d), Q.none()), fb(i);
  }, jg = (i) => {
    fc(i, "width");
    const d = ru(i), p = d.length > 0 ? d : Bi(i);
    un(p, (b) => {
      fc(b, "width"), fb(b);
    }), fb(i);
  }, Iw = {
    styles: {
      "border-collapse": "collapse",
      width: "100%"
    },
    attributes: { border: "1" },
    colGroups: !1
  }, m0 = () => Z.fromTag("th"), OS = () => Z.fromTag("td"), g0 = () => Z.fromTag("col"), Lw = (i, d, p, b) => {
    const _ = Z.fromTag("tr");
    for (let A = 0; A < i; A++) {
      const N = b < d || A < p ? m0() : OS();
      A < p && Fs(N, "scope", "row"), b < d && Fs(N, "scope", "col"), zo(N, Z.fromTag("br")), zo(_, N);
    }
    return _;
  }, p0 = (i) => {
    const d = Z.fromTag("colgroup");
    return Pe(i, () => zo(d, g0())), d;
  }, h0 = (i, d, p, b) => Pe(i, (_) => Lw(d, p, b, _)), DS = (i, d, p, b, _, A = Iw) => {
    const N = Z.fromTag("table"), L = _ !== "cells";
    Ps(N, A.styles), Tr(N, A.attributes), A.colGroups && zo(N, p0(d));
    const Y = Math.min(i, p);
    if (L && p > 0) {
      const It = Z.fromTag("thead");
      zo(N, It);
      const Wt = h0(p, d, _ === "sectionCells" ? Y : 0, b);
      fs(It, Wt);
    }
    const de = Z.fromTag("tbody");
    zo(N, de);
    const Ee = L ? i - Y : i, Ut = h0(Ee, d, L ? 0 : p, b);
    return fs(de, Ut), N;
  }, Ug = (i) => i.dom.innerHTML, $f = (i) => {
    const d = Z.fromTag("div"), p = Z.fromDom(i.dom.cloneNode(!0));
    return zo(d, p), Ug(d);
  }, hh = (i, d) => {
    i.selection.select(d.dom, !0), i.selection.collapse(!0);
  }, Wg = (i, d) => {
    $o(d, "td,th").each(_t(hh, i));
  }, RS = (i, d) => {
    un(Zr(d, "tr"), (p) => {
      c0(i, p.dom), un(Zr(p, "th,td"), (b) => {
        mh(i, b.dom);
      });
    });
  }, Pf = (i) => ho(i) && i.indexOf("%") !== -1, td = (i, d, p, b, _) => {
    const A = ab(i), N = {
      styles: A,
      attributes: Rw(i),
      colGroups: kS(i)
    };
    return i.undoManager.ignore(() => {
      const L = DS(p, d, _, b, zw(i), N);
      Fs(L, "data-mce-id", "__mce");
      const Y = $f(L);
      i.insertContent(Y), i.addVisual();
    }), $o(xd(i), 'table[data-mce-id="__mce"]').map((L) => (Ju(i) ? Om(L) : Va(i) ? jg(L) : (Ar(i) || Pf(A.width)) && Vg(L), Zc(L), Ss(L, "data-mce-id"), RS(i, L), Wg(i, L), L.dom)).getOr(null);
  }, y0 = (i, d, p, b = {}) => {
    const _ = (A) => an(A) && A > 0;
    if (_(d) && _(p)) {
      const A = b.headerRows || 0, N = b.headerColumns || 0;
      return td(i, p, d, N, A);
    } else
      return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
  };
  var mb = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const gb = "x-tinymce/dom-table-", Zg = gb + "rows", Dm = gb + "columns", qg = (i) => {
    const d = mb.FakeClipboardItem(i);
    mb.write([d]);
  }, yh = (i) => {
    var d;
    const p = (d = mb.read()) !== null && d !== void 0 ? d : [];
    return je(p, (b) => Q.from(b.getType(i)));
  }, b0 = (i) => {
    yh(i).isSome() && mb.clear();
  }, Gg = (i) => {
    i.fold(pb, (d) => qg({ [Zg]: d }));
  }, bh = () => yh(Zg), pb = () => b0(Zg), hb = (i) => {
    i.fold(ja, (d) => qg({ [Dm]: d }));
  }, vh = () => yh(Dm), ja = () => b0(Dm), v0 = (i) => Ef(Gl(i), Li(i)), nd = (i) => B1(Gl(i), Li(i)), Hw = (i, d) => {
    const p = Li(i), b = () => v0(i).each((ot) => {
      Ba(ot, p).filter(Re(p)).each((gn) => {
        const co = Z.fromText("");
        if (os(gn, co), br(gn), i.dom.isEmpty(i.getBody()))
          i.setContent(""), i.selection.setCursorLocation();
        else {
          const Mo = i.dom.createRng();
          Mo.setStart(co.dom, 0), Mo.setEnd(co.dom, 0), i.selection.setRng(Mo), i.nodeChanged();
        }
      });
    }), _ = (ot) => v0(i).each((gn) => {
      Va(i) || Ju(i) || Ar(i) || Ba(gn, p).each((Mo) => {
        ot === "relative" && !Fw(Mo) ? Vg(Mo) : ot === "fixed" && !ed(Mo) ? Om(Mo) : ot === "responsive" && !ph(Mo) && jg(Mo), Zc(Mo), Bd(i, Mo.dom, Aa);
      });
    }), A = (ot) => Ba(ot, p), N = (ot) => nd(i).bind((gn) => A(gn).map((co) => ot(co, gn))), L = (ot, gn) => {
      N((co) => {
        i.formatter.toggle("tableclass", { value: gn }, co.dom), Bd(i, co.dom, ob);
      });
    }, Y = (ot, gn) => {
      N((co) => {
        const Mo = Gu(i), da = Pt(Mo, (xr) => i.formatter.match("tablecellclass", { value: gn }, xr.dom)) ? i.formatter.remove : i.formatter.apply;
        un(Mo, (xr) => da("tablecellclass", { value: gn }, xr.dom)), Bd(i, co.dom, ob);
      });
    }, de = () => {
      v0(i).each((ot) => {
        Ba(ot, p).each((gn) => {
          Dt(gn, "caption").fold(() => {
            const co = Z.fromTag("caption");
            zo(co, Z.fromText("Caption")), Ya(gn, co, 0), i.selection.setCursorLocation(co.dom, 0);
          }, (co) => {
            Zs("caption")(ot) && Rn("td", gn).each((Mo) => i.selection.setCursorLocation(Mo.dom, 0)), br(co);
          }), Bd(i, gn.dom, Aa);
        });
      });
    }, Ee = (ot) => {
      i.focus();
    }, yt = (ot, gn = !1) => N((co, Mo) => {
      const Sr = Hi(Gu(i), co, Mo);
      ot(co, Sr, gn).each(Ee);
    }), Ut = () => N((ot, gn) => {
      const co = Hi(Gu(i), ot, gn), Mo = dr(Ge, Z.fromDom(i.getDoc()), Q.none());
      return SS(ot, co, Mo);
    }), It = () => N((ot, gn) => {
      const co = Hi(Gu(i), ot, gn);
      return CS(ot, co);
    }), st = (ot, gn) => gn().each((co) => {
      const Mo = Rt(co, (Sr) => pa(Sr));
      N((Sr, da) => {
        const xr = Br(Z.fromDom(i.getDoc())), gl = zd(Gu(i), da, Mo, xr);
        ot(Sr, gl).each(Ee);
      });
    }), Wt = (ot) => (gn, co) => Ho(co, "type").each((Mo) => {
      yt(ot(Mo), co.no_events);
    });
    ct({
      mceTableSplitCells: () => yt(d.unmergeCells),
      mceTableMergeCells: () => yt(d.mergeCells),
      mceTableInsertRowBefore: () => yt(d.insertRowsBefore),
      mceTableInsertRowAfter: () => yt(d.insertRowsAfter),
      mceTableInsertColBefore: () => yt(d.insertColumnsBefore),
      mceTableInsertColAfter: () => yt(d.insertColumnsAfter),
      mceTableDeleteCol: () => yt(d.deleteColumn),
      mceTableDeleteRow: () => yt(d.deleteRow),
      mceTableCutCol: () => It().each((ot) => {
        hb(ot), yt(d.deleteColumn);
      }),
      mceTableCutRow: () => Ut().each((ot) => {
        Gg(ot), yt(d.deleteRow);
      }),
      mceTableCopyCol: () => It().each((ot) => hb(ot)),
      mceTableCopyRow: () => Ut().each((ot) => Gg(ot)),
      mceTablePasteColBefore: () => st(d.pasteColsBefore, vh),
      mceTablePasteColAfter: () => st(d.pasteColsAfter, vh),
      mceTablePasteRowBefore: () => st(d.pasteRowsBefore, bh),
      mceTablePasteRowAfter: () => st(d.pasteRowsAfter, bh),
      mceTableDelete: b,
      mceTableCellToggleClass: Y,
      mceTableToggleClass: L,
      mceTableToggleCaption: de,
      mceTableSizingMode: (ot, gn) => _(gn),
      mceTableCellType: Wt((ot) => ot === "th" ? d.makeCellsHeader : d.unmakeCellsHeader),
      mceTableColType: Wt((ot) => ot === "th" ? d.makeColumnsHeader : d.unmakeColumnsHeader),
      mceTableRowType: Wt((ot) => {
        switch (ot) {
          case "header":
            return d.makeRowsHeader;
          case "footer":
            return d.makeRowsFooter;
          default:
            return d.makeRowsBody;
        }
      })
    }, (ot, gn) => i.addCommand(gn, ot)), i.addCommand("mceInsertTable", (ot, gn) => {
      y0(i, gn.rows, gn.columns, gn.options);
    }), i.addCommand("mceTableApplyCellStyle", (ot, gn) => {
      const co = (da) => "tablecell" + da.toLowerCase().replace("-", "");
      if (!Kt(gn))
        return;
      const Mo = Gu(i);
      if (Mo.length === 0)
        return;
      const Sr = fo(gn, (da, xr) => i.formatter.has(co(xr)) && ho(da));
      ro(Sr) || (ct(Sr, (da, xr) => {
        const gl = co(xr);
        un(Mo, (dp) => {
          da === "" ? i.formatter.remove(gl, { value: null }, dp.dom, !0) : i.formatter.apply(gl, { value: da }, dp.dom);
        });
      }), A(Mo[0]).each((da) => Bd(i, da.dom, ob)));
    });
  }, k0 = (i, d) => {
    const p = Li(i), b = (_) => B1(Gl(i)).bind((A) => Ba(A, p).map((N) => {
      const L = Hi(Gu(i), N, A);
      return _(N, L);
    })).getOr("");
    ct({
      mceTableRowType: () => b(d.getTableRowType),
      mceTableCellType: () => b(d.getTableCellType),
      mceTableColType: () => b(d.getTableColType)
    }, (_, A) => i.addQueryValueHandler(A, _));
  }, Zi = Ia.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), Vw = (i, d, p, b) => i.fold(d, p, b), yb = (i) => i.fold(ie, ie, ie), jw = Zi.before, w0 = Zi.on, _0 = Zi.after, Yc = {
    before: jw,
    on: w0,
    after: _0,
    cata: Vw,
    getStart: yb
  }, _c = { create: (i, d) => ({
    selection: i,
    kill: d
  }) }, Ww = (i, d) => {
    const p = i.document.createRange();
    return p.selectNode(d.dom), p;
  }, MS = (i, d) => {
    const p = i.document.createRange();
    return Zw(p, d), p;
  }, Zw = (i, d) => i.selectNodeContents(d.dom), qw = (i, d) => {
    d.fold((p) => {
      i.setStartBefore(p.dom);
    }, (p, b) => {
      i.setStart(p.dom, b);
    }, (p) => {
      i.setStartAfter(p.dom);
    });
  }, C0 = (i, d) => {
    d.fold((p) => {
      i.setEndBefore(p.dom);
    }, (p, b) => {
      i.setEnd(p.dom, b);
    }, (p) => {
      i.setEndAfter(p.dom);
    });
  }, Mc = (i, d, p) => {
    const b = i.document.createRange();
    return qw(b, d), C0(b, p), b;
  }, S0 = (i, d, p, b, _) => {
    const A = i.document.createRange();
    return A.setStart(d.dom, p), A.setEnd(b.dom, _), A;
  }, Ci = (i) => ({
    left: i.left,
    top: i.top,
    right: i.right,
    bottom: i.bottom,
    width: i.width,
    height: i.height
  }), bb = (i) => {
    const d = i.getClientRects(), p = d.length > 0 ? d[0] : i.getBoundingClientRect();
    return p.width > 0 || p.height > 0 ? Q.some(p).map(Ci) : Q.none();
  }, Rm = Ia.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Mm = (i, d, p) => d(Z.fromDom(p.startContainer), p.startOffset, Z.fromDom(p.endContainer), p.endOffset), Si = (i, d) => d.match({
    domRange: (p) => ({
      ltr: Ue(p),
      rtl: Q.none
    }),
    relative: (p, b) => ({
      ltr: Tl(() => Mc(i, p, b)),
      rtl: Tl(() => Q.some(Mc(i, b, p)))
    }),
    exact: (p, b, _, A) => ({
      ltr: Tl(() => S0(i, p, b, _, A)),
      rtl: Tl(() => Q.some(S0(i, _, A, p, b)))
    })
  }), qi = (i, d) => {
    const p = d.ltr();
    return p.collapsed ? d.rtl().filter((_) => _.collapsed === !1).map((_) => Rm.rtl(Z.fromDom(_.endContainer), _.endOffset, Z.fromDom(_.startContainer), _.startOffset)).getOrThunk(() => Mm(i, Rm.ltr, p)) : Mm(i, Rm.ltr, p);
  }, Xc = (i, d) => {
    const p = Si(i, d);
    return qi(i, p);
  }, hu = (i, d) => Xc(i, d).match({
    ltr: (b, _, A, N) => {
      const L = i.document.createRange();
      return L.setStart(b.dom, _), L.setEnd(A.dom, N), L;
    },
    rtl: (b, _, A, N) => {
      const L = i.document.createRange();
      return L.setStart(A.dom, N), L.setEnd(b.dom, _), L;
    }
  });
  Rm.ltr, Rm.rtl;
  const Xl = { create: (i, d, p, b) => ({
    start: i,
    soffset: d,
    finish: p,
    foffset: b
  }) }, Gw = { create: (i, d, p, b) => ({
    start: Yc.on(i, d),
    finish: Yc.on(p, b)
  }) }, x0 = (i, d) => {
    const p = hu(i, d);
    return Xl.create(Z.fromDom(p.startContainer), p.startOffset, Z.fromDom(p.endContainer), p.endOffset);
  }, kh = Gw.create, Kw = (i, d, p, b, _, A, N) => Ft(p, _) && b === A ? Q.none() : Jo(p, "td,th", d).bind((L) => Jo(_, "td,th", d).bind((Y) => T0(i, d, L, Y, N))), T0 = (i, d, p, b, _) => Ft(p, b) ? Q.none() : no(p, b, d).bind((A) => {
    const N = A.boxes.getOr([]);
    return N.length > 1 ? (_(i, N, A.start, A.finish), Q.some(_c.create(Q.some(kh(p, 0, p, ks(p))), !0))) : Q.none();
  }), Nm = (i, d, p, b, _) => {
    const A = (N) => (_.clearBeforeUpdate(p), _.selectRange(p, N.boxes, N.start, N.finish), N.boxes);
    return Ls(b, i, d, _.firstSelectedSelector, _.lastSelectedSelector).map(A);
  }, wh = (i, d) => ({
    item: i,
    mode: d
  }), E0 = (i, d, p, b = Bm) => i.property().parent(d).map((_) => wh(_, b)), Bm = (i, d, p, b = Kg) => p.sibling(i, d).map((_) => wh(_, b)), Kg = (i, d, p, b = Kg) => {
    const _ = i.property().children(d);
    return p.first(_).map((N) => wh(N, b));
  }, Yw = [
    {
      current: E0,
      next: Bm,
      fallback: Q.none()
    },
    {
      current: Bm,
      next: Kg,
      fallback: Q.some(E0)
    },
    {
      current: Kg,
      next: Kg,
      fallback: Q.some(Bm)
    }
  ], vb = (i, d, p, b, _ = Yw) => Xe(_, (N) => N.current === p).bind((N) => N.current(i, d, b, N.next).orThunk(() => N.fallback.bind((L) => vb(i, d, L, b)))), kb = {
    left: () => ({
      sibling: (p, b) => p.query().prevSibling(b),
      first: (p) => p.length > 0 ? Q.some(p[p.length - 1]) : Q.none()
    }),
    right: () => ({
      sibling: (p, b) => p.query().nextSibling(b),
      first: (p) => p.length > 0 ? Q.some(p[0]) : Q.none()
    })
  }, wb = (i, d, p, b, _, A) => vb(i, d, b, _).bind((L) => A(L.item) ? Q.none() : p(L.item) ? Q.some(L.item) : wb(i, L.item, p, L.mode, _, A)), BS = (i, d, p, b) => wb(i, d, p, Bm, kb.left(), b), $S = (i, d, p, b) => wb(i, d, p, Bm, kb.right(), b), Jw = (i) => (d) => i.property().children(d).length === 0, PS = (i, d, p) => Jl(i, d, Jw(i), p), FS = (i, d, p) => IS(i, d, Jw(i), p), Jl = BS, IS = $S, $m = Sf(), Yg = (i, d) => PS($m, i, d), _b = (i, d) => FS($m, i, d), Qw = (i, d, p) => Jl($m, i, d, p), Cb = (i, d, p) => IS($m, i, d, p), XE = (i, d, p) => qr(i, d, p).isSome(), z0 = Ia.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]), LS = (i, d, p) => {
    const b = i.getRect(d), _ = i.getRect(p);
    return _.right > b.left && _.left < b.right;
  }, HS = (i) => Jo(i, "tr"), yu = {
    ...z0,
    verify: (i, d, p, b, _, A, N) => Jo(b, "td,th", N).bind((L) => Jo(d, "td,th", N).map((Y) => Ft(L, Y) ? Ft(b, L) && ks(L) === _ ? A(Y) : z0.none("in same cell") : Kp(HS, [
      L,
      Y
    ]).fold(() => LS(i, Y, L) ? z0.success() : A(Y), (de) => A(Y)))).getOr(z0.none("default")),
    cata: (i, d, p, b, _) => i.fold(d, p, b, _)
  }, Ff = (i, d, p, b) => ({
    parent: i,
    children: d,
    element: p,
    index: b
  }), _h = (i) => se(i).bind((d) => {
    const p = Nt(d);
    return O0(p, i).map((b) => Ff(d, p, i, b));
  }), O0 = (i, d) => O(i, _t(Ft, d)), Xg = Zs("br"), Jg = (i, d, p) => d(i, p).bind((b) => qn(b) && mo(b).trim().length === 0 ? Jg(b, d, p) : Q.some(b)), Qg = (i, d, p) => p.traverse(d).orThunk(() => Jg(d, p.gather, i)).map(p.relative), D0 = (i, d) => on(i, d).filter(Xg).orThunk(() => on(i, d - 1).filter(Xg)), jS = (i, d, p, b) => D0(d, p).bind((_) => b.traverse(_).fold(() => Jg(_, b.gather, i).map(b.relative), (A) => _h(A).map((N) => Yc.on(N.parent, N.index)))), Ml = (i, d, p, b) => (Xg(d) ? Qg(i, d, b) : jS(i, d, p, b)).map((A) => ({
    start: A,
    finish: A
  })), Sb = (i) => yu.cata(i, (d) => Q.none(), () => Q.none(), (d) => Q.some(fu(d, 0)), (d) => Q.some(fu(d, ks(d)))), Pm = (i, d) => ({
    left: i.left,
    top: i.top + d,
    right: i.right,
    bottom: i.bottom + d
  }), Nl = (i, d) => ({
    left: i.left,
    top: i.top - d,
    right: i.right,
    bottom: i.bottom - d
  }), xb = (i, d, p) => ({
    left: i.left + d,
    top: i.top + p,
    right: i.right + d,
    bottom: i.bottom + p
  }), ep = (i) => i.top, US = (i) => i.bottom, e_ = (i, d, p) => p >= 0 && p < ks(d) ? i.getRangedRect(d, p, d, p + 1) : p > 0 ? i.getRangedRect(d, p - 1, d, p) : Q.none(), Ql = (i) => ({
    left: i.left,
    top: i.top,
    right: i.right,
    bottom: i.bottom
  }), fl = (i, d) => Q.some(i.getRect(d)), za = (i, d, p) => ht(d) ? fl(i, d).map(Ql) : qn(d) ? e_(i, d, p).map(Ql) : Q.none(), t_ = (i, d) => ht(d) ? fl(i, d).map(Ql) : qn(d) ? i.getRangedRect(d, 0, d, ks(d)).map(Ql) : Q.none(), Fd = 5, Fm = 100, Gi = Ia.generate([
    { none: [] },
    { retry: ["caret"] }
  ]), n_ = (i, d) => i.left < d.left || Math.abs(d.right - i.left) < 1 || i.left > d.right, o_ = (i, d, p) => B(d, dw).fold(rt, (b) => t_(i, b).exists((_) => n_(p, _))), WS = (i, d, p, b, _) => {
    const A = Pm(_, Fd);
    return Math.abs(p.bottom - b.bottom) < 1 || p.top > _.bottom ? Gi.retry(A) : p.top === _.bottom ? Gi.retry(Pm(_, 1)) : o_(i, d, _) ? Gi.retry(xb(A, Fd, 0)) : Gi.none();
  }, R0 = {
    point: ep,
    adjuster: (i, d, p, b, _) => {
      const A = Nl(_, Fd);
      return Math.abs(p.top - b.top) < 1 || p.bottom < _.top ? Gi.retry(A) : p.bottom === _.top ? Gi.retry(Nl(_, 1)) : o_(i, d, _) ? Gi.retry(xb(A, Fd, 0)) : Gi.none();
    },
    move: Nl,
    gather: Yg
  }, qS = {
    point: US,
    adjuster: WS,
    move: Pm,
    gather: _b
  }, s_ = (i, d, p) => i.elementFromPoint(d, p).filter((b) => we(b) === "table").isSome(), r_ = (i, d, p, b, _) => M0(i, d, p, d.move(b, Fd), _), M0 = (i, d, p, b, _) => _ === 0 ? Q.some(b) : s_(i, b.left, d.point(b)) ? r_(i, d, p, b, _ - 1) : i.situsFromPoint(b.left, d.point(b)).bind((A) => A.start.fold(Q.none, (N) => t_(i, N).bind((L) => d.adjuster(i, N, L, p, b).fold(Q.none, (Y) => M0(i, d, p, Y, _ - 1))).orThunk(() => Q.some(b)), Q.none)), a_ = (i, d, p) => i.point(d) > p.getInnerHeight() ? Q.some(i.point(d) - p.getInnerHeight()) : i.point(d) < 0 ? Q.some(-i.point(d)) : Q.none(), N0 = (i, d, p) => {
    const b = i.move(p, Fd), _ = M0(d, i, p, b, Fm).getOr(b);
    return a_(i, _, d).fold(() => d.situsFromPoint(_.left, i.point(_)), (A) => (d.scrollBy(0, A), d.situsFromPoint(_.left, i.point(_) - A)));
  }, Ch = {
    tryUp: _t(N0, R0),
    tryDown: _t(N0, qS),
    getJumpSize: Ue(Fd)
  }, c_ = 20, Yo = (i, d, p) => i.getSelection().bind((b) => Ml(d, b.finish, b.foffset, p).fold(() => Q.some(fu(b.finish, b.foffset)), (_) => {
    const A = i.fromSitus(_), N = yu.verify(i, b.finish, b.foffset, A.finish, A.foffset, p.failure, d);
    return Sb(N);
  })), xi = (i, d, p, b, _, A) => A === 0 ? Q.none() : GS(i, d, p, b, _).bind((N) => {
    const L = i.fromSitus(N), Y = yu.verify(i, p, b, L.finish, L.foffset, _.failure, d);
    return yu.cata(Y, () => Q.none(), () => Q.some(N), (de) => Ft(p, de) && b === 0 ? Id(i, p, b, Nl, _) : xi(i, d, de, 0, _, A - 1), (de) => Ft(p, de) && b === ks(de) ? Id(i, p, b, Pm, _) : xi(i, d, de, ks(de), _, A - 1));
  }), Id = (i, d, p, b, _) => za(i, d, p).bind((A) => Tb(i, _, b(A, Ch.getJumpSize()))), Tb = (i, d, p) => {
    const b = xo().browser;
    return b.isChromium() || b.isSafari() || b.isFirefox() ? d.retry(i, p) : Q.none();
  }, GS = (i, d, p, b, _) => za(i, p, b).bind((A) => Tb(i, _, A)), B0 = (i, d, p) => Yo(i, d, p).bind((b) => xi(i, d, b.element, b.offset, p, c_).map(i.fromSitus)), KS = (i, d) => XE(i, (p) => se(p).exists((b) => Ft(b, d))), Sh = (i, d, p, b, _) => Jo(b, "td,th", d).bind((A) => Jo(A, "table", d).bind((N) => KS(_, N) ? B0(i, d, p).bind((L) => Jo(L.finish, "td,th", d).map((Y) => ({
    start: A,
    finish: Y,
    range: L
  }))) : Q.none())), Ld = (i, d, p, b, _, A) => A(b, d).orThunk(() => Sh(i, d, p, b, _).map((N) => {
    const L = N.range;
    return _c.create(Q.some(kh(L.start, L.soffset, L.finish, L.foffset)), !0);
  })), tp = (i, d) => Jo(i, "tr", d).bind((p) => Jo(p, "table", d).bind((b) => {
    const _ = Zr(b, "tr");
    return Ft(p, _[0]) ? Qw(b, (A) => Ii(A).isSome(), d).map((A) => {
      const N = ks(A);
      return _c.create(Q.some(kh(A, N, A, N)), !0);
    }) : Q.none();
  })), JE = (i, d) => Jo(i, "tr", d).bind((p) => Jo(p, "table", d).bind((b) => {
    const _ = Zr(b, "tr");
    return Ft(p, _[_.length - 1]) ? Cb(b, (A) => iu(A).isSome(), d).map((A) => _c.create(Q.some(kh(A, 0, A, 0)), !0)) : Q.none();
  })), YS = (i, d, p, b, _, A, N) => Sh(i, p, b, _, A).bind((L) => T0(d, p, L.start, L.finish, N)), $0 = (i) => {
    let d = i;
    return {
      get: () => d,
      set: (_) => {
        d = _;
      }
    };
  }, P0 = (i) => {
    const d = $0(Q.none()), p = () => d.get().each(i);
    return {
      clear: () => {
        p(), d.set(Q.none());
      },
      isSet: () => d.get().isSome(),
      get: () => d.get(),
      set: (L) => {
        p(), d.set(Q.some(L));
      }
    };
  }, xh = () => {
    const i = P0(Ge);
    return {
      ...i,
      on: (p) => i.get().each(p)
    };
  }, Eb = (i, d) => Jo(i, "td,th", d), Th = (i, d, p, b) => {
    const _ = xh(), A = _.clear, N = (Ee) => {
      _.on((yt) => {
        b.clearBeforeUpdate(d), Eb(Ee.target, p).each((Ut) => {
          no(yt, Ut, p).each((It) => {
            const st = It.boxes.getOr([]);
            if (st.length === 1) {
              const Wt = st[0], ot = Od(Wt) === "false", gn = it(Dc(Ee.target), Wt, Ft);
              ot && gn && (b.selectRange(d, st, Wt, Wt), i.selectContents(Wt));
            } else
              st.length > 1 && (b.selectRange(d, st, It.start, It.finish), i.selectContents(Ut));
          });
        });
      });
    };
    return {
      clearstate: A,
      mousedown: (Ee) => {
        b.clear(d), Eb(Ee.target, p).each(_.set);
      },
      mouseover: (Ee) => {
        N(Ee);
      },
      mouseup: (Ee) => {
        N(Ee), A();
      }
    };
  }, Ab = {
    traverse: zt,
    gather: _b,
    relative: Yc.before,
    retry: Ch.tryDown,
    failure: yu.failedDown
  }, Eh = {
    traverse: Lt,
    gather: Yg,
    relative: Yc.before,
    retry: Ch.tryUp,
    failure: yu.failedUp
  }, Ah = (i) => (d) => d === i, F0 = Ah(38), zh = Ah(40), zb = (i) => i >= 37 && i <= 40, l_ = {
    isBackward: Ah(37),
    isForward: Ah(39)
  }, XS = {
    isBackward: Ah(39),
    isForward: Ah(37)
  }, i_ = (i) => {
    const d = i !== void 0 ? i.dom : document, p = d.body.scrollLeft || d.documentElement.scrollLeft, b = d.body.scrollTop || d.documentElement.scrollTop;
    return ll(p, b);
  }, JS = (i, d, p) => {
    const _ = (p !== void 0 ? p.dom : document).defaultView;
    _ && _.scrollBy(i, d);
  }, Ob = Ia.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), u_ = (i) => Ob.exact(i.start, i.soffset, i.finish, i.foffset), Oh = (i) => i.match({
    domRange: (d) => Z.fromDom(d.startContainer),
    relative: (d, p) => Yc.getStart(d),
    exact: (d, p, b, _) => d
  }), d_ = Ob.domRange, QS = Ob.relative, ex = Ob.exact, tx = (i) => {
    const d = Oh(i);
    return bt(d);
  }, nx = Xl.create, np = {
    domRange: d_,
    relative: QS,
    exact: ex,
    exactFromRange: u_,
    getWin: tx,
    range: nx
  }, cn = (i, d, p) => {
    var b, _;
    return Q.from((_ = (b = i.dom).caretPositionFromPoint) === null || _ === void 0 ? void 0 : _.call(b, d, p)).bind((A) => {
      if (A.offsetNode === null)
        return Q.none();
      const N = i.dom.createRange();
      return N.setStart(A.offsetNode, A.offset), N.collapse(), Q.some(N);
    });
  }, Oa = (i, d, p) => {
    var b, _;
    return Q.from((_ = (b = i.dom).caretRangeFromPoint) === null || _ === void 0 ? void 0 : _.call(b, d, p));
  }, Db = (() => document.caretPositionFromPoint ? cn : document.caretRangeFromPoint ? Oa : Q.none)(), Ua = (i, d, p) => {
    const b = Z.fromDom(i.document);
    return Db(b, d, p).map((_) => Xl.create(Z.fromDom(_.startContainer), _.startOffset, Z.fromDom(_.endContainer), _.endOffset));
  }, Bl = (i, d) => {
    const p = we(i);
    return p === "input" ? Yc.after(i) : Qe([
      "br",
      "img"
    ], p) ? d === 0 ? Yc.before(i) : Yc.after(i) : Yc.on(i, d);
  }, f_ = (i, d) => {
    const p = i.fold(Yc.before, Bl, Yc.after), b = d.fold(Yc.before, Bl, Yc.after);
    return np.relative(p, b);
  }, Dh = (i, d, p, b) => {
    const _ = Bl(i, d), A = Bl(p, b);
    return np.relative(_, A);
  }, Rb = (i, d, p, b) => {
    const A = Bn(i).dom.createRange();
    return A.setStart(i.dom, d), A.setEnd(p.dom, b), A;
  }, I0 = (i, d, p, b) => {
    const _ = Rb(i, d, p, b), A = Ft(i, p) && d === b;
    return _.collapsed && !A;
  }, Mb = (i) => Q.from(i.getSelection()), Nb = (i, d) => {
    Mb(i).each((p) => {
      p.removeAllRanges(), p.addRange(d);
    });
  }, L0 = (i, d, p, b, _) => {
    const A = S0(i, d, p, b, _);
    Nb(i, A);
  }, m_ = (i, d, p, b, _, A) => {
    d.collapse(p.dom, b), d.extend(_.dom, A);
  }, g_ = (i, d) => Xc(i, d).match({
    ltr: (p, b, _, A) => {
      L0(i, p, b, _, A);
    },
    rtl: (p, b, _, A) => {
      Mb(i).each((N) => {
        if (N.setBaseAndExtent)
          N.setBaseAndExtent(p.dom, b, _.dom, A);
        else if (N.extend)
          try {
            m_(i, N, p, b, _, A);
          } catch {
            L0(i, _, A, p, b);
          }
        else
          L0(i, _, A, p, b);
      });
    }
  }), H0 = (i, d, p, b, _) => {
    const A = Dh(d, p, b, _);
    g_(i, A);
  }, p_ = (i, d, p) => {
    const b = f_(d, p);
    g_(i, b);
  }, V0 = (i) => {
    if (i.rangeCount > 0) {
      const d = i.getRangeAt(0), p = i.getRangeAt(i.rangeCount - 1);
      return Q.some(Xl.create(Z.fromDom(d.startContainer), d.startOffset, Z.fromDom(p.endContainer), p.endOffset));
    } else
      return Q.none();
  }, Bb = (i) => {
    if (i.anchorNode === null || i.focusNode === null)
      return V0(i);
    {
      const d = Z.fromDom(i.anchorNode), p = Z.fromDom(i.focusNode);
      return I0(d, i.anchorOffset, p, i.focusOffset) ? Q.some(Xl.create(d, i.anchorOffset, p, i.focusOffset)) : V0(i);
    }
  }, op = (i, d, p = !0) => {
    const _ = (p ? MS : Ww)(i, d);
    Nb(i, _);
  }, Tn = (i) => Mb(i).filter((d) => d.rangeCount > 0).bind(Bb), bu = (i) => Tn(i).map((d) => np.exact(d.start, d.soffset, d.finish, d.foffset)), j0 = (i, d) => {
    const p = hu(i, d);
    return bb(p);
  }, h_ = (i, d, p) => Ua(i, d, p), Im = (i) => {
    Mb(i).each((d) => d.removeAllRanges());
  }, If = (i) => ({
    elementFromPoint: (ot, gn) => Z.fromPoint(Z.fromDom(i.document), ot, gn),
    getRect: (ot) => ot.dom.getBoundingClientRect(),
    getRangedRect: (ot, gn, co, Mo) => {
      const Sr = np.exact(ot, gn, co, Mo);
      return j0(i, Sr);
    },
    getSelection: () => bu(i).map((ot) => x0(i, ot)),
    fromSitus: (ot) => {
      const gn = np.relative(ot.start, ot.finish);
      return x0(i, gn);
    },
    situsFromPoint: (ot, gn) => h_(i, ot, gn).map((co) => Gw.create(co.start, co.soffset, co.finish, co.foffset)),
    clearSelection: () => {
      Im(i);
    },
    collapseSelection: (ot = !1) => {
      bu(i).each((gn) => gn.fold((co) => co.collapse(ot), (co, Mo) => {
        const Sr = ot ? co : Mo;
        p_(i, Sr, Sr);
      }, (co, Mo, Sr, da) => {
        const xr = ot ? co : Sr, gl = ot ? Mo : da;
        H0(i, xr, gl, xr, gl);
      }));
    },
    setSelection: (ot) => {
      H0(i, ot.start, ot.soffset, ot.finish, ot.foffset);
    },
    setRelativeSelection: (ot, gn) => {
      p_(i, ot, gn);
    },
    selectNode: (ot) => {
      op(i, ot, !1);
    },
    selectContents: (ot) => {
      op(i, ot);
    },
    getInnerHeight: () => i.innerHeight,
    getScrollY: () => i_(Z.fromDom(i.document)).top,
    scrollBy: (ot, gn) => {
      JS(ot, gn, Z.fromDom(i.document));
    }
  }), sp = (i, d) => ({
    rows: i,
    cols: d
  }), y_ = (i, d, p, b) => {
    const _ = If(i), A = Th(_, d, p, b);
    return {
      clearstate: A.clearstate,
      mousedown: A.mousedown,
      mouseover: A.mouseover,
      mouseup: A.mouseup
    };
  }, ox = (i, d, p, b) => {
    const _ = If(i), A = () => (b.clear(d), Q.none());
    return {
      keydown: (Y, de, Ee, yt, Ut, It) => {
        const st = Y.raw, Wt = st.which, ot = st.shiftKey === !0;
        return Zu(d, b.selectedSelector).fold(() => (zb(Wt) && !ot && b.clearBeforeUpdate(d), zh(Wt) && ot ? _t(YS, _, d, p, Ab, yt, de, b.selectRange) : F0(Wt) && ot ? _t(YS, _, d, p, Eh, yt, de, b.selectRange) : zh(Wt) ? _t(Ld, _, p, Ab, yt, de, JE) : F0(Wt) ? _t(Ld, _, p, Eh, yt, de, tp) : Q.none), (co) => {
          const Mo = (Sr) => () => je(Sr, (xr) => Nm(xr.rows, xr.cols, d, co, b)).fold(() => M1(d, b.firstSelectedSelector, b.lastSelectedSelector).map((xr) => {
            const gl = zh(Wt) || It.isForward(Wt) ? Yc.after : Yc.before;
            return _.setRelativeSelection(Yc.on(xr.first, 0), gl(xr.table)), b.clear(d), _c.create(Q.none(), !0);
          }), (xr) => Q.some(_c.create(Q.none(), !0)));
          return zh(Wt) && ot ? Mo([sp(1, 0)]) : F0(Wt) && ot ? Mo([sp(-1, 0)]) : It.isBackward(Wt) && ot ? Mo([
            sp(0, -1),
            sp(-1, 0)
          ]) : It.isForward(Wt) && ot ? Mo([
            sp(0, 1),
            sp(1, 0)
          ]) : zb(Wt) && !ot ? A : Q.none;
        })();
      },
      keyup: (Y, de, Ee, yt, Ut) => Zu(d, b.selectedSelector).fold(() => {
        const It = Y.raw, st = It.which;
        return It.shiftKey === !0 && zb(st) ? Kw(d, p, de, Ee, yt, Ut, b.selectRange) : Q.none();
      }, Q.none)
    };
  }, sx = (i, d, p, b) => {
    const _ = If(i);
    return (A, N) => {
      b.clearBeforeUpdate(d), no(A, N, p).each((L) => {
        const Y = L.boxes.getOr([]);
        b.selectRange(d, Y, L.start, L.finish), _.selectContents(N), _.collapseSelection();
      });
    };
  }, Rh = (i, d) => {
    const p = Gn(i, d);
    return p === void 0 || p === "" ? [] : p.split(" ");
  }, $b = (i, d, p) => {
    const _ = Rh(i, d).concat([p]);
    return Fs(i, d, _.join(" ")), !0;
  }, Mh = (i, d, p) => {
    const b = Fn(Rh(i, d), (_) => _ !== p);
    return b.length > 0 ? Fs(i, d, b.join(" ")) : Ss(i, d), !1;
  }, Lf = (i) => i.dom.classList !== void 0, Cc = (i) => Rh(i, "class"), Ki = (i, d) => $b(i, "class", d), vu = (i, d) => Mh(i, "class", d), ku = (i, d) => {
    Lf(i) ? i.dom.classList.add(d) : Ki(i, d);
  }, Pb = (i) => {
    (Lf(i) ? i.dom.classList : Cc(i)).length === 0 && Ss(i, "class");
  }, rx = (i, d) => {
    Lf(i) ? i.dom.classList.remove(d) : vu(i, d), Pb(i);
  }, Nh = (i, d) => Lf(i) && i.dom.classList.contains(d), ax = (i, d) => {
    un(d, (p) => {
      rx(i, p);
    });
  }, U0 = (i) => (d) => {
    ku(d, i);
  }, W0 = (i) => (d) => {
    ax(d, i);
  }, v_ = {
    byClass: (i) => {
      const d = U0(i.selected), p = W0([
        i.selected,
        i.lastSelected,
        i.firstSelected
      ]), b = (A) => {
        const N = Zr(A, i.selectedSelector);
        un(N, p);
      };
      return {
        clearBeforeUpdate: b,
        clear: b,
        selectRange: (A, N, L, Y) => {
          b(A), un(N, d), ku(L, i.firstSelected), ku(Y, i.lastSelected);
        },
        selectedSelector: i.selectedSelector,
        firstSelectedSelector: i.firstSelectedSelector,
        lastSelectedSelector: i.lastSelectedSelector
      };
    },
    byAttr: (i, d, p) => {
      const b = (Y) => {
        Ss(Y, i.selected), Ss(Y, i.firstSelected), Ss(Y, i.lastSelected);
      }, _ = (Y) => {
        Fs(Y, i.selected, "1");
      }, A = (Y) => {
        N(Y), p();
      }, N = (Y) => {
        const de = Zr(Y, `${i.selectedSelector},${i.firstSelectedSelector},${i.lastSelectedSelector}`);
        un(de, b);
      };
      return {
        clearBeforeUpdate: N,
        clear: A,
        selectRange: (Y, de, Ee, yt) => {
          A(Y), un(de, _), Fs(Ee, i.firstSelected, "1"), Fs(yt, i.lastSelected, "1"), d(de, Ee, yt);
        },
        selectedSelector: i.selectedSelector,
        firstSelectedSelector: i.firstSelectedSelector,
        lastSelectedSelector: i.lastSelectedSelector
      };
    }
  }, Z0 = (i, d, p, b) => {
    switch (i.tag) {
      case "none":
        return d();
      case "single":
        return b(i.element);
      case "multiple":
        return p(i.elements);
    }
  }, q0 = () => ({ tag: "none" }), Ds = (i) => ({
    tag: "multiple",
    elements: i
  }), Ti = (i) => ({
    tag: "single",
    element: i
  }), k_ = (i, d, p) => ({ get: () => qu(i(), p).fold(() => d().fold(q0, Ti), Ds) }), w_ = (i, d) => {
    const p = i.slice(0, d[d.length - 1].row + 1), b = ch(p);
    return en(b, (_) => {
      const A = _.cells.slice(0, d[d.length - 1].column + 1);
      return Rt(A, (N) => N.element);
    });
  }, __ = (i, d) => {
    const p = i.slice(d[0].row + d[0].rowspan - 1, i.length), b = ch(p);
    return en(b, (_) => {
      const A = _.cells.slice(d[0].column + d[0].colspan - 1, _.cells.length);
      return Rt(A, (N) => N.element);
    });
  }, G0 = (i, d, p) => {
    const b = Po.fromTable(i);
    return hi(b, d).map((A) => {
      const N = ah(b, p, !1), { rows: L } = vs(N), Y = w_(L, A), de = __(L, A);
      return {
        upOrLeftCells: Y,
        downOrRightCells: de
      };
    });
  }, C_ = (i, d, p, b, _, A, N) => ({
    target: i,
    x: d,
    y: p,
    stop: b,
    prevent: _,
    kill: A,
    raw: N
  }), Fb = (i) => {
    const d = Z.fromDom(to(i).getOr(i.target)), p = () => i.stopPropagation(), b = () => i.preventDefault(), _ = At(b, p);
    return C_(d, i.clientX, i.clientY, p, b, _, i);
  }, lx = (i, d) => (p) => {
    i(p) && d(Fb(p));
  }, rp = (i, d, p, b, _) => {
    const A = lx(p, b);
    return i.dom.addEventListener(d, A, _), { unbind: _t(ix, i, d, A, _) };
  }, Bh = (i, d, p, b) => rp(i, d, p, b, !1), ix = (i, d, p, b) => {
    i.dom.removeEventListener(d, p, b);
  }, Ib = lt, ap = (i, d, p) => Bh(i, d, Ib, p), Hf = Fb, K0 = (i) => Nh(Z.fromDom(i.target), "ephox-snooker-resizer-bar") === !1, ux = (i, d) => {
    const p = k_(() => Z.fromDom(i.getBody()), () => B1(Gl(i), Li(i)), kr.selectedSelector), b = (Y, de, Ee) => {
      Ba(de).each((Ut) => {
        const It = Aw(i), st = dr(Ge, Z.fromDom(i.getDoc()), It), Wt = Gu(i), ot = G0(Ut, { selection: Wt }, st);
        gS(i, Y, de, Ee, ot);
      });
    }, _ = () => xw(i), A = v_.byAttr(kr, b, _);
    return i.on("init", (Y) => {
      const de = i.getWin(), Ee = xd(i), yt = Li(i), Ut = () => {
        const Ys = i.selection, Sc = Z.fromDom(Ys.getStart()), Nc = Z.fromDom(Ys.getEnd());
        Kp(Ba, [
          Sc,
          Nc
        ]).fold(() => A.clear(Ee), Ge);
      }, It = y_(de, Ee, yt, A), st = ox(de, Ee, yt, A), Wt = sx(de, Ee, yt, A), ot = (Ys) => Ys.raw.shiftKey === !0;
      i.on("TableSelectorChange", (Ys) => Wt(Ys.start, Ys.finish));
      const gn = (Ys, Sc) => {
        !ot(Ys) || (Sc.kill && Ys.kill(), Sc.selection.each((Nc) => {
          const Yi = np.relative(Nc.start, Nc.finish), zi = hu(de, Yi);
          i.selection.setRng(zi);
        }));
      }, co = (Ys) => {
        const Sc = Hf(Ys);
        if (Sc.raw.shiftKey && zb(Sc.raw.which)) {
          const Nc = i.selection.getRng(), Yi = Z.fromDom(Nc.startContainer), zi = Z.fromDom(Nc.endContainer);
          st.keyup(Sc, Yi, Nc.startOffset, zi, Nc.endOffset).each((mp) => {
            gn(Sc, mp);
          });
        }
      }, Mo = (Ys) => {
        const Sc = Hf(Ys);
        d.hide();
        const Nc = i.selection.getRng(), Yi = Z.fromDom(Nc.startContainer), zi = Z.fromDom(Nc.endContainer), mp = Hp(l_, XS)(Z.fromDom(i.selection.getStart()));
        st.keydown(Sc, Yi, Nc.startOffset, zi, Nc.endOffset, mp).each((xc) => {
          gn(Sc, xc);
        }), d.show();
      }, Sr = (Ys) => Ys.button === 0, da = (Ys) => Ys.buttons === void 0 ? !0 : (Ys.buttons & 1) !== 0, xr = (Ys) => {
        It.clearstate();
      }, gl = (Ys) => {
        Sr(Ys) && K0(Ys) && It.mousedown(Hf(Ys));
      }, dp = (Ys) => {
        da(Ys) && K0(Ys) && It.mouseover(Hf(Ys));
      }, fp = (Ys) => {
        Sr(Ys) && K0(Ys) && It.mouseup(Hf(Ys));
      }, Ih = (() => {
        const Ys = $0(Z.fromDom(Ee)), Sc = $0(0);
        return { touchEnd: (Yi) => {
          const zi = Z.fromDom(Yi.target);
          if (Zs("td")(zi) || Zs("th")(zi)) {
            const mp = Ys.get(), xc = Sc.get();
            Ft(mp, zi) && Yi.timeStamp - xc < 300 && (Yi.preventDefault(), Wt(zi, zi));
          }
          Ys.set(zi), Sc.set(Yi.timeStamp);
        } };
      })();
      i.on("dragstart", xr), i.on("mousedown", gl), i.on("mouseover", dp), i.on("mouseup", fp), i.on("touchend", Ih.touchEnd), i.on("keyup", co), i.on("keydown", Mo), i.on("NodeChange", Ut);
    }), i.on("PreInit", () => {
      i.serializer.addTempAttr(kr.firstSelected), i.serializer.addTempAttr(kr.lastSelected);
    }), {
      getSelectedCells: () => Z0(p.get(), Ue([]), (Y) => Rt(Y, (de) => de.dom), (Y) => [Y.dom]),
      clearSelectedCells: (Y) => A.clear(Z.fromDom(Y))
    };
  }, Ei = (i) => {
    let d = [];
    return {
      bind: (A) => {
        if (A === void 0)
          throw new Error("Event bind error: undefined handler");
        d.push(A);
      },
      unbind: (A) => {
        d = Fn(d, (N) => N !== A);
      },
      trigger: (...A) => {
        const N = {};
        un(i, (L, Y) => {
          N[L] = A[Y];
        }), un(d, (L) => {
          L(N);
        });
      }
    };
  }, Wa = (i) => {
    const d = Ht(i, (b) => ({
      bind: b.bind,
      unbind: b.unbind
    })), p = Ht(i, (b) => b.trigger);
    return {
      registry: d,
      trigger: p
    };
  }, Jc = (i, d) => {
    let p = null;
    const b = () => {
      $t(p) || (clearTimeout(p), p = null);
    };
    return {
      cancel: b,
      throttle: (...A) => {
        b(), p = setTimeout(() => {
          p = null, i.apply(null, A);
        }, d);
      }
    };
  }, wu = (i) => i.slice(0).sort(), QE = (i, d) => {
    throw new Error("All required keys (" + wu(i).join(", ") + ") were not specified. Specified keys were: " + wu(d).join(", ") + ".");
  }, Y0 = (i) => {
    throw new Error("Unsupported keys for object: " + wu(i).join(", "));
  }, dx = (i, d) => {
    if (!Bt(d))
      throw new Error("The " + i + " fields must be an array. Was: " + d + ".");
    un(d, (p) => {
      if (!ho(p))
        throw new Error("The value " + p + " in the " + i + " fields was not a string.");
    });
  }, cs = (i, d) => {
    throw new Error("All values need to be of type: " + d + ". Keys (" + wu(i).join(", ") + ") were not.");
  }, S_ = (i) => {
    const d = wu(i);
    Xe(d, (b, _) => _ < d.length - 1 && b === d[_ + 1]).each((b) => {
      throw new Error("The field: " + b + " occurs more than once in the combined fields: [" + d.join(", ") + "].");
    });
  }, x_ = (i, d) => X0(i, d, {
    validate: mt,
    label: "function"
  }), X0 = (i, d, p) => {
    if (d.length === 0)
      throw new Error("You must specify at least one required field.");
    return dx("required", d), S_(d), (b) => {
      const _ = ke(b);
      Pt(d, (L) => Qe(_, L)) || QE(d, _), i(d, _);
      const N = Fn(d, (L) => !p.validate(b[L], L));
      return N.length > 0 && cs(N, p.label), b;
    };
  }, J0 = (i, d) => {
    const p = Fn(d, (b) => !Qe(i, b));
    p.length > 0 && Y0(p);
  }, Lb = (i) => x_(J0, i), Hb = Lb([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]), Vb = Lb([
    "element",
    "start",
    "stop",
    "destroy"
  ]), jb = Lb([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]), cp = () => {
    let i = Q.none();
    const d = () => {
      i = Q.none();
    }, p = (A, N) => {
      const L = i.map((Y) => A.compare(Y, N));
      return i = Q.some(N), L;
    }, b = (A, N) => {
      N.extract(A).each((Y) => {
        p(N, Y).each((Ee) => {
          _.trigger.move(Ee);
        });
      });
    }, _ = Wa({ move: Ei(["info"]) });
    return {
      onEvent: b,
      reset: d,
      events: _.registry
    };
  }, T_ = () => {
    const i = Wa({ move: Ei(["info"]) });
    return {
      onEvent: Ge,
      reset: Ge,
      events: i.registry
    };
  }, Q0 = () => {
    const i = T_(), d = cp();
    let p = i;
    return {
      on: () => {
        p.reset(), p = d;
      },
      off: () => {
        p.reset(), p = i;
      },
      isOn: () => p === d,
      onEvent: (L, Y) => {
        p.onEvent(L, Y);
      },
      events: d.events
    };
  }, E_ = (i, d, p) => {
    let b = !1;
    const _ = Wa({
      start: Ei([]),
      stop: Ei([])
    }), A = Q0(), N = () => {
      It.stop(), A.isOn() && (A.off(), _.trigger.stop());
    }, L = Jc(N, 200), Y = (Wt) => {
      It.start(Wt), A.on(), _.trigger.start();
    }, de = (Wt) => {
      L.cancel(), A.onEvent(Wt, d);
    };
    A.events.move.bind((Wt) => {
      d.mutate(i, Wt.info);
    });
    const Ee = () => {
      b = !0;
    }, yt = () => {
      b = !1;
    }, Ut = (Wt) => (...ot) => {
      b && Wt.apply(null, ot);
    }, It = d.sink(jb({
      forceDrop: N,
      drop: Ut(N),
      move: Ut(de),
      delayDrop: Ut(L.throttle)
    }), p), st = () => {
      It.destroy();
    };
    return {
      element: It.element,
      go: Y,
      on: Ee,
      off: yt,
      destroy: st,
      events: _.registry
    };
  }, A_ = (i) => {
    const d = i.replace(/\./g, "-");
    return { resolve: (b) => d + "-" + b };
  }, mx = A_("ephox-dragster").resolve, v7 = (i) => {
    const d = {
      layerClass: mx("blocker"),
      ...i
    }, p = Z.fromTag("div");
    return Fs(p, "role", "presentation"), Ps(p, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    }), ku(p, mx("blocker")), ku(p, d.layerClass), {
      element: Ue(p),
      destroy: () => {
        br(p);
      }
    };
  };
  var gx = Hb({
    compare: (i, d) => ll(d.left - i.left, d.top - i.top),
    extract: (i) => Q.some(ll(i.x, i.y)),
    sink: (i, d) => {
      const p = v7(d), b = ap(p.element(), "mousedown", i.forceDrop), _ = ap(p.element(), "mouseup", i.drop), A = ap(p.element(), "mousemove", i.move), N = ap(p.element(), "mouseout", i.delayDrop), L = () => {
        p.destroy(), _.unbind(), A.unbind(), N.unbind(), b.unbind();
      }, Y = (Ee) => {
        zo(Ee, p.element());
      }, de = () => {
        br(p.element());
      };
      return Vb({
        element: p.element,
        start: Y,
        stop: de,
        destroy: L
      });
    },
    mutate: (i, d) => {
      i.mutate(d.left, d.top);
    }
  });
  const px = (i, d = {}) => {
    var p;
    const b = (p = d.mode) !== null && p !== void 0 ? p : gx;
    return E_(i, b, d);
  }, $h = A_("ephox-snooker").resolve, hx = () => {
    const i = Wa({
      drag: Ei([
        "xDelta",
        "yDelta"
      ])
    });
    return {
      mutate: (p, b) => {
        i.trigger.drag(p, b);
      },
      events: i.registry
    };
  }, yx = () => {
    const i = Wa({
      drag: Ei([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let d = Q.none();
    const p = hx();
    return p.events.drag.bind((A) => {
      d.each((N) => {
        i.trigger.drag(A.xDelta, A.yDelta, N);
      });
    }), {
      assign: (A) => {
        d = Q.some(A);
      },
      get: () => d,
      mutate: p.mutate,
      events: i.registry
    };
  }, z_ = (i, d, p, b, _) => {
    const A = Z.fromTag("div");
    return Ps(A, {
      position: "absolute",
      left: d - b / 2 + "px",
      top: p + "px",
      height: _ + "px",
      width: b + "px"
    }), Tr(A, {
      "data-column": i,
      role: "presentation"
    }), A;
  }, Wb = (i, d, p, b, _) => {
    const A = Z.fromTag("div");
    return Ps(A, {
      position: "absolute",
      left: d + "px",
      top: p - _ / 2 + "px",
      height: _ + "px",
      width: b + "px"
    }), Tr(A, {
      "data-row": i,
      role: "presentation"
    }), A;
  }, tv = $h("resizer-bar"), nv = $h("resizer-rows"), ov = $h("resizer-cols"), Ph = 7, sv = (i, d) => en(i.all, (p, b) => d(p.element) ? [b] : []), O_ = (i, d) => {
    const p = [];
    return Pe(i.grid.columns, (b) => {
      Po.getColumnAt(i, b).map((A) => A.element).forall(d) && p.push(b);
    }), Fn(p, (b) => {
      const _ = Po.filterItems(i, (A) => A.column === b);
      return Pt(_, (A) => d(A.element));
    });
  }, Zb = (i) => {
    const d = Zr(i.parent(), "." + tv);
    un(d, br);
  }, rv = (i, d, p) => {
    const b = i.origin();
    un(d, (_) => {
      _.each((A) => {
        const N = p(b, A);
        ku(N, tv), zo(i.parent(), N);
      });
    });
  }, bx = (i, d, p, b) => {
    rv(i, d, (_, A) => {
      const N = z_(A.col, A.x - _.left, p.top - _.top, Ph, b);
      return ku(N, ov), N;
    });
  }, vx = (i, d, p, b) => {
    rv(i, d, (_, A) => {
      const N = Wb(A.row, p.left - _.left, A.y - _.top, b, Ph);
      return ku(N, nv), N;
    });
  }, Hs = (i, d, p, b, _) => {
    const A = mi(p), N = d.isResizable, L = b.length > 0 ? yd.positions(b, p) : [], Y = L.length > 0 ? sv(i, N) : [], de = Fn(L, (It, st) => z(Y, (Wt) => st === Wt));
    vx(d, de, A, Mr(p));
    const Ee = _.length > 0 ? Pr.positions(_, p) : [], yt = Ee.length > 0 ? O_(i, N) : [], Ut = Fn(Ee, (It, st) => z(yt, (Wt) => st === Wt));
    bx(d, Ut, A, Wl(p));
  }, av = (i, d) => {
    if (Zb(i), i.isResizable(d)) {
      const p = Po.fromTable(d), b = ig(p), _ = hd(p);
      Hs(p, i, d, b, _);
    }
  }, Ai = (i, d) => {
    const p = Zr(i.parent(), "." + tv);
    un(p, d);
  }, _u = (i) => {
    Ai(i, (d) => {
      Oo(d, "display", "none");
    });
  }, Fh = (i) => {
    Ai(i, (d) => {
      Oo(d, "display", "block");
    });
  }, Qc = (i) => Nh(i, nv), qb = (i) => Nh(i, ov), lp = $h("resizer-bar-dragging"), Gb = (i) => {
    const d = yx(), p = px(d, {});
    let b = Q.none();
    const _ = (st, Wt) => Q.from(Gn(st, Wt));
    d.events.drag.bind((st) => {
      _(st.target, "data-row").each((Wt) => {
        const ot = $r(st.target, "top");
        Oo(st.target, "top", ot + st.yDelta + "px");
      }), _(st.target, "data-column").each((Wt) => {
        const ot = $r(st.target, "left");
        Oo(st.target, "left", ot + st.xDelta + "px");
      });
    });
    const A = (st, Wt) => {
      const ot = $r(st, Wt), gn = ur(st, "data-initial-" + Wt, 0);
      return ot - gn;
    };
    p.events.stop.bind(() => {
      d.get().each((st) => {
        b.each((Wt) => {
          _(st, "data-row").each((ot) => {
            const gn = A(st, "top");
            Ss(st, "data-initial-top"), It.trigger.adjustHeight(Wt, gn, parseInt(ot, 10));
          }), _(st, "data-column").each((ot) => {
            const gn = A(st, "left");
            Ss(st, "data-initial-left"), It.trigger.adjustWidth(Wt, gn, parseInt(ot, 10));
          }), av(i, Wt);
        });
      });
    });
    const N = (st, Wt) => {
      It.trigger.startAdjust(), d.assign(st), Fs(st, "data-initial-" + Wt, $r(st, Wt)), ku(st, lp), Oo(st, "opacity", "0.2"), p.go(i.parent());
    }, L = ap(i.parent(), "mousedown", (st) => {
      Qc(st.target) && N(st.target, "top"), qb(st.target) && N(st.target, "left");
    }), Y = (st) => Ft(st, i.view()), de = (st) => Jo(st, "table", Y).filter(Gk), Ee = ap(i.view(), "mouseover", (st) => {
      de(st.target).fold(() => {
        Vo(st.target) && Zb(i);
      }, (Wt) => {
        b = Q.some(Wt), av(i, Wt);
      });
    }), yt = () => {
      L.unbind(), Ee.unbind(), p.destroy(), Zb(i);
    }, Ut = (st) => {
      av(i, st);
    }, It = Wa({
      adjustHeight: Ei([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: Ei([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: Ei([])
    });
    return {
      destroy: yt,
      refresh: Ut,
      on: p.on,
      off: p.off,
      hideBars: _t(_u, i),
      showBars: _t(Fh, i),
      events: It.registry
    };
  }, D_ = { create: (i, d, p) => {
    const b = yd, _ = Pr, A = Gb(i), N = Wa({
      beforeResize: Ei([
        "table",
        "type"
      ]),
      afterResize: Ei([
        "table",
        "type"
      ]),
      startDrag: Ei([])
    });
    return A.events.adjustHeight.bind((L) => {
      const Y = L.table;
      N.trigger.beforeResize(Y, "row");
      const de = b.delta(L.delta, Y);
      Gy(Y, de, L.row, b), N.trigger.afterResize(Y, "row");
    }), A.events.startAdjust.bind((L) => {
      N.trigger.startDrag();
    }), A.events.adjustWidth.bind((L) => {
      const Y = L.table;
      N.trigger.beforeResize(Y, "col");
      const de = _.delta(L.delta, Y), Ee = p(Y);
      uh(Y, de, L.column, d, Ee), N.trigger.afterResize(Y, "col");
    }), {
      on: A.on,
      off: A.off,
      refreshBars: A.refresh,
      hideBars: A.hideBars,
      showBars: A.showBars,
      destroy: A.destroy,
      events: N.registry
    };
  } }, ls = {
    only: (i, d) => {
      const p = pr(i) ? yr(i) : i;
      return {
        parent: Ue(p),
        view: Ue(i),
        origin: Ue(ll(0, 0)),
        isResizable: d
      };
    },
    detached: (i, d, p) => {
      const b = () => mi(d);
      return {
        parent: Ue(d),
        view: Ue(i),
        origin: b,
        isResizable: p
      };
    },
    body: (i, d, p) => ({
      parent: Ue(d),
      view: Ue(i),
      origin: Ue(ll(0, 0)),
      isResizable: p
    })
  }, Cu = () => {
    const i = Z.fromTag("div");
    return Ps(i, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    }), zo(ha(), i), i;
  }, up = (i, d) => i.inline ? ls.body(Z.fromDom(i.getBody()), Cu(), d) : ls.only(Z.fromDom(i.getDoc()), d), cv = (i, d) => {
    i.inline && br(d.parent());
  }, Vf = (i) => tn(i) && i.tagName === "TABLE", gs = "bar-", s5 = (i) => Gn(i, "data-mce-resize") !== "false", lv = (i) => {
    const d = Po.fromTable(i);
    Po.hasColumns(d) || un(Bi(i), (p) => {
      const b = uc(p, "width");
      Oo(p, "width", b), Ss(p, "width");
    });
  }, iv = (i) => {
    const d = xh(), p = xh(), b = xh();
    let _, A;
    const N = (st) => Mw(i, st), L = () => rb(i) ? Sg() : qk(), Y = (st) => xg(st).columns, de = (st, Wt, ot) => {
      const gn = re(Wt, "e");
      if (A === "" && Vg(st), ot !== _ && A !== "") {
        Oo(st, "width", A);
        const co = L(), Mo = N(st), Sr = rb(i) || gn ? Y(st) - 1 : 0;
        uh(st, ot - _, Sr, co, Mo);
      } else if (Hk(A)) {
        const co = parseFloat(A.replace("%", "")), Mo = ot * co / _;
        Oo(st, "width", Mo + "%");
      }
      MC(A) && lv(st);
    }, Ee = () => {
      p.on((st) => {
        st.destroy();
      }), b.on((st) => {
        cv(i, st);
      });
    };
    return i.on("init", () => {
      const st = up(i, s5);
      if (b.set(st), vS(i) && Dw(i)) {
        const Wt = L(), ot = D_.create(st, Wt, N);
        ot.on(), ot.events.startDrag.bind((gn) => {
          d.set(i.selection.getRng());
        }), ot.events.beforeResize.bind((gn) => {
          const co = gn.table.dom;
          pS(i, co, yg(co), O1(co), gs + gn.type);
        }), ot.events.afterResize.bind((gn) => {
          const co = gn.table, Mo = co.dom;
          Zc(co), d.on((Sr) => {
            i.selection.setRng(Sr), i.focus();
          }), hS(i, Mo, yg(Mo), O1(Mo), gs + gn.type), i.undoManager.add();
        }), p.set(ot);
      }
    }), i.on("ObjectResizeStart", (st) => {
      const Wt = st.target;
      if (Vf(Wt)) {
        const ot = Z.fromDom(Wt);
        un(i.dom.select(".mce-clonedresizable"), (gn) => {
          i.dom.addClass(gn, "mce-" + i0(i) + "-columns");
        }), !ed(ot) && Ju(i) ? Om(ot) : !Fw(ot) && Ar(i) && Vg(ot), ph(ot) && G(st.origin, gs) && Vg(ot), _ = st.width, A = Va(i) ? "" : Gp(i, Wt).getOr("");
      }
    }), i.on("ObjectResized", (st) => {
      const Wt = st.target;
      if (Vf(Wt)) {
        const ot = Z.fromDom(Wt), gn = st.origin;
        G(gn, "corner-") && de(ot, gn, st.width), Zc(ot), Bd(i, ot.dom, ob);
      }
    }), i.on("SwitchMode", () => {
      p.on((st) => {
        i.mode.isReadOnly() ? st.hideBars() : st.showBars();
      });
    }), i.on("remove", () => {
      Ee();
    }), {
      refresh: (st) => {
        p.on((Wt) => Wt.refreshBars(Z.fromDom(st)));
      },
      hide: () => {
        p.on((st) => st.hideBars());
      },
      show: () => {
        p.on((st) => st.showBars());
      }
    };
  }, kx = (i) => {
    Ew(i);
    const d = iv(i), p = ux(i, d), b = wS(i, d, p);
    return Hw(i, b), k0(i, b), LC(i, b), {
      getSelectedCells: p.getSelectedCells,
      clearSelectedCells: p.clearSelectedCells
    };
  }, ml = (i) => ({ table: kx(i) });
  var Lm = () => {
    ns.add("dom", ml);
  };
  Lm();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (Je, rt, lt) => {
    const Q = rt === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
    Je.execCommand(Q, !1, lt === !1 ? null : { "list-style-type": lt });
  }, Eo = (Je) => {
    Je.addCommand("ApplyUnorderedListStyle", (rt, lt) => {
      To(Je, "UL", lt["list-style-type"]);
    }), Je.addCommand("ApplyOrderedListStyle", (rt, lt) => {
      To(Je, "OL", lt["list-style-type"]);
    });
  }, In = (Je) => (rt) => rt.options.get(Je), Jn = (Je) => {
    const rt = Je.options.register;
    rt("advlist_number_styles", {
      processor: "string[]",
      default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
    }), rt("advlist_bullet_styles", {
      processor: "string[]",
      default: "default,circle,square".split(",")
    });
  }, uo = In("advlist_number_styles"), ho = In("advlist_bullet_styles");
  var Kt = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Bt = (Je) => Je == null, $t = (Je) => !Bt(Je);
  class Un {
    constructor(rt, lt) {
      this.tag = rt, this.value = lt;
    }
    static some(rt) {
      return new Un(!0, rt);
    }
    static none() {
      return Un.singletonNone;
    }
    fold(rt, lt) {
      return this.tag ? lt(this.value) : rt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(rt) {
      return this.tag ? Un.some(rt(this.value)) : Un.none();
    }
    bind(rt) {
      return this.tag ? rt(this.value) : Un.none();
    }
    exists(rt) {
      return this.tag && rt(this.value);
    }
    forall(rt) {
      return !this.tag || rt(this.value);
    }
    filter(rt) {
      return !this.tag || rt(this.value) ? this : Un.none();
    }
    getOr(rt) {
      return this.tag ? this.value : rt;
    }
    or(rt) {
      return this.tag ? this : rt;
    }
    getOrThunk(rt) {
      return this.tag ? this.value : rt();
    }
    orThunk(rt) {
      return this.tag ? this : rt();
    }
    getOrDie(rt) {
      if (this.tag)
        return this.value;
      throw new Error(rt != null ? rt : "Called getOrDie on None");
    }
    static from(rt) {
      return $t(rt) ? Un.some(rt) : Un.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(rt) {
      this.tag && rt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Un.singletonNone = new Un(!1);
  const Ao = (Je, rt) => Je.dom.isChildOf(rt, Je.getBody()), tn = (Je) => Je && /^(TH|TD)$/.test(Je.nodeName), mt = (Je) => (rt) => rt && /^(OL|UL|DL)$/.test(rt.nodeName) && Ao(Je, rt), an = (Je) => {
    const rt = Je.dom.getParent(Je.selection.getNode(), "ol,ul"), lt = Je.dom.getStyle(rt, "listStyleType");
    return Un.from(lt);
  }, Ge = (Je, rt) => {
    for (let lt = 0; lt < Je.length; lt++) {
      const Q = Je[lt];
      if (rt(Q))
        return lt;
    }
    return -1;
  }, At = (Je) => Je.replace(/\-/g, " ").replace(/\b\w/g, (rt) => rt.toUpperCase()), He = (Je, rt, lt) => {
    const Q = Ge(rt.parents, tn), wn = Q !== -1 ? rt.parents.slice(0, Q) : rt.parents, ft = Kt.grep(wn, mt(Je));
    return ft.length > 0 && ft[0].nodeName === lt;
  }, Ue = (Je, rt) => (lt) => {
    const Q = (wn) => {
      lt.setActive(He(Je, wn, rt));
    };
    return Je.on("NodeChange", Q), () => Je.off("NodeChange", Q);
  }, ie = (Je, rt, lt, Q, wn, ft) => {
    Je.ui.registry.addSplitButton(rt, {
      tooltip: lt,
      icon: wn === "OL" ? "ordered-list" : "unordered-list",
      presets: "listpreview",
      columns: 3,
      fetch: (Ot) => {
        const Se = Kt.map(ft, (Qe) => {
          const z = wn === "OL" ? "num" : "bull", Pe = Qe === "disc" || Qe === "decimal" ? "default" : Qe, Rt = Qe === "default" ? "" : Qe, un = At(Qe);
          return {
            type: "choiceitem",
            value: Rt,
            icon: "list-" + z + "-" + Pe,
            text: un
          };
        });
        Ot(Se);
      },
      onAction: () => Je.execCommand(Q),
      onItemAction: (Ot, Se) => {
        To(Je, wn, Se);
      },
      select: (Ot) => an(Je).map((Qe) => Ot === Qe).getOr(!1),
      onSetup: Ue(Je, wn)
    });
  }, dn = (Je, rt, lt, Q, wn, ft) => {
    Je.ui.registry.addToggleButton(rt, {
      active: !1,
      tooltip: lt,
      icon: wn === "OL" ? "ordered-list" : "unordered-list",
      onSetup: Ue(Je, wn),
      onAction: () => Je.execCommand(Q)
    });
  }, _t = (Je, rt, lt, Q, wn, ft) => {
    ft.length > 1 ? ie(Je, rt, lt, Q, wn, ft) : dn(Je, rt, lt, Q, wn);
  }, Re = (Je) => {
    _t(Je, "numlist", "Numbered list", "InsertOrderedList", "OL", uo(Je)), _t(Je, "bullist", "Bullet list", "InsertUnorderedList", "UL", ho(Je));
  };
  var oe = () => {
    ns.add("advlist", (Je) => {
      Je.hasPlugin("lists") ? (Jn(Je), Re(Je), Eo(Je)) : console.error("Please use the Lists plugin together with the Advanced List plugin.");
    });
  };
  oe();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = () => /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g, Eo = (Se) => (Qe) => Qe.options.get(Se), In = (Se) => {
    const Qe = Se.options.register;
    Qe("autolink_pattern", {
      processor: "regexp",
      default: new RegExp("^" + To().source + "$", "i")
    }), Qe("link_default_target", { processor: "string" }), Qe("link_default_protocol", {
      processor: "string",
      default: "https"
    });
  }, Jn = Eo("autolink_pattern"), uo = Eo("link_default_target"), ho = Eo("link_default_protocol"), Kt = (Se, Qe, z) => {
    var Pe;
    return z(Se, Qe.prototype) ? !0 : ((Pe = Se.constructor) === null || Pe === void 0 ? void 0 : Pe.name) === Qe.name;
  }, Bt = (Se) => {
    const Qe = typeof Se;
    return Se === null ? "null" : Qe === "object" && Array.isArray(Se) ? "array" : Qe === "object" && Kt(Se, String, (z, Pe) => Pe.isPrototypeOf(z)) ? "string" : Qe;
  }, Un = ((Se) => (Qe) => Bt(Qe) === Se)("string"), Ao = (Se) => Se == null, tn = (Se) => !Ao(Se), mt = (Se, Qe, z) => Qe === "" || Se.length >= Qe.length && Se.substr(z, z + Qe.length) === Qe, an = (Se, Qe) => Se.indexOf(Qe) !== -1, Ge = (Se, Qe) => mt(Se, Qe, 0), At = (Se) => /^[(\[{ \u00a0]$/.test(Se), He = (Se) => Se.nodeType === 3, Ue = (Se) => Se.nodeType === 1, ie = (Se, Qe) => {
    if (Qe < 0 && (Qe = 0), He(Se)) {
      const z = Se.data.length;
      Qe > z && (Qe = z);
    }
    return Qe;
  }, dn = (Se, Qe, z) => {
    !Ue(Qe) || Qe.hasChildNodes() ? Se.setStart(Qe, ie(Qe, z)) : Se.setStartBefore(Qe);
  }, _t = (Se, Qe, z) => {
    !Ue(Qe) || Qe.hasChildNodes() ? Se.setEnd(Qe, ie(Qe, z)) : Se.setEndAfter(Qe);
  }, Re = (Se) => /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(Se), oe = (Se) => /[?!,.;:]/.test(Se), Je = (Se, Qe) => {
    let z, Pe, Rt, un, Ct, _o;
    const Fn = Jn(Se);
    if (Se.dom.getParent(Se.selection.getNode(), "a[href]") !== null)
      return;
    const Sn = Se.selection.getRng().cloneRange();
    if (Sn.startOffset < 5) {
      if (un = Sn.endContainer.previousSibling, !un) {
        if (!Sn.endContainer.firstChild || !Sn.endContainer.firstChild.nextSibling)
          return;
        un = Sn.endContainer.firstChild.nextSibling;
      }
      if (Ct = un.length, dn(Sn, un, Ct), _t(Sn, un, Ct), Sn.endOffset < 5)
        return;
      z = Sn.endOffset, Pe = un;
    } else {
      if (Pe = Sn.endContainer, !He(Pe) && Pe.firstChild) {
        for (; !He(Pe) && Pe.firstChild; )
          Pe = Pe.firstChild;
        He(Pe) && (dn(Sn, Pe, 0), _t(Sn, Pe, Pe.nodeValue.length));
      }
      Sn.endOffset === 1 ? z = 2 : z = Sn.endOffset - 1 - Qe;
    }
    const Dn = z;
    do
      dn(Sn, Pe, z >= 2 ? z - 2 : 0), _t(Sn, Pe, z >= 1 ? z - 1 : 0), z -= 1, _o = Sn.toString();
    while (!At(_o) && z - 2 >= 0);
    At(Sn.toString()) ? (dn(Sn, Pe, z), _t(Sn, Pe, Dn), z += 1) : Sn.startOffset === 0 ? (dn(Sn, Pe, 0), _t(Sn, Pe, Dn)) : (dn(Sn, Pe, z), _t(Sn, Pe, Dn)), Rt = Sn.toString(), oe(Rt.charAt(Rt.length - 1)) && _t(Sn, Pe, Dn - 1), Rt = Sn.toString().trim();
    const Mn = Rt.match(Fn), Xe = ho(Se);
    if (Mn) {
      let O = Mn[0];
      return Ge(O, "www.") ? O = Xe + "://" + O : an(O, "@") && !Re(O) && (O = "mailto:" + O), {
        rng: Sn,
        url: O
      };
    } else
      return null;
  }, rt = (Se, Qe) => {
    const z = uo(Se), { rng: Pe, url: Rt } = Qe, un = Se.selection.getBookmark();
    Se.selection.setRng(Pe);
    const Ct = "createlink", _o = {
      command: Ct,
      ui: !1,
      value: Rt
    };
    Se.dispatch("BeforeExecCommand", _o).isDefaultPrevented() || (Se.getDoc().execCommand(Ct, !1, Rt), Se.dispatch("ExecCommand", _o), Un(z) && Se.dom.setAttrib(Se.selection.getNode(), "target", z)), Se.selection.moveToBookmark(un), Se.nodeChanged();
  }, lt = (Se) => {
    const Qe = Je(Se, 0);
    tn(Qe) && rt(Se, Qe);
  }, Q = lt, wn = (Se) => {
    const Qe = Je(Se, -1);
    tn(Qe) && rt(Se, Qe);
  }, ft = (Se) => {
    Se.on("keydown", (Qe) => {
      Qe.keyCode === 13 && !Qe.isDefaultPrevented() && wn(Se);
    }), Se.on("keyup", (Qe) => {
      Qe.keyCode === 32 ? lt(Se) : (Qe.keyCode === 48 && Qe.shiftKey || Qe.keyCode === 221) && Q(Se);
    });
  };
  var Ot = () => {
    ns.add("autolink", (Se) => {
      In(Se), ft(Se);
    });
  };
  Ot();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (E, M, H) => {
    var ye;
    return H(E, M.prototype) ? !0 : ((ye = E.constructor) === null || ye === void 0 ? void 0 : ye.name) === M.name;
  }, Eo = (E) => {
    const M = typeof E;
    return E === null ? "null" : M === "object" && Array.isArray(E) ? "array" : M === "object" && To(E, String, (H, ye) => ye.isPrototypeOf(H)) ? "string" : M;
  }, In = (E) => (M) => Eo(M) === E, Jn = (E) => (M) => typeof M === E, uo = In("string"), ho = In("object"), Kt = In("array"), Bt = Jn("boolean"), $t = (E) => E == null, Un = (E) => !$t(E), Ao = Jn("function"), tn = Jn("number"), mt = () => {
  }, an = (E) => () => E, Ge = (E, M) => E === M, At = (E) => (M) => !E(M), He = an(!1);
  class Ue {
    constructor(M, H) {
      this.tag = M, this.value = H;
    }
    static some(M) {
      return new Ue(!0, M);
    }
    static none() {
      return Ue.singletonNone;
    }
    fold(M, H) {
      return this.tag ? H(this.value) : M();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(M) {
      return this.tag ? Ue.some(M(this.value)) : Ue.none();
    }
    bind(M) {
      return this.tag ? M(this.value) : Ue.none();
    }
    exists(M) {
      return this.tag && M(this.value);
    }
    forall(M) {
      return !this.tag || M(this.value);
    }
    filter(M) {
      return !this.tag || M(this.value) ? this : Ue.none();
    }
    getOr(M) {
      return this.tag ? this.value : M;
    }
    or(M) {
      return this.tag ? this : M;
    }
    getOrThunk(M) {
      return this.tag ? this.value : M();
    }
    orThunk(M) {
      return this.tag ? this : M();
    }
    getOrDie(M) {
      if (this.tag)
        return this.value;
      throw new Error(M != null ? M : "Called getOrDie on None");
    }
    static from(M) {
      return Un(M) ? Ue.some(M) : Ue.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(M) {
      this.tag && M(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ue.singletonNone = new Ue(!1);
  const ie = Array.prototype.slice, dn = Array.prototype.indexOf, _t = Array.prototype.push, Re = (E, M) => dn.call(E, M), oe = (E, M) => Re(E, M) > -1, Je = (E, M) => {
    for (let H = 0, ye = E.length; H < ye; H++) {
      const ze = E[H];
      if (M(ze, H))
        return !0;
    }
    return !1;
  }, rt = (E, M) => {
    const H = E.length, ye = new Array(H);
    for (let ze = 0; ze < H; ze++) {
      const sn = E[ze];
      ye[ze] = M(sn, ze);
    }
    return ye;
  }, lt = (E, M) => {
    for (let H = 0, ye = E.length; H < ye; H++) {
      const ze = E[H];
      M(ze, H);
    }
  }, Q = (E, M) => {
    const H = [];
    for (let ye = 0, ze = E.length; ye < ze; ye++) {
      const sn = E[ye];
      M(sn, ye) && H.push(sn);
    }
    return H;
  }, wn = (E, M) => {
    if (E.length === 0)
      return [];
    {
      let H = M(E[0]);
      const ye = [];
      let ze = [];
      for (let sn = 0, Yn = E.length; sn < Yn; sn++) {
        const xo = E[sn], Zo = M(xo);
        Zo !== H && (ye.push(ze), ze = []), H = Zo, ze.push(xo);
      }
      return ze.length !== 0 && ye.push(ze), ye;
    }
  }, ft = (E, M, H) => (lt(E, (ye, ze) => {
    H = M(H, ye, ze);
  }), H), Ot = (E, M, H) => {
    for (let ye = 0, ze = E.length; ye < ze; ye++) {
      const sn = E[ye];
      if (M(sn, ye))
        return Ue.some(sn);
      if (H(sn, ye))
        break;
    }
    return Ue.none();
  }, Se = (E, M) => Ot(E, M, He), Qe = (E) => {
    const M = [];
    for (let H = 0, ye = E.length; H < ye; ++H) {
      if (!Kt(E[H]))
        throw new Error("Arr.flatten item " + H + " was not an array, input: " + E);
      _t.apply(M, E[H]);
    }
    return M;
  }, z = (E, M) => Qe(rt(E, M)), Pe = (E) => {
    const M = ie.call(E, 0);
    return M.reverse(), M;
  }, Rt = (E, M) => M >= 0 && M < E.length ? Ue.some(E[M]) : Ue.none(), un = (E) => Rt(E, 0), Ct = (E) => Rt(E, E.length - 1), _o = (E, M) => {
    const H = [], ye = Ao(M) ? (ze) => Je(H, (sn) => M(sn, ze)) : (ze) => oe(H, ze);
    for (let ze = 0, sn = E.length; ze < sn; ze++) {
      const Yn = E[ze];
      ye(Yn) || H.push(Yn);
    }
    return H;
  }, Fn = (E, M, H = Ge) => E.exists((ye) => H(ye, M)), Sn = (E, M, H = Ge) => Dn(E, M, H).getOr(E.isNone() && M.isNone()), Dn = (E, M, H) => E.isSome() && M.isSome() ? Ue.some(H(E.getOrDie(), M.getOrDie())) : Ue.none(), Mn = 1, Xe = (E, M) => {
    const ye = (M || document).createElement("div");
    if (ye.innerHTML = E, !ye.hasChildNodes() || ye.childNodes.length > 1) {
      const ze = "HTML does not have a single root node";
      throw console.error(ze, E), new Error(ze);
    }
    return en(ye.childNodes[0]);
  }, O = (E, M) => {
    const ye = (M || document).createElement(E);
    return en(ye);
  }, gt = (E, M) => {
    const ye = (M || document).createTextNode(E);
    return en(ye);
  }, en = (E) => {
    if (E == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: E };
  }, Ne = {
    fromHtml: Xe,
    fromTag: O,
    fromText: gt,
    fromDom: en,
    fromPoint: (E, M, H) => Ue.from(E.dom.elementFromPoint(M, H)).map(en)
  }, We = (E, M) => {
    const H = E.dom;
    if (H.nodeType !== Mn)
      return !1;
    {
      const ye = H;
      if (ye.matches !== void 0)
        return ye.matches(M);
      if (ye.msMatchesSelector !== void 0)
        return ye.msMatchesSelector(M);
      if (ye.webkitMatchesSelector !== void 0)
        return ye.webkitMatchesSelector(M);
      if (ye.mozMatchesSelector !== void 0)
        return ye.mozMatchesSelector(M);
      throw new Error("Browser lacks native selectors");
    }
  }, Ae = (E, M) => E.dom === M.dom, Oe = (E, M) => {
    const H = E.dom, ye = M.dom;
    return H === ye ? !1 : H.contains(ye);
  }, ae = We;
  var X = (E, M, H, ye, ze) => E(H, ye) ? Ue.some(H) : Ao(ze) && ze(H) ? Ue.none() : M(H, ye, ze);
  typeof window < "u" || Function("return this;")();
  const je = (E) => E.dom.nodeName.toLowerCase(), ke = (E) => E.dom.nodeType, ct = ((E) => (M) => ke(M) === E)(Mn), Ht = (E) => (M) => ct(M) && je(M) === E, vo = (E) => Ue.from(E.dom.parentNode).map(Ne.fromDom), Wn = (E) => Ue.from(E.dom.nextSibling).map(Ne.fromDom), ko = (E) => rt(E.dom.childNodes, Ne.fromDom), fo = (E, M) => {
    const H = E.dom.childNodes;
    return Ue.from(H[M]).map(Ne.fromDom);
  }, yn = (E) => fo(E, 0), ds = (E) => fo(E, E.dom.childNodes.length - 1), Ho = (E, M, H) => {
    let ye = E.dom;
    const ze = Ao(H) ? H : He;
    for (; ye.parentNode; ) {
      ye = ye.parentNode;
      const sn = Ne.fromDom(ye);
      if (M(sn))
        return Ue.some(sn);
      if (ze(sn))
        break;
    }
    return Ue.none();
  }, mn = (E, M, H) => X((ze, sn) => sn(ze), Ho, E, M, H), Io = (E, M) => {
    vo(E).each((ye) => {
      ye.dom.insertBefore(M.dom, E.dom);
    });
  }, ro = (E, M) => {
    Wn(E).fold(() => {
      vo(E).each((ze) => {
        Ln(ze, M);
      });
    }, (ye) => {
      Io(ye, M);
    });
  }, Ln = (E, M) => {
    E.dom.appendChild(M.dom);
  }, Go = (E, M) => {
    lt(M, (H) => {
      Io(E, H);
    });
  }, Ro = (E, M) => {
    lt(M, (H) => {
      Ln(E, H);
    });
  }, Os = (E) => {
    E.dom.textContent = "", lt(ko(E), (M) => {
      Qs(M);
    });
  }, Qs = (E) => {
    const M = E.dom;
    M.parentNode !== null && M.parentNode.removeChild(M);
  };
  var we = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), $e = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Vt = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Jt = Object.keys, ht = (E, M) => {
    const H = Jt(E);
    for (let ye = 0, ze = H.length; ye < ze; ye++) {
      const sn = H[ye], Yn = E[sn];
      M(Yn, sn);
    }
  }, qn = (E) => (M, H) => {
    E[H] = M;
  }, pr = (E, M, H, ye) => {
    const ze = {};
    return ht(E, (sn, Yn) => {
      (M(sn, Yn) ? H : ye)(sn, Yn);
    }), ze;
  }, zr = (E, M) => {
    const H = {};
    return pr(E, M, qn(H), mt), H;
  }, Zs = (E, M, H) => {
    if (uo(H) || Bt(H) || tn(H))
      E.setAttribute(M, H + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", M, ":: Value ", H, ":: Element ", E), new Error("Attribute value was not simple");
  }, hr = (E, M) => {
    const H = E.dom;
    ht(M, (ye, ze) => {
      Zs(H, ze, ye);
    });
  }, Fs = (E) => ft(E.dom.attributes, (M, H) => (M[H.name] = H.value, M), {}), Tr = (E, M) => Ne.fromDom(E.dom.cloneNode(M)), Xo = (E) => Tr(E, !0), Gn = (E, M) => {
    const H = Ne.fromTag(M), ye = Fs(E);
    return hr(H, ye), H;
  }, er = (E, M) => {
    const H = Gn(E, M);
    ro(E, H);
    const ye = ko(E);
    return Ro(H, ye), Qs(E), H;
  };
  var Ss = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), ir = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ka = (E) => (M) => M && M.nodeName.toLowerCase() === E, Ra = (E) => (M) => M && E.test(M.nodeName), Ur = (E) => E && E.nodeType === 3, rs = Ra(/^(OL|UL|DL)$/), cc = Ra(/^(OL|UL)$/), Z = Ka("ol"), le = Ra(/^(LI|DT|DD)$/), Ce = Ra(/^(DT|DD)$/), wt = Ra(/^(TH|TD)$/), Rn = Ka("br"), Ft = (E) => E.parentNode.firstChild === E, Co = (E, M) => M && !!E.schema.getTextBlockElements()[M.nodeName], tr = (E, M) => E && E.nodeName in M, Bn = (E, M) => Rn(M) ? E.isBlock(M.nextSibling) && !Rn(M.previousSibling) : !1, No = (E, M, H) => {
    const ye = E.isEmpty(M);
    return H && E.select("span[data-mce-type=bookmark]", M).length > 0 ? !1 : ye;
  }, yr = (E, M) => E.isChildOf(M, E.getRoot()), bt = (E) => (M) => M.options.get(E), se = (E) => {
    const M = E.options.register;
    M("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, me = bt("lists_indent_on_tab"), tt = bt("forced_root_block"), Lt = bt("forced_root_block_attrs"), zt = (E, M) => {
    const H = E.dom, ye = E.schema.getBlockElements(), ze = H.createFragment(), sn = tt(E), Yn = Lt(E);
    let xo, Zo, jo;
    for (Zo = H.create(sn, Yn), tr(M.firstChild, ye) || ze.appendChild(Zo); xo = M.firstChild; ) {
      const ws = xo.nodeName;
      !jo && (ws !== "SPAN" || xo.getAttribute("data-mce-type") !== "bookmark") && (jo = !0), tr(xo, ye) ? (ze.appendChild(xo), Zo = null) : (Zo || (Zo = H.create(sn, Yn), ze.appendChild(Zo)), Zo.appendChild(xo));
    }
    return jo || Zo.appendChild(H.create("br", { "data-mce-bogus": "1" })), ze;
  }, Nt = Ss.DOM, on = (E, M, H) => {
    const ye = (Zo) => {
      ir.each(ze, (jo) => {
        Zo.parentNode.insertBefore(jo, H.parentNode);
      }), Nt.remove(Zo);
    }, ze = Nt.select('span[data-mce-type="bookmark"]', M), sn = zt(E, H), Yn = Nt.createRng();
    Yn.setStartAfter(H), Yn.setEndAfter(M);
    const xo = Yn.extractContents();
    for (let Zo = xo.firstChild; Zo; Zo = Zo.firstChild)
      if (Zo.nodeName === "LI" && E.dom.isEmpty(Zo)) {
        Nt.remove(Zo);
        break;
      }
    E.dom.isEmpty(xo) || Nt.insertAfter(xo, M), Nt.insertAfter(sn, M), No(E.dom, H.parentNode) && ye(H.parentNode), Nt.remove(H), No(E.dom, M) && Nt.remove(M);
  }, Yt = Ht("dd"), On = Ht("dt"), os = (E, M) => {
    Yt(M) ? er(M, "dt") : On(M) && vo(M).each((H) => on(E, H.dom, M.dom));
  }, $s = (E) => {
    On(E) && er(E, "dd");
  }, zo = (E, M, H) => {
    M === "Indent" ? lt(H, $s) : lt(H, (ye) => os(E, ye));
  }, Ya = (E, M) => {
    if (Ur(E))
      return {
        container: E,
        offset: M
      };
    const H = we.getNode(E, M);
    return Ur(H) ? {
      container: H,
      offset: M >= E.childNodes.length ? H.data.length : 0
    } : H.previousSibling && Ur(H.previousSibling) ? {
      container: H.previousSibling,
      offset: H.previousSibling.data.length
    } : H.nextSibling && Ur(H.nextSibling) ? {
      container: H.nextSibling,
      offset: 0
    } : {
      container: E,
      offset: M
    };
  }, sa = (E) => {
    const M = E.cloneRange(), H = Ya(E.startContainer, E.startOffset);
    M.setStart(H.container, H.offset);
    const ye = Ya(E.endContainer, E.endOffset);
    return M.setEnd(ye.container, ye.offset), M;
  }, Bo = [
    "OL",
    "UL",
    "DL"
  ], fs = Bo.join(","), Lo = (E, M) => {
    const H = M || E.selection.getStart(!0);
    return E.dom.getParent(H, fs, ol(E, H));
  }, br = (E, M) => E && M.length === 1 && M[0] === E, Er = (E) => Q(E.querySelectorAll(fs), rs), ra = (E) => {
    const M = Lo(E), H = E.selection.getSelectedBlocks();
    return br(M, H) ? Er(M) : Q(H, (ye) => rs(ye) && M !== ye);
  }, nl = (E, M) => {
    const H = ir.map(M, (ye) => {
      const ze = E.dom.getParent(ye, "li,dd,dt", ol(E, ye));
      return ze || ye;
    });
    return _o(H);
  }, pa = (E) => {
    const M = E.selection.getSelectedBlocks();
    return Q(nl(E, M), le);
  }, Wr = (E) => Q(pa(E), Ce), Ma = (E, M) => {
    const H = E.dom.getParents(M, "TD,TH");
    return H.length > 0 ? H[0] : E.getBody();
  }, ci = (E, M) => !rs(M) && !le(M) && Je(Bo, (H) => E.isValidChild(M.nodeName, H)), ol = (E, M) => {
    const H = E.dom.getParents(M, E.dom.isBlock);
    return Se(H, (ze) => ci(E.schema, ze)).getOr(E.getBody());
  }, aa = (E, M) => {
    const H = E.dom.getParents(M, "ol,ul", ol(E, M));
    return Ct(H);
  }, Xa = (E) => {
    const M = aa(E, E.selection.getStart()), H = Q(E.selection.getSelectedBlocks(), cc);
    return M.toArray().concat(H);
  }, kl = (E) => {
    const M = Xa(E);
    return Ja(E, M);
  }, Ja = (E, M) => {
    const H = rt(M, (ye) => aa(E, ye).getOr(ye));
    return _o(H);
  }, li = (E, M) => {
    const ye = (M || document).createDocumentFragment();
    return lt(E, (ze) => {
      ye.appendChild(ze.dom);
    }), Ne.fromDom(ye);
  }, Qa = (E, M, H) => E.dispatch("ListMutation", {
    action: M,
    element: H
  }), Hl = ((E) => (M) => M.replace(E, ""))(/^\s+|\s+$/g), or = (E) => E.length > 0, U = (E) => !or(E), fe = (E) => E.style !== void 0 && Ao(E.style.getPropertyValue), _e = (E, M, H) => {
    if (!uo(H))
      throw console.error("Invalid call to CSS.set. Property ", M, ":: Value ", H, ":: Element ", E), new Error("CSS value must be a string: " + H);
    fe(E) && E.style.setProperty(M, H);
  }, nt = (E, M, H) => {
    const ye = E.dom;
    _e(ye, M, H);
  }, Et = (E, M) => {
    Ln(E.item, M.list);
  }, So = (E) => {
    for (let M = 1; M < E.length; M++)
      Et(E[M - 1], E[M]);
  }, Ko = (E, M) => {
    Dn(Ct(E), un(M), Et);
  }, js = (E, M) => {
    const H = {
      list: Ne.fromTag(M, E),
      item: Ne.fromTag("li", E)
    };
    return Ln(H.list, H.item), H;
  }, Ns = (E, M, H) => {
    const ye = [];
    for (let ze = 0; ze < H; ze++)
      ye.push(js(E, M.listType));
    return ye;
  }, Jr = (E, M) => {
    for (let H = 0; H < E.length - 1; H++)
      nt(E[H].item, "list-style-type", "none");
    Ct(E).each((H) => {
      hr(H.list, M.listAttributes), hr(H.item, M.itemAttributes), Ro(H.item, M.content);
    });
  }, to = (E, M) => {
    je(E.list) !== M.listType && (E.list = er(E.list, M.listType)), hr(E.list, M.listAttributes);
  }, Ic = (E, M, H) => {
    const ye = Ne.fromTag("li", E);
    return hr(ye, M), Ro(ye, H), ye;
  }, Vo = (E, M) => {
    Ln(E.list, M), E.item = M;
  }, ha = (E, M, H) => {
    const ye = M.slice(0, H.depth);
    return Ct(ye).each((ze) => {
      const sn = Ic(E, H.itemAttributes, H.content);
      Vo(ze, sn), to(ze, H);
    }), ye;
  }, Vl = (E, M, H) => {
    const ye = Ns(E, H, H.depth - M.length);
    return So(ye), Jr(ye, H), Ko(M, ye), M.concat(ye);
  }, nr = (E, M) => {
    const H = ft(M, (ye, ze) => ze.depth > ye.length ? Vl(E, ye, ze) : ha(E, ye, ze), []);
    return un(H).map((ye) => ye.list);
  }, ca = (E) => ae(E, "OL,UL"), lc = (E) => yn(E).exists(ca), Lc = (E) => ds(E).exists(ca), Qt = (E) => E.depth > 0, Zr = (E) => E.isSelected, wl = (E) => {
    const M = ko(E), H = Lc(E) ? M.slice(0, -1) : M;
    return rt(H, Xo);
  }, qr = (E, M, H) => vo(E).filter(ct).map((ye) => ({
    depth: M,
    dirty: !1,
    isSelected: H,
    content: wl(E),
    itemAttributes: Fs(E),
    listAttributes: Fs(ye),
    listType: je(ye)
  })), B = (E, M) => {
    switch (E) {
      case "Indent":
        M.depth++;
        break;
      case "Outdent":
        M.depth--;
        break;
      case "Flatten":
        M.depth = 0;
    }
    M.dirty = !0;
  }, j = (E, M) => {
    E.listType = M.listType, E.listAttributes = { ...M.listAttributes };
  }, ce = (E) => {
    E.listAttributes = zr(E.listAttributes, (M, H) => H !== "start");
  }, Fe = (E, M) => {
    const H = E[M].depth, ye = (sn) => sn.depth === H && !sn.dirty, ze = (sn) => sn.depth < H;
    return Ot(Pe(E.slice(0, M)), ye, ze).orThunk(() => Ot(E.slice(M + 1), ye, ze));
  }, Dt = (E) => (lt(E, (M, H) => {
    Fe(E, H).fold(() => {
      M.dirty && ce(M);
    }, (ye) => j(M, ye));
  }), E), $o = (E) => {
    let M = E;
    return {
      get: () => M,
      set: (ze) => {
        M = ze;
      }
    };
  }, Jo = (E, M, H, ye) => yn(ye).filter(ca).fold(() => {
    M.each((Yn) => {
      Ae(Yn.start, ye) && H.set(!0);
    });
    const ze = qr(ye, E, H.get());
    M.each((Yn) => {
      Ae(Yn.end, ye) && H.set(!1);
    });
    const sn = ds(ye).filter(ca).map((Yn) => it(E, M, H, Yn)).getOr([]);
    return ze.toArray().concat(sn);
  }, (ze) => it(E, M, H, ze)), it = (E, M, H, ye) => z(ko(ye), (ze) => {
    const sn = ca(ze) ? it : Jo, Yn = E + 1;
    return sn(Yn, M, H, ze);
  }), hs = (E, M) => {
    const H = $o(!1), ye = 0;
    return rt(E, (ze) => ({
      sourceList: ze,
      entries: it(ye, M, H, ze)
    }));
  }, Ca = (E, M) => {
    const H = Dt(M);
    return rt(H, (ye) => {
      const ze = li(ye.content);
      return Ne.fromDom(zt(E, ze.dom));
    });
  }, qs = (E, M) => {
    const H = Dt(M);
    return nr(E.contentDocument, H).toArray();
  }, Hc = (E, M) => z(wn(M, Qt), (H) => un(H).exists(Qt) ? qs(E, H) : Ca(E, H)), as = (E, M) => {
    lt(Q(E, Zr), (H) => B(M, H));
  }, G = (E) => {
    const M = rt(pa(E), Ne.fromDom);
    return Dn(Se(M, At(lc)), Se(Pe(M), At(lc)), (H, ye) => ({
      start: H,
      end: ye
    }));
  }, re = (E, M, H) => {
    const ye = hs(M, G(E));
    lt(ye, (ze) => {
      as(ze.entries, H);
      const sn = Hc(E, ze.entries);
      lt(sn, (Yn) => {
        Qa(E, H === "Indent" ? "IndentList" : "OutdentList", Yn.dom);
      }), Go(ze.sourceList, sn), Qs(ze.sourceList);
    });
  }, Me = (E, M) => {
    const H = rt(kl(E), Ne.fromDom), ye = rt(Wr(E), Ne.fromDom);
    let ze = !1;
    if (H.length || ye.length) {
      const sn = E.selection.getBookmark();
      re(E, H, M), zo(E, M, ye), E.selection.moveToBookmark(sn), E.selection.setRng(sa(E.selection.getRng())), E.nodeChanged(), ze = !0;
    }
    return ze;
  }, Ye = (E) => Me(E, "Indent"), bn = (E) => Me(E, "Outdent"), An = (E) => Me(E, "Flatten");
  var Wo = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const Xs = Ss.DOM, ic = (E) => {
    const M = {}, H = (ye) => {
      let ze = E[ye ? "startContainer" : "endContainer"], sn = E[ye ? "startOffset" : "endOffset"];
      if (ze.nodeType === 1) {
        const Yn = Xs.create("span", { "data-mce-type": "bookmark" });
        ze.hasChildNodes() ? (sn = Math.min(sn, ze.childNodes.length - 1), ye ? ze.insertBefore(Yn, ze.childNodes[sn]) : Xs.insertAfter(Yn, ze.childNodes[sn])) : ze.appendChild(Yn), ze = Yn, sn = 0;
      }
      M[ye ? "startContainer" : "endContainer"] = ze, M[ye ? "startOffset" : "endOffset"] = sn;
    };
    return H(!0), E.collapsed || H(), M;
  }, Oo = (E) => {
    const M = (ye) => {
      let ze;
      const sn = (Zo) => {
        let jo = Zo.parentNode.firstChild, ws = 0;
        for (; jo; ) {
          if (jo === Zo)
            return ws;
          (jo.nodeType !== 1 || jo.getAttribute("data-mce-type") !== "bookmark") && ws++, jo = jo.nextSibling;
        }
        return -1;
      };
      let Yn = ze = E[ye ? "startContainer" : "endContainer"], xo = E[ye ? "startOffset" : "endOffset"];
      !Yn || (Yn.nodeType === 1 && (xo = sn(Yn), Yn = Yn.parentNode, Xs.remove(ze), !Yn.hasChildNodes() && Xs.isBlock(Yn) && Yn.appendChild(Xs.create("br"))), E[ye ? "startContainer" : "endContainer"] = Yn, E[ye ? "startOffset" : "endOffset"] = xo);
    };
    M(!0), M();
    const H = Xs.createRng();
    return H.setStart(E.startContainer, E.startOffset), E.endContainer && H.setEnd(E.endContainer, E.endOffset), sa(H);
  }, Ps = (E) => {
    switch (E) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, uc = (E) => /\btox\-/.test(E.className), dc = (E, M, H) => {
    const ye = (sn) => {
      const Yn = Ot(sn.parents, rs, wt).filter((xo) => xo.nodeName === M && !uc(xo)).isSome();
      H(Yn);
    }, ze = E.dom.getParents(E.selection.getNode());
    return ye({ parents: ze }), E.on("NodeChange", ye), () => E.off("NodeChange", ye);
  }, su = (E, M, H) => {
    const ye = H["list-style-type"] ? H["list-style-type"] : null;
    E.setStyle(M, "list-style-type", ye);
  }, fc = (E, M) => {
    ir.each(M, (H, ye) => {
      E.setAttribute(ye, H);
    });
  }, ms = (E, M, H) => {
    fc(M, H["list-attributes"]), ir.each(E.select("li", M), (ye) => {
      fc(ye, H["list-item-attributes"]);
    });
  }, ur = (E, M, H) => {
    su(E, M, H), ms(E, M, H);
  }, Na = (E, M, H) => {
    ir.each(H, (ye) => E.setStyle(M, ye, ""));
  }, _l = (E, M, H, ye) => {
    let ze = M[H ? "startContainer" : "endContainer"];
    const sn = M[H ? "startOffset" : "endOffset"];
    for (ze.nodeType === 1 && (ze = ze.childNodes[Math.min(sn, ze.childNodes.length - 1)] || ze), !H && Rn(ze.nextSibling) && (ze = ze.nextSibling); ze.parentNode !== ye; ) {
      if (Co(E, ze) || /^(TD|TH)$/.test(ze.parentNode.nodeName))
        return ze;
      ze = ze.parentNode;
    }
    return ze;
  }, Ni = (E, M, H) => {
    const ye = [], ze = E.dom, sn = _l(E, M, !0, H), Yn = _l(E, M, !1, H);
    let xo;
    const Zo = [];
    for (let jo = sn; jo && (Zo.push(jo), jo !== Yn); jo = jo.nextSibling)
      ;
    return ir.each(Zo, (jo) => {
      if (Co(E, jo)) {
        ye.push(jo), xo = null;
        return;
      }
      if (ze.isBlock(jo) || Rn(jo)) {
        Rn(jo) && ze.remove(jo), xo = null;
        return;
      }
      const ws = jo.nextSibling;
      if (Wo.isBookmarkNode(jo) && (rs(ws) || Co(E, ws) || !ws && jo.parentNode === H)) {
        xo = null;
        return;
      }
      xo || (xo = ze.create("p"), jo.parentNode.insertBefore(xo, jo), ye.push(xo)), xo.appendChild(jo);
    }), ye;
  }, $r = (E, M, H) => {
    const ye = E.getStyle(M, "list-style-type");
    let ze = H ? H["list-style-type"] : "";
    return ze = ze === null ? "" : ze, ye === ze;
  }, Cl = (E, M, H) => {
    const ye = E.selection.getRng();
    let ze = "LI";
    const sn = ol(E, E.selection.getStart(!0)), Yn = E.dom;
    if (Yn.getContentEditable(E.selection.getNode()) === "false")
      return;
    M = M.toUpperCase(), M === "DL" && (ze = "DT");
    const xo = ic(ye), Zo = Ni(E, ye, sn);
    ir.each(Zo, (jo) => {
      let ws;
      const Or = jo.previousSibling, Gr = jo.parentNode;
      le(Gr) || (Or && rs(Or) && Or.nodeName === M && $r(Yn, Or, H) ? (ws = Or, jo = Yn.rename(jo, ze), Or.appendChild(jo)) : (ws = Yn.create(M), jo.parentNode.insertBefore(ws, jo), ws.appendChild(jo), jo = Yn.rename(jo, ze)), Na(Yn, jo, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), ur(Yn, ws, H), xl(E.dom, ws));
    }), E.selection.setRng(Oo(xo));
  }, Sa = (E, M) => E && M && rs(E) && E.nodeName === M.nodeName, Mu = (E, M, H) => {
    const ye = E.getStyle(M, "list-style-type", !0), ze = E.getStyle(H, "list-style-type", !0);
    return ye === ze;
  }, sm = (E, M) => E.className === M.className, Sl = (E, M, H) => Sa(M, H) && Mu(E, M, H) && sm(M, H), xl = (E, M) => {
    let H, ye;
    if (H = M.nextSibling, Sl(E, M, H)) {
      for (; ye = H.firstChild; )
        M.appendChild(ye);
      E.remove(H);
    }
    if (H = M.previousSibling, Sl(E, M, H)) {
      for (; ye = H.lastChild; )
        M.insertBefore(ye, M.firstChild);
      E.remove(H);
    }
  }, Bi = (E, M, H, ye) => {
    if (M.nodeName !== H) {
      const ze = E.dom.rename(M, H);
      ur(E.dom, ze, ye), Qa(E, Ps(H), ze);
    } else
      ur(E.dom, M, ye), Qa(E, Ps(H), M);
  }, ru = (E, M, H, ye, ze) => {
    const sn = rs(M);
    if (sn && M.nodeName === ye && !Ba(ze))
      An(E);
    else {
      Cl(E, ye, ze);
      const Yn = ic(E.selection.getRng()), xo = sn ? [
        M,
        ...H
      ] : H;
      ir.each(xo, (Zo) => {
        Bi(E, Zo, ye, ze);
      }), E.selection.setRng(Oo(Yn));
    }
  }, Ba = (E) => "list-style-type" in E, sf = (E, M, H, ye) => {
    if (M !== E.getBody())
      if (M)
        if (M.nodeName === H && !Ba(ye) && !uc(M))
          An(E);
        else {
          const ze = ic(E.selection.getRng());
          ur(E.dom, M, ye);
          const sn = E.dom.rename(M, H);
          xl(E.dom, sn), E.selection.setRng(Oo(ze)), Cl(E, H, ye), Qa(E, Ps(H), sn);
        }
      else
        Cl(E, H, ye), Qa(E, Ps(H), M);
  }, jl = (E, M, H) => {
    const ye = Lo(E), ze = ra(E), sn = ho(H) ? H : {};
    ze.length > 0 ? ru(E, ye, ze, M, sn) : sf(E, ye, M, sn);
  }, dd = Ss.DOM, Nu = (E, M) => {
    const H = M.parentNode;
    if (H.nodeName === "LI" && H.firstChild === M) {
      const ye = H.previousSibling;
      ye && ye.nodeName === "LI" ? (ye.appendChild(M), No(E, H) && dd.remove(H)) : dd.setStyle(H, "listStyleType", "none");
    }
    if (rs(H)) {
      const ye = H.previousSibling;
      ye && ye.nodeName === "LI" && ye.appendChild(M);
    }
  }, fd = (E, M) => {
    const H = ir.grep(E.select("ol,ul", M));
    ir.each(H, (ye) => {
      Nu(E, ye);
    });
  }, Bu = (E, M, H, ye) => {
    let ze = M.startContainer;
    const sn = M.startOffset;
    if (Ur(ze) && (H ? sn < ze.data.length : sn > 0))
      return ze;
    const Yn = E.schema.getNonEmptyElements();
    ze.nodeType === 1 && (ze = we.getNode(ze, sn));
    const xo = new $e(ze, ye);
    H && Bn(E.dom, ze) && xo.next();
    const Zo = H ? xo.next.bind(xo) : xo.prev2.bind(xo);
    for (; ze = Zo(); )
      if (ze.nodeName === "LI" && !ze.hasChildNodes() || Yn[ze.nodeName] || Ur(ze) && ze.data.length > 0)
        return ze;
  }, Tl = (E, M) => {
    const H = M.childNodes;
    return H.length === 1 && !rs(H[0]) && E.isBlock(H[0]);
  }, og = (E, M) => {
    Tl(E, M) && E.remove(M.firstChild, !0);
  }, $u = (E, M, H) => {
    let ye;
    const ze = Tl(E, H) ? H.firstChild : H;
    if (og(E, M), !No(E, M, !0))
      for (; ye = M.firstChild; )
        ze.appendChild(ye);
  }, rf = (E, M, H) => {
    let ye;
    const ze = M.parentNode;
    if (!yr(E, M) || !yr(E, H))
      return;
    rs(H.lastChild) && (ye = H.lastChild), ze === H.lastChild && Rn(ze.previousSibling) && E.remove(ze.previousSibling);
    const sn = H.lastChild;
    sn && Rn(sn) && M.hasChildNodes() && E.remove(sn), No(E, H, !0) && Os(Ne.fromDom(H)), $u(E, M, H), ye && H.appendChild(ye);
    const xo = Oe(Ne.fromDom(H), Ne.fromDom(M)) ? E.getParents(M, rs, H) : [];
    E.remove(M), lt(xo, (Zo) => {
      No(E, Zo) && Zo !== E.getRoot() && E.remove(Zo);
    });
  }, mc = (E, M, H) => {
    Os(Ne.fromDom(H)), rf(E.dom, M, H), E.selection.setCursorLocation(H, 0);
  }, af = (E, M, H, ye) => {
    const ze = E.dom;
    if (ze.isEmpty(ye))
      mc(E, H, ye);
    else {
      const sn = ic(M);
      rf(ze, H, ye), E.selection.setRng(Oo(sn));
    }
  }, be = (E, M, H, ye) => {
    const ze = ic(M);
    rf(E.dom, H, ye);
    const sn = Oo(ze);
    E.selection.setRng(sn);
  }, Pu = (E, M) => {
    const H = E.dom, ye = E.selection, ze = ye.getStart(), sn = Ma(E, ze), Yn = H.getParent(ye.getStart(), "LI", sn);
    if (Yn) {
      const xo = Yn.parentNode;
      if (xo === E.getBody() && No(H, xo))
        return !0;
      const Zo = sa(ye.getRng()), jo = H.getParent(Bu(E, Zo, M, sn), "LI", sn);
      if (jo && jo !== Yn)
        return E.undoManager.transact(() => {
          M ? af(E, Zo, jo, Yn) : Ft(Yn) ? bn(E) : be(E, Zo, Yn, jo);
        }), !0;
      if (!jo && !M && Zo.startOffset === 0 && Zo.endOffset === 0)
        return E.undoManager.transact(() => {
          An(E);
        }), !0;
    }
    return !1;
  }, El = (E, M, H) => {
    const ye = E.getParent(M.parentNode, E.isBlock, H);
    E.remove(M), ye && E.isEmpty(ye) && E.remove(ye);
  }, cf = (E, M) => {
    const H = E.dom, ye = E.selection.getStart(), ze = Ma(E, ye), sn = H.getParent(ye, H.isBlock, ze);
    if (sn && H.isEmpty(sn)) {
      const Yn = sa(E.selection.getRng()), xo = H.getParent(Bu(E, Yn, M, ze), "LI", ze);
      if (xo) {
        const Zo = (Gr) => oe([
          "td",
          "th",
          "caption"
        ], je(Gr)), jo = (Gr) => Gr.dom === ze, ws = mn(Ne.fromDom(xo), Zo, jo), Or = mn(Ne.fromDom(Yn.startContainer), Zo, jo);
        return Sn(ws, Or, Ae) ? (E.undoManager.transact(() => {
          El(H, sn, ze), xl(H, xo.parentNode), E.selection.select(xo, !0), E.selection.collapse(M);
        }), !0) : !1;
      }
    }
    return !1;
  }, wy = (E, M) => Pu(E, M) || cf(E, M), sg = (E) => {
    const M = E.selection.getStart(), H = Ma(E, M);
    return E.dom.getParent(M, "LI,DT,DD", H) || pa(E).length > 0;
  }, Is = (E) => sg(E) ? (E.undoManager.transact(() => {
    E.execCommand("Delete"), fd(E.dom, E.getBody());
  }), !0) : !1, ya = (E, M) => E.selection.isCollapsed() ? wy(E, M) : Is(E), Ul = (E) => {
    E.on("ExecCommand", (M) => {
      const H = M.command.toLowerCase();
      (H === "delete" || H === "forwarddelete") && sg(E) && fd(E.dom, E.getBody());
    }), E.on("keydown", (M) => {
      M.keyCode === Vt.BACKSPACE ? ya(E, !1) && M.preventDefault() : M.keyCode === Vt.DELETE && ya(E, !0) && M.preventDefault();
    });
  }, ii = (E) => ({
    backspaceDelete: (M) => {
      ya(E, M);
    }
  }), rm = (E, M) => {
    const H = Lo(E);
    E.undoManager.transact(() => {
      ho(M.styles) && E.dom.setStyles(H, M.styles), ho(M.attrs) && ht(M.attrs, (ye, ze) => E.dom.setAttrib(H, ze, ye));
    });
  }, $i = (E) => {
    const M = Pe(Hl(E).split("")), H = rt(M, (ye, ze) => {
      const sn = ye.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
      return Math.pow(26, ze) * sn;
    });
    return ft(H, (ye, ze) => ye + ze, 0);
  }, ec = (E) => {
    if (E--, E < 0)
      return "";
    {
      const M = E % 26, H = Math.floor(E / 26), ye = ec(H), ze = String.fromCharCode("A".charCodeAt(0) + M);
      return ye + ze;
    }
  }, am = (E) => /^[A-Z]+$/.test(E), rg = (E) => /^[a-z]+$/.test(E), cm = (E) => /^[0-9]+$/.test(E), sl = (E) => cm(E) ? 2 : am(E) ? 0 : rg(E) ? 1 : U(E) ? 3 : 4, lf = (E) => {
    switch (sl(E)) {
      case 2:
        return Ue.some({
          listStyleType: Ue.none(),
          start: E
        });
      case 0:
        return Ue.some({
          listStyleType: Ue.some("upper-alpha"),
          start: $i(E).toString()
        });
      case 1:
        return Ue.some({
          listStyleType: Ue.some("lower-alpha"),
          start: $i(E).toString()
        });
      case 3:
        return Ue.some({
          listStyleType: Ue.none(),
          start: ""
        });
      case 4:
        return Ue.none();
    }
  }, uf = (E) => {
    const M = parseInt(E.start, 10);
    return Fn(E.listStyleType, "upper-alpha") ? ec(M) : Fn(E.listStyleType, "lower-alpha") ? ec(M).toLowerCase() : E.start;
  }, Ec = (E) => {
    const M = Lo(E);
    !Z(M) || E.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: uf({
          start: E.dom.getAttrib(M, "start", "1"),
          listStyleType: Ue.some(E.dom.getStyle(M, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (H) => {
        const ye = H.getData();
        lf(ye.start).each((ze) => {
          E.execCommand("mceListUpdate", !1, {
            attrs: { start: ze.start === "1" ? "" : ze.start },
            styles: { "list-style-type": ze.listStyleType.getOr("") }
          });
        }), H.close();
      }
    });
  }, Qr = (E, M) => () => {
    const H = Lo(E);
    return H && H.nodeName === M;
  }, au = (E) => {
    E.addCommand("mceListProps", () => {
      Ec(E);
    });
  }, md = (E) => {
    E.on("BeforeExecCommand", (M) => {
      const H = M.command.toLowerCase();
      H === "indent" ? Ye(E) : H === "outdent" && bn(E);
    }), E.addCommand("InsertUnorderedList", (M, H) => {
      jl(E, "UL", H);
    }), E.addCommand("InsertOrderedList", (M, H) => {
      jl(E, "OL", H);
    }), E.addCommand("InsertDefinitionList", (M, H) => {
      jl(E, "DL", H);
    }), E.addCommand("RemoveList", () => {
      An(E);
    }), au(E), E.addCommand("mceListUpdate", (M, H) => {
      ho(H) && rm(E, H);
    }), E.addQueryStateHandler("InsertUnorderedList", Qr(E, "UL")), E.addQueryStateHandler("InsertOrderedList", Qr(E, "OL")), E.addQueryStateHandler("InsertDefinitionList", Qr(E, "DL"));
  }, rl = (E) => {
    E.on("keydown", (M) => {
      M.keyCode !== Vt.TAB || Vt.metaKeyPressed(M) || E.undoManager.transact(() => {
        (M.shiftKey ? bn(E) : Ye(E)) && M.preventDefault();
      });
    });
  }, al = (E) => {
    me(E) && rl(E), Ul(E);
  }, lm = (E) => {
    const M = (H) => () => E.execCommand(H);
    E.hasPlugin("advlist") || (E.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: M("InsertOrderedList"),
      onSetup: (H) => dc(E, "OL", H.setActive)
    }), E.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: M("InsertUnorderedList"),
      onSetup: (H) => dc(E, "UL", H.setActive)
    }));
  }, im = (E) => {
    const M = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => E.execCommand("mceListProps"),
      onSetup: (H) => dc(E, "OL", H.setEnabled)
    };
    E.ui.registry.addMenuItem("listprops", M), E.ui.registry.addContextMenu("lists", {
      update: (H) => {
        const ye = Lo(E, H);
        return Z(ye) ? ["listprops"] : [];
      }
    });
  };
  var df = () => {
    ns.add("lists", (E) => (se(E), E.hasPlugin("rtc", !0) === !1 ? (al(E), md(E)) : au(E), lm(E), im(E), ii(E)));
  };
  df();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (U, fe, _e) => {
    var nt;
    return _e(U, fe.prototype) ? !0 : ((nt = U.constructor) === null || nt === void 0 ? void 0 : nt.name) === fe.name;
  }, Eo = (U) => {
    const fe = typeof U;
    return U === null ? "null" : fe === "object" && Array.isArray(U) ? "array" : fe === "object" && To(U, String, (_e, nt) => nt.isPrototypeOf(_e)) ? "string" : fe;
  }, In = (U) => (fe) => Eo(fe) === U, Jn = (U) => (fe) => typeof fe === U, uo = (U) => (fe) => U === fe, ho = In("string"), Kt = In("object"), Bt = In("array"), $t = uo(null), Un = Jn("boolean"), Ao = (U) => U == null, tn = (U) => !Ao(U), mt = Jn("function"), an = (U, fe) => {
    if (Bt(U)) {
      for (let _e = 0, nt = U.length; _e < nt; ++_e)
        if (!fe(U[_e]))
          return !1;
      return !0;
    }
    return !1;
  }, Ge = () => {
  }, At = (U, fe) => U === fe;
  class He {
    constructor(fe, _e) {
      this.tag = fe, this.value = _e;
    }
    static some(fe) {
      return new He(!0, fe);
    }
    static none() {
      return He.singletonNone;
    }
    fold(fe, _e) {
      return this.tag ? _e(this.value) : fe();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(fe) {
      return this.tag ? He.some(fe(this.value)) : He.none();
    }
    bind(fe) {
      return this.tag ? fe(this.value) : He.none();
    }
    exists(fe) {
      return this.tag && fe(this.value);
    }
    forall(fe) {
      return !this.tag || fe(this.value);
    }
    filter(fe) {
      return !this.tag || fe(this.value) ? this : He.none();
    }
    getOr(fe) {
      return this.tag ? this.value : fe;
    }
    or(fe) {
      return this.tag ? this : fe;
    }
    getOrThunk(fe) {
      return this.tag ? this.value : fe();
    }
    orThunk(fe) {
      return this.tag ? this : fe();
    }
    getOrDie(fe) {
      if (this.tag)
        return this.value;
      throw new Error(fe != null ? fe : "Called getOrDie on None");
    }
    static from(fe) {
      return tn(fe) ? He.some(fe) : He.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(fe) {
      this.tag && fe(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  He.singletonNone = new He(!1);
  const Ue = Array.prototype.indexOf, ie = Array.prototype.push, dn = (U, fe) => Ue.call(U, fe), _t = (U, fe) => dn(U, fe) > -1, Re = (U, fe) => {
    const _e = U.length, nt = new Array(_e);
    for (let Et = 0; Et < _e; Et++) {
      const So = U[Et];
      nt[Et] = fe(So, Et);
    }
    return nt;
  }, oe = (U, fe) => {
    for (let _e = 0, nt = U.length; _e < nt; _e++) {
      const Et = U[_e];
      fe(Et, _e);
    }
  }, Je = (U, fe, _e) => (oe(U, (nt, Et) => {
    _e = fe(_e, nt, Et);
  }), _e), rt = (U) => {
    const fe = [];
    for (let _e = 0, nt = U.length; _e < nt; ++_e) {
      if (!Bt(U[_e]))
        throw new Error("Arr.flatten item " + _e + " was not an array, input: " + U);
      ie.apply(fe, U[_e]);
    }
    return fe;
  }, lt = (U, fe) => rt(Re(U, fe)), Q = (U, fe) => {
    for (let _e = 0; _e < U.length; _e++) {
      const nt = fe(U[_e], _e);
      if (nt.isSome())
        return nt;
    }
    return He.none();
  }, wn = (U, fe, _e = At) => U.exists((nt) => _e(nt, fe)), ft = (U) => {
    const fe = [], _e = (nt) => {
      fe.push(nt);
    };
    for (let nt = 0; nt < U.length; nt++)
      U[nt].each(_e);
    return fe;
  }, Ot = (U, fe) => U ? He.some(fe) : He.none(), Se = (U) => (fe) => fe.options.get(U), Qe = (U) => {
    const fe = U.options.register;
    fe("link_assume_external_targets", {
      processor: (_e) => {
        const nt = ho(_e) || Un(_e);
        return nt ? _e === !0 ? {
          value: 1,
          valid: nt
        } : _e === "http" || _e === "https" ? {
          value: _e,
          valid: nt
        } : {
          value: 0,
          valid: nt
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), fe("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), fe("link_list", { processor: (_e) => ho(_e) || mt(_e) || an(_e, Kt) }), fe("link_default_target", { processor: "string" }), fe("link_default_protocol", {
      processor: "string",
      default: "https"
    }), fe("link_target_list", {
      processor: (_e) => Un(_e) || an(_e, Kt),
      default: !0
    }), fe("link_rel_list", {
      processor: "object[]",
      default: []
    }), fe("link_class_list", {
      processor: "object[]",
      default: []
    }), fe("link_title", {
      processor: "boolean",
      default: !0
    }), fe("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), fe("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, z = Se("link_assume_external_targets"), Pe = Se("link_context_toolbar"), Rt = Se("link_list"), un = Se("link_default_target"), Ct = Se("link_default_protocol"), _o = Se("link_target_list"), Fn = Se("link_rel_list"), Sn = Se("link_class_list"), Dn = Se("link_title"), Mn = Se("allow_unsafe_link_target"), Xe = Se("link_quicklink");
  var O = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const gt = (U) => ho(U.value) ? U.value : "", en = (U) => ho(U.text) ? U.text : ho(U.title) ? U.title : "", Pt = (U, fe) => {
    const _e = [];
    return O.each(U, (nt) => {
      const Et = en(nt);
      if (nt.menu !== void 0) {
        const So = Pt(nt.menu, fe);
        _e.push({
          text: Et,
          items: So
        });
      } else {
        const So = fe(nt);
        _e.push({
          text: Et,
          value: So
        });
      }
    }), _e;
  }, Ne = (U = gt) => (fe) => He.from(fe).map((_e) => Pt(_e, U)), Oe = {
    sanitize: (U) => Ne(gt)(U),
    sanitizeWith: Ne,
    createUi: (U, fe) => (_e) => ({
      name: U,
      type: "listbox",
      label: fe,
      items: _e
    }),
    getValue: gt
  }, ae = Object.keys, X = Object.hasOwnProperty, je = (U, fe) => {
    const _e = ae(U);
    for (let nt = 0, Et = _e.length; nt < Et; nt++) {
      const So = _e[nt], Ko = U[So];
      fe(Ko, So);
    }
  }, ke = (U) => (fe, _e) => {
    U[_e] = fe;
  }, ue = (U, fe, _e, nt) => {
    const Et = {};
    return je(U, (So, Ko) => {
      (fe(So, Ko) ? _e : nt)(So, Ko);
    }), Et;
  }, ct = (U, fe) => {
    const _e = {};
    return ue(U, fe, ke(_e), Ge), _e;
  }, Ht = (U, fe) => X.call(U, fe), vo = (U, fe) => Ht(U, fe) && U[fe] !== void 0 && U[fe] !== null;
  var Wn = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), ko = tinymce.util.Tools.resolve("tinymce.util.URI");
  const fo = (U) => U && U.nodeName.toLowerCase() === "a", yn = (U) => fo(U) && !!mn(U), ds = (U, fe) => {
    if (U.collapsed)
      return [];
    {
      const _e = U.cloneContents(), nt = new Wn(_e.firstChild, _e), Et = [];
      let So = _e.firstChild;
      do
        fe(So) && Et.push(So);
      while (So = nt.next());
      return Et;
    }
  }, Ho = (U) => /^\w+:/i.test(U), mn = (U) => {
    const fe = U.getAttribute("data-mce-href");
    return fe || U.getAttribute("href");
  }, Io = (U, fe) => {
    const _e = ["noopener"], nt = U ? U.split(/\s+/) : [], Et = (Ns) => O.trim(Ns.sort().join(" ")), So = (Ns) => (Ns = Ko(Ns), Ns.length > 0 ? Ns.concat(_e) : _e), Ko = (Ns) => Ns.filter((Jr) => O.inArray(_e, Jr) === -1), js = fe ? So(nt) : Ko(nt);
    return js.length > 0 ? Et(js) : "";
  }, ro = (U) => U.replace(/\uFEFF/g, ""), Ln = (U, fe) => (fe = fe || U.selection.getNode(), we(fe) ? U.dom.select("a[href]", fe)[0] : U.dom.getParent(fe, "a[href]")), Go = (U, fe) => {
    const _e = fe ? fe.innerText || fe.textContent : U.getContent({ format: "text" });
    return ro(_e);
  }, Ro = (U) => O.grep(U, yn).length > 0, Os = (U) => ds(U, yn).length > 0, Qs = (U) => {
    const fe = U.schema.getTextInlineElements(), _e = (Et) => Et.nodeType === 1 && !fo(Et) && !Ht(fe, Et.nodeName.toLowerCase());
    return ds(U.selection.getRng(), _e).length === 0;
  }, we = (U) => U && U.nodeName === "FIGURE" && /\bimage\b/i.test(U.className), $e = (U) => Je([
    "title",
    "rel",
    "class",
    "target"
  ], (_e, nt) => (U[nt].each((Et) => {
    _e[nt] = Et.length > 0 ? Et : null;
  }), _e), { href: U.href }), Vt = (U, fe) => (fe === "http" || fe === "https") && !Ho(U) ? fe + "://" + U : U, Jt = (U, fe) => {
    const _e = { ...fe };
    if (Fn(U).length === 0 && !Mn(U)) {
      const nt = Io(_e.rel, _e.target === "_blank");
      _e.rel = nt || null;
    }
    return He.from(_e.target).isNone() && _o(U) === !1 && (_e.target = un(U)), _e.href = Vt(_e.href, z(U)), _e;
  }, ht = (U, fe, _e, nt) => {
    _e.each((Et) => {
      Ht(fe, "innerText") ? fe.innerText = Et : fe.textContent = Et;
    }), U.dom.setAttribs(fe, nt), U.selection.select(fe);
  }, qn = (U, fe, _e, nt) => {
    we(fe) ? er(U, fe, nt) : _e.fold(() => {
      U.execCommand("mceInsertLink", !1, nt);
    }, (Et) => {
      U.insertContent(U.dom.createHTML("a", nt, U.dom.encode(Et)));
    });
  }, pr = (U, fe, _e) => {
    const nt = U.selection.getNode(), Et = Ln(U, nt), So = Jt(U, $e(_e));
    U.undoManager.transact(() => {
      _e.href === fe.href && fe.attach(), Et ? (U.focus(), ht(U, Et, _e.text, So)) : qn(U, nt, _e.text, So);
    });
  }, zr = (U) => {
    const fe = U.dom, _e = U.selection, nt = _e.getBookmark(), Et = _e.getRng().cloneRange(), So = fe.getParent(Et.startContainer, "a[href]", U.getBody()), Ko = fe.getParent(Et.endContainer, "a[href]", U.getBody());
    So && Et.setStartBefore(So), Ko && Et.setEndAfter(Ko), _e.setRng(Et), U.execCommand("unlink"), _e.moveToBookmark(nt);
  }, Zs = (U) => {
    U.undoManager.transact(() => {
      const fe = U.selection.getNode();
      we(fe) ? Gn(U, fe) : zr(U), U.focus();
    });
  }, hr = (U) => {
    const {
      class: fe,
      href: _e,
      rel: nt,
      target: Et,
      text: So,
      title: Ko
    } = U;
    return ct({
      class: fe.getOrNull(),
      href: _e,
      rel: nt.getOrNull(),
      target: Et.getOrNull(),
      text: So.getOrNull(),
      title: Ko.getOrNull()
    }, (js, Ns) => $t(js) === !1);
  }, Fs = (U, fe) => {
    const _e = U.options.get, nt = {
      allow_html_data_urls: _e("allow_html_data_urls"),
      allow_script_urls: _e("allow_script_urls"),
      allow_svg_data_urls: _e("allow_svg_data_urls")
    }, Et = fe.href;
    return {
      ...fe,
      href: ko.isDomSafe(Et, "a", nt) ? Et : ""
    };
  }, Tr = (U, fe, _e) => {
    const nt = Fs(U, _e);
    U.hasPlugin("rtc", !0) ? U.execCommand("createlink", !1, hr(nt)) : pr(U, fe, nt);
  }, Xo = (U) => {
    U.hasPlugin("rtc", !0) ? U.execCommand("unlink") : Zs(U);
  }, Gn = (U, fe) => {
    const _e = U.dom.select("img", fe)[0];
    if (_e) {
      const nt = U.dom.getParents(_e, "a[href]", fe)[0];
      nt && (nt.parentNode.insertBefore(_e, nt), U.dom.remove(nt));
    }
  }, er = (U, fe, _e) => {
    const nt = U.dom.select("img", fe)[0];
    if (nt) {
      const Et = U.dom.create("a", _e);
      nt.parentNode.insertBefore(Et, nt), Et.appendChild(nt);
    }
  }, Ss = (U) => vo(U, "items"), ir = (U, fe) => Q(fe, (_e) => Ss(_e) ? ir(U, _e.items) : Ot(_e.value === U, _e)), Ka = (U, fe, _e, nt) => {
    const Et = nt[fe], So = U.length > 0;
    return Et !== void 0 ? ir(Et, _e).map((Ko) => ({
      url: {
        value: Ko.value,
        meta: {
          text: So ? U : Ko.text,
          attach: Ge
        }
      },
      text: So ? U : Ko.text
    })) : He.none();
  }, Ra = (U, fe) => fe === "link" ? U.link : fe === "anchor" ? U.anchor : He.none(), rs = {
    init: (U, fe) => {
      const _e = {
        text: U.text,
        title: U.title
      }, nt = (Ns) => Ot(_e.title.length <= 0, He.from(Ns.meta.title).getOr("")), Et = (Ns) => Ot(_e.text.length <= 0, He.from(Ns.meta.text).getOr(Ns.value)), So = (Ns) => {
        const Jr = Et(Ns.url), to = nt(Ns.url);
        return Jr.isSome() || to.isSome() ? He.some({
          ...Jr.map((Ic) => ({ text: Ic })).getOr({}),
          ...to.map((Ic) => ({ title: Ic })).getOr({})
        }) : He.none();
      }, Ko = (Ns, Jr) => {
        const to = Ra(fe, Jr.name).getOr([]);
        return Ka(_e.text, Jr.name, to, Ns);
      };
      return { onChange: (Ns, Jr) => {
        const to = Jr.name;
        return to === "url" ? So(Ns()) : _t([
          "anchor",
          "link"
        ], to) ? Ko(Ns(), Jr) : ((to === "text" || to === "title") && (_e[to] = Ns()[to]), He.none());
      } };
    },
    getDelta: Ka
  };
  var cc = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const Z = (U, fe, _e) => {
    const nt = U.selection.getRng();
    cc.setEditorTimeout(U, () => {
      U.windowManager.confirm(fe, (Et) => {
        U.selection.setRng(nt), _e(Et);
      });
    });
  }, le = (U) => {
    const fe = U.href;
    return fe.indexOf("@") > 0 && fe.indexOf("/") === -1 && fe.indexOf("mailto:") === -1 ? He.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (nt) => ({
        ...nt,
        href: "mailto:" + fe
      })
    }) : He.none();
  }, Ce = (U, fe) => (_e) => {
    const nt = _e.href;
    return U === 1 && !Ho(nt) || U === 0 && /^\s*www(\.|\d\.)/i.test(nt) ? He.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${fe}:// prefix?`,
      preprocess: (So) => ({
        ...So,
        href: fe + "://" + nt
      })
    }) : He.none();
  }, Rn = { preprocess: (U, fe) => Q([
    le,
    Ce(z(U), Ct(U))
  ], (_e) => _e(fe)).fold(() => Promise.resolve(fe), (_e) => new Promise((nt) => {
    Z(U, _e.message, (Et) => {
      nt(Et ? _e.preprocess(fe) : fe);
    });
  })) }, Co = { getAnchors: (U) => {
    const fe = U.dom.select("a:not([href])"), _e = lt(fe, (nt) => {
      const Et = nt.name || nt.id;
      return Et ? [{
        text: Et,
        value: "#" + Et
      }] : [];
    });
    return _e.length > 0 ? He.some([{
      text: "None",
      value: ""
    }].concat(_e)) : He.none();
  } }, Bn = { getClasses: (U) => {
    const fe = Sn(U);
    return fe.length > 0 ? Oe.sanitize(fe) : He.none();
  } }, No = (U) => {
    try {
      return He.some(JSON.parse(U));
    } catch {
      return He.none();
    }
  }, bt = { getLinks: (U) => {
    const fe = (nt) => U.convertURL(nt.value || nt.url, "href"), _e = Rt(U);
    return new Promise((nt) => {
      ho(_e) ? fetch(_e).then((Et) => Et.ok ? Et.text().then(No) : Promise.reject()).then(nt, () => nt(He.none())) : mt(_e) ? _e((Et) => nt(He.some(Et))) : nt(He.from(_e));
    }).then((nt) => nt.bind(Oe.sanitizeWith(fe)).map((Et) => Et.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(Et) : Et));
  } }, me = { getRels: (U, fe) => {
    const _e = Fn(U);
    if (_e.length > 0) {
      const nt = wn(fe, "_blank"), Et = Mn(U) === !1, So = (js) => Io(Oe.getValue(js), nt);
      return (Et ? Oe.sanitizeWith(So) : Oe.sanitize)(_e);
    }
    return He.none();
  } }, tt = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], zt = { getTargets: (U) => {
    const fe = _o(U);
    return Bt(fe) ? Oe.sanitize(fe).orThunk(() => He.some(tt)) : fe === !1 ? He.none() : He.some(tt);
  } }, Nt = (U, fe, _e) => {
    const nt = U.getAttrib(fe, _e);
    return nt !== null && nt.length > 0 ? He.some(nt) : He.none();
  }, on = (U, fe) => {
    const _e = U.dom, Et = Qs(U) ? He.some(Go(U.selection, fe)) : He.none(), So = fe ? He.some(_e.getAttrib(fe, "href")) : He.none(), Ko = fe ? He.from(_e.getAttrib(fe, "target")) : He.none(), js = Nt(_e, fe, "rel"), Ns = Nt(_e, fe, "class"), Jr = Nt(_e, fe, "title");
    return {
      url: So,
      text: Et,
      title: Jr,
      target: Ko,
      rel: js,
      linkClass: Ns
    };
  }, On = { collect: (U, fe) => bt.getLinks(U).then((_e) => {
    const nt = on(U, fe);
    return {
      anchor: nt,
      catalogs: {
        targets: zt.getTargets(U),
        rels: me.getRels(U, nt.target),
        classes: Bn.getClasses(U),
        anchor: Co.getAnchors(U),
        link: _e
      },
      optNode: He.from(fe),
      flags: { titleEnabled: Dn(U) }
    };
  }) }, os = (U, fe) => (_e) => {
    const nt = _e.getData();
    if (!nt.url.value) {
      Xo(U), _e.close();
      return;
    }
    const Et = (js) => He.from(nt[js]).filter((Ns) => !wn(fe.anchor[js], Ns)), So = {
      href: nt.url.value,
      text: Et("text"),
      target: Et("target"),
      rel: Et("rel"),
      class: Et("linkClass"),
      title: Et("title")
    }, Ko = {
      href: nt.url.value,
      attach: nt.url.meta !== void 0 && nt.url.meta.attach ? nt.url.meta.attach : Ge
    };
    Rn.preprocess(U, So).then((js) => {
      Tr(U, Ko, js);
    }), _e.close();
  }, $s = (U) => {
    const fe = Ln(U);
    return On.collect(U, fe);
  }, zo = (U, fe) => {
    const _e = U.anchor, nt = _e.url.getOr("");
    return {
      url: {
        value: nt,
        meta: { original: { value: nt } }
      },
      text: _e.text.getOr(""),
      title: _e.title.getOr(""),
      anchor: nt,
      link: nt,
      rel: _e.rel.getOr(""),
      target: _e.target.or(fe).getOr(""),
      linkClass: _e.linkClass.getOr("")
    };
  }, Ya = (U, fe, _e) => {
    const nt = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL"
    }], Et = U.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), So = U.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], Ko = He.from(un(_e)), js = zo(U, Ko), Ns = U.catalogs, Jr = rs.init(js, Ns), to = {
      type: "panel",
      items: rt([
        nt,
        Et,
        So,
        ft([
          Ns.anchor.map(Oe.createUi("anchor", "Anchors")),
          Ns.rels.map(Oe.createUi("rel", "Rel")),
          Ns.targets.map(Oe.createUi("target", "Open link in...")),
          Ns.link.map(Oe.createUi("link", "Link list")),
          Ns.classes.map(Oe.createUi("linkClass", "Class"))
        ])
      ])
    };
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: to,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: js,
      onChange: (Ic, { name: Vo }) => {
        Jr.onChange(Ic.getData, { name: Vo }).each((ha) => {
          Ic.setData(ha);
        });
      },
      onSubmit: fe
    };
  }, sa = (U) => {
    $s(U).then((_e) => {
      const nt = os(U, _e);
      return Ya(_e, nt, U);
    }).then((_e) => {
      U.windowManager.open(_e);
    });
  }, Bo = (U) => {
    U.addCommand("mceLink", (fe, _e) => {
      (_e == null ? void 0 : _e.dialog) === !0 || !Xe(U) ? sa(U) : U.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  };
  var fs = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Lo = (U, fe) => {
    document.body.appendChild(U), U.dispatchEvent(fe), document.body.removeChild(U);
  }, br = (U) => {
    const fe = document.createElement("a");
    fe.target = "_blank", fe.href = U, fe.rel = "noreferrer noopener";
    const _e = document.createEvent("MouseEvents");
    _e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), Lo(fe, _e);
  }, Er = (U, fe) => U.dom.getParent(fe, "a[href]"), ra = (U) => Er(U, U.selection.getStart()), nl = (U) => U.altKey === !0 && U.shiftKey === !1 && U.ctrlKey === !1 && U.metaKey === !1, pa = (U, fe) => {
    if (fe) {
      const _e = mn(fe);
      if (/^#/.test(_e)) {
        const nt = U.dom.select(_e);
        nt.length && U.selection.scrollIntoView(nt[0], !0);
      } else
        br(fe.href);
    }
  }, Wr = (U) => () => {
    U.execCommand("mceLink", !1, { dialog: !0 });
  }, Ma = (U) => () => {
    pa(U, ra(U));
  }, ci = (U) => {
    U.on("click", (fe) => {
      const _e = Er(U, fe.target);
      _e && fs.metaKeyPressed(fe) && (fe.preventDefault(), pa(U, _e));
    }), U.on("keydown", (fe) => {
      if (!fe.isDefaultPrevented() && fe.keyCode === 13 && nl(fe)) {
        const _e = ra(U);
        _e && (fe.preventDefault(), pa(U, _e));
      }
    });
  }, ol = (U, fe) => (U.on("NodeChange", fe), () => U.off("NodeChange", fe)), aa = (U) => (fe) => {
    const _e = () => fe.setActive(!U.mode.isReadOnly() && Ln(U, U.selection.getNode()) !== null);
    return _e(), ol(U, _e);
  }, Xa = (U) => (fe) => {
    const _e = () => fe.setEnabled(Ln(U, U.selection.getNode()) !== null);
    return _e(), ol(U, _e);
  }, kl = (U) => (fe) => {
    const _e = (Et) => Ro(Et) || Os(U.selection.getRng()), nt = U.dom.getParents(U.selection.getStart());
    return fe.setEnabled(_e(nt)), ol(U, (Et) => fe.setEnabled(_e(Et.parents)));
  }, Ja = (U) => {
    U.addShortcut("Meta+K", "", () => {
      U.execCommand("mceLink");
    });
  }, li = (U) => {
    U.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      onAction: Wr(U),
      onSetup: aa(U)
    }), U.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: Ma(U),
      onSetup: Xa(U)
    }), U.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => Xo(U),
      onSetup: kl(U)
    });
  }, Qa = (U) => {
    U.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: Ma(U),
      onSetup: Xa(U)
    }), U.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onAction: Wr(U)
    }), U.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => Xo(U),
      onSetup: kl(U)
    });
  }, Fc = (U) => {
    const fe = "link unlink openlink", _e = "link";
    U.ui.registry.addContextMenu("link", { update: (nt) => Ro(U.dom.getParents(nt, "a")) ? fe : _e });
  }, Hl = (U) => {
    const fe = (Et) => {
      Et.selection.collapse(!1);
    }, _e = (Et) => {
      const So = U.selection.getNode();
      return Et.setEnabled(Ln(U, So) !== null), Ge;
    }, nt = (Et) => {
      const So = Ln(U), Ko = Qs(U);
      if (!So && Ko) {
        const js = Go(U.selection, So);
        return He.some(js.length > 0 ? js : Et);
      } else
        return He.none();
    };
    U.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: aa(U)
      },
      label: "Link",
      predicate: (Et) => !!Ln(U, Et) && Pe(U),
      initValue: () => {
        const Et = Ln(U);
        return Et ? mn(Et) : "";
      },
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (Et) => {
            const So = U.selection.getNode();
            return Et.setActive(!!Ln(U, So)), aa(U)(Et);
          },
          onAction: (Et) => {
            const So = Et.getValue(), Ko = nt(So);
            Tr(U, {
              href: So,
              attach: Ge
            }, {
              href: So,
              text: Ko,
              title: He.none(),
              rel: He.none(),
              target: He.none(),
              class: He.none()
            }), fe(U), Et.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: _e,
          onAction: (Et) => {
            Xo(U), Et.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: _e,
          onAction: (Et) => {
            Ma(U)(), Et.hide();
          }
        }
      ]
    });
  };
  var or = () => {
    ns.add("link", (U) => {
      Qe(U), li(U), Qa(U), Fc(U), Hl(U), ci(U), Bo(U), Ja(U);
    });
  };
  or();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = Object.getPrototypeOf, Eo = (B, j, ce) => {
    var Fe;
    return ce(B, j.prototype) ? !0 : ((Fe = B.constructor) === null || Fe === void 0 ? void 0 : Fe.name) === j.name;
  }, In = (B) => {
    const j = typeof B;
    return B === null ? "null" : j === "object" && Array.isArray(B) ? "array" : j === "object" && Eo(B, String, (ce, Fe) => Fe.isPrototypeOf(ce)) ? "string" : j;
  }, Jn = (B) => (j) => In(j) === B, uo = (B) => (j) => typeof j === B, ho = (B) => (j) => B === j, Kt = (B, j) => $t(B) && Eo(B, j, (ce, Fe) => To(ce) === Fe), Bt = Jn("string"), $t = Jn("object"), Un = (B) => Kt(B, Object), Ao = Jn("array"), tn = ho(null), mt = uo("boolean"), an = (B) => B == null, Ge = (B) => !an(B), At = uo("function"), He = uo("number"), Ue = (B, j) => {
    if (Ao(B)) {
      for (let ce = 0, Fe = B.length; ce < Fe; ++ce)
        if (!j(B[ce]))
          return !1;
      return !0;
    }
    return !1;
  }, ie = () => {
  };
  class dn {
    constructor(j, ce) {
      this.tag = j, this.value = ce;
    }
    static some(j) {
      return new dn(!0, j);
    }
    static none() {
      return dn.singletonNone;
    }
    fold(j, ce) {
      return this.tag ? ce(this.value) : j();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(j) {
      return this.tag ? dn.some(j(this.value)) : dn.none();
    }
    bind(j) {
      return this.tag ? j(this.value) : dn.none();
    }
    exists(j) {
      return this.tag && j(this.value);
    }
    forall(j) {
      return !this.tag || j(this.value);
    }
    filter(j) {
      return !this.tag || j(this.value) ? this : dn.none();
    }
    getOr(j) {
      return this.tag ? this.value : j;
    }
    or(j) {
      return this.tag ? this : j;
    }
    getOrThunk(j) {
      return this.tag ? this.value : j();
    }
    orThunk(j) {
      return this.tag ? this : j();
    }
    getOrDie(j) {
      if (this.tag)
        return this.value;
      throw new Error(j != null ? j : "Called getOrDie on None");
    }
    static from(j) {
      return Ge(j) ? dn.some(j) : dn.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(j) {
      this.tag && j(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  dn.singletonNone = new dn(!1);
  const _t = Object.keys, Re = Object.hasOwnProperty, oe = (B, j) => {
    const ce = _t(B);
    for (let Fe = 0, Dt = ce.length; Fe < Dt; Fe++) {
      const $o = ce[Fe], Jo = B[$o];
      j(Jo, $o);
    }
  }, Je = (B) => (j, ce) => {
    B[ce] = j;
  }, rt = (B, j, ce, Fe) => {
    const Dt = {};
    return oe(B, ($o, Jo) => {
      (j($o, Jo) ? ce : Fe)($o, Jo);
    }), Dt;
  }, lt = (B, j) => {
    const ce = {};
    return rt(B, j, Je(ce), ie), ce;
  }, Q = (B, j) => Re.call(B, j), wn = (B, j) => Q(B, j) && B[j] !== void 0 && B[j] !== null, ft = Array.prototype.push, Ot = (B) => {
    const j = [];
    for (let ce = 0, Fe = B.length; ce < Fe; ++ce) {
      if (!Ao(B[ce]))
        throw new Error("Arr.flatten item " + ce + " was not an array, input: " + B);
      ft.apply(j, B[ce]);
    }
    return j;
  }, Se = (B, j) => j >= 0 && j < B.length ? dn.some(B[j]) : dn.none(), Qe = (B) => Se(B, 0), z = (B, j) => {
    for (let ce = 0; ce < B.length; ce++) {
      const Fe = j(B[ce], ce);
      if (Fe.isSome())
        return Fe;
    }
    return dn.none();
  };
  typeof window < "u" || Function("return this;")();
  const Pe = (B, j, ce) => {
    if (Bt(ce) || mt(ce) || He(ce))
      B.setAttribute(j, ce + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", j, ":: Value ", ce, ":: Element ", B), new Error("Attribute value was not simple");
  }, Rt = (B, j, ce) => {
    Pe(B.dom, j, ce);
  }, un = (B, j) => {
    B.dom.removeAttribute(j);
  }, Ct = (B, j) => {
    const Fe = (j || document).createElement("div");
    if (Fe.innerHTML = B, !Fe.hasChildNodes() || Fe.childNodes.length > 1) {
      const Dt = "HTML does not have a single root node";
      throw console.error(Dt, B), new Error(Dt);
    }
    return Sn(Fe.childNodes[0]);
  }, _o = (B, j) => {
    const Fe = (j || document).createElement(B);
    return Sn(Fe);
  }, Fn = (B, j) => {
    const Fe = (j || document).createTextNode(B);
    return Sn(Fe);
  }, Sn = (B) => {
    if (B == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: B };
  }, Mn = {
    fromHtml: Ct,
    fromTag: _o,
    fromText: Fn,
    fromDom: Sn,
    fromPoint: (B, j, ce) => dn.from(B.dom.elementFromPoint(j, ce)).map(Sn)
  };
  var Xe = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), O = tinymce.util.Tools.resolve("tinymce.util.URI");
  const gt = (B) => B.length > 0, en = (B) => (j) => j.options.get(B), Pt = (B) => {
    const j = B.options.register;
    j("image_dimensions", {
      processor: "boolean",
      default: !0
    }), j("image_advtab", {
      processor: "boolean",
      default: !1
    }), j("image_uploadtab", {
      processor: "boolean",
      default: !0
    }), j("image_prepend_url", {
      processor: "string",
      default: ""
    }), j("image_class_list", { processor: "object[]" }), j("image_description", {
      processor: "boolean",
      default: !0
    }), j("image_title", {
      processor: "boolean",
      default: !1
    }), j("image_caption", {
      processor: "boolean",
      default: !1
    }), j("image_list", {
      processor: (ce) => {
        const Fe = ce === !1 || Bt(ce) || Ue(ce, $t) || At(ce);
        return Fe ? {
          value: ce,
          valid: Fe
        } : {
          valid: !1,
          message: "Must be false, a string, an array or a function."
        };
      },
      default: !1
    });
  }, Ne = en("image_dimensions"), We = en("image_advtab"), Ae = en("image_uploadtab"), Oe = en("image_prepend_url"), ae = en("image_class_list"), X = en("image_description"), je = en("image_title"), ke = en("image_caption"), ue = en("image_list"), ct = en("a11y_advanced_options"), Ht = en("automatic_uploads"), vo = (B) => gt(B.options.get("images_upload_url")), Wn = (B) => Ge(B.options.get("images_upload_handler")), ko = (B, j) => Math.max(parseInt(B, 10), parseInt(j, 10)), fo = (B) => new Promise((j) => {
    const ce = document.createElement("img"), Fe = ($o) => {
      ce.onload = ce.onerror = null, ce.parentNode && ce.parentNode.removeChild(ce), j($o);
    };
    ce.onload = () => {
      const $o = ko(ce.width, ce.clientWidth), Jo = ko(ce.height, ce.clientHeight), it = {
        width: $o,
        height: Jo
      };
      Fe(Promise.resolve(it));
    }, ce.onerror = () => {
      Fe(Promise.reject(`Failed to get image dimensions for: ${B}`));
    };
    const Dt = ce.style;
    Dt.visibility = "hidden", Dt.position = "fixed", Dt.bottom = Dt.left = "0px", Dt.width = Dt.height = "auto", document.body.appendChild(ce), ce.src = B;
  }), yn = (B) => (B && (B = B.replace(/px$/, "")), B), ds = (B) => (B.length > 0 && /^[0-9]+$/.test(B) && (B += "px"), B), Ho = (B) => {
    if (B.margin) {
      const j = String(B.margin).split(" ");
      switch (j.length) {
        case 1:
          B["margin-top"] = B["margin-top"] || j[0], B["margin-right"] = B["margin-right"] || j[0], B["margin-bottom"] = B["margin-bottom"] || j[0], B["margin-left"] = B["margin-left"] || j[0];
          break;
        case 2:
          B["margin-top"] = B["margin-top"] || j[0], B["margin-right"] = B["margin-right"] || j[1], B["margin-bottom"] = B["margin-bottom"] || j[0], B["margin-left"] = B["margin-left"] || j[1];
          break;
        case 3:
          B["margin-top"] = B["margin-top"] || j[0], B["margin-right"] = B["margin-right"] || j[1], B["margin-bottom"] = B["margin-bottom"] || j[2], B["margin-left"] = B["margin-left"] || j[1];
          break;
        case 4:
          B["margin-top"] = B["margin-top"] || j[0], B["margin-right"] = B["margin-right"] || j[1], B["margin-bottom"] = B["margin-bottom"] || j[2], B["margin-left"] = B["margin-left"] || j[3];
      }
      delete B.margin;
    }
    return B;
  }, mn = (B, j) => {
    const ce = ue(B);
    Bt(ce) ? fetch(ce).then((Fe) => {
      Fe.ok && Fe.json().then(j);
    }) : At(ce) ? ce(j) : j(ce);
  }, Io = (B, j, ce) => {
    const Fe = () => {
      ce.onload = ce.onerror = null, B.selection && (B.selection.select(ce), B.nodeChanged());
    };
    ce.onload = () => {
      !j.width && !j.height && Ne(B) && B.dom.setAttribs(ce, {
        width: String(ce.clientWidth),
        height: String(ce.clientHeight)
      }), Fe();
    }, ce.onerror = Fe;
  }, ro = (B) => new Promise((j, ce) => {
    const Fe = new FileReader();
    Fe.onload = () => {
      j(Fe.result);
    }, Fe.onerror = () => {
      ce(Fe.error.message);
    }, Fe.readAsDataURL(B);
  }), Ln = (B) => B.nodeName === "IMG" && (B.hasAttribute("data-mce-object") || B.hasAttribute("data-mce-placeholder")), Go = (B, j) => {
    const ce = B.options.get;
    return O.isDomSafe(j, "img", {
      allow_html_data_urls: ce("allow_html_data_urls"),
      allow_script_urls: ce("allow_script_urls"),
      allow_svg_data_urls: ce("allow_svg_data_urls")
    });
  }, Ro = Xe.DOM, Os = (B) => B.style.marginLeft && B.style.marginRight && B.style.marginLeft === B.style.marginRight ? yn(B.style.marginLeft) : "", Qs = (B) => B.style.marginTop && B.style.marginBottom && B.style.marginTop === B.style.marginBottom ? yn(B.style.marginTop) : "", we = (B) => B.style.borderWidth ? yn(B.style.borderWidth) : "", $e = (B, j) => B.hasAttribute(j) ? B.getAttribute(j) : "", Vt = (B, j) => B.style[j] ? B.style[j] : "", Jt = (B) => B.parentNode !== null && B.parentNode.nodeName === "FIGURE", ht = (B, j, ce) => {
    ce === "" ? B.removeAttribute(j) : B.setAttribute(j, ce);
  }, qn = (B) => {
    const j = Ro.create("figure", { class: "image" });
    Ro.insertAfter(j, B), j.appendChild(B), j.appendChild(Ro.create("figcaption", { contentEditable: "true" }, "Caption")), j.contentEditable = "false";
  }, pr = (B) => {
    const j = B.parentNode;
    Ro.insertAfter(B, j), Ro.remove(j);
  }, zr = (B) => {
    Jt(B) ? pr(B) : qn(B);
  }, Zs = (B, j) => {
    const ce = B.getAttribute("style"), Fe = j(ce !== null ? ce : "");
    Fe.length > 0 ? (B.setAttribute("style", Fe), B.setAttribute("data-mce-style", Fe)) : B.removeAttribute("style");
  }, hr = (B, j) => (ce, Fe, Dt) => {
    ce.style[Fe] ? (ce.style[Fe] = ds(Dt), Zs(ce, j)) : ht(ce, Fe, Dt);
  }, Fs = (B, j) => B.style[j] ? yn(B.style[j]) : $e(B, j), Tr = (B, j) => {
    const ce = ds(j);
    B.style.marginLeft = ce, B.style.marginRight = ce;
  }, Xo = (B, j) => {
    const ce = ds(j);
    B.style.marginTop = ce, B.style.marginBottom = ce;
  }, Gn = (B, j) => {
    const ce = ds(j);
    B.style.borderWidth = ce;
  }, er = (B, j) => {
    B.style.borderStyle = j;
  }, Ss = (B) => Vt(B, "borderStyle"), ir = (B) => B.nodeName === "FIGURE", Ka = (B) => B.nodeName === "IMG", Ra = (B) => Ro.getAttrib(B, "alt").length === 0 && Ro.getAttrib(B, "role") === "presentation", Ur = (B) => Ra(B) ? "" : $e(B, "alt"), rs = () => ({
    src: "",
    alt: "",
    title: "",
    width: "",
    height: "",
    class: "",
    style: "",
    caption: !1,
    hspace: "",
    vspace: "",
    border: "",
    borderStyle: "",
    isDecorative: !1
  }), cc = (B, j) => {
    const ce = document.createElement("img");
    return ht(ce, "style", j.style), (Os(ce) || j.hspace !== "") && Tr(ce, j.hspace), (Qs(ce) || j.vspace !== "") && Xo(ce, j.vspace), (we(ce) || j.border !== "") && Gn(ce, j.border), (Ss(ce) || j.borderStyle !== "") && er(ce, j.borderStyle), B(ce.getAttribute("style"));
  }, Z = (B, j) => {
    const ce = document.createElement("img");
    if (Co(B, {
      ...j,
      caption: !1
    }, ce), wt(ce, j.alt, j.isDecorative), j.caption) {
      const Fe = Ro.create("figure", { class: "image" });
      return Fe.appendChild(ce), Fe.appendChild(Ro.create("figcaption", { contentEditable: "true" }, "Caption")), Fe.contentEditable = "false", Fe;
    } else
      return ce;
  }, le = (B, j) => ({
    src: $e(j, "src"),
    alt: Ur(j),
    title: $e(j, "title"),
    width: Fs(j, "width"),
    height: Fs(j, "height"),
    class: $e(j, "class"),
    style: B($e(j, "style")),
    caption: Jt(j),
    hspace: Os(j),
    vspace: Qs(j),
    border: we(j),
    borderStyle: Vt(j, "borderStyle"),
    isDecorative: Ra(j)
  }), Ce = (B, j, ce, Fe, Dt) => {
    ce[Fe] !== j[Fe] && Dt(B, Fe, ce[Fe]);
  }, wt = (B, j, ce) => {
    if (ce) {
      Ro.setAttrib(B, "role", "presentation");
      const Fe = Mn.fromDom(B);
      Rt(Fe, "alt", "");
    } else {
      if (tn(j)) {
        const Fe = Mn.fromDom(B);
        un(Fe, "alt");
      } else {
        const Fe = Mn.fromDom(B);
        Rt(Fe, "alt", j);
      }
      Ro.getAttrib(B, "role") === "presentation" && Ro.setAttrib(B, "role", "");
    }
  }, Rn = (B, j, ce) => {
    (ce.alt !== j.alt || ce.isDecorative !== j.isDecorative) && wt(B, ce.alt, ce.isDecorative);
  }, Ft = (B, j) => (ce, Fe, Dt) => {
    B(ce, Dt), Zs(ce, j);
  }, Co = (B, j, ce) => {
    const Fe = le(B, ce);
    Ce(ce, Fe, j, "caption", (Dt, $o, Jo) => zr(Dt)), Ce(ce, Fe, j, "src", ht), Ce(ce, Fe, j, "title", ht), Ce(ce, Fe, j, "width", hr("width", B)), Ce(ce, Fe, j, "height", hr("height", B)), Ce(ce, Fe, j, "class", ht), Ce(ce, Fe, j, "style", Ft((Dt, $o) => ht(Dt, "style", $o), B)), Ce(ce, Fe, j, "hspace", Ft(Tr, B)), Ce(ce, Fe, j, "vspace", Ft(Xo, B)), Ce(ce, Fe, j, "border", Ft(Gn, B)), Ce(ce, Fe, j, "borderStyle", Ft(er, B)), Rn(ce, Fe, j);
  }, tr = (B, j) => {
    const ce = B.dom.styles.parse(j), Fe = Ho(ce), Dt = B.dom.styles.parse(B.dom.styles.serialize(Fe));
    return B.dom.styles.serialize(Dt);
  }, Bn = (B) => {
    const j = B.selection.getNode(), ce = B.dom.getParent(j, "figure.image");
    return ce ? B.dom.select("img", ce)[0] : j && (j.nodeName !== "IMG" || Ln(j)) ? null : j;
  }, No = (B, j) => {
    const ce = B.dom, Fe = lt(B.schema.getTextBlockElements(), ($o, Jo) => !B.schema.isValidChild(Jo, "figure")), Dt = ce.getParent(j.parentNode, ($o) => wn(Fe, $o.nodeName), B.getBody());
    return Dt ? ce.split(Dt, j) : j;
  }, yr = (B) => {
    const j = Bn(B);
    return j ? le((ce) => tr(B, ce), j) : rs();
  }, bt = (B, j) => {
    const ce = Z((Dt) => tr(B, Dt), j);
    B.dom.setAttrib(ce, "data-mce-id", "__mcenew"), B.focus(), B.selection.setContent(ce.outerHTML);
    const Fe = B.dom.select('*[data-mce-id="__mcenew"]')[0];
    if (B.dom.setAttrib(Fe, "data-mce-id", null), ir(Fe)) {
      const Dt = No(B, Fe);
      B.selection.select(Dt);
    } else
      B.selection.select(Fe);
  }, se = (B, j) => {
    B.dom.setAttrib(j, "src", j.getAttribute("src"));
  }, me = (B, j) => {
    if (j) {
      const ce = B.dom.is(j.parentNode, "figure.image") ? j.parentNode : j;
      B.dom.remove(ce), B.focus(), B.nodeChanged(), B.dom.isEmpty(B.getBody()) && (B.setContent(""), B.selection.setCursorLocation());
    }
  }, tt = (B, j) => {
    const ce = Bn(B);
    if (Co((Fe) => tr(B, Fe), j, ce), se(B, ce), ir(ce.parentNode)) {
      const Fe = ce.parentNode;
      No(B, Fe), B.selection.select(ce.parentNode);
    } else
      B.selection.select(ce), Io(B, j, ce);
  }, Lt = (B, j) => {
    const ce = j.src;
    return {
      ...j,
      src: Go(B, ce) ? ce : ""
    };
  }, zt = (B, j) => {
    const ce = Bn(B);
    if (ce) {
      const Dt = {
        ...le((Jo) => tr(B, Jo), ce),
        ...j
      }, $o = Lt(B, Dt);
      Dt.src ? tt(B, $o) : me(B, ce);
    } else
      j.src && bt(B, {
        ...rs(),
        ...j
      });
  }, Yt = ((B) => (...j) => {
    if (j.length === 0)
      throw new Error("Can't merge zero objects");
    const ce = {};
    for (let Fe = 0; Fe < j.length; Fe++) {
      const Dt = j[Fe];
      for (const $o in Dt)
        Q(Dt, $o) && (ce[$o] = B(ce[$o], Dt[$o]));
    }
    return ce;
  })((B, j) => Un(B) && Un(j) ? Yt(B, j) : j);
  var On = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), os = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const $s = (B) => Bt(B.value) ? B.value : "", zo = (B) => Bt(B.text) ? B.text : Bt(B.title) ? B.title : "", Ya = (B, j) => {
    const ce = [];
    return os.each(B, (Fe) => {
      const Dt = zo(Fe);
      if (Fe.menu !== void 0) {
        const $o = Ya(Fe.menu, j);
        ce.push({
          text: Dt,
          items: $o
        });
      } else {
        const $o = j(Fe);
        ce.push({
          text: Dt,
          value: $o
        });
      }
    }), ce;
  }, sa = (B = $s) => (j) => j ? dn.from(j).map((ce) => Ya(ce, B)) : dn.none(), Bo = (B) => sa($s)(B), fs = (B) => Q(B, "items"), Lo = (B, j) => z(B, (ce) => fs(ce) ? Lo(ce.items, j) : ce.value === j ? dn.some(ce) : dn.none()), Er = {
    sanitizer: sa,
    sanitize: Bo,
    findEntry: (B, j) => B.bind((ce) => Lo(ce, j))
  }, nl = { makeTab: (B) => ({
    title: "Advanced",
    name: "advanced",
    items: [{
      type: "grid",
      columns: 2,
      items: [
        {
          type: "input",
          label: "Vertical space",
          name: "vspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Horizontal space",
          name: "hspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Border width",
          name: "border",
          inputMode: "numeric"
        },
        {
          type: "listbox",
          name: "borderstyle",
          label: "Border style",
          items: [
            {
              text: "Select...",
              value: ""
            },
            {
              text: "Solid",
              value: "solid"
            },
            {
              text: "Dotted",
              value: "dotted"
            },
            {
              text: "Dashed",
              value: "dashed"
            },
            {
              text: "Double",
              value: "double"
            },
            {
              text: "Groove",
              value: "groove"
            },
            {
              text: "Ridge",
              value: "ridge"
            },
            {
              text: "Inset",
              value: "inset"
            },
            {
              text: "Outset",
              value: "outset"
            },
            {
              text: "None",
              value: "none"
            },
            {
              text: "Hidden",
              value: "hidden"
            }
          ]
        }
      ]
    }]
  }) }, pa = (B) => {
    const j = Er.sanitizer((Ye) => B.convertURL(Ye.value || Ye.url, "src")), ce = new Promise((Ye) => {
      mn(B, (bn) => {
        Ye(j(bn).map((An) => Ot([
          [{
            text: "None",
            value: ""
          }],
          An
        ])));
      });
    }), Fe = Er.sanitize(ae(B)), Dt = We(B), $o = Ae(B), Jo = vo(B), it = Wn(B), hs = yr(B), Ca = X(B), qs = je(B), Hc = Ne(B), as = ke(B), G = ct(B), re = Ht(B), Me = dn.some(Oe(B)).filter((Ye) => Bt(Ye) && Ye.length > 0);
    return ce.then((Ye) => ({
      image: hs,
      imageList: Ye,
      classList: Fe,
      hasAdvTab: Dt,
      hasUploadTab: $o,
      hasUploadUrl: Jo,
      hasUploadHandler: it,
      hasDescription: Ca,
      hasImageTitle: qs,
      hasDimensions: Hc,
      hasImageCaption: as,
      prependURL: Me,
      hasAccessibilityOptions: G,
      automaticUploads: re
    }));
  }, Wr = (B) => {
    const j = {
      name: "src",
      type: "urlinput",
      filetype: "image",
      label: "Source"
    }, ce = B.imageList.map((qs) => ({
      name: "images",
      type: "listbox",
      label: "Image list",
      items: qs
    })), Fe = {
      name: "alt",
      type: "input",
      label: "Alternative description",
      enabled: !(B.hasAccessibilityOptions && B.image.isDecorative)
    }, Dt = {
      name: "title",
      type: "input",
      label: "Image title"
    }, $o = {
      name: "dimensions",
      type: "sizeinput"
    }, Jo = {
      type: "label",
      label: "Accessibility",
      items: [{
        name: "isDecorative",
        type: "checkbox",
        label: "Image is decorative"
      }]
    }, it = B.classList.map((qs) => ({
      name: "classes",
      type: "listbox",
      label: "Class",
      items: qs
    })), hs = {
      type: "label",
      label: "Caption",
      items: [{
        type: "checkbox",
        name: "caption",
        label: "Show caption"
      }]
    }, Ca = (qs) => qs ? {
      type: "grid",
      columns: 2
    } : { type: "panel" };
    return Ot([
      [j],
      ce.toArray(),
      B.hasAccessibilityOptions && B.hasDescription ? [Jo] : [],
      B.hasDescription ? [Fe] : [],
      B.hasImageTitle ? [Dt] : [],
      B.hasDimensions ? [$o] : [],
      [{
        ...Ca(B.classList.isSome() && B.hasImageCaption),
        items: Ot([
          it.toArray(),
          B.hasImageCaption ? [hs] : []
        ])
      }]
    ]);
  }, ci = {
    makeTab: (B) => ({
      title: "General",
      name: "general",
      items: Wr(B)
    }),
    makeItems: Wr
  }, aa = { makeTab: (B) => ({
    title: "Upload",
    name: "upload",
    items: [{
      type: "dropzone",
      name: "fileinput"
    }]
  }) }, Xa = (B) => ({
    prevImage: Er.findEntry(B.imageList, B.image.src),
    prevAlt: B.image.alt,
    open: !0
  }), kl = (B) => ({
    src: {
      value: B.src,
      meta: {}
    },
    images: B.src,
    alt: B.alt,
    title: B.title,
    dimensions: {
      width: B.width,
      height: B.height
    },
    classes: B.class,
    caption: B.caption,
    style: B.style,
    vspace: B.vspace,
    border: B.border,
    hspace: B.hspace,
    borderstyle: B.borderStyle,
    fileinput: [],
    isDecorative: B.isDecorative
  }), Ja = (B, j) => ({
    src: B.src.value,
    alt: B.alt.length === 0 && j ? null : B.alt,
    title: B.title,
    width: B.dimensions.width,
    height: B.dimensions.height,
    class: B.classes,
    style: B.style,
    caption: B.caption,
    hspace: B.hspace,
    vspace: B.vspace,
    border: B.border,
    borderStyle: B.borderstyle,
    isDecorative: B.isDecorative
  }), li = (B, j) => /^(?:[a-zA-Z]+:)?\/\//.test(j) ? dn.none() : B.prependURL.bind((ce) => j.substring(0, ce.length) !== ce ? dn.some(ce + j) : dn.none()), Qa = (B, j) => {
    const ce = j.getData();
    li(B, ce.src.value).each((Fe) => {
      j.setData({
        src: {
          value: Fe,
          meta: ce.src.meta
        }
      });
    });
  }, Fc = (B, j, ce) => {
    B.hasDescription && Bt(ce.alt) && (j.alt = ce.alt), B.hasAccessibilityOptions && (j.isDecorative = ce.isDecorative || j.isDecorative || !1), B.hasImageTitle && Bt(ce.title) && (j.title = ce.title), B.hasDimensions && (Bt(ce.width) && (j.dimensions.width = ce.width), Bt(ce.height) && (j.dimensions.height = ce.height)), Bt(ce.class) && Er.findEntry(B.classList, ce.class).each((Fe) => {
      j.classes = Fe.value;
    }), B.hasImageCaption && mt(ce.caption) && (j.caption = ce.caption), B.hasAdvTab && (Bt(ce.style) && (j.style = ce.style), Bt(ce.vspace) && (j.vspace = ce.vspace), Bt(ce.border) && (j.border = ce.border), Bt(ce.hspace) && (j.hspace = ce.hspace), Bt(ce.borderstyle) && (j.borderstyle = ce.borderstyle));
  }, Hl = (B, j) => {
    const ce = j.getData(), Fe = ce.src.meta;
    if (Fe !== void 0) {
      const Dt = Yt({}, ce);
      Fc(B, Dt, Fe), j.setData(Dt);
    }
  }, or = (B, j, ce, Fe) => {
    const Dt = Fe.getData(), $o = Dt.src.value, Jo = Dt.src.meta || {};
    !Jo.width && !Jo.height && j.hasDimensions && (gt($o) ? B.imageSize($o).then((it) => {
      ce.open && Fe.setData({ dimensions: it });
    }).catch((it) => console.error(it)) : Fe.setData({
      dimensions: {
        width: "",
        height: ""
      }
    }));
  }, U = (B, j, ce) => {
    const Fe = ce.getData(), Dt = Er.findEntry(B.imageList, Fe.src.value);
    j.prevImage = Dt, ce.setData({ images: Dt.map(($o) => $o.value).getOr("") });
  }, fe = (B, j, ce, Fe) => {
    Qa(j, Fe), Hl(j, Fe), or(B, j, ce, Fe), U(j, ce, Fe);
  }, _e = (B, j, ce, Fe) => {
    const Dt = Fe.getData(), $o = Er.findEntry(j.imageList, Dt.images);
    $o.each((Jo) => {
      Dt.alt === "" || ce.prevImage.map((hs) => hs.text === Dt.alt).getOr(!1) ? Jo.value === "" ? Fe.setData({
        src: Jo,
        alt: ce.prevAlt
      }) : Fe.setData({
        src: Jo,
        alt: Jo.text
      }) : Fe.setData({ src: Jo });
    }), ce.prevImage = $o, fe(B, j, ce, Fe);
  }, nt = (B, j, ce, Fe) => {
    const Dt = Fe.getData();
    Fe.block("Uploading image"), Qe(Dt.fileinput).fold(() => {
      Fe.unblock();
    }, ($o) => {
      const Jo = URL.createObjectURL($o), it = () => {
        Fe.unblock(), URL.revokeObjectURL(Jo);
      }, hs = (Ca) => {
        Fe.setData({
          src: {
            value: Ca,
            meta: {}
          }
        }), Fe.showTab("general"), fe(B, j, ce, Fe);
      };
      ro($o).then((Ca) => {
        const qs = B.createBlobCache($o, Jo, Ca);
        j.automaticUploads ? B.uploadImage(qs).then((Hc) => {
          hs(Hc.url), it();
        }).catch((Hc) => {
          it(), B.alertErr(Hc);
        }) : (B.addToBlobCache(qs), hs(qs.blobUri()), Fe.unblock());
      });
    });
  }, Et = (B, j, ce) => (Fe, Dt) => {
    Dt.name === "src" ? fe(B, j, ce, Fe) : Dt.name === "images" ? _e(B, j, ce, Fe) : Dt.name === "alt" ? ce.prevAlt = Fe.getData().alt : Dt.name === "fileinput" ? nt(B, j, ce, Fe) : Dt.name === "isDecorative" && Fe.setEnabled("alt", !Fe.getData().isDecorative);
  }, So = (B) => () => {
    B.open = !1;
  }, Ko = (B) => B.hasAdvTab || B.hasUploadUrl || B.hasUploadHandler ? {
    type: "tabpanel",
    tabs: Ot([
      [ci.makeTab(B)],
      B.hasAdvTab ? [nl.makeTab(B)] : [],
      B.hasUploadTab && (B.hasUploadUrl || B.hasUploadHandler) ? [aa.makeTab(B)] : []
    ])
  } : {
    type: "panel",
    items: ci.makeItems(B)
  }, js = (B, j, ce) => (Fe) => {
    const Dt = Yt(kl(j.image), Fe.getData()), $o = {
      ...Dt,
      style: cc(ce.normalizeCss, Ja(Dt, !1))
    };
    B.execCommand("mceUpdateImage", !1, Ja($o, j.hasAccessibilityOptions)), B.editorUpload.uploadImagesAuto(), Fe.close();
  }, Ns = (B) => (j) => Go(B, j) ? fo(B.documentBaseURI.toAbsolute(j)).then((ce) => ({
    width: String(ce.width),
    height: String(ce.height)
  })) : Promise.resolve({
    width: "",
    height: ""
  }), Jr = (B) => (j, ce, Fe) => B.editorUpload.blobCache.create({
    blob: j,
    blobUri: ce,
    name: j.name ? j.name.replace(/\.[^\.]+$/, "") : null,
    filename: j.name,
    base64: Fe.split(",")[1]
  }), to = (B) => (j) => {
    B.editorUpload.blobCache.add(j);
  }, Ic = (B) => (j) => {
    B.windowManager.alert(j);
  }, Vo = (B) => (j) => tr(B, j), ha = (B) => (j) => B.dom.parseStyle(j), Vl = (B) => (j, ce) => B.dom.serializeStyle(j, ce), nr = (B) => (j) => On(B).upload([j], !1).then((ce) => ce.length === 0 ? Promise.reject("Failed to upload image") : ce[0].status === !1 ? Promise.reject(ce[0].error.message) : ce[0]), ca = (B) => {
    const j = {
      imageSize: Ns(B),
      addToBlobCache: to(B),
      createBlobCache: Jr(B),
      alertErr: Ic(B),
      normalizeCss: Vo(B),
      parseStyle: ha(B),
      serializeStyle: Vl(B),
      uploadImage: nr(B)
    };
    return { open: () => {
      pa(B).then((Fe) => {
        const Dt = Xa(Fe);
        return {
          title: "Insert/Edit Image",
          size: "normal",
          body: Ko(Fe),
          buttons: [
            {
              type: "cancel",
              name: "cancel",
              text: "Cancel"
            },
            {
              type: "submit",
              name: "save",
              text: "Save",
              primary: !0
            }
          ],
          initialData: kl(Fe.image),
          onSubmit: js(B, Fe, j),
          onChange: Et(j, Fe, Dt),
          onClose: So(Dt)
        };
      }).then(B.windowManager.open);
    } };
  }, lc = (B) => {
    B.addCommand("mceImage", ca(B).open), B.addCommand("mceUpdateImage", (j, ce) => {
      B.undoManager.transact(() => zt(B, ce));
    });
  }, Lc = (B) => {
    const j = B.attr("class");
    return j && /\bimage\b/.test(j);
  }, Qt = (B) => (j) => {
    let ce = j.length;
    const Fe = (Dt) => {
      Dt.attr("contenteditable", B ? "true" : null);
    };
    for (; ce--; ) {
      const Dt = j[ce];
      Lc(Dt) && (Dt.attr("contenteditable", B ? "false" : null), os.each(Dt.getAll("figcaption"), Fe));
    }
  }, Zr = (B) => {
    B.on("PreInit", () => {
      B.parser.addNodeFilter("figure", Qt(!0)), B.serializer.addNodeFilter("figure", Qt(!1));
    });
  }, wl = (B) => {
    B.ui.registry.addToggleButton("image", {
      icon: "image",
      tooltip: "Insert/edit image",
      onAction: ca(B).open,
      onSetup: (j) => (j.setActive(Ge(Bn(B))), B.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", j.setActive).unbind)
    }), B.ui.registry.addMenuItem("image", {
      icon: "image",
      text: "Image...",
      onAction: ca(B).open
    }), B.ui.registry.addContextMenu("image", { update: (j) => ir(j) || Ka(j) && !Ln(j) ? ["image"] : [] });
  };
  var qr = () => {
    ns.add("image", (B) => {
      Pt(B), Zr(B), wl(B), lc(B);
    });
  };
  qr();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (Ne, We) => Ne.dispatch("insertCustomChar", { chr: We }), Eo = (Ne, We) => {
    const Ae = To(Ne, We).chr;
    Ne.execCommand("mceInsertContent", !1, Ae);
  }, In = (Ne, We, Ae) => {
    var Oe;
    return Ae(Ne, We.prototype) ? !0 : ((Oe = Ne.constructor) === null || Oe === void 0 ? void 0 : Oe.name) === We.name;
  }, Jn = (Ne) => {
    const We = typeof Ne;
    return Ne === null ? "null" : We === "object" && Array.isArray(Ne) ? "array" : We === "object" && In(Ne, String, (Ae, Oe) => Oe.isPrototypeOf(Ae)) ? "string" : We;
  }, uo = (Ne) => (We) => Jn(We) === Ne, ho = (Ne) => (We) => typeof We === Ne, Kt = (Ne) => (We) => Ne === We, Bt = uo("array"), $t = Kt(null), Un = (Ne) => Ne == null, Ao = (Ne) => !Un(Ne), tn = ho("function"), an = ((Ne) => () => Ne)(!1);
  class Ge {
    constructor(We, Ae) {
      this.tag = We, this.value = Ae;
    }
    static some(We) {
      return new Ge(!0, We);
    }
    static none() {
      return Ge.singletonNone;
    }
    fold(We, Ae) {
      return this.tag ? Ae(this.value) : We();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(We) {
      return this.tag ? Ge.some(We(this.value)) : Ge.none();
    }
    bind(We) {
      return this.tag ? We(this.value) : Ge.none();
    }
    exists(We) {
      return this.tag && We(this.value);
    }
    forall(We) {
      return !this.tag || We(this.value);
    }
    filter(We) {
      return !this.tag || We(this.value) ? this : Ge.none();
    }
    getOr(We) {
      return this.tag ? this.value : We;
    }
    or(We) {
      return this.tag ? this : We;
    }
    getOrThunk(We) {
      return this.tag ? this.value : We();
    }
    orThunk(We) {
      return this.tag ? this : We();
    }
    getOrDie(We) {
      if (this.tag)
        return this.value;
      throw new Error(We != null ? We : "Called getOrDie on None");
    }
    static from(We) {
      return Ao(We) ? Ge.some(We) : Ge.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(We) {
      this.tag && We(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ge.singletonNone = new Ge(!1);
  const At = Array.prototype.push, He = (Ne, We) => {
    const Ae = Ne.length, Oe = new Array(Ae);
    for (let ae = 0; ae < Ae; ae++) {
      const X = Ne[ae];
      Oe[ae] = We(X, ae);
    }
    return Oe;
  }, Ue = (Ne, We) => {
    for (let Ae = 0, Oe = Ne.length; Ae < Oe; Ae++) {
      const ae = Ne[Ae];
      We(ae, Ae);
    }
  }, ie = (Ne, We, Ae) => {
    for (let Oe = 0, ae = Ne.length; Oe < ae; Oe++) {
      const X = Ne[Oe];
      if (We(X, Oe))
        return Ge.some(X);
      if (Ae(X, Oe))
        break;
    }
    return Ge.none();
  }, dn = (Ne, We) => ie(Ne, We, an), _t = (Ne) => {
    const We = [];
    for (let Ae = 0, Oe = Ne.length; Ae < Oe; ++Ae) {
      if (!Bt(Ne[Ae]))
        throw new Error("Arr.flatten item " + Ae + " was not an array, input: " + Ne);
      At.apply(We, Ne[Ae]);
    }
    return We;
  }, Re = (Ne, We) => _t(He(Ne, We));
  var oe = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Je = (Ne) => (We) => We.options.get(Ne), rt = (Ne) => {
    const We = Ne.options.register, Ae = (Oe) => tn(Oe) || Bt(Oe);
    We("charmap", { processor: Ae }), We("charmap_append", { processor: Ae });
  }, lt = Je("charmap"), Q = Je("charmap_append"), wn = oe.isArray, ft = "User Defined", Ot = () => [
    {
      name: "Currency",
      characters: [
        [
          36,
          "dollar sign"
        ],
        [
          162,
          "cent sign"
        ],
        [
          8364,
          "euro sign"
        ],
        [
          163,
          "pound sign"
        ],
        [
          165,
          "yen sign"
        ],
        [
          164,
          "currency sign"
        ],
        [
          8352,
          "euro-currency sign"
        ],
        [
          8353,
          "colon sign"
        ],
        [
          8354,
          "cruzeiro sign"
        ],
        [
          8355,
          "french franc sign"
        ],
        [
          8356,
          "lira sign"
        ],
        [
          8357,
          "mill sign"
        ],
        [
          8358,
          "naira sign"
        ],
        [
          8359,
          "peseta sign"
        ],
        [
          8360,
          "rupee sign"
        ],
        [
          8361,
          "won sign"
        ],
        [
          8362,
          "new sheqel sign"
        ],
        [
          8363,
          "dong sign"
        ],
        [
          8365,
          "kip sign"
        ],
        [
          8366,
          "tugrik sign"
        ],
        [
          8367,
          "drachma sign"
        ],
        [
          8368,
          "german penny symbol"
        ],
        [
          8369,
          "peso sign"
        ],
        [
          8370,
          "guarani sign"
        ],
        [
          8371,
          "austral sign"
        ],
        [
          8372,
          "hryvnia sign"
        ],
        [
          8373,
          "cedi sign"
        ],
        [
          8374,
          "livre tournois sign"
        ],
        [
          8375,
          "spesmilo sign"
        ],
        [
          8376,
          "tenge sign"
        ],
        [
          8377,
          "indian rupee sign"
        ],
        [
          8378,
          "turkish lira sign"
        ],
        [
          8379,
          "nordic mark sign"
        ],
        [
          8380,
          "manat sign"
        ],
        [
          8381,
          "ruble sign"
        ],
        [
          20870,
          "yen character"
        ],
        [
          20803,
          "yuan character"
        ],
        [
          22291,
          "yuan character, in hong kong and taiwan"
        ],
        [
          22278,
          "yen/yuan character variant one"
        ]
      ]
    },
    {
      name: "Text",
      characters: [
        [
          169,
          "copyright sign"
        ],
        [
          174,
          "registered sign"
        ],
        [
          8482,
          "trade mark sign"
        ],
        [
          8240,
          "per mille sign"
        ],
        [
          181,
          "micro sign"
        ],
        [
          183,
          "middle dot"
        ],
        [
          8226,
          "bullet"
        ],
        [
          8230,
          "three dot leader"
        ],
        [
          8242,
          "minutes / feet"
        ],
        [
          8243,
          "seconds / inches"
        ],
        [
          167,
          "section sign"
        ],
        [
          182,
          "paragraph sign"
        ],
        [
          223,
          "sharp s / ess-zed"
        ]
      ]
    },
    {
      name: "Quotations",
      characters: [
        [
          8249,
          "single left-pointing angle quotation mark"
        ],
        [
          8250,
          "single right-pointing angle quotation mark"
        ],
        [
          171,
          "left pointing guillemet"
        ],
        [
          187,
          "right pointing guillemet"
        ],
        [
          8216,
          "left single quotation mark"
        ],
        [
          8217,
          "right single quotation mark"
        ],
        [
          8220,
          "left double quotation mark"
        ],
        [
          8221,
          "right double quotation mark"
        ],
        [
          8218,
          "single low-9 quotation mark"
        ],
        [
          8222,
          "double low-9 quotation mark"
        ],
        [
          60,
          "less-than sign"
        ],
        [
          62,
          "greater-than sign"
        ],
        [
          8804,
          "less-than or equal to"
        ],
        [
          8805,
          "greater-than or equal to"
        ],
        [
          8211,
          "en dash"
        ],
        [
          8212,
          "em dash"
        ],
        [
          175,
          "macron"
        ],
        [
          8254,
          "overline"
        ],
        [
          164,
          "currency sign"
        ],
        [
          166,
          "broken bar"
        ],
        [
          168,
          "diaeresis"
        ],
        [
          161,
          "inverted exclamation mark"
        ],
        [
          191,
          "turned question mark"
        ],
        [
          710,
          "circumflex accent"
        ],
        [
          732,
          "small tilde"
        ],
        [
          176,
          "degree sign"
        ],
        [
          8722,
          "minus sign"
        ],
        [
          177,
          "plus-minus sign"
        ],
        [
          247,
          "division sign"
        ],
        [
          8260,
          "fraction slash"
        ],
        [
          215,
          "multiplication sign"
        ],
        [
          185,
          "superscript one"
        ],
        [
          178,
          "superscript two"
        ],
        [
          179,
          "superscript three"
        ],
        [
          188,
          "fraction one quarter"
        ],
        [
          189,
          "fraction one half"
        ],
        [
          190,
          "fraction three quarters"
        ]
      ]
    },
    {
      name: "Mathematical",
      characters: [
        [
          402,
          "function / florin"
        ],
        [
          8747,
          "integral"
        ],
        [
          8721,
          "n-ary sumation"
        ],
        [
          8734,
          "infinity"
        ],
        [
          8730,
          "square root"
        ],
        [
          8764,
          "similar to"
        ],
        [
          8773,
          "approximately equal to"
        ],
        [
          8776,
          "almost equal to"
        ],
        [
          8800,
          "not equal to"
        ],
        [
          8801,
          "identical to"
        ],
        [
          8712,
          "element of"
        ],
        [
          8713,
          "not an element of"
        ],
        [
          8715,
          "contains as member"
        ],
        [
          8719,
          "n-ary product"
        ],
        [
          8743,
          "logical and"
        ],
        [
          8744,
          "logical or"
        ],
        [
          172,
          "not sign"
        ],
        [
          8745,
          "intersection"
        ],
        [
          8746,
          "union"
        ],
        [
          8706,
          "partial differential"
        ],
        [
          8704,
          "for all"
        ],
        [
          8707,
          "there exists"
        ],
        [
          8709,
          "diameter"
        ],
        [
          8711,
          "backward difference"
        ],
        [
          8727,
          "asterisk operator"
        ],
        [
          8733,
          "proportional to"
        ],
        [
          8736,
          "angle"
        ]
      ]
    },
    {
      name: "Extended Latin",
      characters: [
        [
          192,
          "A - grave"
        ],
        [
          193,
          "A - acute"
        ],
        [
          194,
          "A - circumflex"
        ],
        [
          195,
          "A - tilde"
        ],
        [
          196,
          "A - diaeresis"
        ],
        [
          197,
          "A - ring above"
        ],
        [
          256,
          "A - macron"
        ],
        [
          198,
          "ligature AE"
        ],
        [
          199,
          "C - cedilla"
        ],
        [
          200,
          "E - grave"
        ],
        [
          201,
          "E - acute"
        ],
        [
          202,
          "E - circumflex"
        ],
        [
          203,
          "E - diaeresis"
        ],
        [
          274,
          "E - macron"
        ],
        [
          204,
          "I - grave"
        ],
        [
          205,
          "I - acute"
        ],
        [
          206,
          "I - circumflex"
        ],
        [
          207,
          "I - diaeresis"
        ],
        [
          298,
          "I - macron"
        ],
        [
          208,
          "ETH"
        ],
        [
          209,
          "N - tilde"
        ],
        [
          210,
          "O - grave"
        ],
        [
          211,
          "O - acute"
        ],
        [
          212,
          "O - circumflex"
        ],
        [
          213,
          "O - tilde"
        ],
        [
          214,
          "O - diaeresis"
        ],
        [
          216,
          "O - slash"
        ],
        [
          332,
          "O - macron"
        ],
        [
          338,
          "ligature OE"
        ],
        [
          352,
          "S - caron"
        ],
        [
          217,
          "U - grave"
        ],
        [
          218,
          "U - acute"
        ],
        [
          219,
          "U - circumflex"
        ],
        [
          220,
          "U - diaeresis"
        ],
        [
          362,
          "U - macron"
        ],
        [
          221,
          "Y - acute"
        ],
        [
          376,
          "Y - diaeresis"
        ],
        [
          562,
          "Y - macron"
        ],
        [
          222,
          "THORN"
        ],
        [
          224,
          "a - grave"
        ],
        [
          225,
          "a - acute"
        ],
        [
          226,
          "a - circumflex"
        ],
        [
          227,
          "a - tilde"
        ],
        [
          228,
          "a - diaeresis"
        ],
        [
          229,
          "a - ring above"
        ],
        [
          257,
          "a - macron"
        ],
        [
          230,
          "ligature ae"
        ],
        [
          231,
          "c - cedilla"
        ],
        [
          232,
          "e - grave"
        ],
        [
          233,
          "e - acute"
        ],
        [
          234,
          "e - circumflex"
        ],
        [
          235,
          "e - diaeresis"
        ],
        [
          275,
          "e - macron"
        ],
        [
          236,
          "i - grave"
        ],
        [
          237,
          "i - acute"
        ],
        [
          238,
          "i - circumflex"
        ],
        [
          239,
          "i - diaeresis"
        ],
        [
          299,
          "i - macron"
        ],
        [
          240,
          "eth"
        ],
        [
          241,
          "n - tilde"
        ],
        [
          242,
          "o - grave"
        ],
        [
          243,
          "o - acute"
        ],
        [
          244,
          "o - circumflex"
        ],
        [
          245,
          "o - tilde"
        ],
        [
          246,
          "o - diaeresis"
        ],
        [
          248,
          "o slash"
        ],
        [
          333,
          "o macron"
        ],
        [
          339,
          "ligature oe"
        ],
        [
          353,
          "s - caron"
        ],
        [
          249,
          "u - grave"
        ],
        [
          250,
          "u - acute"
        ],
        [
          251,
          "u - circumflex"
        ],
        [
          252,
          "u - diaeresis"
        ],
        [
          363,
          "u - macron"
        ],
        [
          253,
          "y - acute"
        ],
        [
          254,
          "thorn"
        ],
        [
          255,
          "y - diaeresis"
        ],
        [
          563,
          "y - macron"
        ],
        [
          913,
          "Alpha"
        ],
        [
          914,
          "Beta"
        ],
        [
          915,
          "Gamma"
        ],
        [
          916,
          "Delta"
        ],
        [
          917,
          "Epsilon"
        ],
        [
          918,
          "Zeta"
        ],
        [
          919,
          "Eta"
        ],
        [
          920,
          "Theta"
        ],
        [
          921,
          "Iota"
        ],
        [
          922,
          "Kappa"
        ],
        [
          923,
          "Lambda"
        ],
        [
          924,
          "Mu"
        ],
        [
          925,
          "Nu"
        ],
        [
          926,
          "Xi"
        ],
        [
          927,
          "Omicron"
        ],
        [
          928,
          "Pi"
        ],
        [
          929,
          "Rho"
        ],
        [
          931,
          "Sigma"
        ],
        [
          932,
          "Tau"
        ],
        [
          933,
          "Upsilon"
        ],
        [
          934,
          "Phi"
        ],
        [
          935,
          "Chi"
        ],
        [
          936,
          "Psi"
        ],
        [
          937,
          "Omega"
        ],
        [
          945,
          "alpha"
        ],
        [
          946,
          "beta"
        ],
        [
          947,
          "gamma"
        ],
        [
          948,
          "delta"
        ],
        [
          949,
          "epsilon"
        ],
        [
          950,
          "zeta"
        ],
        [
          951,
          "eta"
        ],
        [
          952,
          "theta"
        ],
        [
          953,
          "iota"
        ],
        [
          954,
          "kappa"
        ],
        [
          955,
          "lambda"
        ],
        [
          956,
          "mu"
        ],
        [
          957,
          "nu"
        ],
        [
          958,
          "xi"
        ],
        [
          959,
          "omicron"
        ],
        [
          960,
          "pi"
        ],
        [
          961,
          "rho"
        ],
        [
          962,
          "final sigma"
        ],
        [
          963,
          "sigma"
        ],
        [
          964,
          "tau"
        ],
        [
          965,
          "upsilon"
        ],
        [
          966,
          "phi"
        ],
        [
          967,
          "chi"
        ],
        [
          968,
          "psi"
        ],
        [
          969,
          "omega"
        ]
      ]
    },
    {
      name: "Symbols",
      characters: [
        [
          8501,
          "alef symbol"
        ],
        [
          982,
          "pi symbol"
        ],
        [
          8476,
          "real part symbol"
        ],
        [
          978,
          "upsilon - hook symbol"
        ],
        [
          8472,
          "Weierstrass p"
        ],
        [
          8465,
          "imaginary part"
        ]
      ]
    },
    {
      name: "Arrows",
      characters: [
        [
          8592,
          "leftwards arrow"
        ],
        [
          8593,
          "upwards arrow"
        ],
        [
          8594,
          "rightwards arrow"
        ],
        [
          8595,
          "downwards arrow"
        ],
        [
          8596,
          "left right arrow"
        ],
        [
          8629,
          "carriage return"
        ],
        [
          8656,
          "leftwards double arrow"
        ],
        [
          8657,
          "upwards double arrow"
        ],
        [
          8658,
          "rightwards double arrow"
        ],
        [
          8659,
          "downwards double arrow"
        ],
        [
          8660,
          "left right double arrow"
        ],
        [
          8756,
          "therefore"
        ],
        [
          8834,
          "subset of"
        ],
        [
          8835,
          "superset of"
        ],
        [
          8836,
          "not a subset of"
        ],
        [
          8838,
          "subset of or equal to"
        ],
        [
          8839,
          "superset of or equal to"
        ],
        [
          8853,
          "circled plus"
        ],
        [
          8855,
          "circled times"
        ],
        [
          8869,
          "perpendicular"
        ],
        [
          8901,
          "dot operator"
        ],
        [
          8968,
          "left ceiling"
        ],
        [
          8969,
          "right ceiling"
        ],
        [
          8970,
          "left floor"
        ],
        [
          8971,
          "right floor"
        ],
        [
          9001,
          "left-pointing angle bracket"
        ],
        [
          9002,
          "right-pointing angle bracket"
        ],
        [
          9674,
          "lozenge"
        ],
        [
          9824,
          "black spade suit"
        ],
        [
          9827,
          "black club suit"
        ],
        [
          9829,
          "black heart suit"
        ],
        [
          9830,
          "black diamond suit"
        ],
        [
          8194,
          "en space"
        ],
        [
          8195,
          "em space"
        ],
        [
          8201,
          "thin space"
        ],
        [
          8204,
          "zero width non-joiner"
        ],
        [
          8205,
          "zero width joiner"
        ],
        [
          8206,
          "left-to-right mark"
        ],
        [
          8207,
          "right-to-left mark"
        ]
      ]
    }
  ], Se = (Ne) => oe.grep(Ne, (We) => wn(We) && We.length === 2), Qe = (Ne) => wn(Ne) ? Se(Ne) : typeof Ne == "function" ? Ne() : [], z = (Ne, We) => {
    const Ae = lt(Ne);
    Ae && (We = [{
      name: ft,
      characters: Qe(Ae)
    }]);
    const Oe = Q(Ne);
    if (Oe) {
      const ae = oe.grep(We, (X) => X.name === ft);
      return ae.length ? (ae[0].characters = [].concat(ae[0].characters).concat(Qe(Oe)), We) : We.concat({
        name: ft,
        characters: Qe(Oe)
      });
    }
    return We;
  }, Pe = (Ne) => {
    const We = z(Ne, Ot());
    return We.length > 1 ? [{
      name: "All",
      characters: Re(We, (Ae) => Ae.characters)
    }].concat(We) : We;
  }, Rt = (Ne) => ({
    getCharMap: () => Pe(Ne),
    insertChar: (Oe) => {
      Eo(Ne, Oe);
    }
  }), un = (Ne) => {
    let We = Ne;
    return {
      get: () => We,
      set: (ae) => {
        We = ae;
      }
    };
  }, Ct = (Ne, We) => {
    let Ae = null;
    const Oe = () => {
      $t(Ae) || (clearTimeout(Ae), Ae = null);
    };
    return {
      cancel: Oe,
      throttle: (...X) => {
        Oe(), Ae = setTimeout(() => {
          Ae = null, Ne.apply(null, X);
        }, We);
      }
    };
  }, _o = (Ne, We) => Ne.indexOf(We) !== -1, Fn = String.fromCodePoint, Sn = (Ne, We, Ae) => _o(Fn(Ne).toLowerCase(), Ae) ? !0 : _o(We.toLowerCase(), Ae) || _o(We.toLowerCase().replace(/\s+/g, ""), Ae), Dn = (Ne, We) => {
    const Ae = [], Oe = We.toLowerCase();
    return Ue(Ne.characters, (ae) => {
      Sn(ae[0], ae[1], Oe) && Ae.push(ae);
    }), He(Ae, (ae) => ({
      text: ae[1],
      value: Fn(ae[0]),
      icon: Fn(ae[0])
    }));
  }, Mn = "pattern", Xe = (Ne, We) => {
    const Ae = () => [
      {
        label: "Search",
        type: "input",
        name: Mn
      },
      {
        type: "collection",
        name: "results"
      }
    ], Oe = () => He(We, (fo) => ({
      title: fo.name,
      name: fo.name,
      items: Ae()
    })), ae = () => ({
      type: "panel",
      items: Ae()
    }), X = () => ({
      type: "tabpanel",
      tabs: Oe()
    }), je = We.length === 1 ? un(ft) : un("All"), ke = (fo, yn) => {
      dn(We, (ds) => ds.name === je.get()).each((ds) => {
        const Ho = Dn(ds, yn);
        fo.setData({ results: Ho });
      });
    }, ct = Ct((fo) => {
      const yn = fo.getData().pattern;
      ke(fo, yn);
    }, 40), Ht = We.length === 1 ? ae() : X(), vo = {
      pattern: "",
      results: Dn(We[0], "")
    }, Wn = {
      title: "Special Character",
      size: "normal",
      body: Ht,
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: vo,
      onAction: (fo, yn) => {
        yn.name === "results" && (Eo(Ne, yn.value), fo.close());
      },
      onTabChange: (fo, yn) => {
        je.set(yn.newTabName), ct.throttle(fo);
      },
      onChange: (fo, yn) => {
        yn.name === Mn && ct.throttle(fo);
      }
    };
    Ne.windowManager.open(Wn).focus(Mn);
  }, O = (Ne, We) => {
    Ne.addCommand("mceShowCharmap", () => {
      Xe(Ne, We);
    });
  }, gt = (Ne, We) => {
    Ne.ui.registry.addAutocompleter("charmap", {
      ch: ":",
      columns: "auto",
      minChars: 2,
      fetch: (Ae, Oe) => new Promise((ae, X) => {
        ae(Dn(We, Ae));
      }),
      onAction: (Ae, Oe, ae) => {
        Ne.selection.setRng(Oe), Ne.insertContent(ae), Ae.hide();
      }
    });
  }, en = (Ne) => {
    Ne.ui.registry.addButton("charmap", {
      icon: "insert-character",
      tooltip: "Special character",
      onAction: () => Ne.execCommand("mceShowCharmap")
    }), Ne.ui.registry.addMenuItem("charmap", {
      icon: "insert-character",
      text: "Special character...",
      onAction: () => Ne.execCommand("mceShowCharmap")
    });
  };
  var Pt = () => {
    ns.add("charmap", (Ne) => {
      rt(Ne);
      const We = Pe(Ne);
      return O(Ne, We), en(Ne), gt(Ne, We[0]), Rt(Ne);
    });
  };
  Pt();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager"), To = tinymce.util.Tools.resolve("tinymce.Env"), Eo = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const In = (mt) => (an) => an.options.get(mt), Jn = In("content_style"), uo = In("content_css_cors"), ho = In("body_class"), Kt = In("body_id"), Bt = (mt) => {
    var an;
    let Ge = "";
    const At = mt.dom.encode, He = (an = Jn(mt)) !== null && an !== void 0 ? an : "";
    Ge += '<base href="' + At(mt.documentBaseURI.getURI()) + '">';
    const Ue = uo(mt) ? ' crossorigin="anonymous"' : "";
    Eo.each(mt.contentCSS, (lt) => {
      Ge += '<link type="text/css" rel="stylesheet" href="' + At(mt.documentBaseURI.toAbsolute(lt)) + '"' + Ue + ">";
    }), He && (Ge += '<style type="text/css">' + He + "</style>");
    const ie = Kt(mt), dn = ho(mt), _t = To.os.isMacOS() || To.os.isiOS() ? "e.metaKey" : "e.ctrlKey && !e.altKey", Re = '<script>document.addEventListener && document.addEventListener("click", function(e) {for (var elm = e.target; elm; elm = elm.parentNode) {if (elm.nodeName === "A" && !(' + _t + ")) {e.preventDefault();}}}, false);<\/script> ", oe = mt.getBody().dir, Je = oe ? ' dir="' + At(oe) + '"' : "";
    return "<!DOCTYPE html><html><head>" + Ge + '</head><body id="' + At(ie) + '" class="mce-content-body ' + At(dn) + '"' + Je + ">" + mt.getContent() + Re + "</body></html>";
  }, $t = (mt) => {
    const an = Bt(mt);
    mt.windowManager.open({
      title: "Preview",
      size: "large",
      body: {
        type: "panel",
        items: [{
          name: "preview",
          type: "iframe",
          sandboxed: !0,
          transparent: !1
        }]
      },
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: { preview: an }
    }).focus("close");
  }, Un = (mt) => {
    mt.addCommand("mcePreview", () => {
      $t(mt);
    });
  }, Ao = (mt) => {
    const an = () => mt.execCommand("mcePreview");
    mt.ui.registry.addButton("preview", {
      icon: "preview",
      tooltip: "Preview",
      onAction: an
    }), mt.ui.registry.addMenuItem("preview", {
      icon: "preview",
      text: "Preview",
      onAction: an
    });
  };
  var tn = () => {
    ns.add("preview", (mt) => {
      Un(mt), Ao(mt);
    });
  };
  tn();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager"), To = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), Eo = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const In = (ft) => (Ot) => Ot.options.get(ft), Jn = (ft) => {
    const Ot = ft.options.register;
    Ot("allow_html_in_named_anchor", {
      processor: "boolean",
      default: !1
    });
  }, uo = In("allow_html_in_named_anchor"), ho = "a:not([href])", Kt = (ft) => !ft, Bt = (ft) => ft.getAttribute("id") || ft.getAttribute("name") || "", $t = (ft) => ft && ft.nodeName.toLowerCase() === "a", Un = (ft) => $t(ft) && !ft.getAttribute("href") && Bt(ft) !== "", Ao = (ft) => Un(ft) && !ft.firstChild, tn = (ft) => {
    const Ot = ft.dom;
    To(Ot).walk(ft.selection.getRng(), (Se) => {
      Eo.each(Se, (Qe) => {
        Ao(Qe) && Ot.remove(Qe, !1);
      });
    });
  }, mt = (ft) => /^[A-Za-z][A-Za-z0-9\-:._]*$/.test(ft), an = (ft) => ft.dom.getParent(ft.selection.getStart(), ho), Ge = (ft) => {
    const Ot = an(ft);
    return Ot ? Bt(Ot) : "";
  }, At = (ft, Ot) => {
    ft.undoManager.transact(() => {
      uo(ft) || ft.selection.collapse(!0), ft.selection.isCollapsed() ? ft.insertContent(ft.dom.createHTML("a", { id: Ot })) : (tn(ft), ft.formatter.remove("namedAnchor", null, null, !0), ft.formatter.apply("namedAnchor", { value: Ot }), ft.addVisual());
    });
  }, He = (ft, Ot, Se) => {
    Se.removeAttribute("name"), Se.id = Ot, ft.addVisual(), ft.undoManager.add();
  }, Ue = (ft, Ot) => {
    const Se = an(ft);
    Se ? He(ft, Ot, Se) : At(ft, Ot), ft.focus();
  }, ie = (ft, Ot) => mt(Ot) ? (Ue(ft, Ot), !0) : (ft.windowManager.alert("ID should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores."), !1), dn = (ft) => {
    const Ot = Ge(ft);
    ft.windowManager.open({
      title: "Anchor",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          name: "id",
          type: "input",
          label: "ID",
          placeholder: "example"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { id: Ot },
      onSubmit: (Se) => {
        ie(ft, Se.getData().id) && Se.close();
      }
    });
  }, _t = (ft) => {
    ft.addCommand("mceAnchor", () => {
      dn(ft);
    });
  }, Re = (ft) => ft && Kt(ft.attr("href")) && !Kt(ft.attr("id") || ft.attr("name")), oe = (ft) => Re(ft) && !ft.firstChild, Je = (ft) => (Ot) => {
    for (let Se = 0; Se < Ot.length; Se++) {
      const Qe = Ot[Se];
      oe(Qe) && Qe.attr("contenteditable", ft);
    }
  }, rt = (ft) => {
    ft.on("PreInit", () => {
      ft.parser.addNodeFilter("a", Je("false")), ft.serializer.addNodeFilter("a", Je(null));
    });
  }, lt = (ft) => {
    ft.formatter.register("namedAnchor", {
      inline: "a",
      selector: ho,
      remove: "all",
      split: !0,
      deep: !0,
      attributes: { id: "%value" },
      onmatch: (Ot, Se, Qe) => Un(Ot)
    });
  }, Q = (ft) => {
    ft.ui.registry.addToggleButton("anchor", {
      icon: "bookmark",
      tooltip: "Anchor",
      onAction: () => ft.execCommand("mceAnchor"),
      onSetup: (Ot) => ft.selection.selectorChangedWithUnbind("a:not([href])", Ot.setActive).unbind
    }), ft.ui.registry.addMenuItem("anchor", {
      icon: "bookmark",
      text: "Anchor...",
      onAction: () => ft.execCommand("mceAnchor")
    });
  };
  var wn = () => {
    ns.add("anchor", (ft) => {
      Jn(ft), rt(ft), _t(ft), Q(ft), ft.on("PreInit", () => {
        lt(ft);
      });
    });
  };
  wn();
})();
(function() {
  const ns = (se) => {
    let me = se;
    return {
      get: () => me,
      set: (zt) => {
        me = zt;
      }
    };
  };
  var To = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = (se, me, tt) => {
    var Lt;
    return tt(se, me.prototype) ? !0 : ((Lt = se.constructor) === null || Lt === void 0 ? void 0 : Lt.name) === me.name;
  }, In = (se) => {
    const me = typeof se;
    return se === null ? "null" : me === "object" && Array.isArray(se) ? "array" : me === "object" && Eo(se, String, (tt, Lt) => Lt.isPrototypeOf(tt)) ? "string" : me;
  }, Jn = (se) => (me) => In(me) === se, uo = (se) => (me) => typeof me === se, ho = Jn("string"), Kt = Jn("array"), Bt = uo("boolean"), $t = (se) => se == null, Un = (se) => !$t(se), Ao = uo("number"), tn = () => {
  }, mt = (se) => () => se, an = mt(!0), At = mt("[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]");
  class He {
    constructor(me, tt) {
      this.tag = me, this.value = tt;
    }
    static some(me) {
      return new He(!0, me);
    }
    static none() {
      return He.singletonNone;
    }
    fold(me, tt) {
      return this.tag ? tt(this.value) : me();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(me) {
      return this.tag ? He.some(me(this.value)) : He.none();
    }
    bind(me) {
      return this.tag ? me(this.value) : He.none();
    }
    exists(me) {
      return this.tag && me(this.value);
    }
    forall(me) {
      return !this.tag || me(this.value);
    }
    filter(me) {
      return !this.tag || me(this.value) ? this : He.none();
    }
    getOr(me) {
      return this.tag ? this.value : me;
    }
    or(me) {
      return this.tag ? this : me;
    }
    getOrThunk(me) {
      return this.tag ? this.value : me();
    }
    orThunk(me) {
      return this.tag ? this : me();
    }
    getOrDie(me) {
      if (this.tag)
        return this.value;
      throw new Error(me != null ? me : "Called getOrDie on None");
    }
    static from(me) {
      return Un(me) ? He.some(me) : He.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(me) {
      this.tag && me(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  He.singletonNone = new He(!1);
  const Ue = At;
  var ie = tinymce.util.Tools.resolve("tinymce.Env"), dn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const _t = Array.prototype.slice, Re = Array.prototype.push, oe = (se, me) => {
    const tt = se.length, Lt = new Array(tt);
    for (let zt = 0; zt < tt; zt++) {
      const Nt = se[zt];
      Lt[zt] = me(Nt, zt);
    }
    return Lt;
  }, Je = (se, me) => {
    for (let tt = 0, Lt = se.length; tt < Lt; tt++) {
      const zt = se[tt];
      me(zt, tt);
    }
  }, rt = (se, me) => {
    for (let tt = se.length - 1; tt >= 0; tt--) {
      const Lt = se[tt];
      me(Lt, tt);
    }
  }, lt = (se, me) => {
    if (se.length === 0)
      return [];
    {
      let tt = me(se[0]);
      const Lt = [];
      let zt = [];
      for (let Nt = 0, on = se.length; Nt < on; Nt++) {
        const Yt = se[Nt], On = me(Yt);
        On !== tt && (Lt.push(zt), zt = []), tt = On, zt.push(Yt);
      }
      return zt.length !== 0 && Lt.push(zt), Lt;
    }
  }, Q = (se, me, tt) => (Je(se, (Lt, zt) => {
    tt = me(tt, Lt, zt);
  }), tt), wn = (se) => {
    const me = [];
    for (let tt = 0, Lt = se.length; tt < Lt; ++tt) {
      if (!Kt(se[tt]))
        throw new Error("Arr.flatten item " + tt + " was not an array, input: " + se);
      Re.apply(me, se[tt]);
    }
    return me;
  }, ft = (se, me) => wn(oe(se, me)), Ot = (se, me) => {
    const tt = _t.call(se, 0);
    return tt.sort(me), tt;
  }, Se = Object.hasOwnProperty, Qe = (se, me) => Se.call(se, me);
  typeof window < "u" || Function("return this;")();
  const z = 9, Pe = 11, Rt = 1, un = 3, Ct = (se) => se.dom.nodeType, Fn = ((se) => (me) => Ct(me) === se)(un), Sn = (se, me, tt) => {
    if (ho(tt) || Bt(tt) || Ao(tt))
      se.setAttribute(me, tt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", me, ":: Value ", tt, ":: Element ", se), new Error("Attribute value was not simple");
  }, Dn = (se, me, tt) => {
    Sn(se.dom, me, tt);
  }, Mn = (se, me) => {
    const Lt = (me || document).createElement("div");
    if (Lt.innerHTML = se, !Lt.hasChildNodes() || Lt.childNodes.length > 1) {
      const zt = "HTML does not have a single root node";
      throw console.error(zt, se), new Error(zt);
    }
    return gt(Lt.childNodes[0]);
  }, Xe = (se, me) => {
    const Lt = (me || document).createElement(se);
    return gt(Lt);
  }, O = (se, me) => {
    const Lt = (me || document).createTextNode(se);
    return gt(Lt);
  }, gt = (se) => {
    if (se == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: se };
  }, Pt = {
    fromHtml: Mn,
    fromTag: Xe,
    fromText: O,
    fromDom: gt,
    fromPoint: (se, me, tt) => He.from(se.dom.elementFromPoint(me, tt)).map(gt)
  }, Ne = (se) => se.nodeType !== Rt && se.nodeType !== z && se.nodeType !== Pe || se.childElementCount === 0, We = (se, me) => {
    const tt = me === void 0 ? document : me.dom;
    return Ne(tt) ? [] : oe(tt.querySelectorAll(se), Pt.fromDom);
  }, Ae = (se) => He.from(se.dom.parentNode).map(Pt.fromDom), Oe = (se) => oe(se.dom.childNodes, Pt.fromDom), ae = (se, me) => ({
    element: se,
    offset: me
  }), X = (se, me) => {
    const tt = Oe(se);
    return tt.length > 0 && me < tt.length ? ae(tt[me], 0) : ae(se, me);
  }, je = (se, me) => {
    Ae(se).each((Lt) => {
      Lt.dom.insertBefore(me.dom, se.dom);
    });
  }, ke = (se, me) => {
    se.dom.appendChild(me.dom);
  }, ue = (se, me) => {
    je(se, me), ke(me, se);
  }, Ht = ((se, me) => {
    const tt = (Nt) => {
      if (!se(Nt))
        throw new Error("Can only get " + me + " value of a " + me + " node");
      return Lt(Nt).getOr("");
    }, Lt = (Nt) => se(Nt) ? He.from(Nt.dom.nodeValue) : He.none();
    return {
      get: tt,
      getOption: Lt,
      set: (Nt, on) => {
        if (!se(Nt))
          throw new Error("Can only set raw " + me + " value of a " + me + " node");
        Nt.dom.nodeValue = on;
      }
    };
  })(Fn, "text"), vo = (se) => Ht.get(se), Wn = (se, me, tt) => (se.compareDocumentPosition(me) & tt) !== 0, ko = (se, me) => Wn(se, me, Node.DOCUMENT_POSITION_PRECEDING), fo = (se, me) => We(me, se);
  var yn = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const ds = (se, me) => se.isBlock(me) || Qe(se.schema.getVoidElements(), me.nodeName), Ho = (se, me) => se.getContentEditable(me) === "false", mn = (se, me) => se.getContentEditable(me) === "true" && se.getContentEditableParent(me.parentNode) === "false", Io = (se, me) => !se.isBlock(me) && Qe(se.schema.getWhitespaceElements(), me.nodeName), ro = (se, me) => ds(se, me) || Ho(se, me) || Io(se, me) || mn(se, me), Ln = (se) => se.nodeType === 3, Go = () => ({
    sOffset: 0,
    fOffset: 0,
    elements: []
  }), Ro = (se, me) => X(Pt.fromDom(se), me), Os = (se, me, tt, Lt, zt, Nt = !0) => {
    let on = Nt ? me(!1) : tt;
    for (; on; ) {
      const Yt = Ho(se, on);
      if (Yt || Io(se, on)) {
        if (Yt ? Lt.cef(on) : Lt.boundary(on))
          break;
        on = me(!0);
        continue;
      } else if (ds(se, on)) {
        if (Lt.boundary(on))
          break;
      } else
        Ln(on) && Lt.text(on);
      if (on === zt)
        break;
      on = me(!1);
    }
  }, Qs = (se, me, tt, Lt, zt) => {
    if (ro(se, tt))
      return;
    const Nt = se.getParent(Lt, se.isBlock), on = new yn(tt, Nt), Yt = zt ? on.next.bind(on) : on.prev.bind(on);
    Os(se, Yt, tt, {
      boundary: an,
      cef: an,
      text: (On) => {
        zt ? me.fOffset += On.length : me.sOffset += On.length, me.elements.push(Pt.fromDom(On));
      }
    });
  }, we = (se, me, tt, Lt, zt, Nt = !0) => {
    const on = new yn(tt, me), Yt = [];
    let On = Go();
    Qs(se, On, tt, me, !1);
    const os = () => (On.elements.length > 0 && (Yt.push(On), On = Go()), !1);
    return Os(se, on.next.bind(on), tt, {
      boundary: os,
      cef: ($s) => (os(), zt && Yt.push(...zt.cef($s)), !1),
      text: ($s) => {
        On.elements.push(Pt.fromDom($s)), zt && zt.text($s, On);
      }
    }, Lt, Nt), Lt && Qs(se, On, Lt, me, !0), os(), Yt;
  }, $e = (se, me) => {
    const tt = Ro(me.startContainer, me.startOffset), Lt = tt.element.dom, zt = Ro(me.endContainer, me.endOffset), Nt = zt.element.dom;
    return we(se, me.commonAncestorContainer, Lt, Nt, {
      text: (on, Yt) => {
        on === Nt ? Yt.fOffset += on.length - zt.offset : on === Lt && (Yt.sOffset += tt.offset);
      },
      cef: (on) => {
        const Yt = ft(fo(Pt.fromDom(on), "*[contenteditable=true]"), (On) => {
          const os = On.dom;
          return we(se, os, os);
        });
        return Ot(Yt, (On, os) => ko(On.elements[0].dom, os.elements[0].dom) ? 1 : -1);
      }
    }, !1);
  }, Vt = (se, me) => me.collapsed ? [] : $e(se, me), Jt = (se, me) => {
    const tt = se.createRng();
    return tt.selectNode(me), Vt(se, tt);
  }, ht = (se, me) => ft(me, (tt) => Jt(se, tt)), qn = (se, me, tt = 0, Lt = se.length) => {
    const zt = me.regex;
    zt.lastIndex = tt;
    const Nt = [];
    let on;
    for (; on = zt.exec(se); ) {
      const Yt = on[me.matchIndex], On = on.index + on[0].indexOf(Yt), os = On + Yt.length;
      if (os > Lt)
        break;
      Nt.push({
        start: On,
        finish: os
      }), zt.lastIndex = os;
    }
    return Nt;
  }, pr = (se, me) => {
    const tt = Q(se, (Lt, zt) => {
      const Nt = vo(zt), on = Lt.last, Yt = on + Nt.length, On = ft(me, (os, $s) => os.start < Yt && os.finish > on ? [{
        element: zt,
        start: Math.max(on, os.start) - on,
        finish: Math.min(Yt, os.finish) - on,
        matchId: $s
      }] : []);
      return {
        results: Lt.results.concat(On),
        last: Yt
      };
    }, {
      results: [],
      last: 0
    }).results;
    return lt(tt, (Lt) => Lt.matchId);
  }, zr = (se, me) => ft(me, (tt) => {
    const Lt = tt.elements, zt = oe(Lt, vo).join(""), Nt = qn(zt, se, tt.sOffset, zt.length - tt.fOffset);
    return pr(Lt, Nt);
  }), Zs = (se, me) => {
    rt(se, (tt, Lt) => {
      rt(tt, (zt) => {
        const Nt = Pt.fromDom(me.cloneNode(!1));
        Dn(Nt, "data-mce-index", Lt);
        const on = zt.element.dom;
        if (on.length === zt.finish && zt.start === 0)
          ue(zt.element, Nt);
        else {
          on.length !== zt.finish && on.splitText(zt.finish);
          const Yt = on.splitText(zt.start);
          ue(Pt.fromDom(Yt), Nt);
        }
      });
    });
  }, hr = (se, me, tt, Lt) => {
    const zt = Jt(se, tt), Nt = zr(me, zt);
    return Zs(Nt, Lt), Nt.length;
  }, Fs = (se, me, tt, Lt) => {
    const zt = tt.getBookmark(), Nt = se.select("td[data-mce-selected],th[data-mce-selected]"), on = Nt.length > 0 ? ht(se, Nt) : Vt(se, tt.getRng()), Yt = zr(me, on);
    return Zs(Yt, Lt), tt.moveToBookmark(zt), Yt.length;
  }, Tr = (se) => {
    const me = se.getAttribute("data-mce-index");
    return typeof me == "number" ? "" + me : me;
  }, Xo = (se, me, tt, Lt) => {
    const zt = se.dom.create("span", { "data-mce-bogus": 1 });
    zt.className = "mce-match-marker";
    const Nt = se.getBody();
    return le(se, me, !1), Lt ? Fs(se.dom, tt, se.selection, zt) : hr(se.dom, tt, Nt, zt);
  }, Gn = (se) => {
    const me = se.parentNode;
    se.firstChild && me.insertBefore(se.firstChild, se), se.parentNode.removeChild(se);
  }, er = (se, me) => {
    const tt = [], Lt = dn.toArray(se.getBody().getElementsByTagName("span"));
    if (Lt.length)
      for (let zt = 0; zt < Lt.length; zt++) {
        const Nt = Tr(Lt[zt]);
        Nt === null || !Nt.length || Nt === me.toString() && tt.push(Lt[zt]);
      }
    return tt;
  }, Ss = (se, me, tt) => {
    const Lt = me.get();
    let zt = Lt.index;
    const Nt = se.dom;
    tt = tt !== !1, tt ? zt + 1 === Lt.count ? zt = 0 : zt++ : zt - 1 === -1 ? zt = Lt.count - 1 : zt--, Nt.removeClass(er(se, Lt.index), "mce-match-marker-selected");
    const on = er(se, zt);
    return on.length ? (Nt.addClass(er(se, zt), "mce-match-marker-selected"), se.selection.scrollIntoView(on[0]), zt) : -1;
  }, ir = (se, me) => {
    const tt = me.parentNode;
    se.remove(me), se.isEmpty(tt) && se.remove(tt);
  }, Ka = (se, me) => {
    const tt = se.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&").replace(/\s/g, "[^\\S\\r\\n\\uFEFF]"), Lt = "(" + tt + ")";
    return me ? `(?:^|\\s|${Ue()})` + Lt + `(?=$|\\s|${Ue()})` : Lt;
  }, Ra = (se, me, tt, Lt, zt, Nt) => {
    const on = se.selection, Yt = Ka(tt, zt), On = on.isForward(), os = {
      regex: new RegExp(Yt, Lt ? "g" : "gi"),
      matchIndex: 1
    }, $s = Xo(se, me, os, Nt);
    if (ie.browser.isSafari() && on.setRng(on.getRng(), On), $s) {
      const zo = Ss(se, me, !0);
      me.set({
        index: zo,
        count: $s,
        text: tt,
        matchCase: Lt,
        wholeWord: zt,
        inSelection: Nt
      });
    }
    return $s;
  }, Ur = (se, me) => {
    const tt = Ss(se, me, !0);
    me.set({
      ...me.get(),
      index: tt
    });
  }, rs = (se, me) => {
    const tt = Ss(se, me, !1);
    me.set({
      ...me.get(),
      index: tt
    });
  }, cc = (se) => {
    const me = Tr(se);
    return me !== null && me.length > 0;
  }, Z = (se, me, tt, Lt, zt) => {
    const Nt = me.get(), on = Nt.index;
    let Yt, On = on;
    Lt = Lt !== !1;
    const os = se.getBody(), $s = dn.grep(dn.toArray(os.getElementsByTagName("span")), cc);
    for (let zo = 0; zo < $s.length; zo++) {
      const Ya = Tr($s[zo]);
      let sa = Yt = parseInt(Ya, 10);
      if (zt || sa === Nt.index) {
        for (tt.length ? ($s[zo].firstChild.nodeValue = tt, Gn($s[zo])) : ir(se.dom, $s[zo]); $s[++zo]; )
          if (sa = parseInt(Tr($s[zo]), 10), sa === Yt)
            ir(se.dom, $s[zo]);
          else {
            zo--;
            break;
          }
        Lt && On--;
      } else
        Yt > on && $s[zo].setAttribute("data-mce-index", String(Yt - 1));
    }
    return me.set({
      ...Nt,
      count: zt ? 0 : Nt.count - 1,
      index: On
    }), Lt ? Ur(se, me) : rs(se, me), !zt && me.get().count > 0;
  }, le = (se, me, tt) => {
    let Lt, zt;
    const Nt = me.get(), on = dn.toArray(se.getBody().getElementsByTagName("span"));
    for (let Yt = 0; Yt < on.length; Yt++) {
      const On = Tr(on[Yt]);
      On !== null && On.length && (On === Nt.index.toString() && (Lt || (Lt = on[Yt].firstChild), zt = on[Yt].firstChild), Gn(on[Yt]));
    }
    if (me.set({
      ...Nt,
      index: -1,
      count: 0,
      text: ""
    }), Lt && zt) {
      const Yt = se.dom.createRng();
      return Yt.setStart(Lt, 0), Yt.setEnd(zt, zt.data.length), tt !== !1 && se.selection.setRng(Yt), Yt;
    }
  }, Ce = (se, me) => me.get().count > 1, wt = (se, me) => me.get().count > 1, Rn = (se, me) => ({
    done: (Yt) => le(se, me, Yt),
    find: (Yt, On, os, $s = !1) => Ra(se, me, Yt, On, os, $s),
    next: () => Ur(se, me),
    prev: () => rs(se, me),
    replace: (Yt, On, os) => Z(se, me, Yt, On, os)
  }), Ft = (se) => {
    const me = ns(He.none()), tt = () => me.get().each(se);
    return {
      clear: () => {
        tt(), me.set(He.none());
      },
      isSet: () => me.get().isSome(),
      get: () => me.get(),
      set: (Yt) => {
        tt(), me.set(He.some(Yt));
      }
    };
  }, Co = () => {
    const se = Ft(tn);
    return {
      ...se,
      on: (tt) => se.get().each(tt)
    };
  }, tr = (se, me) => {
    const tt = Co();
    se.undoManager.add();
    const Lt = dn.trim(se.selection.getContent({ format: "text" })), zt = (Bo) => {
      Bo.setEnabled("next", Ce(se, me)), Bo.setEnabled("prev", wt(se, me));
    }, Nt = (Bo) => {
      const fs = Bo.getData(), Lo = me.get();
      me.set({
        ...Lo,
        matchCase: fs.matchcase,
        wholeWord: fs.wholewords,
        inSelection: fs.inselection
      });
    }, on = (Bo, fs) => {
      Je([
        "replace",
        "replaceall",
        "prev",
        "next"
      ], (Er) => Bo.setEnabled(Er, !fs));
    }, Yt = (Bo) => {
      se.windowManager.alert("Could not find the specified string.", () => {
        Bo.focus("findtext");
      });
    }, On = (Bo, fs) => {
      ie.browser.isSafari() && ie.deviceType.isTouch() && (fs === "find" || fs === "replace" || fs === "replaceall") && Bo.focus(fs);
    }, os = (Bo) => {
      le(se, me, !1), on(Bo, !0), zt(Bo);
    }, $s = (Bo) => {
      const fs = Bo.getData(), Lo = me.get();
      if (!fs.findtext.length) {
        os(Bo);
        return;
      }
      if (Lo.text === fs.findtext && Lo.matchCase === fs.matchcase && Lo.wholeWord === fs.wholewords)
        Ur(se, me);
      else {
        const br = Ra(se, me, fs.findtext, fs.matchcase, fs.wholewords, fs.inselection);
        br <= 0 && Yt(Bo), on(Bo, br === 0);
      }
      zt(Bo);
    }, zo = me.get(), Ya = {
      findtext: Lt,
      replacetext: "",
      wholewords: zo.wholeWord,
      matchcase: zo.matchCase,
      inselection: zo.inSelection
    }, sa = {
      title: "Find and Replace",
      size: "normal",
      body: {
        type: "panel",
        items: [
          {
            type: "bar",
            items: [
              {
                type: "input",
                name: "findtext",
                placeholder: "Find",
                maximized: !0,
                inputMode: "search"
              },
              {
                type: "button",
                name: "prev",
                text: "Previous",
                icon: "action-prev",
                enabled: !1,
                borderless: !0
              },
              {
                type: "button",
                name: "next",
                text: "Next",
                icon: "action-next",
                enabled: !1,
                borderless: !0
              }
            ]
          },
          {
            type: "input",
            name: "replacetext",
            placeholder: "Replace with",
            inputMode: "search"
          }
        ]
      },
      buttons: [
        {
          type: "menu",
          name: "options",
          icon: "preferences",
          tooltip: "Preferences",
          align: "start",
          items: [
            {
              type: "togglemenuitem",
              name: "matchcase",
              text: "Match case"
            },
            {
              type: "togglemenuitem",
              name: "wholewords",
              text: "Find whole words only"
            },
            {
              type: "togglemenuitem",
              name: "inselection",
              text: "Find in selection"
            }
          ]
        },
        {
          type: "custom",
          name: "find",
          text: "Find",
          primary: !0
        },
        {
          type: "custom",
          name: "replace",
          text: "Replace",
          enabled: !1
        },
        {
          type: "custom",
          name: "replaceall",
          text: "Replace all",
          enabled: !1
        }
      ],
      initialData: Ya,
      onChange: (Bo, fs) => {
        fs.name === "findtext" && me.get().count > 0 && os(Bo);
      },
      onAction: (Bo, fs) => {
        const Lo = Bo.getData();
        switch (fs.name) {
          case "find":
            $s(Bo);
            break;
          case "replace":
            Z(se, me, Lo.replacetext) ? zt(Bo) : os(Bo);
            break;
          case "replaceall":
            Z(se, me, Lo.replacetext, !0, !0), os(Bo);
            break;
          case "prev":
            rs(se, me), zt(Bo);
            break;
          case "next":
            Ur(se, me), zt(Bo);
            break;
          case "matchcase":
          case "wholewords":
          case "inselection":
            Nt(Bo), os(Bo);
            break;
        }
        On(Bo, fs.name);
      },
      onSubmit: (Bo) => {
        $s(Bo), On(Bo, "find");
      },
      onClose: () => {
        se.focus(), le(se, me), se.undoManager.add();
      }
    };
    tt.set(se.windowManager.open(sa, { inline: "toolbar" }));
  }, Bn = (se, me) => {
    se.addCommand("SearchReplace", () => {
      tr(se, me);
    });
  }, No = (se, me) => () => {
    tr(se, me);
  }, yr = (se, me) => {
    se.ui.registry.addMenuItem("searchreplace", {
      text: "Find and replace...",
      shortcut: "Meta+F",
      onAction: No(se, me),
      icon: "search"
    }), se.ui.registry.addButton("searchreplace", {
      tooltip: "Find and replace",
      onAction: No(se, me),
      icon: "search"
    }), se.shortcuts.add("Meta+F", "", No(se, me));
  };
  var bt = () => {
    To.add("searchreplace", (se) => {
      const me = ns({
        index: -1,
        count: 0,
        text: "",
        matchCase: !1,
        wholeWord: !1,
        inSelection: !1
      });
      return Bn(se, me), yr(se, me), Rn(se, me);
    });
  };
  bt();
})();
(function() {
  const ns = (tn) => {
    let mt = tn;
    return {
      get: () => mt,
      set: (At) => {
        mt = At;
      }
    };
  };
  var To = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = (tn, mt) => {
    tn.dispatch("VisualBlocks", { state: mt });
  }, In = (tn, mt, an) => {
    tn.dom.toggleClass(tn.getBody(), "mce-visualblocks"), an.set(!an.get()), Eo(tn, an.get());
  }, Jn = (tn, mt, an) => {
    tn.addCommand("mceVisualBlocks", () => {
      In(tn, mt, an);
    });
  }, uo = (tn) => (mt) => mt.options.get(tn), ho = (tn) => {
    const mt = tn.options.register;
    mt("visualblocks_default_state", {
      processor: "boolean",
      default: !1
    });
  }, Kt = uo("visualblocks_default_state"), Bt = (tn, mt, an) => {
    tn.on("PreviewFormats AfterPreviewFormats", (Ge) => {
      an.get() && tn.dom.toggleClass(tn.getBody(), "mce-visualblocks", Ge.type === "afterpreviewformats");
    }), tn.on("init", () => {
      Kt(tn) && In(tn, mt, an);
    });
  }, $t = (tn, mt) => (an) => {
    an.setActive(mt.get());
    const Ge = (At) => an.setActive(At.state);
    return tn.on("VisualBlocks", Ge), () => tn.off("VisualBlocks", Ge);
  }, Un = (tn, mt) => {
    const an = () => tn.execCommand("mceVisualBlocks");
    tn.ui.registry.addToggleButton("visualblocks", {
      icon: "visualblocks",
      tooltip: "Show blocks",
      onAction: an,
      onSetup: $t(tn, mt)
    }), tn.ui.registry.addToggleMenuItem("visualblocks", {
      text: "Show blocks",
      icon: "visualblocks",
      onAction: an,
      onSetup: $t(tn, mt)
    });
  };
  var Ao = () => {
    To.add("visualblocks", (tn, mt) => {
      ho(tn);
      const an = ns(!1);
      Jn(tn, mt, an), Un(tn, an), Bt(tn, mt, an);
    });
  };
  Ao();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (Kt, Bt) => {
    Kt.focus(), Kt.undoManager.transact(() => {
      Kt.setContent(Bt);
    }), Kt.selection.setCursorLocation(), Kt.nodeChanged();
  }, Eo = (Kt) => Kt.getContent({ source_view: !0 }), In = (Kt) => {
    const Bt = Eo(Kt);
    Kt.windowManager.open({
      title: "Source Code",
      size: "large",
      body: {
        type: "panel",
        items: [{
          type: "textarea",
          name: "code"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { code: Bt },
      onSubmit: ($t) => {
        To(Kt, $t.getData().code), $t.close();
      }
    });
  }, Jn = (Kt) => {
    Kt.addCommand("mceCodeEditor", () => {
      In(Kt);
    });
  }, uo = (Kt) => {
    const Bt = () => Kt.execCommand("mceCodeEditor");
    Kt.ui.registry.addButton("code", {
      icon: "sourcecode",
      tooltip: "Source code",
      onAction: Bt
    }), Kt.ui.registry.addMenuItem("code", {
      icon: "sourcecode",
      text: "Source code",
      onAction: Bt
    });
  };
  var ho = () => {
    ns.add("code", (Kt) => (Jn(Kt), uo(Kt), {}));
  };
  ho();
})();
(function() {
  const ns = (G) => {
    let re = G;
    return {
      get: () => re,
      set: (bn) => {
        re = bn;
      }
    };
  };
  var To = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = (G) => ({ isFullscreen: () => G.get() !== null }), In = (G, re, Me) => {
    var Ye;
    return Me(G, re.prototype) ? !0 : ((Ye = G.constructor) === null || Ye === void 0 ? void 0 : Ye.name) === re.name;
  }, Jn = (G) => {
    const re = typeof G;
    return G === null ? "null" : re === "object" && Array.isArray(G) ? "array" : re === "object" && In(G, String, (Me, Ye) => Ye.isPrototypeOf(Me)) ? "string" : re;
  }, uo = (G) => (re) => Jn(re) === G, ho = (G) => (re) => typeof re === G, Kt = (G) => (re) => G === re, Bt = uo("string"), $t = uo("array"), Un = Kt(null), Ao = ho("boolean"), tn = (G) => G == null, mt = (G) => !tn(G), an = ho("function"), Ge = ho("number"), At = () => {
  }, He = (G, re) => (...Me) => G(re.apply(null, Me)), Ue = (G, re) => (Me) => G(re(Me)), ie = (G) => () => G;
  function dn(G, ...re) {
    return (...Me) => {
      const Ye = re.concat(Me);
      return G.apply(null, Ye);
    };
  }
  const _t = ie(!1), Re = ie(!0);
  class oe {
    constructor(re, Me) {
      this.tag = re, this.value = Me;
    }
    static some(re) {
      return new oe(!0, re);
    }
    static none() {
      return oe.singletonNone;
    }
    fold(re, Me) {
      return this.tag ? Me(this.value) : re();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(re) {
      return this.tag ? oe.some(re(this.value)) : oe.none();
    }
    bind(re) {
      return this.tag ? re(this.value) : oe.none();
    }
    exists(re) {
      return this.tag && re(this.value);
    }
    forall(re) {
      return !this.tag || re(this.value);
    }
    filter(re) {
      return !this.tag || re(this.value) ? this : oe.none();
    }
    getOr(re) {
      return this.tag ? this.value : re;
    }
    or(re) {
      return this.tag ? this : re;
    }
    getOrThunk(re) {
      return this.tag ? this.value : re();
    }
    orThunk(re) {
      return this.tag ? this : re();
    }
    getOrDie(re) {
      if (this.tag)
        return this.value;
      throw new Error(re != null ? re : "Called getOrDie on None");
    }
    static from(re) {
      return mt(re) ? oe.some(re) : oe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(re) {
      this.tag && re(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  oe.singletonNone = new oe(!1);
  const Je = (G) => {
    const re = ns(oe.none()), Me = () => re.get().each(G);
    return {
      clear: () => {
        Me(), re.set(oe.none());
      },
      isSet: () => re.get().isSome(),
      get: () => re.get(),
      set: (Xs) => {
        Me(), re.set(oe.some(Xs));
      }
    };
  }, rt = () => Je((G) => G.unbind()), lt = () => {
    const G = Je(At);
    return {
      ...G,
      on: (Me) => G.get().each(Me)
    };
  }, Q = (G, re) => {
    let Me = null;
    return {
      cancel: () => {
        Un(Me) || (clearTimeout(Me), Me = null);
      },
      throttle: (...An) => {
        Un(Me) && (Me = setTimeout(() => {
          Me = null, G.apply(null, An);
        }, re));
      }
    };
  }, wn = Array.prototype.push, ft = (G, re) => {
    const Me = G.length, Ye = new Array(Me);
    for (let bn = 0; bn < Me; bn++) {
      const An = G[bn];
      Ye[bn] = re(An, bn);
    }
    return Ye;
  }, Ot = (G, re) => {
    for (let Me = 0, Ye = G.length; Me < Ye; Me++) {
      const bn = G[Me];
      re(bn, Me);
    }
  }, Se = (G, re) => {
    const Me = [];
    for (let Ye = 0, bn = G.length; Ye < bn; Ye++) {
      const An = G[Ye];
      re(An, Ye) && Me.push(An);
    }
    return Me;
  }, Qe = (G, re, Me) => {
    for (let Ye = 0, bn = G.length; Ye < bn; Ye++) {
      const An = G[Ye];
      if (re(An, Ye))
        return oe.some(An);
      if (Me(An, Ye))
        break;
    }
    return oe.none();
  }, z = (G, re) => Qe(G, re, _t), Pe = (G) => {
    const re = [];
    for (let Me = 0, Ye = G.length; Me < Ye; ++Me) {
      if (!$t(G[Me]))
        throw new Error("Arr.flatten item " + Me + " was not an array, input: " + G);
      wn.apply(re, G[Me]);
    }
    return re;
  }, Rt = (G, re) => Pe(ft(G, re)), un = (G, re) => re >= 0 && re < G.length ? oe.some(G[re]) : oe.none(), Ct = (G) => un(G, 0), _o = (G, re) => {
    for (let Me = 0; Me < G.length; Me++) {
      const Ye = re(G[Me], Me);
      if (Ye.isSome())
        return Ye;
    }
    return oe.none();
  }, Fn = Object.keys, Sn = (G, re) => {
    const Me = Fn(G);
    for (let Ye = 0, bn = Me.length; Ye < bn; Ye++) {
      const An = Me[Ye], Wo = G[An];
      re(Wo, An);
    }
  }, Dn = (G, re) => G.indexOf(re) !== -1, Mn = (G) => G.style !== void 0 && an(G.style.getPropertyValue), Xe = (G, re) => {
    const Ye = (re || document).createElement("div");
    if (Ye.innerHTML = G, !Ye.hasChildNodes() || Ye.childNodes.length > 1) {
      const bn = "HTML does not have a single root node";
      throw console.error(bn, G), new Error(bn);
    }
    return en(Ye.childNodes[0]);
  }, O = (G, re) => {
    const Ye = (re || document).createElement(G);
    return en(Ye);
  }, gt = (G, re) => {
    const Ye = (re || document).createTextNode(G);
    return en(Ye);
  }, en = (G) => {
    if (G == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: G };
  }, Ne = {
    fromHtml: Xe,
    fromTag: O,
    fromText: gt,
    fromDom: en,
    fromPoint: (G, re, Me) => oe.from(G.dom.elementFromPoint(re, Me)).map(en)
  };
  typeof window < "u" || Function("return this;")();
  const We = 9, Ae = 11, Oe = 1, ae = 3, X = (G) => G.dom.nodeType, je = (G) => (re) => X(re) === G, ke = je(Oe), ue = je(ae), ct = je(We), Ht = je(Ae), vo = (G, re) => {
    const Me = G.dom;
    if (Me.nodeType !== Oe)
      return !1;
    {
      const Ye = Me;
      if (Ye.matches !== void 0)
        return Ye.matches(re);
      if (Ye.msMatchesSelector !== void 0)
        return Ye.msMatchesSelector(re);
      if (Ye.webkitMatchesSelector !== void 0)
        return Ye.webkitMatchesSelector(re);
      if (Ye.mozMatchesSelector !== void 0)
        return Ye.mozMatchesSelector(re);
      throw new Error("Browser lacks native selectors");
    }
  }, Wn = (G) => G.nodeType !== Oe && G.nodeType !== We && G.nodeType !== Ae || G.childElementCount === 0, ko = (G, re) => {
    const Me = re === void 0 ? document : re.dom;
    return Wn(Me) ? [] : ft(Me.querySelectorAll(G), Ne.fromDom);
  }, fo = (G, re) => G.dom === re.dom, yn = (G) => Ne.fromDom(G.dom.ownerDocument), ds = (G) => ct(G) ? G : yn(G), Ho = (G) => oe.from(G.dom.parentNode).map(Ne.fromDom), mn = (G, re) => {
    const Me = an(re) ? re : _t;
    let Ye = G.dom;
    const bn = [];
    for (; Ye.parentNode !== null && Ye.parentNode !== void 0; ) {
      const An = Ye.parentNode, Wo = Ne.fromDom(An);
      if (bn.push(Wo), Me(Wo) === !0)
        break;
      Ye = An;
    }
    return bn;
  }, Io = (G) => {
    const re = (Me) => Se(Me, (Ye) => !fo(G, Ye));
    return Ho(G).map(ro).map(re).getOr([]);
  }, ro = (G) => ft(G.dom.childNodes, Ne.fromDom), Ln = (G) => Ht(G) && mt(G.dom.host), Go = an(Element.prototype.attachShadow) && an(Node.prototype.getRootNode), Ro = ie(Go), Os = Go ? (G) => Ne.fromDom(G.dom.getRootNode()) : ds, Qs = (G) => {
    const re = Os(G);
    return Ln(re) ? oe.some(re) : oe.none();
  }, we = (G) => Ne.fromDom(G.dom.host), $e = (G) => {
    if (Ro() && mt(G.target)) {
      const re = Ne.fromDom(G.target);
      if (ke(re) && Vt(re) && G.composed && G.composedPath) {
        const Me = G.composedPath();
        if (Me)
          return Ct(Me);
      }
    }
    return oe.from(G.target);
  }, Vt = (G) => mt(G.dom.shadowRoot), Jt = (G) => {
    const re = ue(G) ? G.dom.parentNode : G.dom;
    if (re == null || re.ownerDocument === null)
      return !1;
    const Me = re.ownerDocument;
    return Qs(Ne.fromDom(re)).fold(() => Me.body.contains(re), Ue(Jt, we));
  }, ht = (G) => {
    const re = G.dom.body;
    if (re == null)
      throw new Error("Body is not available yet");
    return Ne.fromDom(re);
  }, qn = (G, re, Me) => {
    if (Bt(Me) || Ao(Me) || Ge(Me))
      G.setAttribute(re, Me + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", re, ":: Value ", Me, ":: Element ", G), new Error("Attribute value was not simple");
  }, pr = (G, re, Me) => {
    qn(G.dom, re, Me);
  }, zr = (G, re) => {
    const Me = G.dom.getAttribute(re);
    return Me === null ? void 0 : Me;
  }, Zs = (G, re) => {
    G.dom.removeAttribute(re);
  }, hr = (G, re, Me) => {
    if (!Bt(Me))
      throw console.error("Invalid call to CSS.set. Property ", re, ":: Value ", Me, ":: Element ", G), new Error("CSS value must be a string: " + Me);
    Mn(G) && G.style.setProperty(re, Me);
  }, Fs = (G, re) => {
    const Me = G.dom;
    Sn(re, (Ye, bn) => {
      hr(Me, bn, Ye);
    });
  }, Tr = (G, re) => {
    const Me = G.dom, bn = window.getComputedStyle(Me).getPropertyValue(re);
    return bn === "" && !Jt(G) ? Xo(Me, re) : bn;
  }, Xo = (G, re) => Mn(G) ? G.style.getPropertyValue(re) : "", Gn = (G, re, Me, Ye, bn, An, Wo) => ({
    target: G,
    x: re,
    y: Me,
    stop: Ye,
    prevent: bn,
    kill: An,
    raw: Wo
  }), er = (G) => {
    const re = Ne.fromDom($e(G).getOr(G.target)), Me = () => G.stopPropagation(), Ye = () => G.preventDefault(), bn = He(Ye, Me);
    return Gn(re, G.clientX, G.clientY, Me, Ye, bn, G);
  }, Ss = (G, re) => (Me) => {
    G(Me) && re(er(Me));
  }, ir = (G, re, Me, Ye, bn) => {
    const An = Ss(Me, Ye);
    return G.dom.addEventListener(re, An, bn), { unbind: dn(Ra, G, re, An, bn) };
  }, Ka = (G, re, Me, Ye) => ir(G, re, Me, Ye, !1), Ra = (G, re, Me, Ye) => {
    G.dom.removeEventListener(re, Me, Ye);
  }, Ur = Re, rs = (G, re, Me) => Ka(G, re, Ur, Me), cc = (G) => {
    let re = !1, Me;
    return (...Ye) => (re || (re = !0, Me = G.apply(null, Ye)), Me);
  }, Z = (G, re, Me, Ye) => {
    const bn = G.isiOS() && /ipad/i.test(Me) === !0, An = G.isiOS() && !bn, Wo = G.isiOS() || G.isAndroid(), Xs = Wo || Ye("(pointer:coarse)"), ic = bn || !An && Wo && Ye("(min-device-width:768px)"), Oo = An || Wo && !ic, Ps = re.isSafari() && G.isiOS() && /safari/i.test(Me) === !1, uc = !Oo && !ic && !Ps;
    return {
      isiPad: ie(bn),
      isiPhone: ie(An),
      isTablet: ie(ic),
      isPhone: ie(Oo),
      isTouch: ie(Xs),
      isAndroid: G.isAndroid,
      isiOS: G.isiOS,
      isWebView: ie(Ps),
      isDesktop: ie(uc)
    };
  }, le = (G, re) => {
    for (let Me = 0; Me < G.length; Me++) {
      const Ye = G[Me];
      if (Ye.test(re))
        return Ye;
    }
  }, Ce = (G, re) => {
    const Me = le(G, re);
    if (!Me)
      return {
        major: 0,
        minor: 0
      };
    const Ye = (bn) => Number(re.replace(Me, "$" + bn));
    return Ft(Ye(1), Ye(2));
  }, wt = (G, re) => {
    const Me = String(re).toLowerCase();
    return G.length === 0 ? Rn() : Ce(G, Me);
  }, Rn = () => Ft(0, 0), Ft = (G, re) => ({
    major: G,
    minor: re
  }), Co = {
    nu: Ft,
    detect: wt,
    unknown: Rn
  }, tr = (G, re) => _o(re.brands, (Me) => {
    const Ye = Me.brand.toLowerCase();
    return z(G, (bn) => {
      var An;
      return Ye === ((An = bn.brand) === null || An === void 0 ? void 0 : An.toLowerCase());
    }).map((bn) => ({
      current: bn.name,
      version: Co.nu(parseInt(Me.version, 10), 0)
    }));
  }), Bn = (G, re) => {
    const Me = String(re).toLowerCase();
    return z(G, (Ye) => Ye.search(Me));
  }, No = (G, re) => Bn(G, re).map((Me) => {
    const Ye = Co.detect(Me.versionRegexes, re);
    return {
      current: Me.name,
      version: Ye
    };
  }), yr = (G, re) => Bn(G, re).map((Me) => {
    const Ye = Co.detect(Me.versionRegexes, re);
    return {
      current: Me.name,
      version: Ye
    };
  }), bt = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, se = (G) => (re) => Dn(re, G), me = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (G) => Dn(G, "edge/") && Dn(G, "chrome") && Dn(G, "safari") && Dn(G, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        bt
      ],
      search: (G) => Dn(G, "chrome") && !Dn(G, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (G) => Dn(G, "msie") || Dn(G, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        bt,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: se("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: se("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        bt,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (G) => (Dn(G, "safari") || Dn(G, "mobile/")) && Dn(G, "applewebkit")
    }
  ], tt = [
    {
      name: "Windows",
      search: se("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (G) => Dn(G, "iphone") || Dn(G, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: se("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: se("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: se("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: se("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: se("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: se("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Lt = {
    browsers: ie(me),
    oses: ie(tt)
  }, zt = "Edge", Nt = "Chromium", on = "IE", Yt = "Opera", On = "Firefox", os = "Safari", $s = () => zo({
    current: void 0,
    version: Co.unknown()
  }), zo = (G) => {
    const re = G.current, Me = G.version, Ye = (bn) => () => re === bn;
    return {
      current: re,
      version: Me,
      isEdge: Ye(zt),
      isChromium: Ye(Nt),
      isIE: Ye(on),
      isOpera: Ye(Yt),
      isFirefox: Ye(On),
      isSafari: Ye(os)
    };
  }, Ya = {
    unknown: $s,
    nu: zo,
    edge: ie(zt),
    chromium: ie(Nt),
    ie: ie(on),
    opera: ie(Yt),
    firefox: ie(On),
    safari: ie(os)
  }, sa = "Windows", Bo = "iOS", fs = "Android", Lo = "Linux", br = "macOS", Er = "Solaris", ra = "FreeBSD", nl = "ChromeOS", pa = () => Wr({
    current: void 0,
    version: Co.unknown()
  }), Wr = (G) => {
    const re = G.current, Me = G.version, Ye = (bn) => () => re === bn;
    return {
      current: re,
      version: Me,
      isWindows: Ye(sa),
      isiOS: Ye(Bo),
      isAndroid: Ye(fs),
      isMacOS: Ye(br),
      isLinux: Ye(Lo),
      isSolaris: Ye(Er),
      isFreeBSD: Ye(ra),
      isChromeOS: Ye(nl)
    };
  }, Ma = {
    unknown: pa,
    nu: Wr,
    windows: ie(sa),
    ios: ie(Bo),
    android: ie(fs),
    linux: ie(Lo),
    macos: ie(br),
    solaris: ie(Er),
    freebsd: ie(ra),
    chromeos: ie(nl)
  }, ol = { detect: (G, re, Me) => {
    const Ye = Lt.browsers(), bn = Lt.oses(), An = re.bind((ic) => tr(Ye, ic)).orThunk(() => No(Ye, G)).fold(Ya.unknown, Ya.nu), Wo = yr(bn, G).fold(Ma.unknown, Ma.nu), Xs = Z(Wo, An, G, Me);
    return {
      browser: An,
      os: Wo,
      deviceType: Xs
    };
  } }, aa = (G) => window.matchMedia(G).matches;
  let Xa = cc(() => ol.detect(navigator.userAgent, oe.from(navigator.userAgentData), aa));
  const kl = () => Xa(), Ja = (G, re) => ({
    left: G,
    top: re,
    translate: (Ye, bn) => Ja(G + Ye, re + bn)
  }), li = Ja, Qa = (G) => {
    const re = G !== void 0 ? G.dom : document, Me = re.body.scrollLeft || re.documentElement.scrollLeft, Ye = re.body.scrollTop || re.documentElement.scrollTop;
    return li(Me, Ye);
  }, Fc = (G) => {
    const re = G === void 0 ? window : G;
    return kl().browser.isFirefox() ? oe.none() : oe.from(re.visualViewport);
  }, Hl = (G, re, Me, Ye) => ({
    x: G,
    y: re,
    width: Me,
    height: Ye,
    right: G + Me,
    bottom: re + Ye
  }), or = (G) => {
    const re = G === void 0 ? window : G, Me = re.document, Ye = Qa(Ne.fromDom(Me));
    return Fc(re).fold(() => {
      const bn = re.document.documentElement, An = bn.clientWidth, Wo = bn.clientHeight;
      return Hl(Ye.left, Ye.top, An, Wo);
    }, (bn) => Hl(Math.max(bn.pageLeft, Ye.left), Math.max(bn.pageTop, Ye.top), bn.width, bn.height));
  }, U = (G, re, Me) => Fc(Me).map((Ye) => {
    const bn = (An) => re(er(An));
    return Ye.addEventListener(G, bn), { unbind: () => Ye.removeEventListener(G, bn) };
  }).getOrThunk(() => ({ unbind: At }));
  var fe = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), _e = tinymce.util.Tools.resolve("tinymce.Env");
  const nt = (G, re) => {
    G.dispatch("FullscreenStateChanged", { state: re }), G.dispatch("ResizeEditor");
  }, Et = (G) => (re) => re.options.get(G), So = (G) => {
    const re = G.options.register;
    re("fullscreen_native", {
      processor: "boolean",
      default: !1
    });
  }, Ko = Et("fullscreen_native"), js = (G) => {
    const re = Ne.fromDom(G.getElement());
    return Qs(re).map(we).getOrThunk(() => ht(yn(re)));
  }, Ns = (G) => G.fullscreenElement !== void 0 ? G.fullscreenElement : G.msFullscreenElement !== void 0 ? G.msFullscreenElement : G.webkitFullscreenElement !== void 0 ? G.webkitFullscreenElement : null, Jr = () => document.fullscreenElement !== void 0 ? "fullscreenchange" : document.msFullscreenElement !== void 0 ? "MSFullscreenChange" : document.webkitFullscreenElement !== void 0 ? "webkitfullscreenchange" : "fullscreenchange", to = (G) => {
    const re = G.dom;
    re.requestFullscreen ? re.requestFullscreen() : re.msRequestFullscreen ? re.msRequestFullscreen() : re.webkitRequestFullScreen && re.webkitRequestFullScreen();
  }, Ic = (G) => {
    const re = G.dom;
    re.exitFullscreen ? re.exitFullscreen() : re.msExitFullscreen ? re.msExitFullscreen() : re.webkitCancelFullScreen && re.webkitCancelFullScreen();
  }, Vo = (G) => G.dom === Ns(yn(G).dom), ha = (G, re, Me) => Se(mn(G, Me), re), Vl = (G, re) => Se(Io(G), re), nr = (G) => ko(G), ca = (G, re, Me) => ha(G, (Ye) => vo(Ye, re), Me), lc = (G, re) => Vl(G, (Me) => vo(Me, re)), Lc = "data-ephox-mobile-fullscreen-style", Qt = "display:none!important;", Zr = "position:absolute!important;", wl = "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;", qr = "background-color:rgb(255,255,255)!important;", B = _e.os.isAndroid(), j = (G) => {
    const re = Tr(G, "background-color");
    return re !== void 0 && re !== "" ? "background-color:" + re + "!important" : qr;
  }, ce = (G, re, Me) => {
    const Ye = (Oo) => lc(Oo, "*:not(.tox-silver-sink)"), bn = (Oo) => (Ps) => {
      const uc = zr(Ps, "style"), dc = uc === void 0 ? "no-styles" : uc.trim();
      dc !== Oo && (pr(Ps, Lc, dc), Fs(Ps, G.parseStyle(Oo)));
    }, An = ca(re, "*"), Wo = Rt(An, Ye), Xs = j(Me);
    Ot(Wo, bn(Qt)), Ot(An, bn(Zr + wl + Xs)), bn((B === !0 ? "" : Zr) + wl + Xs)(re);
  }, Fe = (G) => {
    const re = nr("[" + Lc + "]");
    Ot(re, (Me) => {
      const Ye = zr(Me, Lc);
      Ye !== "no-styles" ? Fs(Me, G.parseStyle(Ye)) : Zs(Me, "style"), Zs(Me, Lc);
    });
  }, Dt = fe.DOM, $o = () => or(window), Jo = (G) => window.scrollTo(G.x, G.y), it = Fc().fold(() => ({
    bind: At,
    unbind: At
  }), (G) => {
    const re = lt(), Me = rt(), Ye = rt(), bn = () => {
      document.body.scrollTop = 0, document.documentElement.scrollTop = 0;
    }, An = () => {
      window.requestAnimationFrame(() => {
        re.on((Oo) => Fs(Oo, {
          top: G.offsetTop + "px",
          left: G.offsetLeft + "px",
          height: G.height + "px",
          width: G.width + "px"
        }));
      });
    }, Wo = Q(() => {
      bn(), An();
    }, 50);
    return {
      bind: (Oo) => {
        re.set(Oo), Wo.throttle(), Me.set(U("resize", Wo.throttle)), Ye.set(U("scroll", Wo.throttle));
      },
      unbind: () => {
        re.on(() => {
          Me.clear(), Ye.clear();
        }), re.clear();
      }
    };
  }), hs = (G, re) => {
    const Me = document.body, Ye = document.documentElement, bn = G.getContainer(), An = Ne.fromDom(bn), Wo = js(G), Xs = re.get(), ic = Ne.fromDom(G.getBody()), Oo = _e.deviceType.isTouch(), Ps = bn.style, dc = G.iframeElement.style, su = (ms) => {
      ms(Me, "tox-fullscreen"), ms(Ye, "tox-fullscreen"), ms(bn, "tox-fullscreen"), Qs(An).map((ur) => we(ur).dom).each((ur) => {
        ms(ur, "tox-fullscreen"), ms(ur, "tox-shadowhost");
      });
    }, fc = () => {
      Oo && Fe(G.dom), su(Dt.removeClass), it.unbind(), oe.from(re.get()).each((ms) => ms.fullscreenChangeHandler.unbind());
    };
    if (Xs)
      Xs.fullscreenChangeHandler.unbind(), Ko(G) && Vo(Wo) && Ic(yn(Wo)), dc.width = Xs.iframeWidth, dc.height = Xs.iframeHeight, Ps.width = Xs.containerWidth, Ps.height = Xs.containerHeight, Ps.top = Xs.containerTop, Ps.left = Xs.containerLeft, fc(), Jo(Xs.scrollPos), re.set(null), nt(G, !1), G.off("remove", fc);
    else {
      const ms = rs(yn(Wo), Jr(), (Na) => {
        Ko(G) && !Vo(Wo) && re.get() !== null && hs(G, re);
      }), ur = {
        scrollPos: $o(),
        containerWidth: Ps.width,
        containerHeight: Ps.height,
        containerTop: Ps.top,
        containerLeft: Ps.left,
        iframeWidth: dc.width,
        iframeHeight: dc.height,
        fullscreenChangeHandler: ms
      };
      Oo && ce(G.dom, An, ic), dc.width = dc.height = "100%", Ps.width = Ps.height = "", su(Dt.addClass), it.bind(An), G.on("remove", fc), re.set(ur), Ko(G) && to(Wo), nt(G, !0);
    }
  }, Ca = (G, re) => {
    G.addCommand("mceFullScreen", () => {
      hs(G, re);
    });
  }, qs = (G, re) => (Me) => {
    Me.setActive(re.get() !== null);
    const Ye = (bn) => Me.setActive(bn.state);
    return G.on("FullscreenStateChanged", Ye), () => G.off("FullscreenStateChanged", Ye);
  }, Hc = (G, re) => {
    const Me = () => G.execCommand("mceFullScreen");
    G.ui.registry.addToggleMenuItem("fullscreen", {
      text: "Fullscreen",
      icon: "fullscreen",
      shortcut: "Meta+Shift+F",
      onAction: Me,
      onSetup: qs(G, re)
    }), G.ui.registry.addToggleButton("fullscreen", {
      tooltip: "Fullscreen",
      icon: "fullscreen",
      onAction: Me,
      onSetup: qs(G, re)
    });
  };
  var as = () => {
    To.add("fullscreen", (G) => {
      const re = ns(null);
      return G.inline || (So(G), Ca(G, re), Hc(G, re), G.addShortcut("Meta+Shift+F", "", "mceFullScreen")), Eo(re);
    });
  };
  as();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (_t) => (Re) => Re.options.get(_t), Eo = (_t) => {
    const Re = _t.options.register;
    Re("insertdatetime_dateformat", {
      processor: "string",
      default: _t.translate("%Y-%m-%d")
    }), Re("insertdatetime_timeformat", {
      processor: "string",
      default: _t.translate("%H:%M:%S")
    }), Re("insertdatetime_formats", {
      processor: "string[]",
      default: [
        "%H:%M:%S",
        "%Y-%m-%d",
        "%I:%M:%S %p",
        "%D"
      ]
    }), Re("insertdatetime_element", {
      processor: "boolean",
      default: !1
    });
  }, In = To("insertdatetime_dateformat"), Jn = To("insertdatetime_timeformat"), uo = To("insertdatetime_formats"), ho = To("insertdatetime_element"), Kt = (_t) => {
    const Re = uo(_t);
    return Re.length > 0 ? Re[0] : Jn(_t);
  }, Bt = "Sun Mon Tue Wed Thu Fri Sat Sun".split(" "), $t = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" "), Un = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), Ao = "January February March April May June July August September October November December".split(" "), tn = (_t, Re) => {
    if (_t = "" + _t, _t.length < Re)
      for (let oe = 0; oe < Re - _t.length; oe++)
        _t = "0" + _t;
    return _t;
  }, mt = (_t, Re, oe = new Date()) => (Re = Re.replace("%D", "%m/%d/%Y"), Re = Re.replace("%r", "%I:%M:%S %p"), Re = Re.replace("%Y", "" + oe.getFullYear()), Re = Re.replace("%y", "" + oe.getYear()), Re = Re.replace("%m", tn(oe.getMonth() + 1, 2)), Re = Re.replace("%d", tn(oe.getDate(), 2)), Re = Re.replace("%H", "" + tn(oe.getHours(), 2)), Re = Re.replace("%M", "" + tn(oe.getMinutes(), 2)), Re = Re.replace("%S", "" + tn(oe.getSeconds(), 2)), Re = Re.replace("%I", "" + ((oe.getHours() + 11) % 12 + 1)), Re = Re.replace("%p", oe.getHours() < 12 ? "AM" : "PM"), Re = Re.replace("%B", "" + _t.translate(Ao[oe.getMonth()])), Re = Re.replace("%b", "" + _t.translate(Un[oe.getMonth()])), Re = Re.replace("%A", "" + _t.translate($t[oe.getDay()])), Re = Re.replace("%a", "" + _t.translate(Bt[oe.getDay()])), Re = Re.replace("%%", "%"), Re), an = (_t, Re, oe, Je) => {
    const rt = _t.dom.create("time", { datetime: oe }, Je);
    Re.parentNode.insertBefore(rt, Re), _t.dom.remove(Re), _t.selection.select(rt, !0), _t.selection.collapse(!1);
  }, Ge = (_t, Re) => {
    if (ho(_t)) {
      const oe = mt(_t, Re);
      let Je;
      /%[HMSIp]/.test(Re) ? Je = mt(_t, "%Y-%m-%dT%H:%M") : Je = mt(_t, "%Y-%m-%d");
      const rt = _t.dom.getParent(_t.selection.getStart(), "time");
      rt ? an(_t, rt, Je, oe) : _t.insertContent('<time datetime="' + Je + '">' + oe + "</time>");
    } else
      _t.insertContent(mt(_t, Re));
  }, At = (_t) => {
    _t.addCommand("mceInsertDate", (Re, oe) => {
      Ge(_t, oe != null ? oe : In(_t));
    }), _t.addCommand("mceInsertTime", (Re, oe) => {
      Ge(_t, oe != null ? oe : Jn(_t));
    });
  }, He = (_t) => {
    let Re = _t;
    return {
      get: () => Re,
      set: (rt) => {
        Re = rt;
      }
    };
  };
  var Ue = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const ie = (_t) => {
    const Re = uo(_t), oe = He(Kt(_t)), Je = (lt) => _t.execCommand("mceInsertDate", !1, lt);
    _t.ui.registry.addSplitButton("insertdatetime", {
      icon: "insert-time",
      tooltip: "Insert date/time",
      select: (lt) => lt === oe.get(),
      fetch: (lt) => {
        lt(Ue.map(Re, (Q) => ({
          type: "choiceitem",
          text: mt(_t, Q),
          value: Q
        })));
      },
      onAction: (lt) => {
        Je(oe.get());
      },
      onItemAction: (lt, Q) => {
        oe.set(Q), Je(Q);
      }
    });
    const rt = (lt) => () => {
      oe.set(lt), Je(lt);
    };
    _t.ui.registry.addNestedMenuItem("insertdatetime", {
      icon: "insert-time",
      text: "Date/time",
      getSubmenuItems: () => Ue.map(Re, (lt) => ({
        type: "menuitem",
        text: mt(_t, lt),
        onAction: rt(lt)
      }))
    });
  };
  var dn = () => {
    ns.add("insertdatetime", (_t) => {
      Eo(_t), At(_t), ie(_t);
    });
  };
  dn();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (Z, le, Ce) => {
    var wt;
    return Ce(Z, le.prototype) ? !0 : ((wt = Z.constructor) === null || wt === void 0 ? void 0 : wt.name) === le.name;
  }, Eo = (Z) => {
    const le = typeof Z;
    return Z === null ? "null" : le === "object" && Array.isArray(Z) ? "array" : le === "object" && To(Z, String, (Ce, wt) => wt.isPrototypeOf(Ce)) ? "string" : le;
  }, In = (Z) => (le) => Eo(le) === Z, Jn = In("string"), uo = In("object"), ho = In("array"), Kt = (Z) => Z == null, Bt = (Z) => !Kt(Z);
  class $t {
    constructor(le, Ce) {
      this.tag = le, this.value = Ce;
    }
    static some(le) {
      return new $t(!0, le);
    }
    static none() {
      return $t.singletonNone;
    }
    fold(le, Ce) {
      return this.tag ? Ce(this.value) : le();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(le) {
      return this.tag ? $t.some(le(this.value)) : $t.none();
    }
    bind(le) {
      return this.tag ? le(this.value) : $t.none();
    }
    exists(le) {
      return this.tag && le(this.value);
    }
    forall(le) {
      return !this.tag || le(this.value);
    }
    filter(le) {
      return !this.tag || le(this.value) ? this : $t.none();
    }
    getOr(le) {
      return this.tag ? this.value : le;
    }
    or(le) {
      return this.tag ? this : le;
    }
    getOrThunk(le) {
      return this.tag ? this.value : le();
    }
    orThunk(le) {
      return this.tag ? this : le();
    }
    getOrDie(le) {
      if (this.tag)
        return this.value;
      throw new Error(le != null ? le : "Called getOrDie on None");
    }
    static from(le) {
      return Bt(le) ? $t.some(le) : $t.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(le) {
      this.tag && le(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  $t.singletonNone = new $t(!1);
  const Un = Array.prototype.push, Ao = (Z, le) => {
    for (let Ce = 0, wt = Z.length; Ce < wt; Ce++) {
      const Rn = Z[Ce];
      le(Rn, Ce);
    }
  }, tn = (Z) => {
    const le = [];
    for (let Ce = 0, wt = Z.length; Ce < wt; ++Ce) {
      if (!ho(Z[Ce]))
        throw new Error("Arr.flatten item " + Ce + " was not an array, input: " + Z);
      Un.apply(le, Z[Ce]);
    }
    return le;
  }, mt = (Z) => {
    let le = Z;
    return {
      get: () => le,
      set: (Rn) => {
        le = Rn;
      }
    };
  }, an = Object.keys, Ge = Object.hasOwnProperty, At = (Z, le) => {
    const Ce = an(Z);
    for (let wt = 0, Rn = Ce.length; wt < Rn; wt++) {
      const Ft = Ce[wt], Co = Z[Ft];
      le(Co, Ft);
    }
  }, He = (Z, le) => Ue(Z, le) ? $t.from(Z[le]) : $t.none(), Ue = (Z, le) => Ge.call(Z, le), ie = (Z) => (le) => le.options.get(Z), dn = (Z) => {
    const le = Z.options.register;
    le("audio_template_callback", { processor: "function" }), le("video_template_callback", { processor: "function" }), le("iframe_template_callback", { processor: "function" }), le("media_live_embeds", {
      processor: "boolean",
      default: !0
    }), le("media_filter_html", {
      processor: "boolean",
      default: !0
    }), le("media_url_resolver", { processor: "function" }), le("media_alt_source", {
      processor: "boolean",
      default: !0
    }), le("media_poster", {
      processor: "boolean",
      default: !0
    }), le("media_dimensions", {
      processor: "boolean",
      default: !0
    });
  }, _t = ie("audio_template_callback"), Re = ie("video_template_callback"), oe = ie("iframe_template_callback"), Je = ie("media_live_embeds"), rt = ie("media_filter_html"), lt = ie("media_url_resolver"), Q = ie("media_alt_source"), wn = ie("media_poster"), ft = ie("media_dimensions");
  var Ot = tinymce.util.Tools.resolve("tinymce.util.Tools"), Se = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Qe = tinymce.util.Tools.resolve("tinymce.html.DomParser");
  const z = Se.DOM, Pe = (Z) => Z.replace(/px$/, ""), Rt = (Z) => {
    const le = Z.attr("style"), Ce = le ? z.parseStyle(le) : {};
    return {
      type: "ephox-embed-iri",
      source: Z.attr("data-ephox-embed-iri"),
      altsource: "",
      poster: "",
      width: He(Ce, "max-width").map(Pe).getOr(""),
      height: He(Ce, "max-height").map(Pe).getOr("")
    };
  }, un = (Z, le) => {
    let Ce = {};
    const Rn = Qe({
      validate: !1,
      forced_root_block: !1
    }, le).parse(Z);
    for (let Ft = Rn; Ft; Ft = Ft.walk())
      if (Ft.type === 1) {
        const Co = Ft.name;
        if (Ft.attr("data-ephox-embed-iri")) {
          Ce = Rt(Ft);
          break;
        } else
          !Ce.source && Co === "param" && (Ce.source = Ft.attr("movie")), (Co === "iframe" || Co === "object" || Co === "embed" || Co === "video" || Co === "audio") && (Ce.type || (Ce.type = Co), Ce = Ot.extend(Ft.attributes.map, Ce)), Co === "script" && (Ce = {
            type: "script",
            source: Ft.attr("src")
          }), Co === "source" && (Ce.source ? Ce.altsource || (Ce.altsource = Ft.attr("src")) : Ce.source = Ft.attr("src")), Co === "img" && !Ce.poster && (Ce.poster = Ft.attr("src"));
      }
    return Ce.source = Ce.source || Ce.src || Ce.data, Ce.altsource = Ce.altsource || "", Ce.poster = Ce.poster || "", Ce;
  }, Ct = (Z) => {
    const le = {
      mp3: "audio/mpeg",
      m4a: "audio/x-m4a",
      wav: "audio/wav",
      mp4: "video/mp4",
      webm: "video/webm",
      ogg: "video/ogg",
      swf: "application/x-shockwave-flash"
    }, Ce = Z.toLowerCase().split(".").pop(), wt = le[Ce];
    return wt || "";
  };
  var _o = tinymce.util.Tools.resolve("tinymce.html.Node"), Fn = tinymce.util.Tools.resolve("tinymce.html.Serializer");
  const Sn = (Z, le = {}) => Qe({
    forced_root_block: !1,
    validate: !1,
    allow_conditional_comments: !0,
    ...le
  }, Z), Dn = Se.DOM, Mn = (Z) => /^[0-9.]+$/.test(Z) ? Z + "px" : Z, Xe = (Z, le) => {
    const Ce = le.attr("style"), wt = Ce ? Dn.parseStyle(Ce) : {};
    wt["max-width"] = Mn(Z.width), wt["max-height"] = Mn(Z.height), le.attr("style", Dn.serializeStyle(wt));
  }, O = [
    "source",
    "altsource"
  ], gt = (Z, le, Ce, wt) => {
    let Rn = 0, Ft = 0;
    const Co = Sn(wt);
    Co.addNodeFilter("source", (Bn) => Rn = Bn.length);
    const tr = Co.parse(Z);
    for (let Bn = tr; Bn; Bn = Bn.walk())
      if (Bn.type === 1) {
        const No = Bn.name;
        if (Bn.attr("data-ephox-embed-iri")) {
          Xe(le, Bn);
          break;
        } else {
          switch (No) {
            case "video":
            case "object":
            case "embed":
            case "img":
            case "iframe":
              le.height !== void 0 && le.width !== void 0 && (Bn.attr("width", le.width), Bn.attr("height", le.height));
              break;
          }
          if (Ce)
            switch (No) {
              case "video":
                Bn.attr("poster", le.poster), Bn.attr("src", null);
                for (let bt = Rn; bt < 2; bt++)
                  if (le[O[bt]]) {
                    const se = new _o("source", 1);
                    se.attr("src", le[O[bt]]), se.attr("type", le[O[bt] + "mime"] || null), Bn.append(se);
                  }
                break;
              case "iframe":
                Bn.attr("src", le.source);
                break;
              case "object":
                const yr = Bn.getAll("img").length > 0;
                if (le.poster && !yr) {
                  Bn.attr("src", le.poster);
                  const bt = new _o("img", 1);
                  bt.attr("src", le.poster), bt.attr("width", le.width), bt.attr("height", le.height), Bn.append(bt);
                }
                break;
              case "source":
                if (Ft < 2 && (Bn.attr("src", le[O[Ft]]), Bn.attr("type", le[O[Ft] + "mime"] || null), !le[O[Ft]])) {
                  Bn.remove();
                  continue;
                }
                Ft++;
                break;
              case "img":
                le.poster || Bn.remove();
                break;
            }
        }
      }
    return Fn({}, wt).serialize(tr);
  }, en = [
    {
      regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$2?$4",
      allowFullscreen: !0
    },
    {
      regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
      allowFullscreen: !1
    },
    {
      regex: /dailymotion\.com\/video\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    },
    {
      regex: /dai\.ly\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    }
  ], Pt = (Z) => {
    const le = Z.match(/^(https?:\/\/|www\.)(.+)$/i);
    return le && le.length > 1 ? le[1] === "www." ? "https://" : le[1] : "https://";
  }, Ne = (Z, le) => {
    const Ce = Pt(le), wt = Z.regex.exec(le);
    let Rn = Ce + Z.url;
    for (let Ft = 0; Ft < wt.length; Ft++)
      Rn = Rn.replace("$" + Ft, () => wt[Ft] ? wt[Ft] : "");
    return Rn.replace(/\?$/, "");
  }, We = (Z) => {
    const le = en.filter((Ce) => Ce.regex.test(Z));
    return le.length > 0 ? Ot.extend({}, le[0], { url: Ne(le[0], Z) }) : null;
  }, Ae = (Z, le) => {
    if (le)
      return le(Z);
    {
      const Ce = Z.allowfullscreen ? ' allowFullscreen="1"' : "";
      return '<iframe src="' + Z.source + '" width="' + Z.width + '" height="' + Z.height + '"' + Ce + "></iframe>";
    }
  }, Oe = (Z) => {
    let le = '<object data="' + Z.source + '" width="' + Z.width + '" height="' + Z.height + '" type="application/x-shockwave-flash">';
    return Z.poster && (le += '<img src="' + Z.poster + '" width="' + Z.width + '" height="' + Z.height + '" />'), le += "</object>", le;
  }, ae = (Z, le) => le ? le(Z) : '<audio controls="controls" src="' + Z.source + '">' + (Z.altsource ? `
<source src="` + Z.altsource + '"' + (Z.altsourcemime ? ' type="' + Z.altsourcemime + '"' : "") + ` />
` : "") + "</audio>", X = (Z, le) => le ? le(Z) : '<video width="' + Z.width + '" height="' + Z.height + '"' + (Z.poster ? ' poster="' + Z.poster + '"' : "") + ` controls="controls">
<source src="` + Z.source + '"' + (Z.sourcemime ? ' type="' + Z.sourcemime + '"' : "") + ` />
` + (Z.altsource ? '<source src="' + Z.altsource + '"' + (Z.altsourcemime ? ' type="' + Z.altsourcemime + '"' : "") + ` />
` : "") + "</video>", je = (Z) => '<script src="' + Z.source + '"><\/script>', ke = (Z, le) => {
    const Ce = Ot.extend({}, le);
    if (!Ce.source && (Ot.extend(Ce, un(Ce.embed, Z.schema)), !Ce.source))
      return "";
    Ce.altsource || (Ce.altsource = ""), Ce.poster || (Ce.poster = ""), Ce.source = Z.convertURL(Ce.source, "source"), Ce.altsource = Z.convertURL(Ce.altsource, "source"), Ce.sourcemime = Ct(Ce.source), Ce.altsourcemime = Ct(Ce.altsource), Ce.poster = Z.convertURL(Ce.poster, "poster");
    const wt = We(Ce.source);
    if (wt && (Ce.source = wt.url, Ce.type = wt.type, Ce.allowfullscreen = wt.allowFullscreen, Ce.width = Ce.width || String(wt.w), Ce.height = Ce.height || String(wt.h)), Ce.embed)
      return gt(Ce.embed, Ce, !0, Z.schema);
    {
      const Rn = _t(Z), Ft = Re(Z), Co = oe(Z);
      return Ce.width = Ce.width || "300", Ce.height = Ce.height || "150", Ot.each(Ce, (tr, Bn) => {
        Ce[Bn] = Z.dom.encode("" + tr);
      }), Ce.type === "iframe" ? Ae(Ce, Co) : Ce.sourcemime === "application/x-shockwave-flash" ? Oe(Ce) : Ce.sourcemime.indexOf("audio") !== -1 ? ae(Ce, Rn) : Ce.type === "script" ? je(Ce) : X(Ce, Ft);
    }
  }, ue = (Z) => Z.hasAttribute("data-mce-object") || Z.hasAttribute("data-ephox-embed-iri"), ct = (Z) => {
    Z.on("click keyup touchend", () => {
      const le = Z.selection.getNode();
      le && Z.dom.hasClass(le, "mce-preview-object") && Z.dom.getAttrib(le, "data-mce-selected") && le.setAttribute("data-mce-selected", "2");
    }), Z.on("ObjectSelected", (le) => {
      le.target.getAttribute("data-mce-object") === "script" && le.preventDefault();
    }), Z.on("ObjectResized", (le) => {
      const Ce = le.target;
      if (Ce.getAttribute("data-mce-object")) {
        let wt = Ce.getAttribute("data-mce-html");
        wt && (wt = unescape(wt), Ce.setAttribute("data-mce-html", escape(gt(wt, {
          width: String(le.width),
          height: String(le.height)
        }, !1, Z.schema))));
      }
    });
  }, Ht = {}, vo = (Z, le, Ce) => new Promise((wt, Rn) => {
    const Ft = (Co) => (Co.html && (Ht[Z.source] = Co), wt({
      url: Z.source,
      html: Co.html ? Co.html : le(Z)
    }));
    Ht[Z.source] ? Ft(Ht[Z.source]) : Ce({ url: Z.source }, Ft, Rn);
  }), Wn = (Z, le) => Promise.resolve({
    html: le(Z),
    url: Z.source
  }), ko = (Z) => (le) => ke(Z, le), fo = (Z, le) => {
    const Ce = lt(Z);
    return Ce ? vo(le, ko(Z), Ce) : Wn(le, ko(Z));
  }, yn = (Z) => Ue(Ht, Z), ds = (Z, le) => He(le, Z).bind((Ce) => He(Ce, "meta")), Ho = (Z, le, Ce) => (wt) => {
    const Rn = () => He(Z, wt), Ft = () => He(le, wt), Co = (No) => He(No, "value").bind((yr) => yr.length > 0 ? $t.some(yr) : $t.none()), tr = () => Rn().bind((No) => uo(No) ? Co(No).orThunk(Ft) : Ft().orThunk(() => $t.from(No))), Bn = () => Ft().orThunk(() => Rn().bind((No) => uo(No) ? Co(No) : $t.from(No)));
    return { [wt]: (wt === Ce ? tr() : Bn()).getOr("") };
  }, mn = (Z, le) => {
    const Ce = {};
    return He(Z, "dimensions").each((wt) => {
      Ao([
        "width",
        "height"
      ], (Rn) => {
        He(le, Rn).orThunk(() => He(wt, Rn)).each((Ft) => Ce[Rn] = Ft);
      });
    }), Ce;
  }, Io = (Z, le) => {
    const Ce = le ? ds(le, Z).getOr({}) : {}, wt = Ho(Z, Ce, le);
    return {
      ...wt("source"),
      ...wt("altsource"),
      ...wt("poster"),
      ...wt("embed"),
      ...mn(Z, Ce)
    };
  }, ro = (Z) => {
    const le = {
      ...Z,
      source: { value: He(Z, "source").getOr("") },
      altsource: { value: He(Z, "altsource").getOr("") },
      poster: { value: He(Z, "poster").getOr("") }
    };
    return Ao([
      "width",
      "height"
    ], (Ce) => {
      He(Z, Ce).each((wt) => {
        const Rn = le.dimensions || {};
        Rn[Ce] = wt, le.dimensions = Rn;
      });
    }), le;
  }, Ln = (Z) => (le) => {
    const Ce = le && le.msg ? "Media embed handler error: " + le.msg : "Media embed handler threw unknown error.";
    Z.notificationManager.open({
      type: "error",
      text: Ce
    });
  }, Go = (Z) => {
    const le = Z.selection.getNode(), Ce = ue(le) ? Z.serializer.serialize(le, { selection: !0 }) : "";
    return {
      embed: Ce,
      ...un(Ce, Z.schema)
    };
  }, Ro = (Z, le) => (Ce) => {
    if (Jn(Ce.url) && Ce.url.trim().length > 0) {
      const wt = Ce.html, Ft = {
        ...un(wt, le.schema),
        source: Ce.url,
        embed: wt
      };
      Z.setData(ro(Ft));
    }
  }, Os = (Z, le) => {
    const Ce = Z.dom.select("*[data-mce-object]");
    for (let wt = 0; wt < le.length; wt++)
      for (let Rn = Ce.length - 1; Rn >= 0; Rn--)
        le[wt] === Ce[Rn] && Ce.splice(Rn, 1);
    Z.selection.select(Ce[0]);
  }, Qs = (Z, le) => {
    const Ce = Z.dom.select("*[data-mce-object]");
    Z.insertContent(le), Os(Z, Ce), Z.nodeChanged();
  }, we = (Z, le, Ce) => {
    le.embed = gt(le.embed, le, !1, Ce.schema), le.embed && (Z.source === le.source || yn(le.source)) ? Qs(Ce, le.embed) : fo(Ce, le).then((wt) => {
      Qs(Ce, wt.html);
    }).catch(Ln(Ce));
  }, $e = (Z) => {
    const le = Go(Z), Ce = mt(le), wt = ro(le), Rn = (Nt, on) => {
      const Yt = Io(on.getData(), "source");
      Nt.source !== Yt.source && (Ro(zt, Z)({
        url: Yt.source,
        html: ""
      }), fo(Z, Yt).then(Ro(zt, Z)).catch(Ln(Z)));
    }, Ft = (Nt) => {
      const on = Io(Nt.getData()), Yt = un(on.embed, Z.schema);
      Nt.setData(ro(Yt));
    }, Co = (Nt, on) => {
      const Yt = Io(Nt.getData(), on), On = ke(Z, Yt);
      Nt.setData(ro({
        ...Yt,
        embed: On
      }));
    }, tr = [{
      name: "source",
      type: "urlinput",
      filetype: "media",
      label: "Source"
    }], Bn = ft(Z) ? [{
      type: "sizeinput",
      name: "dimensions",
      label: "Constrain proportions",
      constrain: !0
    }] : [], No = {
      title: "General",
      name: "general",
      items: tn([
        tr,
        Bn
      ])
    }, bt = {
      title: "Embed",
      items: [{
        type: "textarea",
        name: "embed",
        label: "Paste your embed code below:"
      }]
    }, se = [];
    Q(Z) && se.push({
      name: "altsource",
      type: "urlinput",
      filetype: "media",
      label: "Alternative source URL"
    }), wn(Z) && se.push({
      name: "poster",
      type: "urlinput",
      filetype: "image",
      label: "Media poster (Image URL)"
    });
    const me = {
      title: "Advanced",
      name: "advanced",
      items: se
    }, tt = [
      No,
      bt
    ];
    se.length > 0 && tt.push(me);
    const Lt = {
      type: "tabpanel",
      tabs: tt
    }, zt = Z.windowManager.open({
      title: "Insert/Edit Media",
      size: "normal",
      body: Lt,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (Nt) => {
        const on = Io(Nt.getData());
        we(Ce.get(), on, Z), Nt.close();
      },
      onChange: (Nt, on) => {
        switch (on.name) {
          case "source":
            Rn(Ce.get(), Nt);
            break;
          case "embed":
            Ft(Nt);
            break;
          case "dimensions":
          case "altsource":
          case "poster":
            Co(Nt, on.name);
            break;
        }
        Ce.set(Io(Nt.getData()));
      },
      initialData: wt
    });
  }, Vt = (Z) => ({ showDialog: () => {
    $e(Z);
  } }), Jt = (Z) => {
    const le = () => {
      $e(Z);
    };
    Z.addCommand("mceMedia", le);
  }, ht = (Z, le, Ce) => le === "" || Z.length >= le.length && Z.substr(Ce, Ce + le.length) === le, qn = (Z, le) => ht(Z, le, 0);
  var pr = tinymce.util.Tools.resolve("tinymce.Env");
  const zr = (Z) => {
    const le = Z.name;
    return le === "iframe" || le === "video" || le === "audio";
  }, Zs = (Z, le, Ce, wt = null) => {
    const Rn = Z.attr(Ce);
    return Bt(Rn) ? Rn : Ue(le, Ce) ? null : wt;
  }, hr = (Z, le, Ce) => {
    const wt = le.name === "img" || Z.name === "video", Rn = wt ? "300" : null, Ft = Z.name === "audio" ? "30" : "150", Co = wt ? Ft : null;
    le.attr({
      width: Zs(Z, Ce, "width", Rn),
      height: Zs(Z, Ce, "height", Co)
    });
  }, Fs = (Z, le, Ce, wt) => {
    const Rn = Sn(Z.schema).parse(wt, { context: le });
    for (; Rn.firstChild; )
      Ce.append(Rn.firstChild);
  }, Tr = (Z, le) => {
    const Ce = le.name, wt = new _o("img", 1);
    return Gn(Z, le, wt), hr(le, wt, {}), wt.attr({
      style: le.attr("style"),
      src: pr.transparentSrc,
      "data-mce-object": Ce,
      class: "mce-object mce-object-" + Ce
    }), wt;
  }, Xo = (Z, le) => {
    const Ce = le.name, wt = new _o("span", 1);
    wt.attr({
      contentEditable: "false",
      style: le.attr("style"),
      "data-mce-object": Ce,
      class: "mce-preview-object mce-object-" + Ce
    }), Gn(Z, le, wt);
    const Rn = Z.dom.parseStyle(le.attr("style")), Ft = new _o(Ce, 1);
    if (hr(le, Ft, Rn), Ft.attr({
      src: le.attr("src"),
      style: le.attr("style"),
      class: le.attr("class")
    }), Ce === "iframe")
      Ft.attr({
        allowfullscreen: le.attr("allowfullscreen"),
        frameborder: "0"
      });
    else {
      Ao([
        "controls",
        "crossorigin",
        "currentTime",
        "loop",
        "muted",
        "poster",
        "preload"
      ], (No) => {
        Ft.attr(No, le.attr(No));
      });
      const Bn = wt.attr("data-mce-html");
      Bt(Bn) && Fs(Z, Ce, Ft, unescape(Bn));
    }
    const Co = new _o("span", 1);
    return Co.attr("class", "mce-shim"), wt.append(Ft), wt.append(Co), wt;
  }, Gn = (Z, le, Ce) => {
    const wt = le.attributes;
    let Rn = wt.length;
    for (; Rn--; ) {
      const Bn = wt[Rn].name;
      let No = wt[Rn].value;
      Bn !== "width" && Bn !== "height" && Bn !== "style" && !qn(Bn, "data-mce-") && ((Bn === "data" || Bn === "src") && (No = Z.convertURL(No, Bn)), Ce.attr("data-mce-p-" + Bn, No));
    }
    const Ft = Fn({ inner: !0 }, Z.schema), Co = new _o("div", 1);
    Ao(le.children(), (Bn) => Co.append(Bn));
    const tr = Ft.serialize(Co);
    tr && (Ce.attr("data-mce-html", escape(tr)), Ce.empty());
  }, er = (Z) => {
    const le = Z.attr("class");
    return le && /\btiny-pageembed\b/.test(le);
  }, Ss = (Z) => {
    for (; Z = Z.parent; )
      if (Z.attr("data-ephox-embed-iri") || er(Z))
        return !0;
    return !1;
  }, ir = (Z) => (le) => {
    let Ce = le.length, wt;
    for (; Ce--; )
      wt = le[Ce], wt.parent && (wt.parent.attr("data-mce-object") || (zr(wt) && Je(Z) ? Ss(wt) || wt.replace(Xo(Z, wt)) : Ss(wt) || wt.replace(Tr(Z, wt))));
  }, Ka = (Z, le, Ce) => {
    const wt = rt(Z);
    return Sn(Z.schema, { validate: wt }).parse(Ce, { context: le });
  }, Ra = (Z) => {
    Z.on("PreInit", () => {
      const { schema: le, serializer: Ce, parser: wt } = Z, Rn = le.getBoolAttrs();
      Ao("webkitallowfullscreen mozallowfullscreen".split(" "), (Ft) => {
        Rn[Ft] = {};
      }), At({ embed: ["wmode"] }, (Ft, Co) => {
        const tr = le.getElementRule(Co);
        Ao(Ft, (Bn) => {
          tr.attributes[Bn] = {}, tr.attributesOrder.push(Bn);
        });
      }), wt.addNodeFilter("iframe,video,audio,object,embed,script", ir(Z)), Ce.addAttributeFilter("data-mce-object", (Ft, Co) => {
        let tr = Ft.length;
        for (; tr--; ) {
          const Bn = Ft[tr];
          if (!Bn.parent)
            continue;
          const No = Bn.attr(Co), yr = new _o(No, 1);
          if (No !== "audio" && No !== "script") {
            const tt = Bn.attr("class");
            tt && tt.indexOf("mce-preview-object") !== -1 ? yr.attr({
              width: Bn.firstChild.attr("width"),
              height: Bn.firstChild.attr("height")
            }) : yr.attr({
              width: Bn.attr("width"),
              height: Bn.attr("height")
            });
          }
          yr.attr({ style: Bn.attr("style") });
          const bt = Bn.attributes;
          let se = bt.length;
          for (; se--; ) {
            const tt = bt[se].name;
            tt.indexOf("data-mce-p-") === 0 && yr.attr(tt.substr(11), bt[se].value);
          }
          No === "script" && yr.attr("type", "text/javascript");
          const me = Bn.attr("data-mce-html");
          if (me) {
            const tt = Ka(Z, No, unescape(me));
            Ao(tt.children(), (Lt) => yr.append(Lt));
          }
          Bn.replace(yr);
        }
      });
    }), Z.on("SetContent", () => {
      const le = Z.dom;
      Ao(le.select("span.mce-preview-object"), (Ce) => {
        le.select("span.mce-shim", Ce).length === 0 && le.add(Ce, "span", { class: "mce-shim" });
      });
    });
  }, Ur = (Z) => {
    Z.on("ResolveName", (le) => {
      let Ce;
      le.target.nodeType === 1 && (Ce = le.target.getAttribute("data-mce-object")) && (le.name = Ce);
    });
  }, rs = (Z) => {
    const le = () => Z.execCommand("mceMedia");
    Z.ui.registry.addToggleButton("media", {
      tooltip: "Insert/edit media",
      icon: "embed",
      onAction: le,
      onSetup: (Ce) => {
        const wt = Z.selection;
        return Ce.setActive(ue(wt.getNode())), wt.selectorChangedWithUnbind("img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]", Ce.setActive).unbind;
      }
    }), Z.ui.registry.addMenuItem("media", {
      icon: "embed",
      text: "Media...",
      onAction: le
    });
  };
  var cc = () => {
    ns.add("media", (Z) => (dn(Z), Jt(Z), rs(Z), Ur(Z), Ra(Z), ct(Z), Vt(Z)));
  };
  cc();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (k, S, P) => {
    var q;
    return P(k, S.prototype) ? !0 : ((q = k.constructor) === null || q === void 0 ? void 0 : q.name) === S.name;
  }, Eo = (k) => {
    const S = typeof k;
    return k === null ? "null" : S === "object" && Array.isArray(k) ? "array" : S === "object" && To(k, String, (P, q) => q.isPrototypeOf(P)) ? "string" : S;
  }, In = (k) => (S) => Eo(S) === k, Jn = (k) => (S) => typeof S === k, uo = (k) => (S) => k === S, ho = In("string"), Kt = In("array"), Bt = Jn("boolean"), $t = uo(void 0), Un = (k) => k == null, Ao = (k) => !Un(k), tn = Jn("function"), mt = Jn("number"), an = () => {
  }, Ge = (k, S) => (P) => k(S(P)), At = (k) => () => k, He = (k) => k, Ue = (k, S) => k === S;
  function ie(k, ...S) {
    return (...P) => {
      const q = S.concat(P);
      return k.apply(null, q);
    };
  }
  const dn = At(!1), _t = At(!0);
  class Re {
    constructor(S, P) {
      this.tag = S, this.value = P;
    }
    static some(S) {
      return new Re(!0, S);
    }
    static none() {
      return Re.singletonNone;
    }
    fold(S, P) {
      return this.tag ? P(this.value) : S();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(S) {
      return this.tag ? Re.some(S(this.value)) : Re.none();
    }
    bind(S) {
      return this.tag ? S(this.value) : Re.none();
    }
    exists(S) {
      return this.tag && S(this.value);
    }
    forall(S) {
      return !this.tag || S(this.value);
    }
    filter(S) {
      return !this.tag || S(this.value) ? this : Re.none();
    }
    getOr(S) {
      return this.tag ? this.value : S;
    }
    or(S) {
      return this.tag ? this : S;
    }
    getOrThunk(S) {
      return this.tag ? this.value : S();
    }
    orThunk(S) {
      return this.tag ? this : S();
    }
    getOrDie(S) {
      if (this.tag)
        return this.value;
      throw new Error(S != null ? S : "Called getOrDie on None");
    }
    static from(S) {
      return Ao(S) ? Re.some(S) : Re.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(S) {
      this.tag && S(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Re.singletonNone = new Re(!1);
  const oe = Object.keys, Je = Object.hasOwnProperty, rt = (k, S) => {
    const P = oe(k);
    for (let q = 0, ge = P.length; q < ge; q++) {
      const Ze = P[q], St = k[Ze];
      S(St, Ze);
    }
  }, lt = (k) => (S, P) => {
    k[P] = S;
  }, Q = (k, S, P, q) => {
    const ge = {};
    return rt(k, (Ze, St) => {
      (S(Ze, St) ? P : q)(Ze, St);
    }), ge;
  }, wn = (k, S) => {
    const P = {};
    return Q(k, S, lt(P), an), P;
  }, ft = (k, S) => {
    const P = [];
    return rt(k, (q, ge) => {
      P.push(S(q, ge));
    }), P;
  }, Ot = (k) => ft(k, He), Se = (k) => oe(k).length, Qe = (k, S) => z(k, S) ? Re.from(k[S]) : Re.none(), z = (k, S) => Je.call(k, S), Pe = (k, S) => z(k, S) && k[S] !== void 0 && k[S] !== null, Rt = Array.prototype.indexOf, un = Array.prototype.push, Ct = (k, S) => Rt.call(k, S), _o = (k, S) => Ct(k, S) > -1, Fn = (k, S) => {
    for (let P = 0, q = k.length; P < q; P++) {
      const ge = k[P];
      if (S(ge, P))
        return !0;
    }
    return !1;
  }, Sn = (k, S) => {
    const P = [];
    for (let q = 0; q < k; q++)
      P.push(S(q));
    return P;
  }, Dn = (k, S) => {
    const P = k.length, q = new Array(P);
    for (let ge = 0; ge < P; ge++) {
      const Ze = k[ge];
      q[ge] = S(Ze, ge);
    }
    return q;
  }, Mn = (k, S) => {
    for (let P = 0, q = k.length; P < q; P++) {
      const ge = k[P];
      S(ge, P);
    }
  }, Xe = (k, S) => {
    for (let P = k.length - 1; P >= 0; P--) {
      const q = k[P];
      S(q, P);
    }
  }, O = (k, S) => {
    const P = [], q = [];
    for (let ge = 0, Ze = k.length; ge < Ze; ge++) {
      const St = k[ge];
      (S(St, ge) ? P : q).push(St);
    }
    return {
      pass: P,
      fail: q
    };
  }, gt = (k, S) => {
    const P = [];
    for (let q = 0, ge = k.length; q < ge; q++) {
      const Ze = k[q];
      S(Ze, q) && P.push(Ze);
    }
    return P;
  }, en = (k, S, P) => (Xe(k, (q, ge) => {
    P = S(P, q, ge);
  }), P), Pt = (k, S, P) => (Mn(k, (q, ge) => {
    P = S(P, q, ge);
  }), P), Ne = (k, S, P) => {
    for (let q = 0, ge = k.length; q < ge; q++) {
      const Ze = k[q];
      if (S(Ze, q))
        return Re.some(Ze);
      if (P(Ze, q))
        break;
    }
    return Re.none();
  }, We = (k, S) => Ne(k, S, dn), Ae = (k) => {
    const S = [];
    for (let P = 0, q = k.length; P < q; ++P) {
      if (!Kt(k[P]))
        throw new Error("Arr.flatten item " + P + " was not an array, input: " + k);
      un.apply(S, k[P]);
    }
    return S;
  }, Oe = (k, S) => Ae(Dn(k, S)), ae = (k, S) => {
    for (let P = 0, q = k.length; P < q; ++P) {
      const ge = k[P];
      if (S(ge, P) !== !0)
        return !1;
    }
    return !0;
  }, X = (k, S) => {
    const P = {};
    for (let q = 0, ge = k.length; q < ge; q++) {
      const Ze = k[q];
      P[String(Ze)] = S(Ze, q);
    }
    return P;
  }, je = (k, S) => S >= 0 && S < k.length ? Re.some(k[S]) : Re.none(), ke = (k) => je(k, 0), ue = (k) => je(k, k.length - 1), ct = (k, S) => {
    for (let P = 0; P < k.length; P++) {
      const q = S(k[P], P);
      if (q.isSome())
        return q;
    }
    return Re.none();
  }, Ht = (k, S) => {
    const q = (S || document).createElement("div");
    if (q.innerHTML = k, !q.hasChildNodes() || q.childNodes.length > 1) {
      const ge = "HTML does not have a single root node";
      throw console.error(ge, k), new Error(ge);
    }
    return ko(q.childNodes[0]);
  }, vo = (k, S) => {
    const q = (S || document).createElement(k);
    return ko(q);
  }, Wn = (k, S) => {
    const q = (S || document).createTextNode(k);
    return ko(q);
  }, ko = (k) => {
    if (k == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: k };
  }, yn = {
    fromHtml: Ht,
    fromTag: vo,
    fromText: Wn,
    fromDom: ko,
    fromPoint: (k, S, P) => Re.from(k.dom.elementFromPoint(S, P)).map(ko)
  };
  typeof window < "u" || Function("return this;")();
  const ds = 8, Ho = 9, mn = 11, Io = 1, ro = 3, Ln = (k) => k.dom.nodeName.toLowerCase(), Go = (k) => k.dom.nodeType, Ro = (k) => (S) => Go(S) === k, Os = (k) => Go(k) === ds || Ln(k) === "#comment", Qs = Ro(Io), we = Ro(ro), $e = Ro(Ho), Vt = Ro(mn), Jt = (k) => (S) => Qs(S) && Ln(S) === k, ht = (k, S) => {
    const P = k.dom;
    if (P.nodeType !== Io)
      return !1;
    {
      const q = P;
      if (q.matches !== void 0)
        return q.matches(S);
      if (q.msMatchesSelector !== void 0)
        return q.msMatchesSelector(S);
      if (q.webkitMatchesSelector !== void 0)
        return q.webkitMatchesSelector(S);
      if (q.mozMatchesSelector !== void 0)
        return q.mozMatchesSelector(S);
      throw new Error("Browser lacks native selectors");
    }
  }, qn = (k) => k.nodeType !== Io && k.nodeType !== Ho && k.nodeType !== mn || k.childElementCount === 0, pr = (k, S) => {
    const P = S === void 0 ? document : S.dom;
    return qn(P) ? [] : Dn(P.querySelectorAll(k), yn.fromDom);
  }, zr = (k, S) => {
    const P = S === void 0 ? document : S.dom;
    return qn(P) ? Re.none() : Re.from(P.querySelector(k)).map(yn.fromDom);
  }, Zs = (k, S) => k.dom === S.dom, hr = ht, Fs = (k) => yn.fromDom(k.dom.ownerDocument), Tr = (k) => $e(k) ? k : Fs(k), Xo = (k) => Re.from(k.dom.parentNode).map(yn.fromDom), Gn = (k, S) => {
    const P = tn(S) ? S : dn;
    let q = k.dom;
    const ge = [];
    for (; q.parentNode !== null && q.parentNode !== void 0; ) {
      const Ze = q.parentNode, St = yn.fromDom(Ze);
      if (ge.push(St), P(St) === !0)
        break;
      q = Ze;
    }
    return ge;
  }, er = (k) => Re.from(k.dom.previousSibling).map(yn.fromDom), Ss = (k) => Re.from(k.dom.nextSibling).map(yn.fromDom), ir = (k) => Dn(k.dom.childNodes, yn.fromDom), Ka = (k, S) => {
    const P = k.dom.childNodes;
    return Re.from(P[S]).map(yn.fromDom);
  }, Ra = (k) => Ka(k, 0), Ur = (k) => Vt(k) && Ao(k.dom.host), cc = tn(Element.prototype.attachShadow) && tn(Node.prototype.getRootNode) ? (k) => yn.fromDom(k.dom.getRootNode()) : Tr, Z = (k) => {
    const S = cc(k);
    return Ur(S) ? Re.some(S) : Re.none();
  }, le = (k) => yn.fromDom(k.dom.host), Ce = (k) => {
    const S = we(k) ? k.dom.parentNode : k.dom;
    if (S == null || S.ownerDocument === null)
      return !1;
    const P = S.ownerDocument;
    return Z(yn.fromDom(S)).fold(() => P.body.contains(S), Ge(Ce, le));
  }, wt = (k, S) => gt(ir(k), S), Rn = (k, S) => {
    let P = [];
    return Mn(ir(k), (q) => {
      S(q) && (P = P.concat([q])), P = P.concat(Rn(q, S));
    }), P;
  }, Ft = (k, S) => wt(k, (P) => ht(P, S)), Co = (k, S) => pr(S, k);
  var tr = (k, S, P, q, ge) => k(P, q) ? Re.some(P) : tn(ge) && ge(P) ? Re.none() : S(P, q, ge);
  const Bn = (k, S, P) => {
    let q = k.dom;
    const ge = tn(P) ? P : dn;
    for (; q.parentNode; ) {
      q = q.parentNode;
      const Ze = yn.fromDom(q);
      if (S(Ze))
        return Re.some(Ze);
      if (ge(Ze))
        break;
    }
    return Re.none();
  }, No = (k, S) => {
    const P = (ge) => S(yn.fromDom(ge));
    return We(k.dom.childNodes, P).map(yn.fromDom);
  }, yr = (k, S, P) => Bn(k, (q) => ht(q, S), P), bt = (k, S) => No(k, (P) => ht(P, S)), se = (k, S) => zr(S, k), me = (k, S, P) => tr((ge, Ze) => ht(ge, Ze), yr, k, S, P), tt = (k, S, P) => {
    if (ho(P) || Bt(P) || mt(P))
      k.setAttribute(S, P + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", S, ":: Value ", P, ":: Element ", k), new Error("Attribute value was not simple");
  }, Lt = (k, S, P) => {
    tt(k.dom, S, P);
  }, zt = (k, S) => {
    const P = k.dom;
    rt(S, (q, ge) => {
      tt(P, ge, q);
    });
  }, Nt = (k, S) => {
    const P = k.dom.getAttribute(S);
    return P === null ? void 0 : P;
  }, on = (k, S) => Re.from(Nt(k, S)), Yt = (k, S) => {
    k.dom.removeAttribute(S);
  }, On = (k) => Pt(k.dom.attributes, (S, P) => (S[P.name] = P.value, S), {}), os = (k, S, P = Ue) => k.exists((q) => P(q, S)), $s = (k) => {
    const S = [], P = (q) => {
      S.push(q);
    };
    for (let q = 0; q < k.length; q++)
      k[q].each(P);
    return S;
  }, zo = (k, S, P) => k.isSome() && S.isSome() ? Re.some(P(k.getOrDie(), S.getOrDie())) : Re.none(), Ya = (k) => k.bind(He), sa = (k, S) => k ? Re.some(S) : Re.none(), Bo = (k, S) => k.substring(S), fs = (k, S, P) => S === "" || k.length >= S.length && k.substr(P, P + S.length) === S, Lo = (k, S) => br(k, S) ? Bo(k, S.length) : k, br = (k, S) => fs(k, S, 0), ra = ((k) => (S) => S.replace(k, ""))(/^\s+|\s+$/g), nl = (k) => k.length > 0, pa = (k) => !nl(k), Wr = (k) => {
    const S = parseFloat(k);
    return isNaN(S) ? Re.none() : Re.some(S);
  }, Ma = (k) => k.style !== void 0 && tn(k.style.getPropertyValue), ci = (k, S, P) => {
    if (!ho(P))
      throw console.error("Invalid call to CSS.set. Property ", S, ":: Value ", P, ":: Element ", k), new Error("CSS value must be a string: " + P);
    Ma(k) && k.style.setProperty(S, P);
  }, ol = (k, S) => {
    Ma(k) && k.style.removeProperty(S);
  }, aa = (k, S, P) => {
    const q = k.dom;
    ci(q, S, P);
  }, Xa = (k, S) => {
    const P = k.dom, ge = window.getComputedStyle(P).getPropertyValue(S);
    return ge === "" && !Ce(k) ? kl(P, S) : ge;
  }, kl = (k, S) => Ma(k) ? k.style.getPropertyValue(S) : "", Ja = (k, S) => {
    const P = k.dom, q = kl(P, S);
    return Re.from(q).filter((ge) => ge.length > 0);
  }, li = (k, S) => {
    const P = k.dom;
    ol(P, S), os(on(k, "style").map(ra), "") && Yt(k, "style");
  }, Qa = (k, S, P = 0) => on(k, S).map((q) => parseInt(q, 10)).getOr(P), Fc = (k, S) => Hl(k, S, _t), Hl = (k, S, P) => Oe(ir(k), (q) => ht(q, S) ? P(q) ? [q] : [] : Hl(q, S, P)), or = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], U = (k) => _o(or, k), fe = (k, S) => ({
    rows: k,
    columns: S
  }), _e = (k, S, P) => ({
    element: k,
    rowspan: S,
    colspan: P
  }), nt = (k, S, P, q, ge, Ze) => ({
    element: k,
    rowspan: S,
    colspan: P,
    row: q,
    column: ge,
    isLocked: Ze
  }), Et = (k, S, P) => ({
    element: k,
    cells: S,
    section: P
  }), So = (k, S, P, q) => ({
    startRow: k,
    startCol: S,
    finishRow: P,
    finishCol: q
  }), Ko = (k, S, P) => ({
    element: k,
    colspan: S,
    column: P
  }), js = (k, S) => ({
    element: k,
    columns: S
  }), Ns = (k, S, P = dn) => {
    if (P(S))
      return Re.none();
    if (_o(k, Ln(S)))
      return Re.some(S);
    const q = (ge) => ht(ge, "table") || P(ge);
    return yr(S, k.join(","), q);
  }, Jr = (k, S) => Ns([
    "td",
    "th"
  ], k, S), to = (k) => Fc(k, "th,td"), Ic = (k) => ht(k, "colgroup") ? Ft(k, "col") : Oe(Vl(k), (S) => Ft(S, "col")), Vo = (k, S) => me(k, "table", S), ha = (k) => Fc(k, "tr"), Vl = (k) => Vo(k).fold(At([]), (S) => Ft(S, "colgroup")), nr = (k, S) => Dn(k, (P) => {
    if (Ln(P) === "colgroup") {
      const q = Dn(Ic(P), (ge) => {
        const Ze = Qa(ge, "span", 1);
        return _e(ge, 1, Ze);
      });
      return Et(P, q, "colgroup");
    } else {
      const q = Dn(to(P), (ge) => {
        const Ze = Qa(ge, "rowspan", 1), St = Qa(ge, "colspan", 1);
        return _e(ge, Ze, St);
      });
      return Et(P, q, S(P));
    }
  }), ca = (k) => Xo(k).map((S) => {
    const P = Ln(S);
    return U(P) ? P : "tbody";
  }).getOr("tbody"), lc = (k) => {
    const S = ha(k), q = [
      ...Vl(k),
      ...S
    ];
    return nr(q, ca);
  }, Lc = "data-snooker-locked-cols", Qt = (k) => on(k, Lc).bind((S) => Re.from(S.match(/\d+/g))).map((S) => X(S, _t)), Zr = (k, S) => k + "," + S, wl = (k, S, P) => Re.from(k.access[Zr(S, P)]), qr = (k, S, P) => {
    const q = B(k, (ge) => P(S, ge.element));
    return q.length > 0 ? Re.some(q[0]) : Re.none();
  }, B = (k, S) => {
    const P = Oe(k.all, (q) => q.cells);
    return gt(P, S);
  }, j = (k) => {
    const S = {};
    let P = 0;
    return Mn(k.cells, (q) => {
      const ge = q.colspan;
      Sn(ge, (Ze) => {
        const St = P + Ze;
        S[St] = Ko(q.element, ge, St);
      }), P += ge;
    }), S;
  }, ce = (k) => {
    const S = {}, P = [], ge = ke(k).map((hc) => hc.element).bind(Vo).bind(Qt).getOr({});
    let Ze = 0, St = 0, jt = 0;
    const {
      pass: mo,
      fail: Fo
    } = O(k, (hc) => hc.section === "colgroup");
    Mn(Fo, (hc) => {
      const Fa = [];
      Mn(hc.cells, (iu) => {
        let Ii = 0;
        for (; S[Zr(jt, Ii)] !== void 0; )
          Ii++;
        const pg = Pe(ge, Ii.toString()), wm = nt(iu.element, iu.rowspan, iu.colspan, jt, Ii, pg);
        for (let Nr = 0; Nr < iu.colspan; Nr++)
          for (let Wc = 0; Wc < iu.rowspan; Wc++) {
            const Uu = jt + Wc, uu = Ii + Nr, Cf = Zr(Uu, uu);
            S[Cf] = wm, St = Math.max(St, uu + 1);
          }
        Fa.push(wm);
      }), Ze++, P.push(Et(hc.element, Fa, hc.section)), jt++;
    });
    const { columns: Rr, colgroups: ks } = ue(mo).map((hc) => {
      const Fa = j(hc);
      return {
        colgroups: [js(hc.element, Ot(Fa))],
        columns: Fa
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: fe(Ze, St),
      access: S,
      all: P,
      columns: Rr,
      colgroups: ks
    };
  }, hs = {
    fromTable: (k) => {
      const S = lc(k);
      return ce(S);
    },
    generate: ce,
    getAt: wl,
    findItem: qr,
    filterItems: B,
    justCells: (k) => Oe(k.all, (S) => S.cells),
    justColumns: (k) => Ot(k.columns),
    hasColumns: (k) => oe(k.columns).length > 0,
    getColumnAt: (k, S) => Re.from(k.columns[S])
  };
  var Ca = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const qs = (k, S, P) => {
    const q = k.select("td,th", S);
    let ge;
    return ((St, jt) => {
      for (let mo = 0; mo < jt.length; mo++) {
        const Fo = k.getStyle(jt[mo], P);
        if (typeof St > "u" && (St = Fo), St !== Fo)
          return "";
      }
      return St;
    })(ge, q);
  }, Hc = (k, S, P) => {
    Ca.each("left center right".split(" "), (q) => {
      q !== P && k.formatter.remove("align" + q, {}, S);
    }), P && k.formatter.apply("align" + P, {}, S);
  }, as = (k, S, P) => {
    Ca.each("top middle bottom".split(" "), (q) => {
      q !== P && k.formatter.remove("valign" + q, {}, S);
    }), P && k.formatter.apply("valign" + P, {}, S);
  }, G = (k, S, P) => {
    k.dispatch("TableModified", {
      ...P,
      table: S
    });
  }, re = (k, S) => Wr(k).getOr(S), Me = (k, S, P) => re(Xa(k, S), P), Ye = (k, S, P, q) => {
    const ge = Me(k, `padding-${P}`, 0), Ze = Me(k, `padding-${q}`, 0), St = Me(k, `border-${P}-width`, 0), jt = Me(k, `border-${q}-width`, 0);
    return S - ge - Ze - St - jt;
  }, bn = (k, S) => {
    const P = k.dom, q = P.getBoundingClientRect().width || P.offsetWidth;
    return S === "border-box" ? q : Ye(k, q, "left", "right");
  }, Wo = (k) => bn(k, "content-box");
  var Xs = tinymce.util.Tools.resolve("tinymce.Env");
  const ic = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", Oo = Sn(5, (k) => {
    const S = `${k + 1}px`;
    return {
      title: S,
      value: S
    };
  }), Ps = Dn([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (k) => ({
    title: k,
    value: k.toLowerCase()
  })), uc = "100%", dc = (k) => {
    var S;
    const P = k.dom, q = (S = P.getParent(k.selection.getStart(), P.isBlock)) !== null && S !== void 0 ? S : k.getBody();
    return Wo(yn.fromDom(q)) + "px";
  }, su = (k, S) => Nu(k) || !Sl(k) ? S : dd(k) ? {
    ...S,
    width: dc(k)
  } : {
    ...S,
    width: uc
  }, fc = (k, S) => Nu(k) || Sl(k) ? S : dd(k) ? {
    ...S,
    width: dc(k)
  } : {
    ...S,
    width: uc
  }, ms = (k) => (S) => S.options.get(k), ur = (k) => {
    const S = k.options.register;
    S("table_border_widths", {
      processor: "object[]",
      default: Oo
    }), S("table_border_styles", {
      processor: "object[]",
      default: Ps
    }), S("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), S("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), S("table_advtab", {
      processor: "boolean",
      default: !0
    }), S("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), S("table_grid", {
      processor: "boolean",
      default: !Xs.deviceType.isTouch()
    }), S("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), S("table_row_class_list", {
      processor: "object[]",
      default: []
    }), S("table_class_list", {
      processor: "object[]",
      default: []
    }), S("table_toolbar", {
      processor: "string",
      default: ic
    }), S("table_background_color_map", {
      processor: "object[]",
      default: []
    }), S("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, Na = ms("table_sizing_mode"), _l = ms("table_border_widths"), Ni = ms("table_border_styles"), $r = ms("table_cell_advtab"), Cl = ms("table_row_advtab"), Sa = ms("table_advtab"), Mu = ms("table_appearance_options"), sm = ms("table_grid"), Sl = ms("table_style_by_css"), xl = ms("table_cell_class_list"), Bi = ms("table_row_class_list"), ru = ms("table_class_list"), Ba = ms("table_toolbar"), sf = ms("table_background_color_map"), jl = ms("table_border_color_map"), dd = (k) => Na(k) === "fixed", Nu = (k) => Na(k) === "responsive", fd = (k) => {
    const S = k.options, P = S.get("table_default_styles");
    return S.isSet("table_default_styles") ? P : su(k, P);
  }, Bu = (k) => {
    const S = k.options, P = S.get("table_default_attributes");
    return S.isSet("table_default_attributes") ? P : fc(k, P);
  }, Tl = (k) => k.nodeName.toLowerCase(), og = (k) => yn.fromDom(k.getBody()), $u = (k) => (S) => Zs(S, og(k)), rf = (k) => k ? k.replace(/px$/, "") : "", mc = (k) => /^\d+(\.\d+)?$/.test(k) ? k + "px" : k, af = (k) => yn.fromDom(k.selection.getStart()), be = (k) => yn.fromDom(k.selection.getEnd()), Pu = (k, S) => S.column >= k.startCol && S.column + S.colspan - 1 <= k.finishCol && S.row >= k.startRow && S.row + S.rowspan - 1 <= k.finishRow, El = (k, S) => {
    let P = !0;
    const q = ie(Pu, S);
    for (let ge = S.startRow; ge <= S.finishRow; ge++)
      for (let Ze = S.startCol; Ze <= S.finishCol; Ze++)
        P = P && hs.getAt(k, ge, Ze).exists(q);
    return P ? Re.some(S) : Re.none();
  }, cf = (k, S) => So(Math.min(k.row, S.row), Math.min(k.column, S.column), Math.max(k.row + k.rowspan - 1, S.row + S.rowspan - 1), Math.max(k.column + k.colspan - 1, S.column + S.colspan - 1)), wy = (k, S, P) => {
    const q = hs.findItem(k, S, Zs), ge = hs.findItem(k, P, Zs);
    return q.bind((Ze) => ge.map((St) => cf(Ze, St)));
  }, sg = (k, S, P) => wy(k, S, P).bind((q) => El(k, q)), Is = (k, S, P) => {
    const q = ya(k);
    return sg(q, S, P);
  }, ya = hs.fromTable, Ul = (k, S) => {
    Xo(k).each((q) => {
      q.dom.insertBefore(S.dom, k.dom);
    });
  }, ii = (k, S) => {
    Ss(k).fold(() => {
      Xo(k).each((ge) => {
        $i(ge, S);
      });
    }, (q) => {
      Ul(q, S);
    });
  }, rm = (k, S) => {
    Ra(k).fold(() => {
      $i(k, S);
    }, (q) => {
      k.dom.insertBefore(S.dom, q.dom);
    });
  }, $i = (k, S) => {
    k.dom.appendChild(S.dom);
  }, ec = (k, S) => {
    Ul(k, S), $i(S, k);
  }, am = (k, S) => {
    Mn(S, (P, q) => {
      const ge = q === 0 ? k : S[q - 1];
      ii(ge, P);
    });
  }, rg = (k, S) => {
    Mn(S, (P) => {
      $i(k, P);
    });
  }, cm = (k) => {
    const S = k.dom;
    S.parentNode !== null && S.parentNode.removeChild(S);
  }, sl = (k) => {
    const S = ir(k);
    S.length > 0 && am(k, S), cm(k);
  }, uf = ((k, S) => {
    const P = (Ze) => {
      if (!k(Ze))
        throw new Error("Can only get " + S + " value of a " + S + " node");
      return q(Ze).getOr("");
    }, q = (Ze) => k(Ze) ? Re.from(Ze.dom.nodeValue) : Re.none();
    return {
      get: P,
      getOption: q,
      set: (Ze, St) => {
        if (!k(Ze))
          throw new Error("Can only set raw " + S + " value of a " + S + " node");
        Ze.dom.nodeValue = St;
      }
    };
  })(we, "text"), Ec = (k) => uf.get(k), Qr = (k, S) => uf.set(k, S);
  var au = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], md = () => {
    const k = (Fo) => yn.fromDom(Fo.dom.cloneNode(!1)), S = (Fo) => Tr(Fo).dom, P = (Fo) => Qs(Fo) ? Ln(Fo) === "body" ? !0 : _o(au, Ln(Fo)) : !1, q = (Fo) => Qs(Fo) ? _o([
      "br",
      "img",
      "hr",
      "input"
    ], Ln(Fo)) : !1, ge = (Fo) => Qs(Fo) && Nt(Fo, "contenteditable") === "false", Ze = (Fo, Rr) => Fo.dom.compareDocumentPosition(Rr.dom), St = (Fo, Rr) => {
      const ks = On(Fo);
      zt(Rr, ks);
    }, jt = (Fo) => {
      const Rr = Ln(Fo);
      return _o([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], Rr);
    }, mo = (Fo) => Qs(Fo) ? on(Fo, "lang") : Re.none();
    return {
      up: At({
        selector: yr,
        closest: me,
        predicate: Bn,
        all: Gn
      }),
      down: At({
        selector: Co,
        predicate: Rn
      }),
      styles: At({
        get: Xa,
        getRaw: Ja,
        set: aa,
        remove: li
      }),
      attrs: At({
        get: Nt,
        set: Lt,
        remove: Yt,
        copyTo: St
      }),
      insert: At({
        before: Ul,
        after: ii,
        afterAll: am,
        append: $i,
        appendAll: rg,
        prepend: rm,
        wrap: ec
      }),
      remove: At({
        unwrap: sl,
        remove: cm
      }),
      create: At({
        nu: yn.fromTag,
        clone: k,
        text: yn.fromText
      }),
      query: At({
        comparePosition: Ze,
        prevSibling: er,
        nextSibling: Ss
      }),
      property: At({
        children: ir,
        name: Ln,
        parent: Xo,
        document: S,
        isText: we,
        isComment: Os,
        isElement: Qs,
        isSpecial: jt,
        getLanguage: mo,
        getText: Ec,
        setText: Qr,
        isBoundary: P,
        isEmptyTag: q,
        isNonEditable: ge
      }),
      eq: Zs,
      is: hr
    };
  };
  const rl = (k, S, P, q) => {
    const ge = P[0], Ze = P.slice(1);
    return q(k, S, ge, Ze);
  }, al = (k, S, P) => P.length > 0 ? rl(k, S, P, lm) : Re.none(), lm = (k, S, P, q) => {
    const ge = S(k, P);
    return en(q, (Ze, St) => {
      const jt = S(k, St);
      return im(k, Ze, jt);
    }, ge);
  }, im = (k, S, P) => S.bind((q) => P.filter(ie(k.eq, q))), df = al, E = md(), M = (k, S) => df(E, (P, q) => k(q), S), H = (k) => yr(k, "table"), ye = (k, S) => {
    const P = Co(k, S);
    return P.length > 0 ? Re.some(P) : Re.none();
  }, ze = (k, S, P) => se(k, S).bind((q) => se(k, P).bind((ge) => M(H, [
    q,
    ge
  ]).map((Ze) => ({
    first: q,
    last: ge,
    table: Ze
  })))), sn = (k, S) => ye(k, S), Yn = (k, S, P) => ze(k, S, P).bind((q) => {
    const ge = (mo) => Zs(k, mo), Ze = "thead,tfoot,tbody,table", St = yr(q.first, Ze, ge), jt = yr(q.last, Ze, ge);
    return St.bind((mo) => jt.bind((Fo) => Zs(mo, Fo) ? Is(q.table, q.first, q.last) : Re.none()));
  }), xo = (k) => Dn(k, yn.fromDom), Zo = "data-mce-selected", jo = "td[" + Zo + "],th[" + Zo + "]", ws = "data-mce-first-selected", Or = "td[" + ws + "],th[" + ws + "]", Gr = "data-mce-last-selected", ui = "td[" + Gr + "],th[" + Gr + "]", gd = {
    selected: Zo,
    selectedSelector: jo,
    firstSelected: ws,
    firstSelectedSelector: Or,
    lastSelected: Gr,
    lastSelectedSelector: ui
  }, Ip = (k) => Vo(k).bind((S) => sn(S, gd.firstSelectedSelector)).fold(At(k), (S) => S[0]), Lp = (k) => (S, P) => {
    const q = Ln(S), ge = q === "col" || q === "colgroup" ? Ip(S) : S;
    return me(ge, k, P);
  }, yo = Lp("th,td,caption"), Mr = Lp("th,td"), cl = (k) => xo(k.model.table.getSelectedCells()), _y = (k, S) => {
    const P = Mr(k), q = P.bind((ge) => Vo(ge)).map((ge) => ha(ge));
    return zo(P, q, (ge, Ze) => gt(Ze, (St) => Fn(xo(St.dom.cells), (jt) => Nt(jt, S) === "1" || Zs(jt, ge)))).getOr([]);
  }, Kr = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], Cy = (k) => ({ value: k }), um = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Fu = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, ff = (k) => um.test(k) || Fu.test(k), Gs = (k) => Lo(k, "#").toUpperCase(), $a = (k) => ff(k) ? Re.some({ value: Gs(k) }) : Re.none(), Al = (k) => {
    const S = k.toString(16);
    return (S.length === 1 ? "0" + S : S).toUpperCase();
  }, vs = (k) => {
    const S = Al(k.red) + Al(k.green) + Al(k.blue);
    return Cy(S);
  }, ag = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, mf = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, dm = (k, S, P, q) => ({
    red: k,
    green: S,
    blue: P,
    alpha: q
  }), Iu = (k, S, P, q) => {
    const ge = parseInt(k, 10), Ze = parseInt(S, 10), St = parseInt(P, 10), jt = parseFloat(q);
    return dm(ge, Ze, St, jt);
  }, cg = (k) => {
    if (k === "transparent")
      return Re.some(dm(0, 0, 0, 0));
    const S = ag.exec(k);
    if (S !== null)
      return Re.some(Iu(S[1], S[2], S[3], "1"));
    const P = mf.exec(k);
    return P !== null ? Re.some(Iu(P[1], P[2], P[3], P[4])) : Re.none();
  }, Sy = (k) => $a(k).orThunk(() => cg(k).map(vs)).getOrThunk(() => {
    const S = document.createElement("canvas");
    S.height = 1, S.width = 1;
    const P = S.getContext("2d");
    P.clearRect(0, 0, S.width, S.height), P.fillStyle = "#FFFFFF", P.fillStyle = k, P.fillRect(0, 0, 1, 1);
    const q = P.getImageData(0, 0, 1, 1).data, ge = q[0], Ze = q[1], St = q[2], jt = q[3];
    return vs(dm(ge, Ze, St, jt));
  }), sr = (k) => cg(k).map(vs).map((S) => "#" + S.value).getOr(k), fm = (k) => {
    let S = k;
    return {
      get: () => S,
      set: (ge) => {
        S = ge;
      }
    };
  }, di = (k) => {
    const S = fm(Re.none()), P = () => S.get().each(k);
    return {
      clear: () => {
        P(), S.set(Re.none());
      },
      isSet: () => S.get().isSome(),
      get: () => S.get(),
      set: (jt) => {
        P(), S.set(Re.some(jt));
      }
    };
  }, gf = () => di((k) => k.unbind()), Lu = (k, S, P) => (q) => {
    const ge = gf(), Ze = pa(P), St = () => {
      const jt = cl(k), mo = (Fo) => k.formatter.match(S, { value: P }, Fo.dom, Ze);
      Ze ? (q.setActive(!Fn(jt, mo)), ge.set(k.formatter.formatChanged(S, (Fo) => q.setActive(!Fo), !0))) : (q.setActive(ae(jt, mo)), ge.set(k.formatter.formatChanged(S, q.setActive, !1, { value: P })));
    };
    return k.initialized ? St() : k.on("init", St), ge.clear;
  }, lg = (k) => Pe(k, "menu"), cu = (k) => Dn(k, (S) => {
    const P = S.text || S.title;
    return lg(S) ? {
      text: P,
      items: cu(S.menu)
    } : {
      text: P,
      value: S.value
    };
  }), pf = (k, S, P, q) => Dn(S, (ge) => {
    const Ze = ge.text || ge.title;
    return lg(ge) ? {
      type: "nestedmenuitem",
      text: Ze,
      getSubmenuItems: () => pf(k, ge.menu, P, q)
    } : {
      text: Ze,
      type: "togglemenuitem",
      onAction: () => q(ge.value),
      onSetup: Lu(k, P, ge.value)
    };
  }), pd = (k, S) => (P) => {
    k.execCommand("mceTableApplyCellStyle", !1, { [S]: P });
  }, Po = (k) => Oe(k, (S) => lg(S) ? [{
    ...S,
    menu: Po(S.menu)
  }] : nl(S.value) ? [S] : []), hd = (k, S, P, q) => (ge) => ge(pf(k, S, P, q)), mm = (k, S, P) => {
    const q = Dn(S, (ge) => ({
      text: ge.title,
      value: "#" + Sy(ge.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: q.length > 0 ? q : void 0,
        allowCustomColors: !1
      },
      onAction: (ge) => {
        const Ze = ge.value === "remove" ? "" : ge.value;
        k.execCommand("mceTableApplyCellStyle", !1, { [P]: Ze });
      }
    }];
  }, ig = (k) => () => {
    const P = k.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    k.execCommand("mceTableRowType", !1, { type: P });
  }, gm = (k) => () => {
    const P = k.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    k.execCommand("mceTableColType", !1, { type: P });
  }, Hp = (k) => {
    const S = cu(xl(k));
    return S.length > 0 ? Re.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: S
    }) : Re.none();
  }, fi = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "height",
      type: "input",
      label: "Height"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: Kr
    }
  ], hf = (k) => fi.concat(Hp(k).toArray()), Vn = (k, S) => {
    const q = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat(cu(Ni(k)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ], Ze = S === "cell" ? [{
      name: "borderwidth",
      type: "input",
      label: "Border width"
    }].concat(q) : q;
    return {
      title: "Advanced",
      name: "advanced",
      items: Ze
    };
  }, yf = { normal: (k, S) => {
    const P = k.dom;
    return {
      setAttrib: (St, jt) => {
        P.setAttrib(S, St, jt);
      },
      setStyle: (St, jt) => {
        P.setStyle(S, St, jt);
      },
      setFormat: (St, jt) => {
        jt === "" ? k.formatter.remove(St, { value: null }, S, !0) : k.formatter.apply(St, { value: jt }, S);
      }
    };
  } }, Vp = Jt("th"), ll = (k, S) => k && S ? "sectionCells" : k ? "section" : "cells", Hu = (k) => {
    const S = k.section === "thead", P = os(ug(k.cells), "th");
    return k.section === "tfoot" ? { type: "footer" } : S || P ? {
      type: "header",
      subType: ll(S, P)
    } : { type: "body" };
  }, ug = (k) => {
    const S = gt(k, (P) => Vp(P.element));
    return S.length === 0 ? Re.some("td") : S.length === k.length ? Re.some("th") : Re.none();
  }, mi = (k) => {
    const S = Dn(k, (ge) => Hu(ge).type), P = _o(S, "header"), q = _o(S, "footer");
    if (!P && !q)
      return Re.some("body");
    {
      const ge = _o(S, "body");
      return P && !ge && !q ? Re.some("header") : !P && !ge && q ? Re.some("footer") : Re.none();
    }
  }, xy = (k) => {
    let S = !1, P;
    return (...q) => (S || (S = !0, P = k.apply(null, q)), P);
  }, pm = (k, S) => ct(k.all, (P) => We(P.cells, (q) => Zs(S, q.element))), rn = (k, S, P) => {
    const q = Dn(S.selection, (Ze) => Jr(Ze).bind((St) => pm(k, St)).filter(P)), ge = $s(q);
    return sa(ge.length > 0, ge);
  }, Ty = (k, S) => S.mergable, jp = (k, S) => S.unmergable, hm = (k, S) => rn(k, S, _t), gc = (k, S) => pm(k, S).exists((P) => !P.isLocked), Pn = (k, S) => ae(S, (P) => gc(k, P)), Cr = (k, S) => Ty(k, S).filter((P) => Pn(k, P.cells)), Up = (k, S) => jp(k, S).filter((P) => Pn(k, P));
  ({ ...{ generate: (k) => {
    if (!Kt(k))
      throw new Error("cases must be an array");
    if (k.length === 0)
      throw new Error("there must be at least one case");
    const S = [], P = {};
    return Mn(k, (q, ge) => {
      const Ze = oe(q);
      if (Ze.length !== 1)
        throw new Error("one and only one name per case");
      const St = Ze[0], jt = q[St];
      if (P[St] !== void 0)
        throw new Error("duplicate key detected:" + St);
      if (St === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Kt(jt))
        throw new Error("case arguments must be an array");
      S.push(St), P[St] = (...mo) => {
        const Fo = mo.length;
        if (Fo !== jt.length)
          throw new Error("Wrong number of arguments to case " + St + ". Expected " + jt.length + " (" + jt + "), got " + Fo);
        return {
          fold: (...ks) => {
            if (ks.length !== k.length)
              throw new Error("Wrong number of arguments to fold. Expected " + k.length + ", got " + ks.length);
            return ks[ge].apply(null, mo);
          },
          match: (ks) => {
            const vr = oe(ks);
            if (S.length !== vr.length)
              throw new Error("Wrong number of arguments to match. Expected: " + S.join(",") + `
Actual: ` + vr.join(","));
            if (!ae(S, (Fa) => _o(vr, Fa)))
              throw new Error("Not all branches were specified when using match. Specified: " + vr.join(", ") + `
Required: ` + S.join(", "));
            return ks[St].apply(null, mo);
          },
          log: (ks) => {
            console.log(ks, {
              constructors: S,
              constructor: St,
              params: mo
            });
          }
        };
      };
    }), P;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const Wp = (k, S) => {
    const P = hs.fromTable(k);
    return hm(P, S).bind((ge) => {
      const Ze = ge[ge.length - 1], St = ge[0].row, jt = Ze.row + Ze.rowspan, mo = P.all.slice(St, jt);
      return mi(mo);
    }).getOr("");
  }, Pi = (k) => br(k, "rgb") ? sr(k) : k, Pr = (k) => {
    const S = yn.fromDom(k);
    return {
      borderwidth: Ja(S, "border-width").getOr(""),
      borderstyle: Ja(S, "border-style").getOr(""),
      bordercolor: Ja(S, "border-color").map(Pi).getOr(""),
      backgroundcolor: Ja(S, "background-color").map(Pi).getOr("")
    };
  }, bf = (k) => {
    const S = k[0], P = k.slice(1);
    return Mn(P, (q) => {
      Mn(oe(S), (ge) => {
        rt(q, (Ze, St) => {
          const jt = S[ge];
          jt !== "" && ge === St && jt !== Ze && (S[ge] = "");
        });
      });
    }), S;
  }, dg = (k, S, P, q) => We(k, (ge) => !$t(P.formatter.matchNode(q, S + ge))).getOr(""), ym = ie(dg, [
    "left",
    "center",
    "right"
  ], "align"), vf = ie(dg, [
    "top",
    "middle",
    "bottom"
  ], "valign"), bd = (k, S) => {
    const P = fd(k), q = Bu(k), ge = () => ({
      borderstyle: Qe(P, "border-style").getOr(""),
      bordercolor: Pi(Qe(P, "border-color").getOr("")),
      backgroundcolor: Pi(Qe(P, "background-color").getOr(""))
    }), Ze = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, St = () => {
      const Rr = P["border-width"];
      return Sl(k) && Rr ? { border: Rr } : Qe(q, "border").fold(() => ({}), (ks) => ({ border: ks }));
    }, jt = S ? ge() : {}, mo = () => {
      const Rr = Qe(P, "border-spacing").or(Qe(q, "cellspacing")).fold(() => ({}), (vr) => ({ cellspacing: vr })), ks = Qe(P, "border-padding").or(Qe(q, "cellpadding")).fold(() => ({}), (vr) => ({ cellpadding: vr }));
      return {
        ...Rr,
        ...ks
      };
    };
    return {
      ...Ze,
      ...P,
      ...q,
      ...jt,
      ...St(),
      ...mo()
    };
  }, fg = (k) => Vo(yn.fromDom(k)).map((S) => {
    const P = { selection: xo(k.cells) };
    return Wp(S, P);
  }).getOr(""), x1 = (k, S, P) => {
    const q = (jt, mo) => {
      const Fo = Ja(yn.fromDom(mo), "border-width");
      return Sl(k) && Fo.isSome() ? Fo.getOr("") : jt.getAttrib(mo, "border") || qs(k.dom, mo, "border-width") || qs(k.dom, mo, "border");
    }, ge = k.dom, Ze = Sl(k) ? ge.getStyle(S, "border-spacing") || ge.getAttrib(S, "cellspacing") : ge.getAttrib(S, "cellspacing") || ge.getStyle(S, "border-spacing"), St = Sl(k) ? qs(ge, S, "padding") || ge.getAttrib(S, "cellpadding") : ge.getAttrib(S, "cellpadding") || qs(ge, S, "padding");
    return {
      width: ge.getStyle(S, "width") || ge.getAttrib(S, "width"),
      height: ge.getStyle(S, "height") || ge.getAttrib(S, "height"),
      cellspacing: Ze,
      cellpadding: St,
      border: q(ge, S),
      caption: !!ge.select("caption", S)[0],
      class: ge.getAttrib(S, "class", ""),
      align: ym(k, S),
      ...P ? Pr(S) : {}
    };
  }, kf = (k, S, P) => {
    const q = k.dom;
    return {
      height: q.getStyle(S, "height") || q.getAttrib(S, "height"),
      class: q.getAttrib(S, "class", ""),
      type: fg(S),
      align: ym(k, S),
      ...P ? Pr(S) : {}
    };
  }, vd = (k, S, P, q) => {
    const ge = k.dom, Ze = q.getOr(S), St = (jt, mo) => ge.getStyle(jt, mo) || ge.getAttrib(jt, mo);
    return {
      width: St(Ze, "width"),
      height: St(S, "height"),
      scope: ge.getAttrib(S, "scope"),
      celltype: Tl(S),
      class: ge.getAttrib(S, "class", ""),
      halign: ym(k, S),
      valign: vf(k, S),
      ...P ? Pr(S) : {}
    };
  }, kd = (k, S) => {
    const P = hs.fromTable(k), q = hs.justCells(P), ge = gt(q, (Ze) => Fn(S, (St) => Zs(Ze.element, St)));
    return Dn(ge, (Ze) => ({
      element: Ze.element.dom,
      column: hs.getColumnAt(P, Ze.column).map((St) => St.element.dom)
    }));
  }, Js = (k, S, P, q) => {
    q("scope") && k.setAttrib("scope", P.scope), q("class") && k.setAttrib("class", P.class), q("height") && k.setStyle("height", mc(P.height)), q("width") && S.setStyle("width", mc(P.width));
  }, gi = (k, S, P) => {
    P("backgroundcolor") && k.setFormat("tablecellbackgroundcolor", S.backgroundcolor), P("bordercolor") && k.setFormat("tablecellbordercolor", S.bordercolor), P("borderstyle") && k.setFormat("tablecellborderstyle", S.borderstyle), P("borderwidth") && k.setFormat("tablecellborderwidth", mc(S.borderwidth));
  }, Vc = (k, S, P, q) => {
    const ge = S.length === 1;
    Mn(S, (Ze) => {
      const St = Ze.element, jt = ge ? _t : q, mo = yf.normal(k, St), Fo = Ze.column.map((Rr) => yf.normal(k, Rr)).getOr(mo);
      Js(mo, Fo, P, jt), $r(k) && gi(mo, P, jt), q("halign") && Hc(k, St, P.halign), q("valign") && as(k, St, P.valign);
    });
  }, wd = (k, S) => {
    k.execCommand("mceTableCellType", !1, {
      type: S.celltype,
      no_events: !0
    });
  }, rr = (k, S, P, q) => {
    const ge = wn(q, (Ze, St) => P[St] !== Ze);
    Se(ge) > 0 && S.length >= 1 && Vo(S[0]).each((Ze) => {
      const St = kd(Ze, S), jt = Se(wn(ge, (Fo, Rr) => Rr !== "scope" && Rr !== "celltype")) > 0, mo = z(ge, "celltype");
      (jt || z(ge, "scope")) && Vc(k, St, q, ie(z, ge)), mo && wd(k, q), G(k, Ze.dom, {
        structure: mo,
        style: jt
      });
    });
  }, T1 = (k, S, P, q) => {
    const ge = q.getData();
    q.close(), k.undoManager.transact(() => {
      rr(k, S, P, ge), k.focus();
    });
  }, ba = (k, S) => {
    const P = Vo(S[0]).map((q) => Dn(kd(q, S), (ge) => vd(k, ge.element, $r(k), ge.column)));
    return bf(P.getOrDie());
  }, va = (k) => {
    const S = cl(k);
    if (S.length === 0)
      return;
    const P = ba(k, S), q = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: hf(k)
        },
        Vn(k, "cell")
      ]
    }, ge = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: hf(k)
      }]
    };
    k.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: $r(k) ? q : ge,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: P,
      onSubmit: ie(T1, k, S, P)
    });
  }, Zp = (k) => {
    const S = cu(Bi(k));
    return S.length > 0 ? Re.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: S
    }) : Re.none();
  }, ut = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], Ac = (k) => ut.concat(Zp(k).toArray()), Ey = (k, S, P) => {
    P("class") && k.setAttrib("class", S.class), P("height") && k.setStyle("height", mc(S.height));
  }, la = (k, S, P) => {
    P("backgroundcolor") && k.setStyle("background-color", S.backgroundcolor), P("bordercolor") && k.setStyle("border-color", S.bordercolor), P("borderstyle") && k.setStyle("border-style", S.borderstyle);
  }, bm = (k, S, P, q) => {
    const Ze = S.length === 1 ? _t : q;
    Mn(S, (St) => {
      const jt = yf.normal(k, St);
      Ey(jt, P, Ze), Cl(k) && la(jt, P, Ze), q("align") && Hc(k, St, P.align);
    });
  }, Vu = (k, S) => {
    k.execCommand("mceTableRowType", !1, {
      type: S.type,
      no_events: !0
    });
  }, xa = (k, S, P, q) => {
    const ge = wn(q, (Ze, St) => P[St] !== Ze);
    if (Se(ge) > 0) {
      const Ze = z(ge, "type"), St = Ze ? Se(ge) > 1 : !0;
      St && bm(k, S, q, ie(z, ge)), Ze && Vu(k, q), Vo(yn.fromDom(S[0])).each((jt) => G(k, jt.dom, {
        structure: Ze,
        style: St
      }));
    }
  }, E1 = (k, S, P, q) => {
    const ge = q.getData();
    q.close(), k.undoManager.transact(() => {
      xa(k, S, P, ge), k.focus();
    });
  }, Fi = (k) => {
    const S = _y(af(k), gd.selected);
    if (S.length === 0)
      return;
    const P = Dn(S, (St) => kf(k, St.dom, Cl(k))), q = bf(P), ge = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Ac(k)
        },
        Vn(k, "row")
      ]
    }, Ze = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Ac(k)
      }]
    };
    k.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: Cl(k) ? ge : Ze,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: q,
      onSubmit: ie(E1, k, Dn(S, (St) => St.dom), q)
    });
  }, _d = (k, S, P) => {
    const q = P ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], ge = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], Ze = Mu(k) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], St = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], jt = S.length > 0 ? [{
      type: "listbox",
      name: "class",
      label: "Class",
      items: S
    }] : [];
    return q.concat(ge).concat(Ze).concat(St).concat(jt);
  }, jc = (k, S, P, q) => {
    if (S.tagName === "TD" || S.tagName === "TH")
      ho(P) ? k.setStyle(S, P, q) : k.setStyles(S, P);
    else if (S.children)
      for (let ge = 0; ge < S.children.length; ge++)
        jc(k, S.children[ge], P, q);
  }, xs = (k, S, P) => {
    const q = k.dom, ge = {}, Ze = {};
    if (ge.class = P.class, Ze.height = mc(P.height), Sl(k) ? Ze.width = mc(P.width) : q.getAttrib(S, "width") && (ge.width = rf(P.width)), Sl(k) ? (Ze["border-width"] = mc(P.border), Ze["border-spacing"] = mc(P.cellspacing)) : (ge.border = P.border, ge.cellpadding = P.cellpadding, ge.cellspacing = P.cellspacing), Sl(k) && S.children)
      for (let St = 0; St < S.children.length; St++)
        jc(q, S.children[St], {
          "border-width": mc(P.border),
          padding: mc(P.cellpadding)
        }), Sa(k) && jc(q, S.children[St], { "border-color": P.bordercolor });
    Sa(k) && (Ze["background-color"] = P.backgroundcolor, Ze["border-color"] = P.bordercolor, Ze["border-style"] = P.borderstyle), ge.style = q.serializeStyle({
      ...fd(k),
      ...Ze
    }), q.setAttribs(S, {
      ...Bu(k),
      ...ge
    });
  }, zl = (k, S, P, q) => {
    const ge = k.dom, Ze = q.getData(), St = wn(Ze, (jt, mo) => P[mo] !== jt);
    q.close(), Ze.class === "" && delete Ze.class, k.undoManager.transact(() => {
      if (!S) {
        const jt = parseInt(Ze.cols, 10) || 1, mo = parseInt(Ze.rows, 10) || 1;
        k.execCommand("mceInsertTable", !1, {
          rows: mo,
          columns: jt
        }), S = Mr(af(k), $u(k)).bind((Fo) => Vo(Fo, $u(k))).map((Fo) => Fo.dom).getOrUndefined();
      }
      if (Se(St) > 0) {
        xs(k, S, Ze);
        const jt = ge.select("caption", S)[0];
        (jt && !Ze.caption || !jt && Ze.caption) && k.execCommand("mceTableToggleCaption"), Hc(k, S, Ze.align);
      }
      if (k.focus(), k.addVisual(), Se(St) > 0) {
        const jt = z(St, "caption"), mo = jt ? Se(St) > 1 : !0;
        G(k, S, {
          structure: jt,
          style: mo
        });
      }
    });
  }, wf = (k, S) => {
    const P = k.dom;
    let q, ge = bd(k, Sa(k));
    S === !1 ? (q = P.getParent(k.selection.getStart(), "table", k.getBody()), q ? ge = x1(k, q, Sa(k)) : Sa(k) && (ge.borderstyle = "", ge.bordercolor = "", ge.backgroundcolor = "")) : (ge.cols = "1", ge.rows = "1", Sa(k) && (ge.borderstyle = "", ge.bordercolor = "", ge.backgroundcolor = ""));
    const Ze = cu(ru(k));
    Ze.length > 0 && ge.class && (ge.class = ge.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const St = {
      type: "grid",
      columns: 2,
      items: _d(k, Ze, S)
    }, jt = () => ({
      type: "panel",
      items: [St]
    }), mo = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [St]
        },
        Vn(k, "table")
      ]
    }), Fo = Sa(k) ? mo() : jt();
    k.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: Fo,
      onSubmit: ie(zl, k, q, ge),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: ge
    });
  }, pc = (k) => {
    rt({
      mceTableProps: ie(wf, k, !1),
      mceTableRowProps: ie(Fi, k),
      mceTableCellProps: ie(va, k)
    }, (S, P) => k.addCommand(P, () => S())), k.addCommand("mceInsertTableDialog", (S) => {
      wf(k, !0);
    });
  }, vm = (k, S) => bt(k, S).isSome(), _f = He, mg = (k) => {
    const S = (q, ge) => on(q, ge).exists((Ze) => parseInt(Ze, 10) > 1), P = (q) => S(q, "rowspan") || S(q, "colspan");
    return k.length > 0 && ae(k, P) ? Re.some(k) : Re.none();
  }, zc = (k, S, P) => S.length <= 1 ? Re.none() : Yn(k, P.firstSelectedSelector, P.lastSelectedSelector).map((q) => ({
    bounds: q,
    cells: S
  })), km = (k) => ({
    element: k,
    mergable: Re.none(),
    unmergable: Re.none(),
    selection: [k]
  }), Te = (k, S, P) => ({
    element: P,
    mergable: zc(S, k, gd),
    unmergable: mg(k),
    selection: _f(k)
  }), Uc = (k) => {
    const S = fm(Re.none()), P = fm([]);
    let q = Re.none();
    const ge = Jt("caption"), Ze = (Do) => q.forall((dr) => !dr[Do]), St = () => yo(af(k), $u(k)), jt = () => yo(be(k), $u(k)), mo = () => St().bind((Do) => Ya(zo(Vo(Do), jt().bind(Vo), (dr, Br) => Zs(dr, Br) ? ge(Do) ? Re.some(km(Do)) : Re.some(Te(cl(k), dr, Do)) : Re.none()))), Fo = (Do) => Vo(Do.element).map((Br) => {
      const Ta = hs.fromTable(Br), z1 = hm(Ta, Do).getOr([]), xd = Pt(z1, (Li, Zc) => (Zc.isLocked && (Li.onAny = !0, Zc.column === 0 ? Li.onFirst = !0 : Zc.column + Zc.colspan >= Ta.grid.columns && (Li.onLast = !0)), Li), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: Cr(Ta, Do).isSome(),
        unmergeable: Up(Ta, Do).isSome(),
        locked: xd
      };
    }), Rr = () => {
      S.set(xy(mo)()), q = S.get().bind(Fo), Mn(P.get(), (Do) => Do());
    }, ks = (Do) => (Do(), P.set(P.get().concat([Do])), () => {
      P.set(gt(P.get(), (dr) => dr !== Do));
    }), vr = (Do, dr) => ks(() => S.get().fold(() => {
      Do.setEnabled(!1);
    }, (Br) => {
      Do.setEnabled(!dr(Br));
    })), hc = (Do, dr, Br) => ks(() => S.get().fold(() => {
      Do.setEnabled(!1), Do.setActive(!1);
    }, (Ta) => {
      Do.setEnabled(!dr(Ta)), Do.setActive(Br(Ta));
    })), Fa = (Do) => q.exists((dr) => dr.locked[Do]), iu = (Do) => vr(Do, (dr) => !1), Ii = (Do) => vr(Do, (dr) => ge(dr.element)), pg = (Do) => (dr) => vr(dr, (Br) => ge(Br.element) || Fa(Do)), wm = (Do) => (dr) => vr(dr, (Br) => ge(Br.element) || Do().isNone()), Nr = (Do, dr) => (Br) => vr(Br, (Ta) => ge(Ta.element) || Do().isNone() || Fa(dr)), Wc = (Do) => vr(Do, (dr) => Ze("mergeable")), Uu = (Do) => vr(Do, (dr) => Ze("unmergeable")), uu = (Do) => hc(Do, dn, (dr) => Vo(dr.element, $u(k)).exists((Ta) => vm(Ta, "caption"))), Cf = (Do, dr) => (Br) => hc(Br, (Ta) => ge(Ta.element), () => k.queryCommandValue(Do) === dr), ql = Cf("mceTableRowType", "header"), hg = Cf("mceTableColType", "th");
    return k.on("NodeChange ExecCommand TableSelectorChange", Rr), {
      onSetupTable: iu,
      onSetupCellOrRow: Ii,
      onSetupColumn: pg,
      onSetupPasteable: wm,
      onSetupPasteableColumn: Nr,
      onSetupMergeable: Wc,
      onSetupUnmergeable: Uu,
      resetTargets: Rr,
      onSetupTableWithCaption: uu,
      onSetupTableRowHeaders: ql,
      onSetupTableColumnHeaders: hg,
      targets: S.get
    };
  };
  var gg = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const lu = "x-tinymce/dom-table-", ia = lu + "rows", Oc = lu + "columns", Fr = (k) => {
    var S;
    const P = (S = gg.read()) !== null && S !== void 0 ? S : [];
    return ct(P, (q) => Re.from(q.getType(k)));
  }, Cd = () => Fr(ia), ju = () => Fr(Oc), qp = (k, S) => {
    k.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      fetch: (jt) => jt("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const P = (jt) => () => k.execCommand(jt), q = (jt, mo) => {
      k.queryCommandSupported(mo.command) && k.ui.registry.addButton(jt, {
        ...mo,
        onAction: tn(mo.onAction) ? mo.onAction : P(mo.command)
      });
    }, ge = (jt, mo) => {
      k.queryCommandSupported(mo.command) && k.ui.registry.addToggleButton(jt, {
        ...mo,
        onAction: tn(mo.onAction) ? mo.onAction : P(mo.command)
      });
    };
    q("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: S.onSetupTable
    }), q("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: S.onSetupTable
    }), q("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: S.onSetupCellOrRow
    }), q("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: S.onSetupMergeable
    }), q("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: S.onSetupUnmergeable
    }), q("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: S.onSetupCellOrRow
    }), q("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: S.onSetupCellOrRow
    }), q("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: S.onSetupCellOrRow
    }), q("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: S.onSetupCellOrRow
    }), q("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: S.onSetupColumn("onFirst")
    }), q("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: S.onSetupColumn("onLast")
    }), q("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: S.onSetupColumn("onAny")
    }), q("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: S.onSetupCellOrRow
    }), q("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: S.onSetupCellOrRow
    }), q("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: S.onSetupPasteable(Cd)
    }), q("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: S.onSetupPasteable(Cd)
    }), q("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: S.onSetupColumn("onAny")
    }), q("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: S.onSetupColumn("onAny")
    }), q("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: S.onSetupPasteableColumn(ju, "onFirst")
    }), q("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: S.onSetupPasteableColumn(ju, "onLast")
    }), q("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table"
    });
    const Ze = Po(ru(k));
    Ze.length !== 0 && k.queryCommandSupported("mceTableToggleClass") && k.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: hd(k, Ze, "tableclass", (jt) => k.execCommand("mceTableToggleClass", !1, jt)),
      onSetup: S.onSetupTable
    });
    const St = Po(xl(k));
    St.length !== 0 && k.queryCommandSupported("mceTableCellToggleClass") && k.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: hd(k, St, "tablecellclass", (jt) => k.execCommand("mceTableCellToggleClass", !1, jt)),
      onSetup: S.onSetupCellOrRow
    }), k.queryCommandSupported("mceTableApplyCellStyle") && (k.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: hd(k, Kr, "tablecellverticalalign", pd(k, "vertical-align")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: hd(k, _l(k), "tablecellborderwidth", pd(k, "border-width")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: hd(k, Ni(k), "tablecellborderstyle", pd(k, "border-style")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: (jt) => jt(mm(k, sf(k), "background-color")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: (jt) => jt(mm(k, jl(k), "border-color")),
      onSetup: S.onSetupCellOrRow
    })), ge("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: S.onSetupTableWithCaption
    }), ge("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: ig(k),
      onSetup: S.onSetupTableRowHeaders
    }), ge("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: gm(k),
      onSetup: S.onSetupTableColumnHeaders
    });
  }, Xn = (k) => {
    const S = (q) => k.dom.is(q, "table") && k.getBody().contains(q), P = Ba(k);
    P.length > 0 && k.ui.registry.addContextToolbar("table", {
      predicate: S,
      items: P,
      scope: "node",
      position: "node"
    });
  }, Sd = (k, S) => {
    const P = (ks) => () => k.execCommand(ks), q = (ks, vr) => k.queryCommandSupported(vr.command) ? (k.ui.registry.addMenuItem(ks, {
      ...vr,
      onAction: tn(vr.onAction) ? vr.onAction : P(vr.command)
    }), !0) : !1, ge = (ks, vr) => {
      k.queryCommandSupported(vr.command) && k.ui.registry.addToggleMenuItem(ks, {
        ...vr,
        onAction: tn(vr.onAction) ? vr.onAction : P(vr.command)
      });
    }, Ze = (ks) => {
      k.execCommand("mceInsertTable", !1, {
        rows: ks.numRows,
        columns: ks.numColumns
      });
    }, St = [
      q("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: S.onSetupCellOrRow
      }),
      q("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: S.onSetupCellOrRow
      }),
      q("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: S.onSetupCellOrRow
      }),
      q("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: S.onSetupCellOrRow
      }),
      q("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: S.onSetupCellOrRow
      }),
      q("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: S.onSetupCellOrRow
      }),
      q("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: S.onSetupPasteable(Cd)
      }),
      q("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: S.onSetupPasteable(Cd)
      })
    ], jt = [
      q("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: S.onSetupColumn("onFirst")
      }),
      q("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: S.onSetupColumn("onLast")
      }),
      q("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: S.onSetupColumn("onAny")
      }),
      q("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: S.onSetupColumn("onAny")
      }),
      q("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: S.onSetupColumn("onAny")
      }),
      q("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: S.onSetupPasteableColumn(ju, "onFirst")
      }),
      q("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: S.onSetupPasteableColumn(ju, "onLast")
      })
    ], mo = [
      q("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: S.onSetupCellOrRow
      }),
      q("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: S.onSetupMergeable
      }),
      q("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: S.onSetupUnmergeable
      })
    ];
    sm(k) ? k.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: Ze
      }]
    }) : k.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: P("mceInsertTableDialog")
    }), k.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: P("mceInsertTableDialog")
    }), q("tableprops", {
      text: "Table properties",
      onSetup: S.onSetupTable,
      command: "mceTableProps"
    }), q("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: S.onSetupTable,
      command: "mceTableDelete"
    }), _o(St, !0) && k.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: At("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), _o(jt, !0) && k.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: At("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), _o(mo, !0) && k.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: At("tablecellprops tablemergecells tablesplitcells")
    }), k.ui.registry.addContextMenu("table", {
      update: () => (S.resetTargets(), S.targets().fold(At(""), (ks) => Ln(ks.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const Fo = Po(ru(k));
    Fo.length !== 0 && k.queryCommandSupported("mceTableToggleClass") && k.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => pf(k, Fo, "tableclass", (ks) => k.execCommand("mceTableToggleClass", !1, ks)),
      onSetup: S.onSetupTable
    });
    const Rr = Po(xl(k));
    Rr.length !== 0 && k.queryCommandSupported("mceTableCellToggleClass") && k.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => pf(k, Rr, "tablecellclass", (ks) => k.execCommand("mceTableCellToggleClass", !1, ks)),
      onSetup: S.onSetupCellOrRow
    }), k.queryCommandSupported("mceTableApplyCellStyle") && (k.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => pf(k, Kr, "tablecellverticalalign", pd(k, "vertical-align")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => pf(k, _l(k), "tablecellborderwidth", pd(k, "border-width")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => pf(k, Ni(k), "tablecellborderstyle", pd(k, "border-style")),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => mm(k, sf(k), "background-color"),
      onSetup: S.onSetupCellOrRow
    }), k.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => mm(k, jl(k), "border-color"),
      onSetup: S.onSetupCellOrRow
    })), ge("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: S.onSetupTableWithCaption
    }), ge("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: ig(k),
      onSetup: S.onSetupTableRowHeaders
    }), ge("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: gm(k),
      onSetup: S.onSetupTableRowHeaders
    });
  }, Pa = (k) => {
    const S = Uc(k);
    ur(k), pc(k), Sd(k, S), qp(k, S), Xn(k);
  };
  var A1 = () => {
    ns.add("table", Pa);
  };
  A1();
})();
(function() {
  const ns = (O) => {
    let gt = O;
    return {
      get: () => gt,
      set: (Ne) => {
        gt = Ne;
      }
    };
  };
  var To = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = (O) => ({ addTab: (en) => {
    const Pt = O.get();
    Pt[en.name] = en, O.set(Pt);
  } }), In = (O, gt) => {
    O.addCommand("mceHelp", gt);
  }, Jn = (O) => (gt) => gt.options.get(O), uo = (O) => {
    const gt = O.options.register;
    gt("help_tabs", { processor: "array" });
  }, ho = Jn("help_tabs"), Kt = Jn("forced_plugins"), Bt = (O, gt) => {
    O.ui.registry.addButton("help", {
      icon: "help",
      tooltip: "Help",
      onAction: gt
    }), O.ui.registry.addMenuItem("help", {
      text: "Help",
      icon: "help",
      shortcut: "Alt+0",
      onAction: gt
    });
  }, Un = ((O) => (gt) => O === gt)(void 0), Ao = (O) => O == null, tn = (O) => !Ao(O), an = ((O) => () => O)(!1);
  class Ge {
    constructor(gt, en) {
      this.tag = gt, this.value = en;
    }
    static some(gt) {
      return new Ge(!0, gt);
    }
    static none() {
      return Ge.singletonNone;
    }
    fold(gt, en) {
      return this.tag ? en(this.value) : gt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(gt) {
      return this.tag ? Ge.some(gt(this.value)) : Ge.none();
    }
    bind(gt) {
      return this.tag ? gt(this.value) : Ge.none();
    }
    exists(gt) {
      return this.tag && gt(this.value);
    }
    forall(gt) {
      return !this.tag || gt(this.value);
    }
    filter(gt) {
      return !this.tag || gt(this.value) ? this : Ge.none();
    }
    getOr(gt) {
      return this.tag ? this.value : gt;
    }
    or(gt) {
      return this.tag ? this : gt;
    }
    getOrThunk(gt) {
      return this.tag ? this.value : gt();
    }
    orThunk(gt) {
      return this.tag ? this : gt();
    }
    getOrDie(gt) {
      if (this.tag)
        return this.value;
      throw new Error(gt != null ? gt : "Called getOrDie on None");
    }
    static from(gt) {
      return tn(gt) ? Ge.some(gt) : Ge.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(gt) {
      this.tag && gt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ge.singletonNone = new Ge(!1);
  const At = Array.prototype.indexOf, He = (O, gt) => At.call(O, gt), Ue = (O, gt) => He(O, gt) > -1, ie = (O, gt) => {
    const en = O.length, Pt = new Array(en);
    for (let Ne = 0; Ne < en; Ne++) {
      const We = O[Ne];
      Pt[Ne] = gt(We, Ne);
    }
    return Pt;
  }, dn = (O, gt) => {
    const en = [];
    for (let Pt = 0, Ne = O.length; Pt < Ne; Pt++) {
      const We = O[Pt];
      gt(We, Pt) && en.push(We);
    }
    return en;
  }, _t = (O, gt, en) => {
    for (let Pt = 0, Ne = O.length; Pt < Ne; Pt++) {
      const We = O[Pt];
      if (gt(We, Pt))
        return Ge.some(We);
      if (en(We, Pt))
        break;
    }
    return Ge.none();
  }, Re = (O, gt) => _t(O, gt, an), oe = Object.keys, Je = Object.hasOwnProperty, rt = (O, gt) => lt(O, gt) ? Ge.from(O[gt]) : Ge.none(), lt = (O, gt) => Je.call(O, gt), Q = (O) => {
    const gt = [], en = (Pt) => {
      gt.push(Pt);
    };
    for (let Pt = 0; Pt < O.length; Pt++)
      O[Pt].each(en);
    return gt;
  }, wn = `<h1>Editor UI keyboard navigation</h1>

<h2>Activating keyboard navigation</h2>

<p>The sections of the outer UI of the editor - the menubar, toolbar, sidebar and footer - are all keyboard navigable. As such, there are multiple ways to activate keyboard navigation:</p>
<ul>
  <li>Focus the menubar: Alt + F9 (Windows) or &#x2325;F9 (MacOS)</li>
  <li>Focus the toolbar: Alt + F10 (Windows) or &#x2325;F10 (MacOS)</li>
  <li>Focus the footer: Alt + F11 (Windows) or &#x2325;F11 (MacOS)</li>
</ul>

<p>Focusing the menubar or toolbar will start keyboard navigation at the first item in the menubar or toolbar, which will be highlighted with a gray background. Focusing the footer will start keyboard navigation at the first item in the element path, which will be highlighted with an underline. </p>

<h2>Moving between UI sections</h2>

<p>When keyboard navigation is active, pressing tab will move the focus to the next major section of the UI, where applicable. These sections are:</p>
<ul>
  <li>the menubar</li>
  <li>each group of the toolbar </li>
  <li>the sidebar</li>
  <li>the element path in the footer </li>
  <li>the wordcount toggle button in the footer </li>
  <li>the branding link in the footer </li>
  <li>the editor resize handle in the footer</li>
</ul>

<p>Pressing shift + tab will move backwards through the same sections, except when moving from the footer to the toolbar. Focusing the element path then pressing shift + tab will move focus to the first toolbar group, not the last.</p>

<h2>Moving within UI sections</h2>

<p>Keyboard navigation within UI sections can usually be achieved using the left and right arrow keys. This includes:</p>
<ul>
  <li>moving between menus in the menubar</li>
  <li>moving between buttons in a toolbar group</li>
  <li>moving between items in the element path</li>
</ul>

<p>In all these UI sections, keyboard navigation will cycle within the section. For example, focusing the last button in a toolbar group then pressing right arrow will move focus to the first item in the same toolbar group. </p>

<h1>Executing buttons</h1>

<p>To execute a button, navigate the selection to the desired button and hit space or enter.</p>

<h1>Opening, navigating and closing menus</h1>

<p>When focusing a menubar button or a toolbar button with a menu, pressing space, enter or down arrow will open the menu. When the menu opens the first item will be selected. To move up or down the menu, press the up or down arrow key respectively. This is the same for submenus, which can also be opened and closed using the left and right arrow keys.</p>

<p>To close any active menu, hit the escape key. When a menu is closed the selection will be restored to its previous selection. This also works for closing submenus.</p>

<h1>Context toolbars and menus</h1>

<p>To focus an open context toolbar such as the table context toolbar, press Ctrl + F9 (Windows) or &#x2303;F9 (MacOS).</p>

<p>Context toolbar navigation is the same as toolbar navigation, and context menu navigation is the same as standard menu navigation.</p>

<h1>Dialog navigation</h1>

<p>There are two types of dialog UIs in TinyMCE: tabbed dialogs and non-tabbed dialogs.</p>

<p>When a non-tabbed dialog is opened, the first interactive component in the dialog will be focused. Users can navigate between interactive components by pressing tab. This includes any footer buttons. Navigation will cycle back to the first dialog component if tab is pressed while focusing the last component in the dialog. Pressing shift + tab will navigate backwards.</p>

<p>When a tabbed dialog is opened, the first button in the tab menu is focused. Pressing tab will navigate to the first interactive component in that tab, and will cycle through the tab\u2019s components, the footer buttons, then back to the tab button. To switch to another tab, focus the tab button for the current tab, then use the arrow keys to cycle through the tab buttons.</p>`, ft = () => ({
    name: "keyboardnav",
    title: "Keyboard Navigation",
    items: [{
      type: "htmlpanel",
      presets: "document",
      html: wn
    }]
  });
  var Ot = tinymce.util.Tools.resolve("tinymce.Env");
  const Se = (O) => {
    const gt = Ot.os.isMacOS() || Ot.os.isiOS(), Ne = gt ? {
      alt: "&#x2325;",
      ctrl: "&#x2303;",
      shift: "&#x21E7;",
      meta: "&#x2318;",
      access: "&#x2303;&#x2325;"
    } : {
      meta: "Ctrl ",
      access: "Shift + Alt "
    }, We = O.split("+"), Ae = ie(We, (Oe) => {
      const ae = Oe.toLowerCase().trim();
      return lt(Ne, ae) ? Ne[ae] : Oe;
    });
    return gt ? Ae.join("").replace(/\s/, "") : Ae.join("+");
  }, Qe = [
    {
      shortcuts: ["Meta + B"],
      action: "Bold"
    },
    {
      shortcuts: ["Meta + I"],
      action: "Italic"
    },
    {
      shortcuts: ["Meta + U"],
      action: "Underline"
    },
    {
      shortcuts: ["Meta + A"],
      action: "Select all"
    },
    {
      shortcuts: [
        "Meta + Y",
        "Meta + Shift + Z"
      ],
      action: "Redo"
    },
    {
      shortcuts: ["Meta + Z"],
      action: "Undo"
    },
    {
      shortcuts: ["Access + 1"],
      action: "Heading 1"
    },
    {
      shortcuts: ["Access + 2"],
      action: "Heading 2"
    },
    {
      shortcuts: ["Access + 3"],
      action: "Heading 3"
    },
    {
      shortcuts: ["Access + 4"],
      action: "Heading 4"
    },
    {
      shortcuts: ["Access + 5"],
      action: "Heading 5"
    },
    {
      shortcuts: ["Access + 6"],
      action: "Heading 6"
    },
    {
      shortcuts: ["Access + 7"],
      action: "Paragraph"
    },
    {
      shortcuts: ["Access + 8"],
      action: "Div"
    },
    {
      shortcuts: ["Access + 9"],
      action: "Address"
    },
    {
      shortcuts: ["Alt + 0"],
      action: "Open help dialog"
    },
    {
      shortcuts: ["Alt + F9"],
      action: "Focus to menubar"
    },
    {
      shortcuts: ["Alt + F10"],
      action: "Focus to toolbar"
    },
    {
      shortcuts: ["Alt + F11"],
      action: "Focus to element path"
    },
    {
      shortcuts: ["Ctrl + F9"],
      action: "Focus to contextual toolbar"
    },
    {
      shortcuts: ["Shift + Enter"],
      action: "Open popup menu for split buttons"
    },
    {
      shortcuts: ["Meta + K"],
      action: "Insert link (if link plugin activated)"
    },
    {
      shortcuts: ["Meta + S"],
      action: "Save (if save plugin activated)"
    },
    {
      shortcuts: ["Meta + F"],
      action: "Find (if searchreplace plugin activated)"
    },
    {
      shortcuts: ["Meta + Shift + F"],
      action: "Switch to or from fullscreen mode"
    }
  ], z = () => {
    const O = ie(Qe, (en) => {
      const Pt = ie(en.shortcuts, Se).join(" or ");
      return [
        en.action,
        Pt
      ];
    });
    return {
      name: "shortcuts",
      title: "Handy Shortcuts",
      items: [{
        type: "table",
        header: [
          "Action",
          "Shortcut"
        ],
        cells: O
      }]
    };
  };
  var Pe = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const Rt = ie([
    {
      key: "advlist",
      name: "Advanced List"
    },
    {
      key: "anchor",
      name: "Anchor"
    },
    {
      key: "autolink",
      name: "Autolink"
    },
    {
      key: "autoresize",
      name: "Autoresize"
    },
    {
      key: "autosave",
      name: "Autosave"
    },
    {
      key: "charmap",
      name: "Character Map"
    },
    {
      key: "code",
      name: "Code"
    },
    {
      key: "codesample",
      name: "Code Sample"
    },
    {
      key: "colorpicker",
      name: "Color Picker"
    },
    {
      key: "directionality",
      name: "Directionality"
    },
    {
      key: "emoticons",
      name: "Emoticons"
    },
    {
      key: "fullscreen",
      name: "Full Screen"
    },
    {
      key: "help",
      name: "Help"
    },
    {
      key: "image",
      name: "Image"
    },
    {
      key: "importcss",
      name: "Import CSS"
    },
    {
      key: "insertdatetime",
      name: "Insert Date/Time"
    },
    {
      key: "link",
      name: "Link"
    },
    {
      key: "lists",
      name: "Lists"
    },
    {
      key: "media",
      name: "Media"
    },
    {
      key: "nonbreaking",
      name: "Nonbreaking"
    },
    {
      key: "pagebreak",
      name: "Page Break"
    },
    {
      key: "preview",
      name: "Preview"
    },
    {
      key: "quickbars",
      name: "Quick Toolbars"
    },
    {
      key: "save",
      name: "Save"
    },
    {
      key: "searchreplace",
      name: "Search and Replace"
    },
    {
      key: "table",
      name: "Table"
    },
    {
      key: "template",
      name: "Template"
    },
    {
      key: "textcolor",
      name: "Text Color"
    },
    {
      key: "visualblocks",
      name: "Visual Blocks"
    },
    {
      key: "visualchars",
      name: "Visual Characters"
    },
    {
      key: "wordcount",
      name: "Word Count"
    },
    {
      key: "a11ychecker",
      name: "Accessibility Checker",
      type: "premium"
    },
    {
      key: "advcode",
      name: "Advanced Code Editor",
      type: "premium"
    },
    {
      key: "advtable",
      name: "Advanced Tables",
      type: "premium"
    },
    {
      key: "autocorrect",
      name: "Autocorrect",
      type: "premium"
    },
    {
      key: "casechange",
      name: "Case Change",
      type: "premium"
    },
    {
      key: "checklist",
      name: "Checklist",
      type: "premium"
    },
    {
      key: "editimage",
      name: "Enhanced Image Editing",
      type: "premium"
    },
    {
      key: "mediaembed",
      name: "Enhanced Media Embed",
      type: "premium",
      slug: "introduction-to-mediaembed"
    },
    {
      key: "export",
      name: "Export",
      type: "premium"
    },
    {
      key: "formatpainter",
      name: "Format Painter",
      type: "premium"
    },
    {
      key: "linkchecker",
      name: "Link Checker",
      type: "premium"
    },
    {
      key: "mentions",
      name: "Mentions",
      type: "premium"
    },
    {
      key: "pageembed",
      name: "Page Embed",
      type: "premium"
    },
    {
      key: "permanentpen",
      name: "Permanent Pen",
      type: "premium"
    },
    {
      key: "powerpaste",
      name: "PowerPaste",
      type: "premium",
      slug: "introduction-to-powerpaste"
    },
    {
      key: "rtc",
      name: "Real-Time Collaboration",
      type: "premium",
      slug: "rtc-introduction"
    },
    {
      key: "tinymcespellchecker",
      name: "Spell Checker Pro",
      type: "premium",
      slug: "introduction-to-tiny-spellchecker"
    },
    {
      key: "tinycomments",
      name: "Tiny Comments",
      type: "premium",
      slug: "introduction-to-tiny-comments"
    },
    {
      key: "tinydrive",
      name: "Tiny Drive",
      type: "premium",
      slug: "tinydrive-introduction"
    },
    {
      key: "tableofcontents",
      name: "Table of Contents",
      type: "premium"
    }
  ], (O) => ({
    ...O,
    type: O.type || "opensource",
    slug: O.slug || O.key
  })), un = (O) => {
    const gt = () => {
      const ae = dn(Rt, ({ key: je, type: ke }) => je !== "autocorrect" && ke === "premium"), X = ie(ae, (je) => "<li>" + Pe.translate(je.name) + "</li>").join("");
      return '<div data-mce-tabstop="1" tabindex="-1"><p><b>' + Pe.translate("Premium plugins:") + "</b></p><ul>" + X + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" rel="noopener" target="_blank">' + Pe.translate("Learn more...") + "</a></li></ul></div>";
    }, en = (ae) => `<a href="${ae.url}" target="_blank" rel="noopener">${ae.name}</a>`, Pt = (ae, X) => Re(Rt, (je) => je.key === X).fold(() => {
      const je = ae.plugins[X].getMetadata;
      return typeof je == "function" ? en(je()) : X;
    }, (je) => {
      const ke = je.type === "premium" ? `${je.name}*` : je.name;
      return en({
        name: ke,
        url: `https://www.tiny.cloud/docs/tinymce/6/${je.slug}/`
      });
    }), Ne = (ae) => {
      const X = oe(ae.plugins), je = Kt(ae);
      return Un(je) ? X : dn(X, (ke) => !Ue(je, ke));
    }, We = (ae) => {
      const X = Ne(ae), je = ie(X, (Ht) => "<li>" + Pt(ae, Ht) + "</li>"), ke = je.length, ue = je.join("");
      return "<p><b>" + Pe.translate([
        "Plugins installed ({0}):",
        ke
      ]) + "</b></p><ul>" + ue + "</ul>";
    }, Oe = {
      type: "htmlpanel",
      presets: "document",
      html: [
        ((ae) => ae == null ? "" : '<div data-mce-tabstop="1" tabindex="-1">' + We(ae) + "</div>")(O),
        gt()
      ].join("")
    };
    return {
      name: "plugins",
      title: "Plugins",
      items: [Oe]
    };
  };
  var Ct = tinymce.util.Tools.resolve("tinymce.EditorManager");
  const _o = () => {
    const gt = ((Ne, We) => Ne.indexOf("@") === 0 ? "X.X.X" : Ne + "." + We)(Ct.majorVersion, Ct.minorVersion), en = '<a href="https://www.tiny.cloud/docs/tinymce/6/changelog/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" rel="noopener" target="_blank">TinyMCE ' + gt + "</a>", Pt = {
      type: "htmlpanel",
      html: "<p>" + Pe.translate([
        "You are using {0}",
        en
      ]) + "</p>",
      presets: "document"
    };
    return {
      name: "versions",
      title: "Version",
      items: [Pt]
    };
  }, Fn = (O, gt) => {
    const en = {}, Pt = ie(O, (Ne) => typeof Ne == "string" ? (lt(gt, Ne) && (en[Ne] = gt[Ne]), Ne) : (en[Ne.name] = Ne, Ne.name));
    return {
      tabs: en,
      names: Pt
    };
  }, Sn = (O) => {
    const gt = oe(O), en = gt.indexOf("versions");
    return en !== -1 && (gt.splice(en, 1), gt.push("versions")), {
      tabs: O,
      names: gt
    };
  }, Dn = (O, gt) => {
    const en = z(), Pt = ft(), Ne = un(O), We = _o(), Ae = {
      [en.name]: en,
      [Pt.name]: Pt,
      [Ne.name]: Ne,
      [We.name]: We,
      ...gt.get()
    };
    return Ge.from(ho(O)).fold(() => Sn(Ae), (Oe) => Fn(Oe, Ae));
  }, Mn = (O, gt) => () => {
    const { tabs: en, names: Pt } = Dn(O, gt), Ne = ie(Pt, (Oe) => rt(en, Oe)), We = Q(Ne), Ae = {
      type: "tabpanel",
      tabs: We
    };
    O.windowManager.open({
      title: "Help",
      size: "medium",
      body: Ae,
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }],
      initialData: {}
    });
  };
  var Xe = () => {
    To.add("help", (O) => {
      const gt = ns({}), en = Eo(gt);
      uo(O);
      const Pt = Mn(O, gt);
      return Bt(O, Pt), In(O, Pt), O.shortcuts.add("Alt+0", "Open help dialog", "mceHelp"), en;
    });
  };
  Xe();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = ((Ae) => (Oe) => Ae === Oe)(null), In = (Ae) => Ae, Jn = "\uFEFF", uo = (Ae) => Ae.replace(/\uFEFF/g, ""), ho = (Ae, Oe) => {
    const ae = Ae.length, X = new Array(ae);
    for (let je = 0; je < ae; je++) {
      const ke = Ae[je];
      X[je] = Oe(ke, je);
    }
    return X;
  }, Bt = {
    aletter: "[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F3\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u303B\u303C\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790\uA791\uA7A0-\uA7A9\uA7FA-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]",
    midnumlet: "[-'\\.\u2018\u2019\u2024\uFE52\uFF07\uFF0E]",
    midletter: "[:\xB7\xB7\u05F4\u2027\uFE13\uFE55\uFF1A]",
    midnum: "[\xB1+*/,;;\u0589\u060C\u060D\u066C\u07F8\u2044\uFE10\uFE14\uFE50\uFE54\uFF0C\uFF1B]",
    numeric: "[0-9\u0660-\u0669\u066B\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9]",
    cr: "\\r",
    lf: "\\n",
    newline: "[\v\f\x85\u2028\u2029]",
    extend: "[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B6-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAA\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2\u1DC0-\u1DE6\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\uFF9E\uFF9F]",
    format: "[\xAD\u0600-\u0603\u06DD\u070F\u17B4\u17B5\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB]",
    katakana: "[\u3031-\u3035\u309B\u309C\u30A0-\u30FA\u30FC-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF9D]",
    extendnumlet: "[=_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F\u2200-\u22FF<>]",
    punctuation: "[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]"
  }, $t = {
    ALETTER: 0,
    MIDNUMLET: 1,
    MIDLETTER: 2,
    MIDNUM: 3,
    NUMERIC: 4,
    CR: 5,
    LF: 6,
    NEWLINE: 7,
    EXTEND: 8,
    FORMAT: 9,
    KATAKANA: 10,
    EXTENDNUMLET: 11,
    AT: 12,
    OTHER: 13
  }, Un = [
    new RegExp(Bt.aletter),
    new RegExp(Bt.midnumlet),
    new RegExp(Bt.midletter),
    new RegExp(Bt.midnum),
    new RegExp(Bt.numeric),
    new RegExp(Bt.cr),
    new RegExp(Bt.lf),
    new RegExp(Bt.newline),
    new RegExp(Bt.extend),
    new RegExp(Bt.format),
    new RegExp(Bt.katakana),
    new RegExp(Bt.extendnumlet),
    new RegExp("@")
  ], Ao = "", tn = new RegExp("^" + Bt.punctuation + "$"), mt = /^\s+$/, an = Un, Ge = $t.OTHER, At = (Ae) => {
    let Oe = Ge;
    const ae = an.length;
    for (let X = 0; X < ae; ++X) {
      const je = an[X];
      if (je && je.test(Ae)) {
        Oe = X;
        break;
      }
    }
    return Oe;
  }, He = (Ae) => {
    const Oe = {};
    return (ae) => {
      if (Oe[ae])
        return Oe[ae];
      {
        const X = Ae(ae);
        return Oe[ae] = X, X;
      }
    };
  }, Ue = (Ae) => {
    const Oe = He(At);
    return ho(Ae, Oe);
  }, ie = (Ae, Oe) => {
    const ae = Ae[Oe], X = Ae[Oe + 1];
    if (Oe < 0 || Oe > Ae.length - 1 && Oe !== 0 || ae === $t.ALETTER && X === $t.ALETTER)
      return !1;
    const je = Ae[Oe + 2];
    if (ae === $t.ALETTER && (X === $t.MIDLETTER || X === $t.MIDNUMLET || X === $t.AT) && je === $t.ALETTER)
      return !1;
    const ke = Ae[Oe - 1];
    return (ae === $t.MIDLETTER || ae === $t.MIDNUMLET || X === $t.AT) && X === $t.ALETTER && ke === $t.ALETTER || (ae === $t.NUMERIC || ae === $t.ALETTER) && (X === $t.NUMERIC || X === $t.ALETTER) || (ae === $t.MIDNUM || ae === $t.MIDNUMLET) && X === $t.NUMERIC && ke === $t.NUMERIC || ae === $t.NUMERIC && (X === $t.MIDNUM || X === $t.MIDNUMLET) && je === $t.NUMERIC || ae === $t.EXTEND || ae === $t.FORMAT || ke === $t.EXTEND || ke === $t.FORMAT || X === $t.EXTEND || X === $t.FORMAT || ae === $t.CR && X === $t.LF ? !1 : ae === $t.NEWLINE || ae === $t.CR || ae === $t.LF || X === $t.NEWLINE || X === $t.CR || X === $t.LF ? !0 : !(ae === $t.KATAKANA && X === $t.KATAKANA || X === $t.EXTENDNUMLET && (ae === $t.ALETTER || ae === $t.NUMERIC || ae === $t.KATAKANA || ae === $t.EXTENDNUMLET) || ae === $t.EXTENDNUMLET && (X === $t.ALETTER || X === $t.NUMERIC || X === $t.KATAKANA) || ae === $t.AT);
  }, dn = Ao, _t = mt, Re = tn, oe = (Ae) => Ae === "http" || Ae === "https", Je = (Ae, Oe) => {
    let ae;
    for (ae = Oe; ae < Ae.length && !_t.test(Ae[ae]); ae++)
      ;
    return ae;
  }, rt = (Ae, Oe) => {
    const ae = Je(Ae, Oe + 1);
    return Ae.slice(Oe + 1, ae).join(dn).substr(0, 3) === "://" ? ae : Oe;
  }, lt = (Ae, Oe, ae, X) => {
    const je = [];
    let ke = [];
    for (let ue = 0; ue < ae.length; ++ue)
      if (ke.push(Ae[ue]), ie(ae, ue)) {
        const ct = Oe[ue];
        if ((X.includeWhitespace || !_t.test(ct)) && (X.includePunctuation || !Re.test(ct))) {
          const Ht = ue - ke.length + 1, vo = ue + 1, Wn = Oe.slice(Ht, vo).join(dn);
          if (oe(Wn)) {
            const ko = rt(Oe, ue), fo = Ae.slice(vo, ko);
            Array.prototype.push.apply(ke, fo), ue = ko;
          }
          je.push(ke);
        }
        ke = [];
      }
    return je;
  }, Q = () => ({
    includeWhitespace: !1,
    includePunctuation: !1
  }), ft = (Ae, Oe, ae) => {
    ae = {
      ...Q(),
      ...ae
    };
    const X = [], je = [];
    for (let ue = 0; ue < Ae.length; ue++) {
      const ct = Oe(Ae[ue]);
      ct !== Jn && (X.push(Ae[ue]), je.push(ct));
    }
    const ke = Ue(je);
    return lt(X, je, ke, ae);
  };
  var Ot = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const Se = (Ae, Oe) => {
    const ae = Oe.getBlockElements(), X = Oe.getVoidElements(), je = (Ht) => ae[Ht.nodeName] || X[Ht.nodeName], ke = [];
    let ue = "";
    const ct = new Ot(Ae, Ae);
    for (; Ae = ct.next(); )
      Ae.nodeType === 3 ? ue += uo(Ae.data) : je(Ae) && ue.length && (ke.push(ue), ue = "");
    return ue.length && ke.push(ue), ke;
  }, Qe = (Ae) => Ae.replace(/\u200B/g, ""), z = (Ae) => Ae.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length, Pe = (Ae, Oe) => {
    const ae = Qe(Se(Ae, Oe).join(`
`));
    return ft(ae.split(""), In).length;
  }, Rt = (Ae, Oe) => {
    const ae = Se(Ae, Oe).join("");
    return z(ae);
  }, un = (Ae, Oe) => {
    const ae = Se(Ae, Oe).join("").replace(/\s/g, "");
    return z(ae);
  }, Ct = (Ae, Oe) => () => Oe(Ae.getBody(), Ae.schema), _o = (Ae, Oe) => () => Oe(Ae.selection.getRng().cloneContents(), Ae.schema), Fn = (Ae) => Ct(Ae, Pe), Sn = (Ae) => ({
    body: {
      getWordCount: Fn(Ae),
      getCharacterCount: Ct(Ae, Rt),
      getCharacterCountWithoutSpaces: Ct(Ae, un)
    },
    selection: {
      getWordCount: _o(Ae, Pe),
      getCharacterCount: _o(Ae, Rt),
      getCharacterCountWithoutSpaces: _o(Ae, un)
    },
    getCount: Fn(Ae)
  }), Dn = (Ae, Oe) => {
    Ae.windowManager.open({
      title: "Word Count",
      body: {
        type: "panel",
        items: [{
          type: "table",
          header: [
            "Count",
            "Document",
            "Selection"
          ],
          cells: [
            [
              "Words",
              String(Oe.body.getWordCount()),
              String(Oe.selection.getWordCount())
            ],
            [
              "Characters (no spaces)",
              String(Oe.body.getCharacterCountWithoutSpaces()),
              String(Oe.selection.getCharacterCountWithoutSpaces())
            ],
            [
              "Characters",
              String(Oe.body.getCharacterCount()),
              String(Oe.selection.getCharacterCount())
            ]
          ]
        }]
      },
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }]
    });
  }, Mn = (Ae, Oe) => {
    Ae.addCommand("mceWordCount", () => Dn(Ae, Oe));
  }, Xe = (Ae, Oe) => {
    let ae = null;
    return {
      cancel: () => {
        Eo(ae) || (clearTimeout(ae), ae = null);
      },
      throttle: (...ke) => {
        Eo(ae) && (ae = setTimeout(() => {
          ae = null, Ae.apply(null, ke);
        }, Oe));
      }
    };
  };
  var O = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const gt = (Ae, Oe) => {
    Ae.dispatch("wordCountUpdate", {
      wordCount: {
        words: Oe.body.getWordCount(),
        characters: Oe.body.getCharacterCount(),
        charactersWithoutSpaces: Oe.body.getCharacterCountWithoutSpaces()
      }
    });
  }, en = (Ae, Oe) => {
    gt(Ae, Oe);
  }, Pt = (Ae, Oe, ae) => {
    const X = Xe(() => en(Ae, Oe), ae);
    Ae.on("init", () => {
      en(Ae, Oe), O.setEditorTimeout(Ae, () => {
        Ae.on("SetContent BeforeAddUndo Undo Redo ViewUpdate keyup", X.throttle);
      }, 0), Ae.on("remove", X.cancel);
    });
  }, Ne = (Ae) => {
    const Oe = () => Ae.execCommand("mceWordCount");
    Ae.ui.registry.addButton("wordcount", {
      tooltip: "Word count",
      icon: "character-count",
      onAction: Oe
    }), Ae.ui.registry.addMenuItem("wordcount", {
      text: "Word count",
      icon: "character-count",
      onAction: Oe
    });
  };
  var We = (Ae = 300) => {
    ns.add("wordcount", (Oe) => {
      const ae = Sn(Oe);
      return Mn(Oe, ae), Ne(Oe), Pt(Oe, ae, Ae), ae;
    });
  };
  We();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager"), To = tinymce.util.Tools.resolve("tinymce.Env");
  const Eo = (mt) => (an) => an.options.get(mt), In = (mt) => {
    const an = mt.options.register;
    an("pagebreak_separator", {
      processor: "string",
      default: "<!-- pagebreak -->"
    }), an("pagebreak_split_block", {
      processor: "boolean",
      default: !1
    });
  }, Jn = Eo("pagebreak_separator"), uo = Eo("pagebreak_split_block"), ho = "mce-pagebreak", Kt = (mt) => {
    const an = `<img src="${To.transparentSrc}" class="${ho}" data-mce-resize="false" data-mce-placeholder />`;
    return mt ? `<p>${an}</p>` : an;
  }, Bt = (mt) => {
    const an = Jn(mt), Ge = () => uo(mt), At = new RegExp(an.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, (He) => "\\" + He), "gi");
    mt.on("BeforeSetContent", (He) => {
      He.content = He.content.replace(At, Kt(Ge()));
    }), mt.on("PreInit", () => {
      mt.serializer.addNodeFilter("img", (He) => {
        let Ue = He.length, ie, dn;
        for (; Ue--; )
          if (ie = He[Ue], dn = ie.attr("class"), dn && dn.indexOf(ho) !== -1) {
            const _t = ie.parent;
            if (mt.schema.getBlockElements()[_t.name] && Ge()) {
              _t.type = 3, _t.value = an, _t.raw = !0, ie.remove();
              continue;
            }
            ie.type = 3, ie.value = an, ie.raw = !0;
          }
      });
    });
  }, $t = (mt) => {
    mt.addCommand("mcePageBreak", () => {
      mt.insertContent(Kt(uo(mt)));
    });
  }, Un = (mt) => {
    mt.on("ResolveName", (an) => {
      an.target.nodeName === "IMG" && mt.dom.hasClass(an.target, ho) && (an.name = "pagebreak");
    });
  }, Ao = (mt) => {
    const an = () => mt.execCommand("mcePageBreak");
    mt.ui.registry.addButton("pagebreak", {
      icon: "page-break",
      tooltip: "Page break",
      onAction: an
    }), mt.ui.registry.addMenuItem("pagebreak", {
      text: "Page break",
      icon: "page-break",
      onAction: an
    });
  };
  var tn = () => {
    ns.add("pagebreak", (mt) => {
      In(mt), $t(mt), Ao(mt), Bt(mt), Un(mt);
    });
  };
  tn();
})();
(function() {
  const ns = (we) => {
    let $e = we;
    return {
      get: () => $e,
      set: (ht) => {
        $e = ht;
      }
    };
  };
  var To = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = (we) => ({ isEnabled: () => we.get() }), In = (we, $e) => we.dispatch("VisualChars", { state: $e }), Jn = (we, $e, Vt) => {
    var Jt;
    return Vt(we, $e.prototype) ? !0 : ((Jt = we.constructor) === null || Jt === void 0 ? void 0 : Jt.name) === $e.name;
  }, uo = (we) => {
    const $e = typeof we;
    return we === null ? "null" : $e === "object" && Array.isArray(we) ? "array" : $e === "object" && Jn(we, String, (Vt, Jt) => Jt.isPrototypeOf(Vt)) ? "string" : $e;
  }, ho = (we) => ($e) => uo($e) === we, Kt = (we) => ($e) => typeof $e === we, Bt = (we) => ($e) => we === $e, $t = ho("string"), Un = Bt(null), Ao = Kt("boolean"), tn = (we) => we == null, mt = (we) => !tn(we), an = Kt("number");
  class Ge {
    constructor($e, Vt) {
      this.tag = $e, this.value = Vt;
    }
    static some($e) {
      return new Ge(!0, $e);
    }
    static none() {
      return Ge.singletonNone;
    }
    fold($e, Vt) {
      return this.tag ? Vt(this.value) : $e();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map($e) {
      return this.tag ? Ge.some($e(this.value)) : Ge.none();
    }
    bind($e) {
      return this.tag ? $e(this.value) : Ge.none();
    }
    exists($e) {
      return this.tag && $e(this.value);
    }
    forall($e) {
      return !this.tag || $e(this.value);
    }
    filter($e) {
      return !this.tag || $e(this.value) ? this : Ge.none();
    }
    getOr($e) {
      return this.tag ? this.value : $e;
    }
    or($e) {
      return this.tag ? this : $e;
    }
    getOrThunk($e) {
      return this.tag ? this.value : $e();
    }
    orThunk($e) {
      return this.tag ? this : $e();
    }
    getOrDie($e) {
      if (this.tag)
        return this.value;
      throw new Error($e != null ? $e : "Called getOrDie on None");
    }
    static from($e) {
      return mt($e) ? Ge.some($e) : Ge.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each($e) {
      this.tag && $e(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ge.singletonNone = new Ge(!1);
  const At = (we, $e) => {
    const Vt = we.length, Jt = new Array(Vt);
    for (let ht = 0; ht < Vt; ht++) {
      const qn = we[ht];
      Jt[ht] = $e(qn, ht);
    }
    return Jt;
  }, He = (we, $e) => {
    for (let Vt = 0, Jt = we.length; Vt < Jt; Vt++) {
      const ht = we[Vt];
      $e(ht, Vt);
    }
  }, Ue = (we, $e) => {
    const Vt = [];
    for (let Jt = 0, ht = we.length; Jt < ht; Jt++) {
      const qn = we[Jt];
      $e(qn, Jt) && Vt.push(qn);
    }
    return Vt;
  }, ie = Object.keys, dn = (we, $e) => {
    const Vt = ie(we);
    for (let Jt = 0, ht = Vt.length; Jt < ht; Jt++) {
      const qn = Vt[Jt], pr = we[qn];
      $e(pr, qn);
    }
  };
  typeof window < "u" || Function("return this;")();
  const _t = 3, Re = (we) => we.dom.nodeType, oe = (we) => we.dom.nodeValue, rt = ((we) => ($e) => Re($e) === we)(_t), lt = (we, $e, Vt) => {
    if ($t(Vt) || Ao(Vt) || an(Vt))
      we.setAttribute($e, Vt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", $e, ":: Value ", Vt, ":: Element ", we), new Error("Attribute value was not simple");
  }, Q = (we, $e, Vt) => {
    lt(we.dom, $e, Vt);
  }, wn = (we, $e) => {
    const Vt = we.dom.getAttribute($e);
    return Vt === null ? void 0 : Vt;
  }, ft = (we, $e) => {
    we.dom.removeAttribute($e);
  }, Ot = (we, $e) => {
    const Vt = wn(we, $e);
    return Vt === void 0 || Vt === "" ? [] : Vt.split(" ");
  }, Se = (we, $e, Vt) => {
    const ht = Ot(we, $e).concat([Vt]);
    return Q(we, $e, ht.join(" ")), !0;
  }, Qe = (we, $e, Vt) => {
    const Jt = Ue(Ot(we, $e), (ht) => ht !== Vt);
    return Jt.length > 0 ? Q(we, $e, Jt.join(" ")) : ft(we, $e), !1;
  }, z = (we) => we.dom.classList !== void 0, Pe = (we) => Ot(we, "class"), Rt = (we, $e) => Se(we, "class", $e), un = (we, $e) => Qe(we, "class", $e), Ct = (we, $e) => {
    z(we) ? we.dom.classList.add($e) : Rt(we, $e);
  }, _o = (we) => {
    (z(we) ? we.dom.classList : Pe(we)).length === 0 && ft(we, "class");
  }, Fn = (we, $e) => {
    z(we) ? we.dom.classList.remove($e) : un(we, $e), _o(we);
  }, Sn = (we, $e) => {
    const Jt = ($e || document).createElement("div");
    if (Jt.innerHTML = we, !Jt.hasChildNodes() || Jt.childNodes.length > 1) {
      const ht = "HTML does not have a single root node";
      throw console.error(ht, we), new Error(ht);
    }
    return Xe(Jt.childNodes[0]);
  }, Dn = (we, $e) => {
    const Jt = ($e || document).createElement(we);
    return Xe(Jt);
  }, Mn = (we, $e) => {
    const Jt = ($e || document).createTextNode(we);
    return Xe(Jt);
  }, Xe = (we) => {
    if (we == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: we };
  }, gt = {
    fromHtml: Sn,
    fromTag: Dn,
    fromText: Mn,
    fromDom: Xe,
    fromPoint: (we, $e, Vt) => Ge.from(we.dom.elementFromPoint($e, Vt)).map(Xe)
  }, en = {
    "\xA0": "nbsp",
    "\xAD": "shy"
  }, Pt = (we, $e) => {
    let Vt = "";
    return dn(we, (Jt, ht) => {
      Vt += ht;
    }), new RegExp("[" + Vt + "]", $e ? "g" : "");
  }, Ne = (we) => {
    let $e = "";
    return dn(we, (Vt) => {
      $e && ($e += ","), $e += "span.mce-" + Vt;
    }), $e;
  }, We = Pt(en), Ae = Pt(en, !0), Oe = Ne(en), ae = "mce-nbsp", X = (we) => '<span data-mce-bogus="1" class="mce-' + en[we] + '">' + we + "</span>", je = (we) => {
    const $e = oe(we);
    return rt(we) && $e !== void 0 && We.test($e);
  }, ke = (we, $e) => {
    let Vt = [];
    const Jt = we.dom, ht = At(Jt.childNodes, gt.fromDom);
    return He(ht, (qn) => {
      $e(qn) && (Vt = Vt.concat([qn])), Vt = Vt.concat(ke(qn, $e));
    }), Vt;
  }, ue = (we, $e) => {
    for (; we.parentNode; ) {
      if (we.parentNode === $e)
        return we;
      we = we.parentNode;
    }
  }, ct = (we) => we.replace(Ae, X), Ht = (we) => we.nodeName.toLowerCase() === "span" && we.classList.contains("mce-nbsp-wrap"), vo = (we, $e) => {
    const Vt = ke(gt.fromDom($e), je);
    He(Vt, (Jt) => {
      const ht = Jt.dom.parentNode;
      if (Ht(ht))
        Ct(gt.fromDom(ht), ae);
      else {
        const qn = ct(we.dom.encode(oe(Jt))), pr = we.dom.create("div", null, qn);
        let zr;
        for (; zr = pr.lastChild; )
          we.dom.insertAfter(zr, Jt.dom);
        we.dom.remove(Jt.dom);
      }
    });
  }, Wn = (we, $e) => {
    const Vt = we.dom.select(Oe, $e);
    He(Vt, (Jt) => {
      Ht(Jt) ? Fn(gt.fromDom(Jt), ae) : we.dom.remove(Jt, !0);
    });
  }, ko = (we) => {
    const $e = we.getBody(), Vt = we.selection.getBookmark();
    let Jt = ue(we.selection.getNode(), $e);
    Jt = Jt !== void 0 ? Jt : $e, Wn(we, Jt), vo(we, Jt), we.selection.moveToBookmark(Vt);
  }, fo = (we, $e) => {
    In(we, $e.get());
    const Vt = we.getBody();
    $e.get() === !0 ? vo(we, Vt) : Wn(we, Vt);
  }, yn = (we, $e) => {
    $e.set(!$e.get());
    const Vt = we.selection.getBookmark();
    fo(we, $e), we.selection.moveToBookmark(Vt);
  }, ds = (we, $e) => {
    we.addCommand("mceVisualChars", () => {
      yn(we, $e);
    });
  }, Ho = (we) => ($e) => $e.options.get(we), mn = (we) => {
    const $e = we.options.register;
    $e("visualchars_default_state", {
      processor: "boolean",
      default: !1
    });
  }, Io = Ho("visualchars_default_state"), ro = (we, $e) => {
    we.on("init", () => {
      fo(we, $e);
    });
  }, Ln = (we, $e) => {
    let Vt = null;
    return {
      cancel: () => {
        Un(Vt) || (clearTimeout(Vt), Vt = null);
      },
      throttle: (...qn) => {
        Un(Vt) && (Vt = setTimeout(() => {
          Vt = null, we.apply(null, qn);
        }, $e));
      }
    };
  }, Go = (we, $e) => {
    const Vt = Ln(() => {
      ko(we);
    }, 300);
    we.on("keydown", (Jt) => {
      $e.get() === !0 && (Jt.keyCode === 13 ? ko(we) : Vt.throttle());
    }), we.on("remove", Vt.cancel);
  }, Ro = (we, $e) => (Vt) => {
    Vt.setActive($e.get());
    const Jt = (ht) => Vt.setActive(ht.state);
    return we.on("VisualChars", Jt), () => we.off("VisualChars", Jt);
  }, Os = (we, $e) => {
    const Vt = () => we.execCommand("mceVisualChars");
    we.ui.registry.addToggleButton("visualchars", {
      tooltip: "Show invisible characters",
      icon: "visualchars",
      onAction: Vt,
      onSetup: Ro(we, $e)
    }), we.ui.registry.addToggleMenuItem("visualchars", {
      text: "Show invisible characters",
      icon: "visualchars",
      onAction: Vt,
      onSetup: Ro(we, $e)
    });
  };
  var Qs = () => {
    To.add("visualchars", (we) => {
      mn(we);
      const $e = ns(Io(we));
      return ds(we, $e), Os(we, $e), Go(we, $e), ro(we, $e), Eo($e);
    });
  };
  Qs();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (ke, ue, ct) => {
    var Ht;
    return ct(ke, ue.prototype) ? !0 : ((Ht = ke.constructor) === null || Ht === void 0 ? void 0 : Ht.name) === ue.name;
  }, Eo = (ke) => {
    const ue = typeof ke;
    return ke === null ? "null" : ue === "object" && Array.isArray(ke) ? "array" : ue === "object" && To(ke, String, (ct, Ht) => Ht.isPrototypeOf(ct)) ? "string" : ue;
  }, In = (ke) => (ue) => Eo(ue) === ke, Jn = (ke) => (ue) => typeof ue === ke, uo = In("string"), ho = In("object"), Kt = In("array"), Bt = (ke) => ke == null, $t = (ke) => !Bt(ke), Un = Jn("function"), Ao = (ke, ue) => {
    if (Kt(ke)) {
      for (let ct = 0, Ht = ke.length; ct < Ht; ++ct)
        if (!ue(ke[ct]))
          return !1;
      return !0;
    }
    return !1;
  }, tn = (ke) => () => ke;
  function mt(ke, ...ue) {
    return (...ct) => {
      const Ht = ue.concat(ct);
      return ke.apply(null, Ht);
    };
  }
  const an = tn(!1), Ge = (ke) => ke.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  var At = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const He = (ke) => (ue) => ue.options.get(ke), Ue = (ke) => {
    const ue = ke.options.register;
    ue("template_cdate_classes", {
      processor: "string",
      default: "cdate"
    }), ue("template_mdate_classes", {
      processor: "string",
      default: "mdate"
    }), ue("template_selected_content_classes", {
      processor: "string",
      default: "selcontent"
    }), ue("template_preview_replace_values", { processor: "object" }), ue("template_replace_values", { processor: "object" }), ue("templates", { processor: (ct) => uo(ct) || Ao(ct, ho) || Un(ct) }), ue("template_cdate_format", {
      processor: "string",
      default: ke.translate("%Y-%m-%d")
    }), ue("template_mdate_format", {
      processor: "string",
      default: ke.translate("%Y-%m-%d")
    });
  }, ie = He("template_cdate_classes"), dn = He("template_mdate_classes"), _t = He("template_selected_content_classes"), Re = He("template_preview_replace_values"), oe = He("template_replace_values"), Je = He("templates"), rt = He("template_cdate_format"), lt = He("template_mdate_format"), Q = He("content_style"), wn = He("content_css_cors"), ft = He("body_class"), Ot = (ke, ue) => {
    if (ke = "" + ke, ke.length < ue)
      for (let ct = 0; ct < ue - ke.length; ct++)
        ke = "0" + ke;
    return ke;
  }, Se = (ke, ue, ct = new Date()) => {
    const Ht = "Sun Mon Tue Wed Thu Fri Sat Sun".split(" "), vo = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(" "), Wn = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), ko = "January February March April May June July August September October November December".split(" ");
    return ue = ue.replace("%D", "%m/%d/%Y"), ue = ue.replace("%r", "%I:%M:%S %p"), ue = ue.replace("%Y", "" + ct.getFullYear()), ue = ue.replace("%y", "" + ct.getYear()), ue = ue.replace("%m", Ot(ct.getMonth() + 1, 2)), ue = ue.replace("%d", Ot(ct.getDate(), 2)), ue = ue.replace("%H", "" + Ot(ct.getHours(), 2)), ue = ue.replace("%M", "" + Ot(ct.getMinutes(), 2)), ue = ue.replace("%S", "" + Ot(ct.getSeconds(), 2)), ue = ue.replace("%I", "" + ((ct.getHours() + 11) % 12 + 1)), ue = ue.replace("%p", ct.getHours() < 12 ? "AM" : "PM"), ue = ue.replace("%B", "" + ke.translate(ko[ct.getMonth()])), ue = ue.replace("%b", "" + ke.translate(Wn[ct.getMonth()])), ue = ue.replace("%A", "" + ke.translate(vo[ct.getDay()])), ue = ue.replace("%a", "" + ke.translate(Ht[ct.getDay()])), ue = ue.replace("%%", "%"), ue;
  };
  class Qe {
    constructor(ue, ct) {
      this.tag = ue, this.value = ct;
    }
    static some(ue) {
      return new Qe(!0, ue);
    }
    static none() {
      return Qe.singletonNone;
    }
    fold(ue, ct) {
      return this.tag ? ct(this.value) : ue();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ue) {
      return this.tag ? Qe.some(ue(this.value)) : Qe.none();
    }
    bind(ue) {
      return this.tag ? ue(this.value) : Qe.none();
    }
    exists(ue) {
      return this.tag && ue(this.value);
    }
    forall(ue) {
      return !this.tag || ue(this.value);
    }
    filter(ue) {
      return !this.tag || ue(this.value) ? this : Qe.none();
    }
    getOr(ue) {
      return this.tag ? this.value : ue;
    }
    or(ue) {
      return this.tag ? this : ue;
    }
    getOrThunk(ue) {
      return this.tag ? this.value : ue();
    }
    orThunk(ue) {
      return this.tag ? this : ue();
    }
    getOrDie(ue) {
      if (this.tag)
        return this.value;
      throw new Error(ue != null ? ue : "Called getOrDie on None");
    }
    static from(ue) {
      return $t(ue) ? Qe.some(ue) : Qe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ue) {
      this.tag && ue(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Qe.singletonNone = new Qe(!1);
  const z = (ke, ue) => {
    for (let ct = 0, Ht = ke.length; ct < Ht; ct++) {
      const vo = ke[ct];
      if (ue(vo, ct))
        return !0;
    }
    return !1;
  }, Pe = (ke, ue) => {
    const ct = ke.length, Ht = new Array(ct);
    for (let vo = 0; vo < ct; vo++) {
      const Wn = ke[vo];
      Ht[vo] = ue(Wn, vo);
    }
    return Ht;
  }, Rt = (ke, ue, ct) => {
    for (let Ht = 0, vo = ke.length; Ht < vo; Ht++) {
      const Wn = ke[Ht];
      if (ue(Wn, Ht))
        return Qe.some(Wn);
      if (ct(Wn, Ht))
        break;
    }
    return Qe.none();
  }, un = (ke, ue) => Rt(ke, ue, an), Ct = Object.hasOwnProperty, _o = (ke, ue) => Fn(ke, ue) ? Qe.from(ke[ue]) : Qe.none(), Fn = (ke, ue) => Ct.call(ke, ue), Sn = {
    '"': "&quot;",
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    "'": "&#039;"
  }, Dn = (ke) => ke.replace(/["'<>&]/g, (ue) => _o(Sn, ue).getOr(ue)), Mn = (ke, ue, ct) => z(ct.split(/\s+/), (Ht) => ke.hasClass(ue, Ht)), Xe = (ke, ue) => () => {
    const ct = Je(ke);
    Un(ct) ? ct(ue) : uo(ct) ? fetch(ct).then((Ht) => {
      Ht.ok && Ht.json().then(ue);
    }) : ue(ct);
  }, O = (ke, ue) => (At.each(ue, (ct, Ht) => {
    Un(ct) && (ct = ct(Ht)), ke = ke.replace(new RegExp("\\{\\$" + Ge(Ht) + "\\}", "g"), ct);
  }), ke), gt = (ke, ue) => {
    const ct = ke.dom, Ht = oe(ke);
    At.each(ct.select("*", ue), (vo) => {
      At.each(Ht, (Wn, ko) => {
        ct.hasClass(vo, ko) && Un(Wn) && Wn(vo);
      });
    });
  }, en = (ke, ue, ct) => {
    const Ht = ke.dom, vo = ke.selection.getContent();
    ct = O(ct, oe(ke));
    let Wn = Ht.create("div", null, ct);
    const ko = Ht.select(".mceTmpl", Wn);
    ko && ko.length > 0 && (Wn = Ht.create("div", null), Wn.appendChild(ko[0].cloneNode(!0))), At.each(Ht.select("*", Wn), (fo) => {
      Mn(Ht, fo, ie(ke)) && (fo.innerHTML = Se(ke, rt(ke))), Mn(Ht, fo, dn(ke)) && (fo.innerHTML = Se(ke, lt(ke))), Mn(Ht, fo, _t(ke)) && (fo.innerHTML = vo);
    }), gt(ke, Wn), ke.execCommand("mceInsertContent", !1, Wn.innerHTML), ke.addVisual();
  };
  var Pt = tinymce.util.Tools.resolve("tinymce.Env");
  const Ne = (ke, ue) => {
    var ct;
    if (ue.indexOf("<html>") === -1) {
      let Ht = "";
      const vo = (ct = Q(ke)) !== null && ct !== void 0 ? ct : "", Wn = wn(ke) ? ' crossorigin="anonymous"' : "";
      At.each(ke.contentCSS, (Io) => {
        Ht += '<link type="text/css" rel="stylesheet" href="' + ke.documentBaseURI.toAbsolute(Io) + '"' + Wn + ">";
      }), vo && (Ht += '<style type="text/css">' + vo + "</style>");
      const ko = ft(ke), fo = ke.dom.encode, yn = Pt.os.isMacOS() || Pt.os.isiOS() ? "e.metaKey" : "e.ctrlKey && !e.altKey", ds = '<script>document.addEventListener && document.addEventListener("click", function(e) {for (var elm = e.target; elm; elm = elm.parentNode) {if (elm.nodeName === "A" && !(' + yn + ")) {e.preventDefault();}}}, false);<\/script> ", Ho = ke.getBody().dir, mn = Ho ? ' dir="' + fo(Ho) + '"' : "";
      ue = '<!DOCTYPE html><html><head><base href="' + fo(ke.documentBaseURI.getURI()) + '">' + Ht + ds + '</head><body class="' + fo(ko) + '"' + mn + ">" + ue + "</body></html>";
    }
    return O(ue, Re(ke));
  }, We = (ke, ue) => {
    const ct = () => {
      if (!ue || ue.length === 0) {
        const mn = ke.translate("No templates defined.");
        return ke.notificationManager.open({
          text: mn,
          type: "info"
        }), Qe.none();
      }
      return Qe.from(At.map(ue, (mn, Io) => {
        const ro = (Ln) => Ln.url !== void 0;
        return {
          selected: Io === 0,
          text: mn.title,
          value: {
            url: ro(mn) ? Qe.from(mn.url) : Qe.none(),
            content: ro(mn) ? Qe.none() : Qe.from(mn.content),
            description: mn.description
          }
        };
      }));
    }, Ht = (mn) => Pe(mn, (Io) => ({
      text: Io.text,
      value: Io.text
    })), vo = (mn, Io) => un(mn, (ro) => ro.text === Io), Wn = (mn) => {
      ke.windowManager.alert("Could not load the specified template.", () => mn.focus("template"));
    }, ko = (mn) => mn.value.url.fold(() => Promise.resolve(mn.value.content.getOr("")), (Io) => fetch(Io).then((ro) => ro.ok ? ro.text() : Promise.reject())), fo = (mn, Io) => (ro, Ln) => {
      if (Ln.name === "template") {
        const Go = ro.getData().template;
        vo(mn, Go).each((Ro) => {
          ro.block("Loading..."), ko(Ro).then((Os) => {
            Io(ro, Ro, Os);
          }).catch(() => {
            Io(ro, Ro, ""), ro.setEnabled("save", !1), Wn(ro);
          });
        });
      }
    }, yn = (mn) => (Io) => {
      const ro = Io.getData();
      vo(mn, ro.template).each((Ln) => {
        ko(Ln).then((Go) => {
          ke.execCommand("mceInsertTemplate", !1, Go), Io.close();
        }).catch(() => {
          Io.setEnabled("save", !1), Wn(Io);
        });
      });
    }, ds = (mn) => {
      const Io = Ht(mn), ro = (Ro, Os) => ({
        title: "Insert Template",
        size: "large",
        body: {
          type: "panel",
          items: Ro
        },
        initialData: Os,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        onSubmit: yn(mn),
        onChange: fo(mn, Ln)
      }), Ln = (Ro, Os, Qs) => {
        const we = Ne(ke, Qs), $e = [
          {
            type: "selectbox",
            name: "template",
            label: "Templates",
            items: Io
          },
          {
            type: "htmlpanel",
            html: `<p aria-live="polite">${Dn(Os.value.description)}</p>`
          },
          {
            label: "Preview",
            type: "iframe",
            name: "preview",
            sandboxed: !1,
            transparent: !1
          }
        ], Vt = {
          template: Os.text,
          preview: we
        };
        Ro.unblock(), Ro.redial(ro($e, Vt)), Ro.focus("template");
      }, Go = ke.windowManager.open(ro([], {
        template: "",
        preview: ""
      }));
      Go.block("Loading..."), ko(mn[0]).then((Ro) => {
        Ln(Go, mn[0], Ro);
      }).catch(() => {
        Ln(Go, mn[0], ""), Go.setEnabled("save", !1), Wn(Go);
      });
    };
    ct().each(ds);
  }, Ae = (ke) => (ue) => {
    We(ke, ue);
  }, Oe = (ke) => {
    ke.addCommand("mceInsertTemplate", mt(en, ke)), ke.addCommand("mceTemplate", Xe(ke, Ae(ke)));
  }, ae = (ke) => {
    ke.on("PreProcess", (ue) => {
      const ct = ke.dom, Ht = lt(ke);
      At.each(ct.select("div", ue.node), (vo) => {
        ct.hasClass(vo, "mceTmpl") && (At.each(ct.select("*", vo), (Wn) => {
          Mn(ct, Wn, dn(ke)) && (Wn.innerHTML = Se(ke, Ht));
        }), gt(ke, vo));
      });
    });
  }, X = (ke) => {
    const ue = () => ke.execCommand("mceTemplate");
    ke.ui.registry.addButton("template", {
      icon: "template",
      tooltip: "Insert template",
      onAction: ue
    }), ke.ui.registry.addMenuItem("template", {
      icon: "template",
      text: "Insert template...",
      onAction: ue
    });
  };
  var je = () => {
    ns.add("template", (ke) => {
      Ue(ke), X(ke), Oe(ke), ae(ke);
    });
  };
  je();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const To = (At) => (He) => typeof He === At, Eo = To("boolean"), In = To("number"), Jn = (At) => (He) => He.options.get(At), uo = (At) => {
    const He = At.options.register;
    He("nonbreaking_force_tab", {
      processor: (Ue) => Eo(Ue) ? {
        value: Ue ? 3 : 0,
        valid: !0
      } : In(Ue) ? {
        value: Ue,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean or number."
      },
      default: !1
    }), He("nonbreaking_wrap", {
      processor: "boolean",
      default: !0
    });
  }, ho = Jn("nonbreaking_force_tab"), Kt = Jn("nonbreaking_wrap"), Bt = (At, He) => {
    let Ue = "";
    for (let ie = 0; ie < He; ie++)
      Ue += At;
    return Ue;
  }, $t = (At) => At.plugins.visualchars ? At.plugins.visualchars.isEnabled() : !1, Un = (At, He) => {
    const Ue = () => $t(At) ? "mce-nbsp-wrap mce-nbsp" : "mce-nbsp-wrap", ie = () => `<span class="${Ue()}" contenteditable="false">${Bt("&nbsp;", He)}</span>`, _t = Kt(At) || At.plugins.visualchars ? ie() : Bt("&nbsp;", He);
    At.undoManager.transact(() => At.insertContent(_t));
  }, Ao = (At) => {
    At.addCommand("mceNonBreaking", () => {
      Un(At, 1);
    });
  };
  var tn = tinymce.util.Tools.resolve("tinymce.util.VK");
  const mt = (At) => {
    const He = ho(At);
    He > 0 && At.on("keydown", (Ue) => {
      if (Ue.keyCode === tn.TAB && !Ue.isDefaultPrevented()) {
        if (Ue.shiftKey)
          return;
        Ue.preventDefault(), Ue.stopImmediatePropagation(), Un(At, He);
      }
    });
  }, an = (At) => {
    const He = () => At.execCommand("mceNonBreaking");
    At.ui.registry.addButton("nonbreaking", {
      icon: "non-breaking",
      tooltip: "Nonbreaking space",
      onAction: He
    }), At.ui.registry.addMenuItem("nonbreaking", {
      icon: "non-breaking",
      text: "Nonbreaking space",
      onAction: He
    });
  };
  var Ge = () => {
    ns.add("nonbreaking", (At) => {
      uo(At), Ao(At), an(At), mt(At);
    });
  };
  Ge();
})();
(function() {
  var ns = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const Eo = ((ae) => (X) => ae === X)(null), In = (ae) => ae == null, Jn = (ae) => !In(ae), uo = () => {
  }, Kt = ((ae) => () => ae)(!1);
  class Bt {
    constructor(X, je) {
      this.tag = X, this.value = je;
    }
    static some(X) {
      return new Bt(!0, X);
    }
    static none() {
      return Bt.singletonNone;
    }
    fold(X, je) {
      return this.tag ? je(this.value) : X();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(X) {
      return this.tag ? Bt.some(X(this.value)) : Bt.none();
    }
    bind(X) {
      return this.tag ? X(this.value) : Bt.none();
    }
    exists(X) {
      return this.tag && X(this.value);
    }
    forall(X) {
      return !this.tag || X(this.value);
    }
    filter(X) {
      return !this.tag || X(this.value) ? this : Bt.none();
    }
    getOr(X) {
      return this.tag ? this.value : X;
    }
    or(X) {
      return this.tag ? this : X;
    }
    getOrThunk(X) {
      return this.tag ? this.value : X();
    }
    orThunk(X) {
      return this.tag ? this : X();
    }
    getOrDie(X) {
      if (this.tag)
        return this.value;
      throw new Error(X != null ? X : "Called getOrDie on None");
    }
    static from(X) {
      return Jn(X) ? Bt.some(X) : Bt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(X) {
      this.tag && X(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Bt.singletonNone = new Bt(!1);
  const $t = (ae, X) => {
    for (let je = 0, ke = ae.length; je < ke; je++) {
      const ue = ae[je];
      if (X(ue, je))
        return !0;
    }
    return !1;
  }, Un = (ae, X) => {
    const je = ae.length, ke = new Array(je);
    for (let ue = 0; ue < je; ue++) {
      const ct = ae[ue];
      ke[ue] = X(ct, ue);
    }
    return ke;
  }, Ao = (ae, X) => {
    for (let je = 0, ke = ae.length; je < ke; je++) {
      const ue = ae[je];
      X(ue, je);
    }
  }, tn = (ae) => {
    let X = ae;
    return {
      get: () => X,
      set: (ue) => {
        X = ue;
      }
    };
  }, mt = (ae, X) => {
    let je = null;
    const ke = () => {
      Eo(je) || (clearTimeout(je), je = null);
    };
    return {
      cancel: ke,
      throttle: (...ct) => {
        ke(), je = setTimeout(() => {
          je = null, ae.apply(null, ct);
        }, X);
      }
    };
  }, an = (ae, X) => {
    ae.insertContent(X);
  }, Ge = Object.keys, At = Object.hasOwnProperty, He = (ae, X) => {
    const je = Ge(ae);
    for (let ke = 0, ue = je.length; ke < ue; ke++) {
      const ct = je[ke], Ht = ae[ct];
      X(Ht, ct);
    }
  }, Ue = (ae, X) => ie(ae, (je, ke) => ({
    k: ke,
    v: X(je, ke)
  })), ie = (ae, X) => {
    const je = {};
    return He(ae, (ke, ue) => {
      const ct = X(ke, ue);
      je[ct.k] = ct.v;
    }), je;
  }, dn = (ae, X) => At.call(ae, X), oe = ((ae) => (...X) => {
    if (X.length === 0)
      throw new Error("Can't merge zero objects");
    const je = {};
    for (let ke = 0; ke < X.length; ke++) {
      const ue = X[ke];
      for (const ct in ue)
        dn(ue, ct) && (je[ct] = ae(je[ct], ue[ct]));
    }
    return je;
  })((ae, X) => X), Je = (ae) => {
    const X = tn(Bt.none()), je = () => X.get().each(ae);
    return {
      clear: () => {
        je(), X.set(Bt.none());
      },
      isSet: () => X.get().isSome(),
      get: () => X.get(),
      set: (vo) => {
        je(), X.set(Bt.some(vo));
      }
    };
  }, rt = () => {
    const ae = Je(uo);
    return {
      ...ae,
      on: (je) => ae.get().each(je)
    };
  }, lt = (ae, X, je) => X === "" || ae.length >= X.length && ae.substr(je, je + X.length) === X, Q = (ae, X) => ae.indexOf(X) !== -1, wn = (ae, X) => lt(ae, X, 0);
  var ft = tinymce.util.Tools.resolve("tinymce.Resource");
  const Ot = "tinymce.plugins.emoticons", Se = (ae) => (X) => X.options.get(ae), Qe = (ae, X) => {
    const je = ae.options.register;
    je("emoticons_database", {
      processor: "string",
      default: "emojis"
    }), je("emoticons_database_url", {
      processor: "string",
      default: `${X}/js/${z(ae)}${ae.suffix}.js`
    }), je("emoticons_database_id", {
      processor: "string",
      default: Ot
    }), je("emoticons_append", {
      processor: "object",
      default: {}
    }), je("emoticons_images_url", {
      processor: "string",
      default: "https://twemoji.maxcdn.com/v/13.0.1/72x72/"
    });
  }, z = Se("emoticons_database"), Pe = Se("emoticons_database_url"), Rt = Se("emoticons_database_id"), un = Se("emoticons_append"), Ct = Se("emoticons_images_url"), _o = "All", Fn = {
    symbols: "Symbols",
    people: "People",
    animals_and_nature: "Animals and Nature",
    food_and_drink: "Food and Drink",
    activity: "Activity",
    travel_and_places: "Travel and Places",
    objects: "Objects",
    flags: "Flags",
    user: "User Defined"
  }, Sn = (ae, X) => dn(ae, X) ? ae[X] : X, Dn = (ae) => {
    const X = un(ae);
    return Ue(X, (je) => ({
      keywords: [],
      category: "user",
      ...je
    }));
  }, Mn = (ae, X, je) => {
    const ke = rt(), ue = rt(), ct = Ct(ae), Ht = (Ho) => wn(Ho.char, "<img") ? Ho.char.replace(/src="([^"]+)"/, (mn, Io) => `src="${ct}${Io}"`) : Ho.char, vo = (Ho) => {
      const mn = {}, Io = [];
      He(Ho, (ro, Ln) => {
        const Go = {
          title: Ln,
          keywords: ro.keywords,
          char: Ht(ro),
          category: Sn(Fn, ro.category)
        }, Ro = mn[Go.category] !== void 0 ? mn[Go.category] : [];
        mn[Go.category] = Ro.concat([Go]), Io.push(Go);
      }), ke.set(mn), ue.set(Io);
    };
    ae.on("init", () => {
      ft.load(je, X).then((Ho) => {
        const mn = Dn(ae);
        vo(oe(Ho, mn));
      }, (Ho) => {
        console.log(`Failed to load emojis: ${Ho}`), ke.set({}), ue.set([]);
      });
    });
    const Wn = (Ho) => Ho === _o ? ko() : ke.get().bind((mn) => Bt.from(mn[Ho])).getOr([]), ko = () => ue.get().getOr([]), fo = () => [_o].concat(Ge(ke.get().getOr({}))), yn = () => ds() ? Promise.resolve(!0) : new Promise((Ho, mn) => {
      let Io = 15;
      const ro = setInterval(() => {
        ds() ? (clearInterval(ro), Ho(!0)) : (Io--, Io < 0 && (console.log("Could not load emojis from url: " + X), clearInterval(ro), mn(!1)));
      }, 100);
    }), ds = () => ke.isSet() && ue.isSet();
    return {
      listCategories: fo,
      hasLoaded: ds,
      waitForLoad: yn,
      listAll: ko,
      listCategory: Wn
    };
  }, Xe = (ae, X) => Q(ae.title.toLowerCase(), X) || $t(ae.keywords, (je) => Q(je.toLowerCase(), X)), O = (ae, X, je) => {
    const ke = [], ue = X.toLowerCase(), ct = je.fold(() => Kt, (Ht) => (vo) => vo >= Ht);
    for (let Ht = 0; Ht < ae.length && !((X.length === 0 || Xe(ae[Ht], ue)) && (ke.push({
      value: ae[Ht].char,
      text: ae[Ht].title,
      icon: ae[Ht].char
    }), ct(ke.length))); Ht++)
      ;
    return ke;
  }, gt = "pattern", en = (ae, X) => {
    const je = {
      pattern: "",
      results: O(X.listAll(), "", Bt.some(300))
    }, ke = tn(_o), ue = (fo) => {
      const yn = fo.getData(), ds = ke.get(), Ho = X.listCategory(ds), mn = O(Ho, yn[gt], ds === _o ? Bt.some(300) : Bt.none());
      fo.setData({ results: mn });
    }, ct = mt((fo) => {
      ue(fo);
    }, 200), Ht = {
      label: "Search",
      type: "input",
      name: gt
    }, vo = {
      type: "collection",
      name: "results"
    }, Wn = () => {
      const fo = {
        type: "tabpanel",
        tabs: Un(X.listCategories(), (yn) => ({
          title: yn,
          name: yn,
          items: [
            Ht,
            vo
          ]
        }))
      };
      return {
        title: "Emojis",
        size: "normal",
        body: fo,
        initialData: je,
        onTabChange: (yn, ds) => {
          ke.set(ds.newTabName), ct.throttle(yn);
        },
        onChange: ct.throttle,
        onAction: (yn, ds) => {
          ds.name === "results" && (an(ae, ds.value), yn.close());
        },
        buttons: [{
          type: "cancel",
          text: "Close",
          primary: !0
        }]
      };
    }, ko = ae.windowManager.open(Wn());
    ko.focus(gt), X.hasLoaded() || (ko.block("Loading emojis..."), X.waitForLoad().then(() => {
      ko.redial(Wn()), ct.throttle(ko), ko.focus(gt), ko.unblock();
    }).catch((fo) => {
      ko.redial({
        title: "Emojis",
        body: {
          type: "panel",
          items: [{
            type: "alertbanner",
            level: "error",
            icon: "warning",
            text: "Could not load emojis"
          }]
        },
        buttons: [{
          type: "cancel",
          text: "Close",
          primary: !0
        }],
        initialData: {
          pattern: "",
          results: []
        }
      }), ko.focus(gt), ko.unblock();
    }));
  }, Pt = (ae, X) => {
    ae.addCommand("mceEmoticons", () => en(ae, X));
  }, Ne = (ae) => {
    ae.on("PreInit", () => {
      ae.parser.addAttributeFilter("data-emoticon", (X) => {
        Ao(X, (je) => {
          je.attr("data-mce-resize", "false"), je.attr("data-mce-placeholder", "1");
        });
      });
    });
  }, We = (ae, X) => {
    ae.ui.registry.addAutocompleter("emoticons", {
      ch: ":",
      columns: "auto",
      minChars: 2,
      fetch: (je, ke) => X.waitForLoad().then(() => {
        const ue = X.listAll();
        return O(ue, je, Bt.some(ke));
      }),
      onAction: (je, ke, ue) => {
        ae.selection.setRng(ke), ae.insertContent(ue), je.hide();
      }
    });
  }, Ae = (ae) => {
    const X = () => ae.execCommand("mceEmoticons");
    ae.ui.registry.addButton("emoticons", {
      tooltip: "Emojis",
      icon: "emoji",
      onAction: X
    }), ae.ui.registry.addMenuItem("emoticons", {
      text: "Emojis...",
      icon: "emoji",
      onAction: X
    });
  };
  var Oe = () => {
    ns.add("emoticons", (ae, X) => {
      Qe(ae, X);
      const je = Pe(ae), ke = Rt(ae), ue = Mn(ae, je, ke);
      Pt(ae, ue), Ae(ae), We(ae, ue), Ne(ae);
    });
  };
  Oe();
})();
window.tinymce.Resource.add("tinymce.plugins.emoticons", { grinning: { keywords: ["face", "smile", "happy", "joy", ":D", "grin"], char: "\u{1F600}", fitzpatrick_scale: !1, category: "people" }, grimacing: { keywords: ["face", "grimace", "teeth"], char: "\u{1F62C}", fitzpatrick_scale: !1, category: "people" }, grin: { keywords: ["face", "happy", "smile", "joy", "kawaii"], char: "\u{1F601}", fitzpatrick_scale: !1, category: "people" }, joy: { keywords: ["face", "cry", "tears", "weep", "happy", "happytears", "haha"], char: "\u{1F602}", fitzpatrick_scale: !1, category: "people" }, rofl: { keywords: ["face", "rolling", "floor", "laughing", "lol", "haha"], char: "\u{1F923}", fitzpatrick_scale: !1, category: "people" }, partying: { keywords: ["face", "celebration", "woohoo"], char: "\u{1F973}", fitzpatrick_scale: !1, category: "people" }, smiley: { keywords: ["face", "happy", "joy", "haha", ":D", ":)", "smile", "funny"], char: "\u{1F603}", fitzpatrick_scale: !1, category: "people" }, smile: { keywords: ["face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"], char: "\u{1F604}", fitzpatrick_scale: !1, category: "people" }, sweat_smile: { keywords: ["face", "hot", "happy", "laugh", "sweat", "smile", "relief"], char: "\u{1F605}", fitzpatrick_scale: !1, category: "people" }, laughing: { keywords: ["happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh"], char: "\u{1F606}", fitzpatrick_scale: !1, category: "people" }, innocent: { keywords: ["face", "angel", "heaven", "halo"], char: "\u{1F607}", fitzpatrick_scale: !1, category: "people" }, wink: { keywords: ["face", "happy", "mischievous", "secret", ";)", "smile", "eye"], char: "\u{1F609}", fitzpatrick_scale: !1, category: "people" }, blush: { keywords: ["face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"], char: "\u{1F60A}", fitzpatrick_scale: !1, category: "people" }, slightly_smiling_face: { keywords: ["face", "smile"], char: "\u{1F642}", fitzpatrick_scale: !1, category: "people" }, upside_down_face: { keywords: ["face", "flipped", "silly", "smile"], char: "\u{1F643}", fitzpatrick_scale: !1, category: "people" }, relaxed: { keywords: ["face", "blush", "massage", "happiness"], char: "\u263A\uFE0F", fitzpatrick_scale: !1, category: "people" }, yum: { keywords: ["happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring"], char: "\u{1F60B}", fitzpatrick_scale: !1, category: "people" }, relieved: { keywords: ["face", "relaxed", "phew", "massage", "happiness"], char: "\u{1F60C}", fitzpatrick_scale: !1, category: "people" }, heart_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart"], char: "\u{1F60D}", fitzpatrick_scale: !1, category: "people" }, smiling_face_with_three_hearts: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore"], char: "\u{1F970}", fitzpatrick_scale: !1, category: "people" }, kissing_heart: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F618}", fitzpatrick_scale: !1, category: "people" }, kissing: { keywords: ["love", "like", "face", "3", "valentines", "infatuation", "kiss"], char: "\u{1F617}", fitzpatrick_scale: !1, category: "people" }, kissing_smiling_eyes: { keywords: ["face", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F619}", fitzpatrick_scale: !1, category: "people" }, kissing_closed_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "\u{1F61A}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_winking_eye: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue"], char: "\u{1F61C}", fitzpatrick_scale: !1, category: "people" }, zany: { keywords: ["face", "goofy", "crazy"], char: "\u{1F92A}", fitzpatrick_scale: !1, category: "people" }, raised_eyebrow: { keywords: ["face", "distrust", "scepticism", "disapproval", "disbelief", "surprise"], char: "\u{1F928}", fitzpatrick_scale: !1, category: "people" }, monocle: { keywords: ["face", "stuffy", "wealthy"], char: "\u{1F9D0}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_closed_eyes: { keywords: ["face", "prank", "playful", "mischievous", "smile", "tongue"], char: "\u{1F61D}", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "tongue"], char: "\u{1F61B}", fitzpatrick_scale: !1, category: "people" }, money_mouth_face: { keywords: ["face", "rich", "dollar", "money"], char: "\u{1F911}", fitzpatrick_scale: !1, category: "people" }, nerd_face: { keywords: ["face", "nerdy", "geek", "dork"], char: "\u{1F913}", fitzpatrick_scale: !1, category: "people" }, sunglasses: { keywords: ["face", "cool", "smile", "summer", "beach", "sunglass"], char: "\u{1F60E}", fitzpatrick_scale: !1, category: "people" }, star_struck: { keywords: ["face", "smile", "starry", "eyes", "grinning"], char: "\u{1F929}", fitzpatrick_scale: !1, category: "people" }, clown_face: { keywords: ["face"], char: "\u{1F921}", fitzpatrick_scale: !1, category: "people" }, cowboy_hat_face: { keywords: ["face", "cowgirl", "hat"], char: "\u{1F920}", fitzpatrick_scale: !1, category: "people" }, hugs: { keywords: ["face", "smile", "hug"], char: "\u{1F917}", fitzpatrick_scale: !1, category: "people" }, smirk: { keywords: ["face", "smile", "mean", "prank", "smug", "sarcasm"], char: "\u{1F60F}", fitzpatrick_scale: !1, category: "people" }, no_mouth: { keywords: ["face", "hellokitty"], char: "\u{1F636}", fitzpatrick_scale: !1, category: "people" }, neutral_face: { keywords: ["indifference", "meh", ":|", "neutral"], char: "\u{1F610}", fitzpatrick_scale: !1, category: "people" }, expressionless: { keywords: ["face", "indifferent", "-_-", "meh", "deadpan"], char: "\u{1F611}", fitzpatrick_scale: !1, category: "people" }, unamused: { keywords: ["indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye"], char: "\u{1F612}", fitzpatrick_scale: !1, category: "people" }, roll_eyes: { keywords: ["face", "eyeroll", "frustrated"], char: "\u{1F644}", fitzpatrick_scale: !1, category: "people" }, thinking: { keywords: ["face", "hmmm", "think", "consider"], char: "\u{1F914}", fitzpatrick_scale: !1, category: "people" }, lying_face: { keywords: ["face", "lie", "pinocchio"], char: "\u{1F925}", fitzpatrick_scale: !1, category: "people" }, hand_over_mouth: { keywords: ["face", "whoops", "shock", "surprise"], char: "\u{1F92D}", fitzpatrick_scale: !1, category: "people" }, shushing: { keywords: ["face", "quiet", "shhh"], char: "\u{1F92B}", fitzpatrick_scale: !1, category: "people" }, symbols_over_mouth: { keywords: ["face", "swearing", "cursing", "cussing", "profanity", "expletive"], char: "\u{1F92C}", fitzpatrick_scale: !1, category: "people" }, exploding_head: { keywords: ["face", "shocked", "mind", "blown"], char: "\u{1F92F}", fitzpatrick_scale: !1, category: "people" }, flushed: { keywords: ["face", "blush", "shy", "flattered"], char: "\u{1F633}", fitzpatrick_scale: !1, category: "people" }, disappointed: { keywords: ["face", "sad", "upset", "depressed", ":("], char: "\u{1F61E}", fitzpatrick_scale: !1, category: "people" }, worried: { keywords: ["face", "concern", "nervous", ":("], char: "\u{1F61F}", fitzpatrick_scale: !1, category: "people" }, angry: { keywords: ["mad", "face", "annoyed", "frustrated"], char: "\u{1F620}", fitzpatrick_scale: !1, category: "people" }, rage: { keywords: ["angry", "mad", "hate", "despise"], char: "\u{1F621}", fitzpatrick_scale: !1, category: "people" }, pensive: { keywords: ["face", "sad", "depressed", "upset"], char: "\u{1F614}", fitzpatrick_scale: !1, category: "people" }, confused: { keywords: ["face", "indifference", "huh", "weird", "hmmm", ":/"], char: "\u{1F615}", fitzpatrick_scale: !1, category: "people" }, slightly_frowning_face: { keywords: ["face", "frowning", "disappointed", "sad", "upset"], char: "\u{1F641}", fitzpatrick_scale: !1, category: "people" }, frowning_face: { keywords: ["face", "sad", "upset", "frown"], char: "\u2639", fitzpatrick_scale: !1, category: "people" }, persevere: { keywords: ["face", "sick", "no", "upset", "oops"], char: "\u{1F623}", fitzpatrick_scale: !1, category: "people" }, confounded: { keywords: ["face", "confused", "sick", "unwell", "oops", ":S"], char: "\u{1F616}", fitzpatrick_scale: !1, category: "people" }, tired_face: { keywords: ["sick", "whine", "upset", "frustrated"], char: "\u{1F62B}", fitzpatrick_scale: !1, category: "people" }, weary: { keywords: ["face", "tired", "sleepy", "sad", "frustrated", "upset"], char: "\u{1F629}", fitzpatrick_scale: !1, category: "people" }, pleading: { keywords: ["face", "begging", "mercy"], char: "\u{1F97A}", fitzpatrick_scale: !1, category: "people" }, triumph: { keywords: ["face", "gas", "phew", "proud", "pride"], char: "\u{1F624}", fitzpatrick_scale: !1, category: "people" }, open_mouth: { keywords: ["face", "surprise", "impressed", "wow", "whoa", ":O"], char: "\u{1F62E}", fitzpatrick_scale: !1, category: "people" }, scream: { keywords: ["face", "munch", "scared", "omg"], char: "\u{1F631}", fitzpatrick_scale: !1, category: "people" }, fearful: { keywords: ["face", "scared", "terrified", "nervous", "oops", "huh"], char: "\u{1F628}", fitzpatrick_scale: !1, category: "people" }, cold_sweat: { keywords: ["face", "nervous", "sweat"], char: "\u{1F630}", fitzpatrick_scale: !1, category: "people" }, hushed: { keywords: ["face", "woo", "shh"], char: "\u{1F62F}", fitzpatrick_scale: !1, category: "people" }, frowning: { keywords: ["face", "aw", "what"], char: "\u{1F626}", fitzpatrick_scale: !1, category: "people" }, anguished: { keywords: ["face", "stunned", "nervous"], char: "\u{1F627}", fitzpatrick_scale: !1, category: "people" }, cry: { keywords: ["face", "tears", "sad", "depressed", "upset", ":'("], char: "\u{1F622}", fitzpatrick_scale: !1, category: "people" }, disappointed_relieved: { keywords: ["face", "phew", "sweat", "nervous"], char: "\u{1F625}", fitzpatrick_scale: !1, category: "people" }, drooling_face: { keywords: ["face"], char: "\u{1F924}", fitzpatrick_scale: !1, category: "people" }, sleepy: { keywords: ["face", "tired", "rest", "nap"], char: "\u{1F62A}", fitzpatrick_scale: !1, category: "people" }, sweat: { keywords: ["face", "hot", "sad", "tired", "exercise"], char: "\u{1F613}", fitzpatrick_scale: !1, category: "people" }, hot: { keywords: ["face", "feverish", "heat", "red", "sweating"], char: "\u{1F975}", fitzpatrick_scale: !1, category: "people" }, cold: { keywords: ["face", "blue", "freezing", "frozen", "frostbite", "icicles"], char: "\u{1F976}", fitzpatrick_scale: !1, category: "people" }, sob: { keywords: ["face", "cry", "tears", "sad", "upset", "depressed"], char: "\u{1F62D}", fitzpatrick_scale: !1, category: "people" }, dizzy_face: { keywords: ["spent", "unconscious", "xox", "dizzy"], char: "\u{1F635}", fitzpatrick_scale: !1, category: "people" }, astonished: { keywords: ["face", "xox", "surprised", "poisoned"], char: "\u{1F632}", fitzpatrick_scale: !1, category: "people" }, zipper_mouth_face: { keywords: ["face", "sealed", "zipper", "secret"], char: "\u{1F910}", fitzpatrick_scale: !1, category: "people" }, nauseated_face: { keywords: ["face", "vomit", "gross", "green", "sick", "throw up", "ill"], char: "\u{1F922}", fitzpatrick_scale: !1, category: "people" }, sneezing_face: { keywords: ["face", "gesundheit", "sneeze", "sick", "allergy"], char: "\u{1F927}", fitzpatrick_scale: !1, category: "people" }, vomiting: { keywords: ["face", "sick"], char: "\u{1F92E}", fitzpatrick_scale: !1, category: "people" }, mask: { keywords: ["face", "sick", "ill", "disease"], char: "\u{1F637}", fitzpatrick_scale: !1, category: "people" }, face_with_thermometer: { keywords: ["sick", "temperature", "thermometer", "cold", "fever"], char: "\u{1F912}", fitzpatrick_scale: !1, category: "people" }, face_with_head_bandage: { keywords: ["injured", "clumsy", "bandage", "hurt"], char: "\u{1F915}", fitzpatrick_scale: !1, category: "people" }, woozy: { keywords: ["face", "dizzy", "intoxicated", "tipsy", "wavy"], char: "\u{1F974}", fitzpatrick_scale: !1, category: "people" }, sleeping: { keywords: ["face", "tired", "sleepy", "night", "zzz"], char: "\u{1F634}", fitzpatrick_scale: !1, category: "people" }, zzz: { keywords: ["sleepy", "tired", "dream"], char: "\u{1F4A4}", fitzpatrick_scale: !1, category: "people" }, poop: { keywords: ["hankey", "shitface", "fail", "turd", "shit"], char: "\u{1F4A9}", fitzpatrick_scale: !1, category: "people" }, smiling_imp: { keywords: ["devil", "horns"], char: "\u{1F608}", fitzpatrick_scale: !1, category: "people" }, imp: { keywords: ["devil", "angry", "horns"], char: "\u{1F47F}", fitzpatrick_scale: !1, category: "people" }, japanese_ogre: { keywords: ["monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre"], char: "\u{1F479}", fitzpatrick_scale: !1, category: "people" }, japanese_goblin: { keywords: ["red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin"], char: "\u{1F47A}", fitzpatrick_scale: !1, category: "people" }, skull: { keywords: ["dead", "skeleton", "creepy", "death"], char: "\u{1F480}", fitzpatrick_scale: !1, category: "people" }, ghost: { keywords: ["halloween", "spooky", "scary"], char: "\u{1F47B}", fitzpatrick_scale: !1, category: "people" }, alien: { keywords: ["UFO", "paul", "weird", "outer_space"], char: "\u{1F47D}", fitzpatrick_scale: !1, category: "people" }, robot: { keywords: ["computer", "machine", "bot"], char: "\u{1F916}", fitzpatrick_scale: !1, category: "people" }, smiley_cat: { keywords: ["animal", "cats", "happy", "smile"], char: "\u{1F63A}", fitzpatrick_scale: !1, category: "people" }, smile_cat: { keywords: ["animal", "cats", "smile"], char: "\u{1F638}", fitzpatrick_scale: !1, category: "people" }, joy_cat: { keywords: ["animal", "cats", "haha", "happy", "tears"], char: "\u{1F639}", fitzpatrick_scale: !1, category: "people" }, heart_eyes_cat: { keywords: ["animal", "love", "like", "affection", "cats", "valentines", "heart"], char: "\u{1F63B}", fitzpatrick_scale: !1, category: "people" }, smirk_cat: { keywords: ["animal", "cats", "smirk"], char: "\u{1F63C}", fitzpatrick_scale: !1, category: "people" }, kissing_cat: { keywords: ["animal", "cats", "kiss"], char: "\u{1F63D}", fitzpatrick_scale: !1, category: "people" }, scream_cat: { keywords: ["animal", "cats", "munch", "scared", "scream"], char: "\u{1F640}", fitzpatrick_scale: !1, category: "people" }, crying_cat_face: { keywords: ["animal", "tears", "weep", "sad", "cats", "upset", "cry"], char: "\u{1F63F}", fitzpatrick_scale: !1, category: "people" }, pouting_cat: { keywords: ["animal", "cats"], char: "\u{1F63E}", fitzpatrick_scale: !1, category: "people" }, palms_up: { keywords: ["hands", "gesture", "cupped", "prayer"], char: "\u{1F932}", fitzpatrick_scale: !0, category: "people" }, raised_hands: { keywords: ["gesture", "hooray", "yea", "celebration", "hands"], char: "\u{1F64C}", fitzpatrick_scale: !0, category: "people" }, clap: { keywords: ["hands", "praise", "applause", "congrats", "yay"], char: "\u{1F44F}", fitzpatrick_scale: !0, category: "people" }, wave: { keywords: ["hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"], char: "\u{1F44B}", fitzpatrick_scale: !0, category: "people" }, call_me_hand: { keywords: ["hands", "gesture"], char: "\u{1F919}", fitzpatrick_scale: !0, category: "people" }, "+1": { keywords: ["thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"], char: "\u{1F44D}", fitzpatrick_scale: !0, category: "people" }, "-1": { keywords: ["thumbsdown", "no", "dislike", "hand"], char: "\u{1F44E}", fitzpatrick_scale: !0, category: "people" }, facepunch: { keywords: ["angry", "violence", "fist", "hit", "attack", "hand"], char: "\u{1F44A}", fitzpatrick_scale: !0, category: "people" }, fist: { keywords: ["fingers", "hand", "grasp"], char: "\u270A", fitzpatrick_scale: !0, category: "people" }, fist_left: { keywords: ["hand", "fistbump"], char: "\u{1F91B}", fitzpatrick_scale: !0, category: "people" }, fist_right: { keywords: ["hand", "fistbump"], char: "\u{1F91C}", fitzpatrick_scale: !0, category: "people" }, v: { keywords: ["fingers", "ohyeah", "hand", "peace", "victory", "two"], char: "\u270C", fitzpatrick_scale: !0, category: "people" }, ok_hand: { keywords: ["fingers", "limbs", "perfect", "ok", "okay"], char: "\u{1F44C}", fitzpatrick_scale: !0, category: "people" }, raised_hand: { keywords: ["fingers", "stop", "highfive", "palm", "ban"], char: "\u270B", fitzpatrick_scale: !0, category: "people" }, raised_back_of_hand: { keywords: ["fingers", "raised", "backhand"], char: "\u{1F91A}", fitzpatrick_scale: !0, category: "people" }, open_hands: { keywords: ["fingers", "butterfly", "hands", "open"], char: "\u{1F450}", fitzpatrick_scale: !0, category: "people" }, muscle: { keywords: ["arm", "flex", "hand", "summer", "strong", "biceps"], char: "\u{1F4AA}", fitzpatrick_scale: !0, category: "people" }, pray: { keywords: ["please", "hope", "wish", "namaste", "highfive"], char: "\u{1F64F}", fitzpatrick_scale: !0, category: "people" }, foot: { keywords: ["kick", "stomp"], char: "\u{1F9B6}", fitzpatrick_scale: !0, category: "people" }, leg: { keywords: ["kick", "limb"], char: "\u{1F9B5}", fitzpatrick_scale: !0, category: "people" }, handshake: { keywords: ["agreement", "shake"], char: "\u{1F91D}", fitzpatrick_scale: !1, category: "people" }, point_up: { keywords: ["hand", "fingers", "direction", "up"], char: "\u261D", fitzpatrick_scale: !0, category: "people" }, point_up_2: { keywords: ["fingers", "hand", "direction", "up"], char: "\u{1F446}", fitzpatrick_scale: !0, category: "people" }, point_down: { keywords: ["fingers", "hand", "direction", "down"], char: "\u{1F447}", fitzpatrick_scale: !0, category: "people" }, point_left: { keywords: ["direction", "fingers", "hand", "left"], char: "\u{1F448}", fitzpatrick_scale: !0, category: "people" }, point_right: { keywords: ["fingers", "hand", "direction", "right"], char: "\u{1F449}", fitzpatrick_scale: !0, category: "people" }, fu: { keywords: ["hand", "fingers", "rude", "middle", "flipping"], char: "\u{1F595}", fitzpatrick_scale: !0, category: "people" }, raised_hand_with_fingers_splayed: { keywords: ["hand", "fingers", "palm"], char: "\u{1F590}", fitzpatrick_scale: !0, category: "people" }, love_you: { keywords: ["hand", "fingers", "gesture"], char: "\u{1F91F}", fitzpatrick_scale: !0, category: "people" }, metal: { keywords: ["hand", "fingers", "evil_eye", "sign_of_horns", "rock_on"], char: "\u{1F918}", fitzpatrick_scale: !0, category: "people" }, crossed_fingers: { keywords: ["good", "lucky"], char: "\u{1F91E}", fitzpatrick_scale: !0, category: "people" }, vulcan_salute: { keywords: ["hand", "fingers", "spock", "star trek"], char: "\u{1F596}", fitzpatrick_scale: !0, category: "people" }, writing_hand: { keywords: ["lower_left_ballpoint_pen", "stationery", "write", "compose"], char: "\u270D", fitzpatrick_scale: !0, category: "people" }, selfie: { keywords: ["camera", "phone"], char: "\u{1F933}", fitzpatrick_scale: !0, category: "people" }, nail_care: { keywords: ["beauty", "manicure", "finger", "fashion", "nail"], char: "\u{1F485}", fitzpatrick_scale: !0, category: "people" }, lips: { keywords: ["mouth", "kiss"], char: "\u{1F444}", fitzpatrick_scale: !1, category: "people" }, tooth: { keywords: ["teeth", "dentist"], char: "\u{1F9B7}", fitzpatrick_scale: !1, category: "people" }, tongue: { keywords: ["mouth", "playful"], char: "\u{1F445}", fitzpatrick_scale: !1, category: "people" }, ear: { keywords: ["face", "hear", "sound", "listen"], char: "\u{1F442}", fitzpatrick_scale: !0, category: "people" }, nose: { keywords: ["smell", "sniff"], char: "\u{1F443}", fitzpatrick_scale: !0, category: "people" }, eye: { keywords: ["face", "look", "see", "watch", "stare"], char: "\u{1F441}", fitzpatrick_scale: !1, category: "people" }, eyes: { keywords: ["look", "watch", "stalk", "peek", "see"], char: "\u{1F440}", fitzpatrick_scale: !1, category: "people" }, brain: { keywords: ["smart", "intelligent"], char: "\u{1F9E0}", fitzpatrick_scale: !1, category: "people" }, bust_in_silhouette: { keywords: ["user", "person", "human"], char: "\u{1F464}", fitzpatrick_scale: !1, category: "people" }, busts_in_silhouette: { keywords: ["user", "person", "human", "group", "team"], char: "\u{1F465}", fitzpatrick_scale: !1, category: "people" }, speaking_head: { keywords: ["user", "person", "human", "sing", "say", "talk"], char: "\u{1F5E3}", fitzpatrick_scale: !1, category: "people" }, baby: { keywords: ["child", "boy", "girl", "toddler"], char: "\u{1F476}", fitzpatrick_scale: !0, category: "people" }, child: { keywords: ["gender-neutral", "young"], char: "\u{1F9D2}", fitzpatrick_scale: !0, category: "people" }, boy: { keywords: ["man", "male", "guy", "teenager"], char: "\u{1F466}", fitzpatrick_scale: !0, category: "people" }, girl: { keywords: ["female", "woman", "teenager"], char: "\u{1F467}", fitzpatrick_scale: !0, category: "people" }, adult: { keywords: ["gender-neutral", "person"], char: "\u{1F9D1}", fitzpatrick_scale: !0, category: "people" }, man: { keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"], char: "\u{1F468}", fitzpatrick_scale: !0, category: "people" }, woman: { keywords: ["female", "girls", "lady"], char: "\u{1F469}", fitzpatrick_scale: !0, category: "people" }, blonde_woman: { keywords: ["woman", "female", "girl", "blonde", "person"], char: "\u{1F471}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, blonde_man: { keywords: ["man", "male", "boy", "blonde", "guy", "person"], char: "\u{1F471}", fitzpatrick_scale: !0, category: "people" }, bearded_person: { keywords: ["person", "bewhiskered"], char: "\u{1F9D4}", fitzpatrick_scale: !0, category: "people" }, older_adult: { keywords: ["human", "elder", "senior", "gender-neutral"], char: "\u{1F9D3}", fitzpatrick_scale: !0, category: "people" }, older_man: { keywords: ["human", "male", "men", "old", "elder", "senior"], char: "\u{1F474}", fitzpatrick_scale: !0, category: "people" }, older_woman: { keywords: ["human", "female", "women", "lady", "old", "elder", "senior"], char: "\u{1F475}", fitzpatrick_scale: !0, category: "people" }, man_with_gua_pi_mao: { keywords: ["male", "boy", "chinese"], char: "\u{1F472}", fitzpatrick_scale: !0, category: "people" }, woman_with_headscarf: { keywords: ["female", "hijab", "mantilla", "tichel"], char: "\u{1F9D5}", fitzpatrick_scale: !0, category: "people" }, woman_with_turban: { keywords: ["female", "indian", "hinduism", "arabs", "woman"], char: "\u{1F473}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_with_turban: { keywords: ["male", "indian", "hinduism", "arabs"], char: "\u{1F473}", fitzpatrick_scale: !0, category: "people" }, policewoman: { keywords: ["woman", "police", "law", "legal", "enforcement", "arrest", "911", "female"], char: "\u{1F46E}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, policeman: { keywords: ["man", "police", "law", "legal", "enforcement", "arrest", "911"], char: "\u{1F46E}", fitzpatrick_scale: !0, category: "people" }, construction_worker_woman: { keywords: ["female", "human", "wip", "build", "construction", "worker", "labor", "woman"], char: "\u{1F477}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, construction_worker_man: { keywords: ["male", "human", "wip", "guy", "build", "construction", "worker", "labor"], char: "\u{1F477}", fitzpatrick_scale: !0, category: "people" }, guardswoman: { keywords: ["uk", "gb", "british", "female", "royal", "woman"], char: "\u{1F482}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, guardsman: { keywords: ["uk", "gb", "british", "male", "guy", "royal"], char: "\u{1F482}", fitzpatrick_scale: !0, category: "people" }, female_detective: { keywords: ["human", "spy", "detective", "female", "woman"], char: "\u{1F575}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, male_detective: { keywords: ["human", "spy", "detective"], char: "\u{1F575}", fitzpatrick_scale: !0, category: "people" }, woman_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "woman", "human"], char: "\u{1F469}\u200D\u2695\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "man", "human"], char: "\u{1F468}\u200D\u2695\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_farmer: { keywords: ["rancher", "gardener", "woman", "human"], char: "\u{1F469}\u200D\u{1F33E}", fitzpatrick_scale: !0, category: "people" }, man_farmer: { keywords: ["rancher", "gardener", "man", "human"], char: "\u{1F468}\u200D\u{1F33E}", fitzpatrick_scale: !0, category: "people" }, woman_cook: { keywords: ["chef", "woman", "human"], char: "\u{1F469}\u200D\u{1F373}", fitzpatrick_scale: !0, category: "people" }, man_cook: { keywords: ["chef", "man", "human"], char: "\u{1F468}\u200D\u{1F373}", fitzpatrick_scale: !0, category: "people" }, woman_student: { keywords: ["graduate", "woman", "human"], char: "\u{1F469}\u200D\u{1F393}", fitzpatrick_scale: !0, category: "people" }, man_student: { keywords: ["graduate", "man", "human"], char: "\u{1F468}\u200D\u{1F393}", fitzpatrick_scale: !0, category: "people" }, woman_singer: { keywords: ["rockstar", "entertainer", "woman", "human"], char: "\u{1F469}\u200D\u{1F3A4}", fitzpatrick_scale: !0, category: "people" }, man_singer: { keywords: ["rockstar", "entertainer", "man", "human"], char: "\u{1F468}\u200D\u{1F3A4}", fitzpatrick_scale: !0, category: "people" }, woman_teacher: { keywords: ["instructor", "professor", "woman", "human"], char: "\u{1F469}\u200D\u{1F3EB}", fitzpatrick_scale: !0, category: "people" }, man_teacher: { keywords: ["instructor", "professor", "man", "human"], char: "\u{1F468}\u200D\u{1F3EB}", fitzpatrick_scale: !0, category: "people" }, woman_factory_worker: { keywords: ["assembly", "industrial", "woman", "human"], char: "\u{1F469}\u200D\u{1F3ED}", fitzpatrick_scale: !0, category: "people" }, man_factory_worker: { keywords: ["assembly", "industrial", "man", "human"], char: "\u{1F468}\u200D\u{1F3ED}", fitzpatrick_scale: !0, category: "people" }, woman_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer"], char: "\u{1F469}\u200D\u{1F4BB}", fitzpatrick_scale: !0, category: "people" }, man_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer"], char: "\u{1F468}\u200D\u{1F4BB}", fitzpatrick_scale: !0, category: "people" }, woman_office_worker: { keywords: ["business", "manager", "woman", "human"], char: "\u{1F469}\u200D\u{1F4BC}", fitzpatrick_scale: !0, category: "people" }, man_office_worker: { keywords: ["business", "manager", "man", "human"], char: "\u{1F468}\u200D\u{1F4BC}", fitzpatrick_scale: !0, category: "people" }, woman_mechanic: { keywords: ["plumber", "woman", "human", "wrench"], char: "\u{1F469}\u200D\u{1F527}", fitzpatrick_scale: !0, category: "people" }, man_mechanic: { keywords: ["plumber", "man", "human", "wrench"], char: "\u{1F468}\u200D\u{1F527}", fitzpatrick_scale: !0, category: "people" }, woman_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "woman", "human"], char: "\u{1F469}\u200D\u{1F52C}", fitzpatrick_scale: !0, category: "people" }, man_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "man", "human"], char: "\u{1F468}\u200D\u{1F52C}", fitzpatrick_scale: !0, category: "people" }, woman_artist: { keywords: ["painter", "woman", "human"], char: "\u{1F469}\u200D\u{1F3A8}", fitzpatrick_scale: !0, category: "people" }, man_artist: { keywords: ["painter", "man", "human"], char: "\u{1F468}\u200D\u{1F3A8}", fitzpatrick_scale: !0, category: "people" }, woman_firefighter: { keywords: ["fireman", "woman", "human"], char: "\u{1F469}\u200D\u{1F692}", fitzpatrick_scale: !0, category: "people" }, man_firefighter: { keywords: ["fireman", "man", "human"], char: "\u{1F468}\u200D\u{1F692}", fitzpatrick_scale: !0, category: "people" }, woman_pilot: { keywords: ["aviator", "plane", "woman", "human"], char: "\u{1F469}\u200D\u2708\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_pilot: { keywords: ["aviator", "plane", "man", "human"], char: "\u{1F468}\u200D\u2708\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_astronaut: { keywords: ["space", "rocket", "woman", "human"], char: "\u{1F469}\u200D\u{1F680}", fitzpatrick_scale: !0, category: "people" }, man_astronaut: { keywords: ["space", "rocket", "man", "human"], char: "\u{1F468}\u200D\u{1F680}", fitzpatrick_scale: !0, category: "people" }, woman_judge: { keywords: ["justice", "court", "woman", "human"], char: "\u{1F469}\u200D\u2696\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_judge: { keywords: ["justice", "court", "man", "human"], char: "\u{1F468}\u200D\u2696\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_superhero: { keywords: ["woman", "female", "good", "heroine", "superpowers"], char: "\u{1F9B8}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_superhero: { keywords: ["man", "male", "good", "hero", "superpowers"], char: "\u{1F9B8}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_supervillain: { keywords: ["woman", "female", "evil", "bad", "criminal", "heroine", "superpowers"], char: "\u{1F9B9}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_supervillain: { keywords: ["man", "male", "evil", "bad", "criminal", "hero", "superpowers"], char: "\u{1F9B9}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, mrs_claus: { keywords: ["woman", "female", "xmas", "mother christmas"], char: "\u{1F936}", fitzpatrick_scale: !0, category: "people" }, santa: { keywords: ["festival", "man", "male", "xmas", "father christmas"], char: "\u{1F385}", fitzpatrick_scale: !0, category: "people" }, sorceress: { keywords: ["woman", "female", "mage", "witch"], char: "\u{1F9D9}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, wizard: { keywords: ["man", "male", "mage", "sorcerer"], char: "\u{1F9D9}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_elf: { keywords: ["woman", "female"], char: "\u{1F9DD}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_elf: { keywords: ["man", "male"], char: "\u{1F9DD}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_vampire: { keywords: ["woman", "female"], char: "\u{1F9DB}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_vampire: { keywords: ["man", "male", "dracula"], char: "\u{1F9DB}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_zombie: { keywords: ["woman", "female", "undead", "walking dead"], char: "\u{1F9DF}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "people" }, man_zombie: { keywords: ["man", "male", "dracula", "undead", "walking dead"], char: "\u{1F9DF}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, woman_genie: { keywords: ["woman", "female"], char: "\u{1F9DE}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "people" }, man_genie: { keywords: ["man", "male"], char: "\u{1F9DE}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, mermaid: { keywords: ["woman", "female", "merwoman", "ariel"], char: "\u{1F9DC}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, merman: { keywords: ["man", "male", "triton"], char: "\u{1F9DC}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_fairy: { keywords: ["woman", "female"], char: "\u{1F9DA}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_fairy: { keywords: ["man", "male"], char: "\u{1F9DA}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, angel: { keywords: ["heaven", "wings", "halo"], char: "\u{1F47C}", fitzpatrick_scale: !0, category: "people" }, pregnant_woman: { keywords: ["baby"], char: "\u{1F930}", fitzpatrick_scale: !0, category: "people" }, breastfeeding: { keywords: ["nursing", "baby"], char: "\u{1F931}", fitzpatrick_scale: !0, category: "people" }, princess: { keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"], char: "\u{1F478}", fitzpatrick_scale: !0, category: "people" }, prince: { keywords: ["boy", "man", "male", "crown", "royal", "king"], char: "\u{1F934}", fitzpatrick_scale: !0, category: "people" }, bride_with_veil: { keywords: ["couple", "marriage", "wedding", "woman", "bride"], char: "\u{1F470}", fitzpatrick_scale: !0, category: "people" }, man_in_tuxedo: { keywords: ["couple", "marriage", "wedding", "groom"], char: "\u{1F935}", fitzpatrick_scale: !0, category: "people" }, running_woman: { keywords: ["woman", "walking", "exercise", "race", "running", "female"], char: "\u{1F3C3}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, running_man: { keywords: ["man", "walking", "exercise", "race", "running"], char: "\u{1F3C3}", fitzpatrick_scale: !0, category: "people" }, walking_woman: { keywords: ["human", "feet", "steps", "woman", "female"], char: "\u{1F6B6}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, walking_man: { keywords: ["human", "feet", "steps"], char: "\u{1F6B6}", fitzpatrick_scale: !0, category: "people" }, dancer: { keywords: ["female", "girl", "woman", "fun"], char: "\u{1F483}", fitzpatrick_scale: !0, category: "people" }, man_dancing: { keywords: ["male", "boy", "fun", "dancer"], char: "\u{1F57A}", fitzpatrick_scale: !0, category: "people" }, dancing_women: { keywords: ["female", "bunny", "women", "girls"], char: "\u{1F46F}", fitzpatrick_scale: !1, category: "people" }, dancing_men: { keywords: ["male", "bunny", "men", "boys"], char: "\u{1F46F}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "people" }, couple: { keywords: ["pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"], char: "\u{1F46B}", fitzpatrick_scale: !1, category: "people" }, two_men_holding_hands: { keywords: ["pair", "couple", "love", "like", "bromance", "friendship", "people", "human"], char: "\u{1F46C}", fitzpatrick_scale: !1, category: "people" }, two_women_holding_hands: { keywords: ["pair", "friendship", "couple", "love", "like", "female", "people", "human"], char: "\u{1F46D}", fitzpatrick_scale: !1, category: "people" }, bowing_woman: { keywords: ["woman", "female", "girl"], char: "\u{1F647}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, bowing_man: { keywords: ["man", "male", "boy"], char: "\u{1F647}", fitzpatrick_scale: !0, category: "people" }, man_facepalming: { keywords: ["man", "male", "boy", "disbelief"], char: "\u{1F926}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_facepalming: { keywords: ["woman", "female", "girl", "disbelief"], char: "\u{1F926}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_shrugging: { keywords: ["woman", "female", "girl", "confused", "indifferent", "doubt"], char: "\u{1F937}", fitzpatrick_scale: !0, category: "people" }, man_shrugging: { keywords: ["man", "male", "boy", "confused", "indifferent", "doubt"], char: "\u{1F937}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, tipping_hand_woman: { keywords: ["female", "girl", "woman", "human", "information"], char: "\u{1F481}", fitzpatrick_scale: !0, category: "people" }, tipping_hand_man: { keywords: ["male", "boy", "man", "human", "information"], char: "\u{1F481}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, no_good_woman: { keywords: ["female", "girl", "woman", "nope"], char: "\u{1F645}", fitzpatrick_scale: !0, category: "people" }, no_good_man: { keywords: ["male", "boy", "man", "nope"], char: "\u{1F645}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, ok_woman: { keywords: ["women", "girl", "female", "pink", "human", "woman"], char: "\u{1F646}", fitzpatrick_scale: !0, category: "people" }, ok_man: { keywords: ["men", "boy", "male", "blue", "human", "man"], char: "\u{1F646}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, raising_hand_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F64B}", fitzpatrick_scale: !0, category: "people" }, raising_hand_man: { keywords: ["male", "boy", "man"], char: "\u{1F64B}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, pouting_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F64E}", fitzpatrick_scale: !0, category: "people" }, pouting_man: { keywords: ["male", "boy", "man"], char: "\u{1F64E}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, frowning_woman: { keywords: ["female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy"], char: "\u{1F64D}", fitzpatrick_scale: !0, category: "people" }, frowning_man: { keywords: ["male", "boy", "man", "sad", "depressed", "discouraged", "unhappy"], char: "\u{1F64D}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, haircut_woman: { keywords: ["female", "girl", "woman"], char: "\u{1F487}", fitzpatrick_scale: !0, category: "people" }, haircut_man: { keywords: ["male", "boy", "man"], char: "\u{1F487}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, massage_woman: { keywords: ["female", "girl", "woman", "head"], char: "\u{1F486}", fitzpatrick_scale: !0, category: "people" }, massage_man: { keywords: ["male", "boy", "man", "head"], char: "\u{1F486}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, woman_in_steamy_room: { keywords: ["female", "woman", "spa", "steamroom", "sauna"], char: "\u{1F9D6}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "people" }, man_in_steamy_room: { keywords: ["male", "man", "spa", "steamroom", "sauna"], char: "\u{1F9D6}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "people" }, couple_with_heart_woman_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F491}", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_woman_woman: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_man_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F48F}", fitzpatrick_scale: !1, category: "people" }, couplekiss_woman_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_man: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy: { keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"], char: "\u{1F46A}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl: { keywords: ["home", "parents", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F469}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F469}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "\u{1F468}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, family_man_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", fitzpatrick_scale: !1, category: "people" }, family_man_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", fitzpatrick_scale: !1, category: "people" }, yarn: { keywords: ["ball", "crochet", "knit"], char: "\u{1F9F6}", fitzpatrick_scale: !1, category: "people" }, thread: { keywords: ["needle", "sewing", "spool", "string"], char: "\u{1F9F5}", fitzpatrick_scale: !1, category: "people" }, coat: { keywords: ["jacket"], char: "\u{1F9E5}", fitzpatrick_scale: !1, category: "people" }, labcoat: { keywords: ["doctor", "experiment", "scientist", "chemist"], char: "\u{1F97C}", fitzpatrick_scale: !1, category: "people" }, womans_clothes: { keywords: ["fashion", "shopping_bags", "female"], char: "\u{1F45A}", fitzpatrick_scale: !1, category: "people" }, tshirt: { keywords: ["fashion", "cloth", "casual", "shirt", "tee"], char: "\u{1F455}", fitzpatrick_scale: !1, category: "people" }, jeans: { keywords: ["fashion", "shopping"], char: "\u{1F456}", fitzpatrick_scale: !1, category: "people" }, necktie: { keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"], char: "\u{1F454}", fitzpatrick_scale: !1, category: "people" }, dress: { keywords: ["clothes", "fashion", "shopping"], char: "\u{1F457}", fitzpatrick_scale: !1, category: "people" }, bikini: { keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"], char: "\u{1F459}", fitzpatrick_scale: !1, category: "people" }, kimono: { keywords: ["dress", "fashion", "women", "female", "japanese"], char: "\u{1F458}", fitzpatrick_scale: !1, category: "people" }, lipstick: { keywords: ["female", "girl", "fashion", "woman"], char: "\u{1F484}", fitzpatrick_scale: !1, category: "people" }, kiss: { keywords: ["face", "lips", "love", "like", "affection", "valentines"], char: "\u{1F48B}", fitzpatrick_scale: !1, category: "people" }, footprints: { keywords: ["feet", "tracking", "walking", "beach"], char: "\u{1F463}", fitzpatrick_scale: !1, category: "people" }, flat_shoe: { keywords: ["ballet", "slip-on", "slipper"], char: "\u{1F97F}", fitzpatrick_scale: !1, category: "people" }, high_heel: { keywords: ["fashion", "shoes", "female", "pumps", "stiletto"], char: "\u{1F460}", fitzpatrick_scale: !1, category: "people" }, sandal: { keywords: ["shoes", "fashion", "flip flops"], char: "\u{1F461}", fitzpatrick_scale: !1, category: "people" }, boot: { keywords: ["shoes", "fashion"], char: "\u{1F462}", fitzpatrick_scale: !1, category: "people" }, mans_shoe: { keywords: ["fashion", "male"], char: "\u{1F45E}", fitzpatrick_scale: !1, category: "people" }, athletic_shoe: { keywords: ["shoes", "sports", "sneakers"], char: "\u{1F45F}", fitzpatrick_scale: !1, category: "people" }, hiking_boot: { keywords: ["backpacking", "camping", "hiking"], char: "\u{1F97E}", fitzpatrick_scale: !1, category: "people" }, socks: { keywords: ["stockings", "clothes"], char: "\u{1F9E6}", fitzpatrick_scale: !1, category: "people" }, gloves: { keywords: ["hands", "winter", "clothes"], char: "\u{1F9E4}", fitzpatrick_scale: !1, category: "people" }, scarf: { keywords: ["neck", "winter", "clothes"], char: "\u{1F9E3}", fitzpatrick_scale: !1, category: "people" }, womans_hat: { keywords: ["fashion", "accessories", "female", "lady", "spring"], char: "\u{1F452}", fitzpatrick_scale: !1, category: "people" }, tophat: { keywords: ["magic", "gentleman", "classy", "circus"], char: "\u{1F3A9}", fitzpatrick_scale: !1, category: "people" }, billed_hat: { keywords: ["cap", "baseball"], char: "\u{1F9E2}", fitzpatrick_scale: !1, category: "people" }, rescue_worker_helmet: { keywords: ["construction", "build"], char: "\u26D1", fitzpatrick_scale: !1, category: "people" }, mortar_board: { keywords: ["school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education"], char: "\u{1F393}", fitzpatrick_scale: !1, category: "people" }, crown: { keywords: ["king", "kod", "leader", "royalty", "lord"], char: "\u{1F451}", fitzpatrick_scale: !1, category: "people" }, school_satchel: { keywords: ["student", "education", "bag", "backpack"], char: "\u{1F392}", fitzpatrick_scale: !1, category: "people" }, luggage: { keywords: ["packing", "travel"], char: "\u{1F9F3}", fitzpatrick_scale: !1, category: "people" }, pouch: { keywords: ["bag", "accessories", "shopping"], char: "\u{1F45D}", fitzpatrick_scale: !1, category: "people" }, purse: { keywords: ["fashion", "accessories", "money", "sales", "shopping"], char: "\u{1F45B}", fitzpatrick_scale: !1, category: "people" }, handbag: { keywords: ["fashion", "accessory", "accessories", "shopping"], char: "\u{1F45C}", fitzpatrick_scale: !1, category: "people" }, briefcase: { keywords: ["business", "documents", "work", "law", "legal", "job", "career"], char: "\u{1F4BC}", fitzpatrick_scale: !1, category: "people" }, eyeglasses: { keywords: ["fashion", "accessories", "eyesight", "nerdy", "dork", "geek"], char: "\u{1F453}", fitzpatrick_scale: !1, category: "people" }, dark_sunglasses: { keywords: ["face", "cool", "accessories"], char: "\u{1F576}", fitzpatrick_scale: !1, category: "people" }, goggles: { keywords: ["eyes", "protection", "safety"], char: "\u{1F97D}", fitzpatrick_scale: !1, category: "people" }, ring: { keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"], char: "\u{1F48D}", fitzpatrick_scale: !1, category: "people" }, closed_umbrella: { keywords: ["weather", "rain", "drizzle"], char: "\u{1F302}", fitzpatrick_scale: !1, category: "people" }, dog: { keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"], char: "\u{1F436}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat: { keywords: ["animal", "meow", "nature", "pet", "kitten"], char: "\u{1F431}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse: { keywords: ["animal", "nature", "cheese_wedge", "rodent"], char: "\u{1F42D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hamster: { keywords: ["animal", "nature"], char: "\u{1F439}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit: { keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"], char: "\u{1F430}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fox_face: { keywords: ["animal", "nature", "face"], char: "\u{1F98A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bear: { keywords: ["animal", "nature", "wild"], char: "\u{1F43B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, panda_face: { keywords: ["animal", "nature", "panda"], char: "\u{1F43C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, koala: { keywords: ["animal", "nature"], char: "\u{1F428}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger: { keywords: ["animal", "cat", "danger", "wild", "nature", "roar"], char: "\u{1F42F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lion: { keywords: ["animal", "nature"], char: "\u{1F981}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "\u{1F42E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig: { keywords: ["animal", "oink", "nature"], char: "\u{1F437}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig_nose: { keywords: ["animal", "oink"], char: "\u{1F43D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, frog: { keywords: ["animal", "nature", "croak", "toad"], char: "\u{1F438}", fitzpatrick_scale: !1, category: "animals_and_nature" }, squid: { keywords: ["animal", "nature", "ocean", "sea"], char: "\u{1F991}", fitzpatrick_scale: !1, category: "animals_and_nature" }, octopus: { keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"], char: "\u{1F419}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shrimp: { keywords: ["animal", "ocean", "nature", "seafood"], char: "\u{1F990}", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey_face: { keywords: ["animal", "nature", "circus"], char: "\u{1F435}", fitzpatrick_scale: !1, category: "animals_and_nature" }, gorilla: { keywords: ["animal", "nature", "circus"], char: "\u{1F98D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, see_no_evil: { keywords: ["monkey", "animal", "nature", "haha"], char: "\u{1F648}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hear_no_evil: { keywords: ["animal", "monkey", "nature"], char: "\u{1F649}", fitzpatrick_scale: !1, category: "animals_and_nature" }, speak_no_evil: { keywords: ["monkey", "animal", "nature", "omg"], char: "\u{1F64A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey: { keywords: ["animal", "nature", "banana", "circus"], char: "\u{1F412}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chicken: { keywords: ["animal", "cluck", "nature", "bird"], char: "\u{1F414}", fitzpatrick_scale: !1, category: "animals_and_nature" }, penguin: { keywords: ["animal", "nature"], char: "\u{1F427}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bird: { keywords: ["animal", "nature", "fly", "tweet", "spring"], char: "\u{1F426}", fitzpatrick_scale: !1, category: "animals_and_nature" }, baby_chick: { keywords: ["animal", "chicken", "bird"], char: "\u{1F424}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatching_chick: { keywords: ["animal", "chicken", "egg", "born", "baby", "bird"], char: "\u{1F423}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatched_chick: { keywords: ["animal", "chicken", "baby", "bird"], char: "\u{1F425}", fitzpatrick_scale: !1, category: "animals_and_nature" }, duck: { keywords: ["animal", "nature", "bird", "mallard"], char: "\u{1F986}", fitzpatrick_scale: !1, category: "animals_and_nature" }, eagle: { keywords: ["animal", "nature", "bird"], char: "\u{1F985}", fitzpatrick_scale: !1, category: "animals_and_nature" }, owl: { keywords: ["animal", "nature", "bird", "hoot"], char: "\u{1F989}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bat: { keywords: ["animal", "nature", "blind", "vampire"], char: "\u{1F987}", fitzpatrick_scale: !1, category: "animals_and_nature" }, wolf: { keywords: ["animal", "nature", "wild"], char: "\u{1F43A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, boar: { keywords: ["animal", "nature"], char: "\u{1F417}", fitzpatrick_scale: !1, category: "animals_and_nature" }, horse: { keywords: ["animal", "brown", "nature"], char: "\u{1F434}", fitzpatrick_scale: !1, category: "animals_and_nature" }, unicorn: { keywords: ["animal", "nature", "mystical"], char: "\u{1F984}", fitzpatrick_scale: !1, category: "animals_and_nature" }, honeybee: { keywords: ["animal", "insect", "nature", "bug", "spring", "honey"], char: "\u{1F41D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bug: { keywords: ["animal", "insect", "nature", "worm"], char: "\u{1F41B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, butterfly: { keywords: ["animal", "insect", "nature", "caterpillar"], char: "\u{1F98B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snail: { keywords: ["slow", "animal", "shell"], char: "\u{1F40C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, beetle: { keywords: ["animal", "insect", "nature", "ladybug"], char: "\u{1F41E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ant: { keywords: ["animal", "insect", "nature", "bug"], char: "\u{1F41C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, grasshopper: { keywords: ["animal", "cricket", "chirp"], char: "\u{1F997}", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider: { keywords: ["animal", "arachnid"], char: "\u{1F577}", fitzpatrick_scale: !1, category: "animals_and_nature" }, scorpion: { keywords: ["animal", "arachnid"], char: "\u{1F982}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crab: { keywords: ["animal", "crustacean"], char: "\u{1F980}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snake: { keywords: ["animal", "evil", "nature", "hiss", "python"], char: "\u{1F40D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lizard: { keywords: ["animal", "nature", "reptile"], char: "\u{1F98E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, "t-rex": { keywords: ["animal", "nature", "dinosaur", "tyrannosaurus", "extinct"], char: "\u{1F996}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sauropod: { keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"], char: "\u{1F995}", fitzpatrick_scale: !1, category: "animals_and_nature" }, turtle: { keywords: ["animal", "slow", "nature", "tortoise"], char: "\u{1F422}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tropical_fish: { keywords: ["animal", "swim", "ocean", "beach", "nemo"], char: "\u{1F420}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fish: { keywords: ["animal", "food", "nature"], char: "\u{1F41F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, blowfish: { keywords: ["animal", "nature", "food", "sea", "ocean"], char: "\u{1F421}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dolphin: { keywords: ["animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach"], char: "\u{1F42C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shark: { keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"], char: "\u{1F988}", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale: { keywords: ["animal", "nature", "sea", "ocean"], char: "\u{1F433}", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale2: { keywords: ["animal", "nature", "sea", "ocean"], char: "\u{1F40B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crocodile: { keywords: ["animal", "nature", "reptile", "lizard", "alligator"], char: "\u{1F40A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, leopard: { keywords: ["animal", "nature"], char: "\u{1F406}", fitzpatrick_scale: !1, category: "animals_and_nature" }, zebra: { keywords: ["animal", "nature", "stripes", "safari"], char: "\u{1F993}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger2: { keywords: ["animal", "nature", "roar"], char: "\u{1F405}", fitzpatrick_scale: !1, category: "animals_and_nature" }, water_buffalo: { keywords: ["animal", "nature", "ox", "cow"], char: "\u{1F403}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ox: { keywords: ["animal", "cow", "beef"], char: "\u{1F402}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow2: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "\u{1F404}", fitzpatrick_scale: !1, category: "animals_and_nature" }, deer: { keywords: ["animal", "nature", "horns", "venison"], char: "\u{1F98C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dromedary_camel: { keywords: ["animal", "hot", "desert", "hump"], char: "\u{1F42A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, camel: { keywords: ["animal", "nature", "hot", "desert", "hump"], char: "\u{1F42B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, giraffe: { keywords: ["animal", "nature", "spots", "safari"], char: "\u{1F992}", fitzpatrick_scale: !1, category: "animals_and_nature" }, elephant: { keywords: ["animal", "nature", "nose", "th", "circus"], char: "\u{1F418}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rhinoceros: { keywords: ["animal", "nature", "horn"], char: "\u{1F98F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, goat: { keywords: ["animal", "nature"], char: "\u{1F410}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ram: { keywords: ["animal", "sheep", "nature"], char: "\u{1F40F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sheep: { keywords: ["animal", "nature", "wool", "shipit"], char: "\u{1F411}", fitzpatrick_scale: !1, category: "animals_and_nature" }, racehorse: { keywords: ["animal", "gamble", "luck"], char: "\u{1F40E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig2: { keywords: ["animal", "nature"], char: "\u{1F416}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rat: { keywords: ["animal", "mouse", "rodent"], char: "\u{1F400}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse2: { keywords: ["animal", "nature", "rodent"], char: "\u{1F401}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rooster: { keywords: ["animal", "nature", "chicken"], char: "\u{1F413}", fitzpatrick_scale: !1, category: "animals_and_nature" }, turkey: { keywords: ["animal", "bird"], char: "\u{1F983}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dove: { keywords: ["animal", "bird"], char: "\u{1F54A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dog2: { keywords: ["animal", "nature", "friend", "doge", "pet", "faithful"], char: "\u{1F415}", fitzpatrick_scale: !1, category: "animals_and_nature" }, poodle: { keywords: ["dog", "animal", "101", "nature", "pet"], char: "\u{1F429}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat2: { keywords: ["animal", "meow", "pet", "cats"], char: "\u{1F408}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit2: { keywords: ["animal", "nature", "pet", "magic", "spring"], char: "\u{1F407}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chipmunk: { keywords: ["animal", "nature", "rodent", "squirrel"], char: "\u{1F43F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hedgehog: { keywords: ["animal", "nature", "spiny"], char: "\u{1F994}", fitzpatrick_scale: !1, category: "animals_and_nature" }, raccoon: { keywords: ["animal", "nature"], char: "\u{1F99D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, llama: { keywords: ["animal", "nature", "alpaca"], char: "\u{1F999}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hippopotamus: { keywords: ["animal", "nature"], char: "\u{1F99B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, kangaroo: { keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"], char: "\u{1F998}", fitzpatrick_scale: !1, category: "animals_and_nature" }, badger: { keywords: ["animal", "nature", "honey"], char: "\u{1F9A1}", fitzpatrick_scale: !1, category: "animals_and_nature" }, swan: { keywords: ["animal", "nature", "bird"], char: "\u{1F9A2}", fitzpatrick_scale: !1, category: "animals_and_nature" }, peacock: { keywords: ["animal", "nature", "peahen", "bird"], char: "\u{1F99A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, parrot: { keywords: ["animal", "nature", "bird", "pirate", "talk"], char: "\u{1F99C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, lobster: { keywords: ["animal", "nature", "bisque", "claws", "seafood"], char: "\u{1F99E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mosquito: { keywords: ["animal", "nature", "insect", "malaria"], char: "\u{1F99F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, paw_prints: { keywords: ["animal", "tracking", "footprints", "dog", "cat", "pet", "feet"], char: "\u{1F43E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "\u{1F409}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon_face: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "\u{1F432}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cactus: { keywords: ["vegetable", "plant", "nature"], char: "\u{1F335}", fitzpatrick_scale: !1, category: "animals_and_nature" }, christmas_tree: { keywords: ["festival", "vacation", "december", "xmas", "celebration"], char: "\u{1F384}", fitzpatrick_scale: !1, category: "animals_and_nature" }, evergreen_tree: { keywords: ["plant", "nature"], char: "\u{1F332}", fitzpatrick_scale: !1, category: "animals_and_nature" }, deciduous_tree: { keywords: ["plant", "nature"], char: "\u{1F333}", fitzpatrick_scale: !1, category: "animals_and_nature" }, palm_tree: { keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"], char: "\u{1F334}", fitzpatrick_scale: !1, category: "animals_and_nature" }, seedling: { keywords: ["plant", "nature", "grass", "lawn", "spring"], char: "\u{1F331}", fitzpatrick_scale: !1, category: "animals_and_nature" }, herb: { keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"], char: "\u{1F33F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shamrock: { keywords: ["vegetable", "plant", "nature", "irish", "clover"], char: "\u2618", fitzpatrick_scale: !1, category: "animals_and_nature" }, four_leaf_clover: { keywords: ["vegetable", "plant", "nature", "lucky", "irish"], char: "\u{1F340}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bamboo: { keywords: ["plant", "nature", "vegetable", "panda", "pine_decoration"], char: "\u{1F38D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tanabata_tree: { keywords: ["plant", "nature", "branch", "summer"], char: "\u{1F38B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, leaves: { keywords: ["nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"], char: "\u{1F343}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fallen_leaf: { keywords: ["nature", "plant", "vegetable", "leaves"], char: "\u{1F342}", fitzpatrick_scale: !1, category: "animals_and_nature" }, maple_leaf: { keywords: ["nature", "plant", "vegetable", "ca", "fall"], char: "\u{1F341}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ear_of_rice: { keywords: ["nature", "plant"], char: "\u{1F33E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, hibiscus: { keywords: ["plant", "vegetable", "flowers", "beach"], char: "\u{1F33A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunflower: { keywords: ["nature", "plant", "fall"], char: "\u{1F33B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, rose: { keywords: ["flowers", "valentines", "love", "spring"], char: "\u{1F339}", fitzpatrick_scale: !1, category: "animals_and_nature" }, wilted_flower: { keywords: ["plant", "nature", "flower"], char: "\u{1F940}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tulip: { keywords: ["flowers", "plant", "nature", "summer", "spring"], char: "\u{1F337}", fitzpatrick_scale: !1, category: "animals_and_nature" }, blossom: { keywords: ["nature", "flowers", "yellow"], char: "\u{1F33C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cherry_blossom: { keywords: ["nature", "plant", "spring", "flower"], char: "\u{1F338}", fitzpatrick_scale: !1, category: "animals_and_nature" }, bouquet: { keywords: ["flowers", "nature", "spring"], char: "\u{1F490}", fitzpatrick_scale: !1, category: "animals_and_nature" }, mushroom: { keywords: ["plant", "vegetable"], char: "\u{1F344}", fitzpatrick_scale: !1, category: "animals_and_nature" }, chestnut: { keywords: ["food", "squirrel"], char: "\u{1F330}", fitzpatrick_scale: !1, category: "animals_and_nature" }, jack_o_lantern: { keywords: ["halloween", "light", "pumpkin", "creepy", "fall"], char: "\u{1F383}", fitzpatrick_scale: !1, category: "animals_and_nature" }, shell: { keywords: ["nature", "sea", "beach"], char: "\u{1F41A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider_web: { keywords: ["animal", "insect", "arachnid", "silk"], char: "\u{1F578}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_americas: { keywords: ["globe", "world", "USA", "international"], char: "\u{1F30E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_africa: { keywords: ["globe", "world", "international"], char: "\u{1F30D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_asia: { keywords: ["globe", "world", "east", "international"], char: "\u{1F30F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon: { keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F315}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_gibbous_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon"], char: "\u{1F316}", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F317}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F318}", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F311}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F312}", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F313}", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_gibbous_moon: { keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"], char: "\u{1F314}", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31D}", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "\u{1F31C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_with_face: { keywords: ["nature", "morning", "sky"], char: "\u{1F31E}", fitzpatrick_scale: !1, category: "animals_and_nature" }, crescent_moon: { keywords: ["night", "sleep", "sky", "evening", "magic"], char: "\u{1F319}", fitzpatrick_scale: !1, category: "animals_and_nature" }, star: { keywords: ["night", "yellow"], char: "\u2B50", fitzpatrick_scale: !1, category: "animals_and_nature" }, star2: { keywords: ["night", "sparkle", "awesome", "good", "magic"], char: "\u{1F31F}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dizzy: { keywords: ["star", "sparkle", "shoot", "magic"], char: "\u{1F4AB}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sparkles: { keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"], char: "\u2728", fitzpatrick_scale: !1, category: "animals_and_nature" }, comet: { keywords: ["space"], char: "\u2604", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunny: { keywords: ["weather", "nature", "brightness", "summer", "beach", "spring"], char: "\u2600\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_small_cloud: { keywords: ["weather"], char: "\u{1F324}", fitzpatrick_scale: !1, category: "animals_and_nature" }, partly_sunny: { keywords: ["weather", "nature", "cloudy", "morning", "fall", "spring"], char: "\u26C5", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_large_cloud: { keywords: ["weather"], char: "\u{1F325}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_rain_cloud: { keywords: ["weather"], char: "\u{1F326}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud: { keywords: ["weather", "sky"], char: "\u2601\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_rain: { keywords: ["weather"], char: "\u{1F327}", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning_and_rain: { keywords: ["weather", "lightning"], char: "\u26C8", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning: { keywords: ["weather", "thunder"], char: "\u{1F329}", fitzpatrick_scale: !1, category: "animals_and_nature" }, zap: { keywords: ["thunder", "weather", "lightning bolt", "fast"], char: "\u26A1", fitzpatrick_scale: !1, category: "animals_and_nature" }, fire: { keywords: ["hot", "cook", "flame"], char: "\u{1F525}", fitzpatrick_scale: !1, category: "animals_and_nature" }, boom: { keywords: ["bomb", "explode", "explosion", "collision", "blown"], char: "\u{1F4A5}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowflake: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"], char: "\u2744\uFE0F", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_snow: { keywords: ["weather"], char: "\u{1F328}", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow"], char: "\u26C4", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman_with_snow: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"], char: "\u2603", fitzpatrick_scale: !1, category: "animals_and_nature" }, wind_face: { keywords: ["gust", "air"], char: "\u{1F32C}", fitzpatrick_scale: !1, category: "animals_and_nature" }, dash: { keywords: ["wind", "air", "fast", "shoo", "fart", "smoke", "puff"], char: "\u{1F4A8}", fitzpatrick_scale: !1, category: "animals_and_nature" }, tornado: { keywords: ["weather", "cyclone", "twister"], char: "\u{1F32A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, fog: { keywords: ["weather"], char: "\u{1F32B}", fitzpatrick_scale: !1, category: "animals_and_nature" }, open_umbrella: { keywords: ["weather", "spring"], char: "\u2602", fitzpatrick_scale: !1, category: "animals_and_nature" }, umbrella: { keywords: ["rainy", "weather", "spring"], char: "\u2614", fitzpatrick_scale: !1, category: "animals_and_nature" }, droplet: { keywords: ["water", "drip", "faucet", "spring"], char: "\u{1F4A7}", fitzpatrick_scale: !1, category: "animals_and_nature" }, sweat_drops: { keywords: ["water", "drip", "oops"], char: "\u{1F4A6}", fitzpatrick_scale: !1, category: "animals_and_nature" }, ocean: { keywords: ["sea", "water", "wave", "nature", "tsunami", "disaster"], char: "\u{1F30A}", fitzpatrick_scale: !1, category: "animals_and_nature" }, green_apple: { keywords: ["fruit", "nature"], char: "\u{1F34F}", fitzpatrick_scale: !1, category: "food_and_drink" }, apple: { keywords: ["fruit", "mac", "school"], char: "\u{1F34E}", fitzpatrick_scale: !1, category: "food_and_drink" }, pear: { keywords: ["fruit", "nature", "food"], char: "\u{1F350}", fitzpatrick_scale: !1, category: "food_and_drink" }, tangerine: { keywords: ["food", "fruit", "nature", "orange"], char: "\u{1F34A}", fitzpatrick_scale: !1, category: "food_and_drink" }, lemon: { keywords: ["fruit", "nature"], char: "\u{1F34B}", fitzpatrick_scale: !1, category: "food_and_drink" }, banana: { keywords: ["fruit", "food", "monkey"], char: "\u{1F34C}", fitzpatrick_scale: !1, category: "food_and_drink" }, watermelon: { keywords: ["fruit", "food", "picnic", "summer"], char: "\u{1F349}", fitzpatrick_scale: !1, category: "food_and_drink" }, grapes: { keywords: ["fruit", "food", "wine"], char: "\u{1F347}", fitzpatrick_scale: !1, category: "food_and_drink" }, strawberry: { keywords: ["fruit", "food", "nature"], char: "\u{1F353}", fitzpatrick_scale: !1, category: "food_and_drink" }, melon: { keywords: ["fruit", "nature", "food"], char: "\u{1F348}", fitzpatrick_scale: !1, category: "food_and_drink" }, cherries: { keywords: ["food", "fruit"], char: "\u{1F352}", fitzpatrick_scale: !1, category: "food_and_drink" }, peach: { keywords: ["fruit", "nature", "food"], char: "\u{1F351}", fitzpatrick_scale: !1, category: "food_and_drink" }, pineapple: { keywords: ["fruit", "nature", "food"], char: "\u{1F34D}", fitzpatrick_scale: !1, category: "food_and_drink" }, coconut: { keywords: ["fruit", "nature", "food", "palm"], char: "\u{1F965}", fitzpatrick_scale: !1, category: "food_and_drink" }, kiwi_fruit: { keywords: ["fruit", "food"], char: "\u{1F95D}", fitzpatrick_scale: !1, category: "food_and_drink" }, mango: { keywords: ["fruit", "food", "tropical"], char: "\u{1F96D}", fitzpatrick_scale: !1, category: "food_and_drink" }, avocado: { keywords: ["fruit", "food"], char: "\u{1F951}", fitzpatrick_scale: !1, category: "food_and_drink" }, broccoli: { keywords: ["fruit", "food", "vegetable"], char: "\u{1F966}", fitzpatrick_scale: !1, category: "food_and_drink" }, tomato: { keywords: ["fruit", "vegetable", "nature", "food"], char: "\u{1F345}", fitzpatrick_scale: !1, category: "food_and_drink" }, eggplant: { keywords: ["vegetable", "nature", "food", "aubergine"], char: "\u{1F346}", fitzpatrick_scale: !1, category: "food_and_drink" }, cucumber: { keywords: ["fruit", "food", "pickle"], char: "\u{1F952}", fitzpatrick_scale: !1, category: "food_and_drink" }, carrot: { keywords: ["vegetable", "food", "orange"], char: "\u{1F955}", fitzpatrick_scale: !1, category: "food_and_drink" }, hot_pepper: { keywords: ["food", "spicy", "chilli", "chili"], char: "\u{1F336}", fitzpatrick_scale: !1, category: "food_and_drink" }, potato: { keywords: ["food", "tuber", "vegatable", "starch"], char: "\u{1F954}", fitzpatrick_scale: !1, category: "food_and_drink" }, corn: { keywords: ["food", "vegetable", "plant"], char: "\u{1F33D}", fitzpatrick_scale: !1, category: "food_and_drink" }, leafy_greens: { keywords: ["food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce"], char: "\u{1F96C}", fitzpatrick_scale: !1, category: "food_and_drink" }, sweet_potato: { keywords: ["food", "nature"], char: "\u{1F360}", fitzpatrick_scale: !1, category: "food_and_drink" }, peanuts: { keywords: ["food", "nut"], char: "\u{1F95C}", fitzpatrick_scale: !1, category: "food_and_drink" }, honey_pot: { keywords: ["bees", "sweet", "kitchen"], char: "\u{1F36F}", fitzpatrick_scale: !1, category: "food_and_drink" }, croissant: { keywords: ["food", "bread", "french"], char: "\u{1F950}", fitzpatrick_scale: !1, category: "food_and_drink" }, bread: { keywords: ["food", "wheat", "breakfast", "toast"], char: "\u{1F35E}", fitzpatrick_scale: !1, category: "food_and_drink" }, baguette_bread: { keywords: ["food", "bread", "french"], char: "\u{1F956}", fitzpatrick_scale: !1, category: "food_and_drink" }, bagel: { keywords: ["food", "bread", "bakery", "schmear"], char: "\u{1F96F}", fitzpatrick_scale: !1, category: "food_and_drink" }, pretzel: { keywords: ["food", "bread", "twisted"], char: "\u{1F968}", fitzpatrick_scale: !1, category: "food_and_drink" }, cheese: { keywords: ["food", "chadder"], char: "\u{1F9C0}", fitzpatrick_scale: !1, category: "food_and_drink" }, egg: { keywords: ["food", "chicken", "breakfast"], char: "\u{1F95A}", fitzpatrick_scale: !1, category: "food_and_drink" }, bacon: { keywords: ["food", "breakfast", "pork", "pig", "meat"], char: "\u{1F953}", fitzpatrick_scale: !1, category: "food_and_drink" }, steak: { keywords: ["food", "cow", "meat", "cut", "chop", "lambchop", "porkchop"], char: "\u{1F969}", fitzpatrick_scale: !1, category: "food_and_drink" }, pancakes: { keywords: ["food", "breakfast", "flapjacks", "hotcakes"], char: "\u{1F95E}", fitzpatrick_scale: !1, category: "food_and_drink" }, poultry_leg: { keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"], char: "\u{1F357}", fitzpatrick_scale: !1, category: "food_and_drink" }, meat_on_bone: { keywords: ["good", "food", "drumstick"], char: "\u{1F356}", fitzpatrick_scale: !1, category: "food_and_drink" }, bone: { keywords: ["skeleton"], char: "\u{1F9B4}", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_shrimp: { keywords: ["food", "animal", "appetizer", "summer"], char: "\u{1F364}", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_egg: { keywords: ["food", "breakfast", "kitchen", "egg"], char: "\u{1F373}", fitzpatrick_scale: !1, category: "food_and_drink" }, hamburger: { keywords: ["meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king"], char: "\u{1F354}", fitzpatrick_scale: !1, category: "food_and_drink" }, fries: { keywords: ["chips", "snack", "fast food"], char: "\u{1F35F}", fitzpatrick_scale: !1, category: "food_and_drink" }, stuffed_flatbread: { keywords: ["food", "flatbread", "stuffed", "gyro"], char: "\u{1F959}", fitzpatrick_scale: !1, category: "food_and_drink" }, hotdog: { keywords: ["food", "frankfurter"], char: "\u{1F32D}", fitzpatrick_scale: !1, category: "food_and_drink" }, pizza: { keywords: ["food", "party"], char: "\u{1F355}", fitzpatrick_scale: !1, category: "food_and_drink" }, sandwich: { keywords: ["food", "lunch", "bread"], char: "\u{1F96A}", fitzpatrick_scale: !1, category: "food_and_drink" }, canned_food: { keywords: ["food", "soup"], char: "\u{1F96B}", fitzpatrick_scale: !1, category: "food_and_drink" }, spaghetti: { keywords: ["food", "italian", "noodle"], char: "\u{1F35D}", fitzpatrick_scale: !1, category: "food_and_drink" }, taco: { keywords: ["food", "mexican"], char: "\u{1F32E}", fitzpatrick_scale: !1, category: "food_and_drink" }, burrito: { keywords: ["food", "mexican"], char: "\u{1F32F}", fitzpatrick_scale: !1, category: "food_and_drink" }, green_salad: { keywords: ["food", "healthy", "lettuce"], char: "\u{1F957}", fitzpatrick_scale: !1, category: "food_and_drink" }, shallow_pan_of_food: { keywords: ["food", "cooking", "casserole", "paella"], char: "\u{1F958}", fitzpatrick_scale: !1, category: "food_and_drink" }, ramen: { keywords: ["food", "japanese", "noodle", "chopsticks"], char: "\u{1F35C}", fitzpatrick_scale: !1, category: "food_and_drink" }, stew: { keywords: ["food", "meat", "soup"], char: "\u{1F372}", fitzpatrick_scale: !1, category: "food_and_drink" }, fish_cake: { keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen"], char: "\u{1F365}", fitzpatrick_scale: !1, category: "food_and_drink" }, fortune_cookie: { keywords: ["food", "prophecy"], char: "\u{1F960}", fitzpatrick_scale: !1, category: "food_and_drink" }, sushi: { keywords: ["food", "fish", "japanese", "rice"], char: "\u{1F363}", fitzpatrick_scale: !1, category: "food_and_drink" }, bento: { keywords: ["food", "japanese", "box"], char: "\u{1F371}", fitzpatrick_scale: !1, category: "food_and_drink" }, curry: { keywords: ["food", "spicy", "hot", "indian"], char: "\u{1F35B}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_ball: { keywords: ["food", "japanese"], char: "\u{1F359}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice: { keywords: ["food", "china", "asian"], char: "\u{1F35A}", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_cracker: { keywords: ["food", "japanese"], char: "\u{1F358}", fitzpatrick_scale: !1, category: "food_and_drink" }, oden: { keywords: ["food", "japanese"], char: "\u{1F362}", fitzpatrick_scale: !1, category: "food_and_drink" }, dango: { keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"], char: "\u{1F361}", fitzpatrick_scale: !1, category: "food_and_drink" }, shaved_ice: { keywords: ["hot", "dessert", "summer"], char: "\u{1F367}", fitzpatrick_scale: !1, category: "food_and_drink" }, ice_cream: { keywords: ["food", "hot", "dessert"], char: "\u{1F368}", fitzpatrick_scale: !1, category: "food_and_drink" }, icecream: { keywords: ["food", "hot", "dessert", "summer"], char: "\u{1F366}", fitzpatrick_scale: !1, category: "food_and_drink" }, pie: { keywords: ["food", "dessert", "pastry"], char: "\u{1F967}", fitzpatrick_scale: !1, category: "food_and_drink" }, cake: { keywords: ["food", "dessert"], char: "\u{1F370}", fitzpatrick_scale: !1, category: "food_and_drink" }, cupcake: { keywords: ["food", "dessert", "bakery", "sweet"], char: "\u{1F9C1}", fitzpatrick_scale: !1, category: "food_and_drink" }, moon_cake: { keywords: ["food", "autumn"], char: "\u{1F96E}", fitzpatrick_scale: !1, category: "food_and_drink" }, birthday: { keywords: ["food", "dessert", "cake"], char: "\u{1F382}", fitzpatrick_scale: !1, category: "food_and_drink" }, custard: { keywords: ["dessert", "food"], char: "\u{1F36E}", fitzpatrick_scale: !1, category: "food_and_drink" }, candy: { keywords: ["snack", "dessert", "sweet", "lolly"], char: "\u{1F36C}", fitzpatrick_scale: !1, category: "food_and_drink" }, lollipop: { keywords: ["food", "snack", "candy", "sweet"], char: "\u{1F36D}", fitzpatrick_scale: !1, category: "food_and_drink" }, chocolate_bar: { keywords: ["food", "snack", "dessert", "sweet"], char: "\u{1F36B}", fitzpatrick_scale: !1, category: "food_and_drink" }, popcorn: { keywords: ["food", "movie theater", "films", "snack"], char: "\u{1F37F}", fitzpatrick_scale: !1, category: "food_and_drink" }, dumpling: { keywords: ["food", "empanada", "pierogi", "potsticker"], char: "\u{1F95F}", fitzpatrick_scale: !1, category: "food_and_drink" }, doughnut: { keywords: ["food", "dessert", "snack", "sweet", "donut"], char: "\u{1F369}", fitzpatrick_scale: !1, category: "food_and_drink" }, cookie: { keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"], char: "\u{1F36A}", fitzpatrick_scale: !1, category: "food_and_drink" }, milk_glass: { keywords: ["beverage", "drink", "cow"], char: "\u{1F95B}", fitzpatrick_scale: !1, category: "food_and_drink" }, beer: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "\u{1F37A}", fitzpatrick_scale: !1, category: "food_and_drink" }, beers: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "\u{1F37B}", fitzpatrick_scale: !1, category: "food_and_drink" }, clinking_glasses: { keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"], char: "\u{1F942}", fitzpatrick_scale: !1, category: "food_and_drink" }, wine_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "booze"], char: "\u{1F377}", fitzpatrick_scale: !1, category: "food_and_drink" }, tumbler_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot"], char: "\u{1F943}", fitzpatrick_scale: !1, category: "food_and_drink" }, cocktail: { keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"], char: "\u{1F378}", fitzpatrick_scale: !1, category: "food_and_drink" }, tropical_drink: { keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"], char: "\u{1F379}", fitzpatrick_scale: !1, category: "food_and_drink" }, champagne: { keywords: ["drink", "wine", "bottle", "celebration"], char: "\u{1F37E}", fitzpatrick_scale: !1, category: "food_and_drink" }, sake: { keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"], char: "\u{1F376}", fitzpatrick_scale: !1, category: "food_and_drink" }, tea: { keywords: ["drink", "bowl", "breakfast", "green", "british"], char: "\u{1F375}", fitzpatrick_scale: !1, category: "food_and_drink" }, cup_with_straw: { keywords: ["drink", "soda"], char: "\u{1F964}", fitzpatrick_scale: !1, category: "food_and_drink" }, coffee: { keywords: ["beverage", "caffeine", "latte", "espresso"], char: "\u2615", fitzpatrick_scale: !1, category: "food_and_drink" }, baby_bottle: { keywords: ["food", "container", "milk"], char: "\u{1F37C}", fitzpatrick_scale: !1, category: "food_and_drink" }, salt: { keywords: ["condiment", "shaker"], char: "\u{1F9C2}", fitzpatrick_scale: !1, category: "food_and_drink" }, spoon: { keywords: ["cutlery", "kitchen", "tableware"], char: "\u{1F944}", fitzpatrick_scale: !1, category: "food_and_drink" }, fork_and_knife: { keywords: ["cutlery", "kitchen"], char: "\u{1F374}", fitzpatrick_scale: !1, category: "food_and_drink" }, plate_with_cutlery: { keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"], char: "\u{1F37D}", fitzpatrick_scale: !1, category: "food_and_drink" }, bowl_with_spoon: { keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"], char: "\u{1F963}", fitzpatrick_scale: !1, category: "food_and_drink" }, takeout_box: { keywords: ["food", "leftovers"], char: "\u{1F961}", fitzpatrick_scale: !1, category: "food_and_drink" }, chopsticks: { keywords: ["food"], char: "\u{1F962}", fitzpatrick_scale: !1, category: "food_and_drink" }, soccer: { keywords: ["sports", "football"], char: "\u26BD", fitzpatrick_scale: !1, category: "activity" }, basketball: { keywords: ["sports", "balls", "NBA"], char: "\u{1F3C0}", fitzpatrick_scale: !1, category: "activity" }, football: { keywords: ["sports", "balls", "NFL"], char: "\u{1F3C8}", fitzpatrick_scale: !1, category: "activity" }, baseball: { keywords: ["sports", "balls"], char: "\u26BE", fitzpatrick_scale: !1, category: "activity" }, softball: { keywords: ["sports", "balls"], char: "\u{1F94E}", fitzpatrick_scale: !1, category: "activity" }, tennis: { keywords: ["sports", "balls", "green"], char: "\u{1F3BE}", fitzpatrick_scale: !1, category: "activity" }, volleyball: { keywords: ["sports", "balls"], char: "\u{1F3D0}", fitzpatrick_scale: !1, category: "activity" }, rugby_football: { keywords: ["sports", "team"], char: "\u{1F3C9}", fitzpatrick_scale: !1, category: "activity" }, flying_disc: { keywords: ["sports", "frisbee", "ultimate"], char: "\u{1F94F}", fitzpatrick_scale: !1, category: "activity" }, "8ball": { keywords: ["pool", "hobby", "game", "luck", "magic"], char: "\u{1F3B1}", fitzpatrick_scale: !1, category: "activity" }, golf: { keywords: ["sports", "business", "flag", "hole", "summer"], char: "\u26F3", fitzpatrick_scale: !1, category: "activity" }, golfing_woman: { keywords: ["sports", "business", "woman", "female"], char: "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "activity" }, golfing_man: { keywords: ["sports", "business"], char: "\u{1F3CC}", fitzpatrick_scale: !0, category: "activity" }, ping_pong: { keywords: ["sports", "pingpong"], char: "\u{1F3D3}", fitzpatrick_scale: !1, category: "activity" }, badminton: { keywords: ["sports"], char: "\u{1F3F8}", fitzpatrick_scale: !1, category: "activity" }, goal_net: { keywords: ["sports"], char: "\u{1F945}", fitzpatrick_scale: !1, category: "activity" }, ice_hockey: { keywords: ["sports"], char: "\u{1F3D2}", fitzpatrick_scale: !1, category: "activity" }, field_hockey: { keywords: ["sports"], char: "\u{1F3D1}", fitzpatrick_scale: !1, category: "activity" }, lacrosse: { keywords: ["sports", "ball", "stick"], char: "\u{1F94D}", fitzpatrick_scale: !1, category: "activity" }, cricket: { keywords: ["sports"], char: "\u{1F3CF}", fitzpatrick_scale: !1, category: "activity" }, ski: { keywords: ["sports", "winter", "cold", "snow"], char: "\u{1F3BF}", fitzpatrick_scale: !1, category: "activity" }, skier: { keywords: ["sports", "winter", "snow"], char: "\u26F7", fitzpatrick_scale: !1, category: "activity" }, snowboarder: { keywords: ["sports", "winter"], char: "\u{1F3C2}", fitzpatrick_scale: !0, category: "activity" }, person_fencing: { keywords: ["sports", "fencing", "sword"], char: "\u{1F93A}", fitzpatrick_scale: !1, category: "activity" }, women_wrestling: { keywords: ["sports", "wrestlers"], char: "\u{1F93C}\u200D\u2640\uFE0F", fitzpatrick_scale: !1, category: "activity" }, men_wrestling: { keywords: ["sports", "wrestlers"], char: "\u{1F93C}\u200D\u2642\uFE0F", fitzpatrick_scale: !1, category: "activity" }, woman_cartwheeling: { keywords: ["gymnastics"], char: "\u{1F938}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_cartwheeling: { keywords: ["gymnastics"], char: "\u{1F938}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, woman_playing_handball: { keywords: ["sports"], char: "\u{1F93E}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_playing_handball: { keywords: ["sports"], char: "\u{1F93E}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, ice_skate: { keywords: ["sports"], char: "\u26F8", fitzpatrick_scale: !1, category: "activity" }, curling_stone: { keywords: ["sports"], char: "\u{1F94C}", fitzpatrick_scale: !1, category: "activity" }, skateboard: { keywords: ["board"], char: "\u{1F6F9}", fitzpatrick_scale: !1, category: "activity" }, sled: { keywords: ["sleigh", "luge", "toboggan"], char: "\u{1F6F7}", fitzpatrick_scale: !1, category: "activity" }, bow_and_arrow: { keywords: ["sports"], char: "\u{1F3F9}", fitzpatrick_scale: !1, category: "activity" }, fishing_pole_and_fish: { keywords: ["food", "hobby", "summer"], char: "\u{1F3A3}", fitzpatrick_scale: !1, category: "activity" }, boxing_glove: { keywords: ["sports", "fighting"], char: "\u{1F94A}", fitzpatrick_scale: !1, category: "activity" }, martial_arts_uniform: { keywords: ["judo", "karate", "taekwondo"], char: "\u{1F94B}", fitzpatrick_scale: !1, category: "activity" }, rowing_woman: { keywords: ["sports", "hobby", "water", "ship", "woman", "female"], char: "\u{1F6A3}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, rowing_man: { keywords: ["sports", "hobby", "water", "ship"], char: "\u{1F6A3}", fitzpatrick_scale: !0, category: "activity" }, climbing_woman: { keywords: ["sports", "hobby", "woman", "female", "rock"], char: "\u{1F9D7}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, climbing_man: { keywords: ["sports", "hobby", "man", "male", "rock"], char: "\u{1F9D7}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, swimming_woman: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "woman", "female"], char: "\u{1F3CA}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, swimming_man: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer"], char: "\u{1F3CA}", fitzpatrick_scale: !0, category: "activity" }, woman_playing_water_polo: { keywords: ["sports", "pool"], char: "\u{1F93D}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_playing_water_polo: { keywords: ["sports", "pool"], char: "\u{1F93D}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, woman_in_lotus_position: { keywords: ["woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "\u{1F9D8}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_in_lotus_position: { keywords: ["man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "\u{1F9D8}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, surfing_woman: { keywords: ["sports", "ocean", "sea", "summer", "beach", "woman", "female"], char: "\u{1F3C4}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, surfing_man: { keywords: ["sports", "ocean", "sea", "summer", "beach"], char: "\u{1F3C4}", fitzpatrick_scale: !0, category: "activity" }, bath: { keywords: ["clean", "shower", "bathroom"], char: "\u{1F6C0}", fitzpatrick_scale: !0, category: "activity" }, basketball_woman: { keywords: ["sports", "human", "woman", "female"], char: "\u26F9\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, basketball_man: { keywords: ["sports", "human"], char: "\u26F9", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_woman: { keywords: ["sports", "training", "exercise", "woman", "female"], char: "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_man: { keywords: ["sports", "training", "exercise"], char: "\u{1F3CB}", fitzpatrick_scale: !0, category: "activity" }, biking_woman: { keywords: ["sports", "bike", "exercise", "hipster", "woman", "female"], char: "\u{1F6B4}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, biking_man: { keywords: ["sports", "bike", "exercise", "hipster"], char: "\u{1F6B4}", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_woman: { keywords: ["transportation", "sports", "human", "race", "bike", "woman", "female"], char: "\u{1F6B5}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_man: { keywords: ["transportation", "sports", "human", "race", "bike"], char: "\u{1F6B5}", fitzpatrick_scale: !0, category: "activity" }, horse_racing: { keywords: ["animal", "betting", "competition", "gambling", "luck"], char: "\u{1F3C7}", fitzpatrick_scale: !0, category: "activity" }, business_suit_levitating: { keywords: ["suit", "business", "levitate", "hover", "jump"], char: "\u{1F574}", fitzpatrick_scale: !0, category: "activity" }, trophy: { keywords: ["win", "award", "contest", "place", "ftw", "ceremony"], char: "\u{1F3C6}", fitzpatrick_scale: !1, category: "activity" }, running_shirt_with_sash: { keywords: ["play", "pageant"], char: "\u{1F3BD}", fitzpatrick_scale: !1, category: "activity" }, medal_sports: { keywords: ["award", "winning"], char: "\u{1F3C5}", fitzpatrick_scale: !1, category: "activity" }, medal_military: { keywords: ["award", "winning", "army"], char: "\u{1F396}", fitzpatrick_scale: !1, category: "activity" }, "1st_place_medal": { keywords: ["award", "winning", "first"], char: "\u{1F947}", fitzpatrick_scale: !1, category: "activity" }, "2nd_place_medal": { keywords: ["award", "second"], char: "\u{1F948}", fitzpatrick_scale: !1, category: "activity" }, "3rd_place_medal": { keywords: ["award", "third"], char: "\u{1F949}", fitzpatrick_scale: !1, category: "activity" }, reminder_ribbon: { keywords: ["sports", "cause", "support", "awareness"], char: "\u{1F397}", fitzpatrick_scale: !1, category: "activity" }, rosette: { keywords: ["flower", "decoration", "military"], char: "\u{1F3F5}", fitzpatrick_scale: !1, category: "activity" }, ticket: { keywords: ["event", "concert", "pass"], char: "\u{1F3AB}", fitzpatrick_scale: !1, category: "activity" }, tickets: { keywords: ["sports", "concert", "entrance"], char: "\u{1F39F}", fitzpatrick_scale: !1, category: "activity" }, performing_arts: { keywords: ["acting", "theater", "drama"], char: "\u{1F3AD}", fitzpatrick_scale: !1, category: "activity" }, art: { keywords: ["design", "paint", "draw", "colors"], char: "\u{1F3A8}", fitzpatrick_scale: !1, category: "activity" }, circus_tent: { keywords: ["festival", "carnival", "party"], char: "\u{1F3AA}", fitzpatrick_scale: !1, category: "activity" }, woman_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "\u{1F939}\u200D\u2640\uFE0F", fitzpatrick_scale: !0, category: "activity" }, man_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "\u{1F939}\u200D\u2642\uFE0F", fitzpatrick_scale: !0, category: "activity" }, microphone: { keywords: ["sound", "music", "PA", "sing", "talkshow"], char: "\u{1F3A4}", fitzpatrick_scale: !1, category: "activity" }, headphones: { keywords: ["music", "score", "gadgets"], char: "\u{1F3A7}", fitzpatrick_scale: !1, category: "activity" }, musical_score: { keywords: ["treble", "clef", "compose"], char: "\u{1F3BC}", fitzpatrick_scale: !1, category: "activity" }, musical_keyboard: { keywords: ["piano", "instrument", "compose"], char: "\u{1F3B9}", fitzpatrick_scale: !1, category: "activity" }, drum: { keywords: ["music", "instrument", "drumsticks", "snare"], char: "\u{1F941}", fitzpatrick_scale: !1, category: "activity" }, saxophone: { keywords: ["music", "instrument", "jazz", "blues"], char: "\u{1F3B7}", fitzpatrick_scale: !1, category: "activity" }, trumpet: { keywords: ["music", "brass"], char: "\u{1F3BA}", fitzpatrick_scale: !1, category: "activity" }, guitar: { keywords: ["music", "instrument"], char: "\u{1F3B8}", fitzpatrick_scale: !1, category: "activity" }, violin: { keywords: ["music", "instrument", "orchestra", "symphony"], char: "\u{1F3BB}", fitzpatrick_scale: !1, category: "activity" }, clapper: { keywords: ["movie", "film", "record"], char: "\u{1F3AC}", fitzpatrick_scale: !1, category: "activity" }, video_game: { keywords: ["play", "console", "PS4", "controller"], char: "\u{1F3AE}", fitzpatrick_scale: !1, category: "activity" }, space_invader: { keywords: ["game", "arcade", "play"], char: "\u{1F47E}", fitzpatrick_scale: !1, category: "activity" }, dart: { keywords: ["game", "play", "bar", "target", "bullseye"], char: "\u{1F3AF}", fitzpatrick_scale: !1, category: "activity" }, game_die: { keywords: ["dice", "random", "tabletop", "play", "luck"], char: "\u{1F3B2}", fitzpatrick_scale: !1, category: "activity" }, chess_pawn: { keywords: ["expendable"], char: "\u265F", fitzpatrick_scale: !1, category: "activity" }, slot_machine: { keywords: ["bet", "gamble", "vegas", "fruit machine", "luck", "casino"], char: "\u{1F3B0}", fitzpatrick_scale: !1, category: "activity" }, jigsaw: { keywords: ["interlocking", "puzzle", "piece"], char: "\u{1F9E9}", fitzpatrick_scale: !1, category: "activity" }, bowling: { keywords: ["sports", "fun", "play"], char: "\u{1F3B3}", fitzpatrick_scale: !1, category: "activity" }, red_car: { keywords: ["red", "transportation", "vehicle"], char: "\u{1F697}", fitzpatrick_scale: !1, category: "travel_and_places" }, taxi: { keywords: ["uber", "vehicle", "cars", "transportation"], char: "\u{1F695}", fitzpatrick_scale: !1, category: "travel_and_places" }, blue_car: { keywords: ["transportation", "vehicle"], char: "\u{1F699}", fitzpatrick_scale: !1, category: "travel_and_places" }, bus: { keywords: ["car", "vehicle", "transportation"], char: "\u{1F68C}", fitzpatrick_scale: !1, category: "travel_and_places" }, trolleybus: { keywords: ["bart", "transportation", "vehicle"], char: "\u{1F68E}", fitzpatrick_scale: !1, category: "travel_and_places" }, racing_car: { keywords: ["sports", "race", "fast", "formula", "f1"], char: "\u{1F3CE}", fitzpatrick_scale: !1, category: "travel_and_places" }, police_car: { keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"], char: "\u{1F693}", fitzpatrick_scale: !1, category: "travel_and_places" }, ambulance: { keywords: ["health", "911", "hospital"], char: "\u{1F691}", fitzpatrick_scale: !1, category: "travel_and_places" }, fire_engine: { keywords: ["transportation", "cars", "vehicle"], char: "\u{1F692}", fitzpatrick_scale: !1, category: "travel_and_places" }, minibus: { keywords: ["vehicle", "car", "transportation"], char: "\u{1F690}", fitzpatrick_scale: !1, category: "travel_and_places" }, truck: { keywords: ["cars", "transportation"], char: "\u{1F69A}", fitzpatrick_scale: !1, category: "travel_and_places" }, articulated_lorry: { keywords: ["vehicle", "cars", "transportation", "express"], char: "\u{1F69B}", fitzpatrick_scale: !1, category: "travel_and_places" }, tractor: { keywords: ["vehicle", "car", "farming", "agriculture"], char: "\u{1F69C}", fitzpatrick_scale: !1, category: "travel_and_places" }, kick_scooter: { keywords: ["vehicle", "kick", "razor"], char: "\u{1F6F4}", fitzpatrick_scale: !1, category: "travel_and_places" }, motorcycle: { keywords: ["race", "sports", "fast"], char: "\u{1F3CD}", fitzpatrick_scale: !1, category: "travel_and_places" }, bike: { keywords: ["sports", "bicycle", "exercise", "hipster"], char: "\u{1F6B2}", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_scooter: { keywords: ["vehicle", "vespa", "sasha"], char: "\u{1F6F5}", fitzpatrick_scale: !1, category: "travel_and_places" }, rotating_light: { keywords: ["police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"], char: "\u{1F6A8}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_police_car: { keywords: ["vehicle", "law", "legal", "enforcement", "911"], char: "\u{1F694}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_bus: { keywords: ["vehicle", "transportation"], char: "\u{1F68D}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_automobile: { keywords: ["car", "vehicle", "transportation"], char: "\u{1F698}", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_taxi: { keywords: ["vehicle", "cars", "uber"], char: "\u{1F696}", fitzpatrick_scale: !1, category: "travel_and_places" }, aerial_tramway: { keywords: ["transportation", "vehicle", "ski"], char: "\u{1F6A1}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_cableway: { keywords: ["transportation", "vehicle", "ski"], char: "\u{1F6A0}", fitzpatrick_scale: !1, category: "travel_and_places" }, suspension_railway: { keywords: ["vehicle", "transportation"], char: "\u{1F69F}", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_car: { keywords: ["transportation", "vehicle"], char: "\u{1F683}", fitzpatrick_scale: !1, category: "travel_and_places" }, train: { keywords: ["transportation", "vehicle", "carriage", "public", "travel"], char: "\u{1F68B}", fitzpatrick_scale: !1, category: "travel_and_places" }, monorail: { keywords: ["transportation", "vehicle"], char: "\u{1F69D}", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_side: { keywords: ["transportation", "vehicle"], char: "\u{1F684}", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_front: { keywords: ["transportation", "vehicle", "speed", "fast", "public", "travel"], char: "\u{1F685}", fitzpatrick_scale: !1, category: "travel_and_places" }, light_rail: { keywords: ["transportation", "vehicle"], char: "\u{1F688}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_railway: { keywords: ["transportation", "vehicle"], char: "\u{1F69E}", fitzpatrick_scale: !1, category: "travel_and_places" }, steam_locomotive: { keywords: ["transportation", "vehicle", "train"], char: "\u{1F682}", fitzpatrick_scale: !1, category: "travel_and_places" }, train2: { keywords: ["transportation", "vehicle"], char: "\u{1F686}", fitzpatrick_scale: !1, category: "travel_and_places" }, metro: { keywords: ["transportation", "blue-square", "mrt", "underground", "tube"], char: "\u{1F687}", fitzpatrick_scale: !1, category: "travel_and_places" }, tram: { keywords: ["transportation", "vehicle"], char: "\u{1F68A}", fitzpatrick_scale: !1, category: "travel_and_places" }, station: { keywords: ["transportation", "vehicle", "public"], char: "\u{1F689}", fitzpatrick_scale: !1, category: "travel_and_places" }, flying_saucer: { keywords: ["transportation", "vehicle", "ufo"], char: "\u{1F6F8}", fitzpatrick_scale: !1, category: "travel_and_places" }, helicopter: { keywords: ["transportation", "vehicle", "fly"], char: "\u{1F681}", fitzpatrick_scale: !1, category: "travel_and_places" }, small_airplane: { keywords: ["flight", "transportation", "fly", "vehicle"], char: "\u{1F6E9}", fitzpatrick_scale: !1, category: "travel_and_places" }, airplane: { keywords: ["vehicle", "transportation", "flight", "fly"], char: "\u2708\uFE0F", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_departure: { keywords: ["airport", "flight", "landing"], char: "\u{1F6EB}", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_arrival: { keywords: ["airport", "flight", "boarding"], char: "\u{1F6EC}", fitzpatrick_scale: !1, category: "travel_and_places" }, sailboat: { keywords: ["ship", "summer", "transportation", "water", "sailing"], char: "\u26F5", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_boat: { keywords: ["ship"], char: "\u{1F6E5}", fitzpatrick_scale: !1, category: "travel_and_places" }, speedboat: { keywords: ["ship", "transportation", "vehicle", "summer"], char: "\u{1F6A4}", fitzpatrick_scale: !1, category: "travel_and_places" }, ferry: { keywords: ["boat", "ship", "yacht"], char: "\u26F4", fitzpatrick_scale: !1, category: "travel_and_places" }, passenger_ship: { keywords: ["yacht", "cruise", "ferry"], char: "\u{1F6F3}", fitzpatrick_scale: !1, category: "travel_and_places" }, rocket: { keywords: ["launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly"], char: "\u{1F680}", fitzpatrick_scale: !1, category: "travel_and_places" }, artificial_satellite: { keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"], char: "\u{1F6F0}", fitzpatrick_scale: !1, category: "travel_and_places" }, seat: { keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"], char: "\u{1F4BA}", fitzpatrick_scale: !1, category: "travel_and_places" }, canoe: { keywords: ["boat", "paddle", "water", "ship"], char: "\u{1F6F6}", fitzpatrick_scale: !1, category: "travel_and_places" }, anchor: { keywords: ["ship", "ferry", "sea", "boat"], char: "\u2693", fitzpatrick_scale: !1, category: "travel_and_places" }, construction: { keywords: ["wip", "progress", "caution", "warning"], char: "\u{1F6A7}", fitzpatrick_scale: !1, category: "travel_and_places" }, fuelpump: { keywords: ["gas station", "petroleum"], char: "\u26FD", fitzpatrick_scale: !1, category: "travel_and_places" }, busstop: { keywords: ["transportation", "wait"], char: "\u{1F68F}", fitzpatrick_scale: !1, category: "travel_and_places" }, vertical_traffic_light: { keywords: ["transportation", "driving"], char: "\u{1F6A6}", fitzpatrick_scale: !1, category: "travel_and_places" }, traffic_light: { keywords: ["transportation", "signal"], char: "\u{1F6A5}", fitzpatrick_scale: !1, category: "travel_and_places" }, checkered_flag: { keywords: ["contest", "finishline", "race", "gokart"], char: "\u{1F3C1}", fitzpatrick_scale: !1, category: "travel_and_places" }, ship: { keywords: ["transportation", "titanic", "deploy"], char: "\u{1F6A2}", fitzpatrick_scale: !1, category: "travel_and_places" }, ferris_wheel: { keywords: ["photo", "carnival", "londoneye"], char: "\u{1F3A1}", fitzpatrick_scale: !1, category: "travel_and_places" }, roller_coaster: { keywords: ["carnival", "playground", "photo", "fun"], char: "\u{1F3A2}", fitzpatrick_scale: !1, category: "travel_and_places" }, carousel_horse: { keywords: ["photo", "carnival"], char: "\u{1F3A0}", fitzpatrick_scale: !1, category: "travel_and_places" }, building_construction: { keywords: ["wip", "working", "progress"], char: "\u{1F3D7}", fitzpatrick_scale: !1, category: "travel_and_places" }, foggy: { keywords: ["photo", "mountain"], char: "\u{1F301}", fitzpatrick_scale: !1, category: "travel_and_places" }, tokyo_tower: { keywords: ["photo", "japanese"], char: "\u{1F5FC}", fitzpatrick_scale: !1, category: "travel_and_places" }, factory: { keywords: ["building", "industry", "pollution", "smoke"], char: "\u{1F3ED}", fitzpatrick_scale: !1, category: "travel_and_places" }, fountain: { keywords: ["photo", "summer", "water", "fresh"], char: "\u26F2", fitzpatrick_scale: !1, category: "travel_and_places" }, rice_scene: { keywords: ["photo", "japan", "asia", "tsukimi"], char: "\u{1F391}", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain: { keywords: ["photo", "nature", "environment"], char: "\u26F0", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_snow: { keywords: ["photo", "nature", "environment", "winter", "cold"], char: "\u{1F3D4}", fitzpatrick_scale: !1, category: "travel_and_places" }, mount_fuji: { keywords: ["photo", "mountain", "nature", "japanese"], char: "\u{1F5FB}", fitzpatrick_scale: !1, category: "travel_and_places" }, volcano: { keywords: ["photo", "nature", "disaster"], char: "\u{1F30B}", fitzpatrick_scale: !1, category: "travel_and_places" }, japan: { keywords: ["nation", "country", "japanese", "asia"], char: "\u{1F5FE}", fitzpatrick_scale: !1, category: "travel_and_places" }, camping: { keywords: ["photo", "outdoors", "tent"], char: "\u{1F3D5}", fitzpatrick_scale: !1, category: "travel_and_places" }, tent: { keywords: ["photo", "camping", "outdoors"], char: "\u26FA", fitzpatrick_scale: !1, category: "travel_and_places" }, national_park: { keywords: ["photo", "environment", "nature"], char: "\u{1F3DE}", fitzpatrick_scale: !1, category: "travel_and_places" }, motorway: { keywords: ["road", "cupertino", "interstate", "highway"], char: "\u{1F6E3}", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_track: { keywords: ["train", "transportation"], char: "\u{1F6E4}", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise: { keywords: ["morning", "view", "vacation", "photo"], char: "\u{1F305}", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise_over_mountains: { keywords: ["view", "vacation", "photo"], char: "\u{1F304}", fitzpatrick_scale: !1, category: "travel_and_places" }, desert: { keywords: ["photo", "warm", "saharah"], char: "\u{1F3DC}", fitzpatrick_scale: !1, category: "travel_and_places" }, beach_umbrella: { keywords: ["weather", "summer", "sunny", "sand", "mojito"], char: "\u{1F3D6}", fitzpatrick_scale: !1, category: "travel_and_places" }, desert_island: { keywords: ["photo", "tropical", "mojito"], char: "\u{1F3DD}", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunrise: { keywords: ["photo", "good morning", "dawn"], char: "\u{1F307}", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunset: { keywords: ["photo", "evening", "sky", "buildings"], char: "\u{1F306}", fitzpatrick_scale: !1, category: "travel_and_places" }, cityscape: { keywords: ["photo", "night life", "urban"], char: "\u{1F3D9}", fitzpatrick_scale: !1, category: "travel_and_places" }, night_with_stars: { keywords: ["evening", "city", "downtown"], char: "\u{1F303}", fitzpatrick_scale: !1, category: "travel_and_places" }, bridge_at_night: { keywords: ["photo", "sanfrancisco"], char: "\u{1F309}", fitzpatrick_scale: !1, category: "travel_and_places" }, milky_way: { keywords: ["photo", "space", "stars"], char: "\u{1F30C}", fitzpatrick_scale: !1, category: "travel_and_places" }, stars: { keywords: ["night", "photo"], char: "\u{1F320}", fitzpatrick_scale: !1, category: "travel_and_places" }, sparkler: { keywords: ["stars", "night", "shine"], char: "\u{1F387}", fitzpatrick_scale: !1, category: "travel_and_places" }, fireworks: { keywords: ["photo", "festival", "carnival", "congratulations"], char: "\u{1F386}", fitzpatrick_scale: !1, category: "travel_and_places" }, rainbow: { keywords: ["nature", "happy", "unicorn_face", "photo", "sky", "spring"], char: "\u{1F308}", fitzpatrick_scale: !1, category: "travel_and_places" }, houses: { keywords: ["buildings", "photo"], char: "\u{1F3D8}", fitzpatrick_scale: !1, category: "travel_and_places" }, european_castle: { keywords: ["building", "royalty", "history"], char: "\u{1F3F0}", fitzpatrick_scale: !1, category: "travel_and_places" }, japanese_castle: { keywords: ["photo", "building"], char: "\u{1F3EF}", fitzpatrick_scale: !1, category: "travel_and_places" }, stadium: { keywords: ["photo", "place", "sports", "concert", "venue"], char: "\u{1F3DF}", fitzpatrick_scale: !1, category: "travel_and_places" }, statue_of_liberty: { keywords: ["american", "newyork"], char: "\u{1F5FD}", fitzpatrick_scale: !1, category: "travel_and_places" }, house: { keywords: ["building", "home"], char: "\u{1F3E0}", fitzpatrick_scale: !1, category: "travel_and_places" }, house_with_garden: { keywords: ["home", "plant", "nature"], char: "\u{1F3E1}", fitzpatrick_scale: !1, category: "travel_and_places" }, derelict_house: { keywords: ["abandon", "evict", "broken", "building"], char: "\u{1F3DA}", fitzpatrick_scale: !1, category: "travel_and_places" }, office: { keywords: ["building", "bureau", "work"], char: "\u{1F3E2}", fitzpatrick_scale: !1, category: "travel_and_places" }, department_store: { keywords: ["building", "shopping", "mall"], char: "\u{1F3EC}", fitzpatrick_scale: !1, category: "travel_and_places" }, post_office: { keywords: ["building", "envelope", "communication"], char: "\u{1F3E3}", fitzpatrick_scale: !1, category: "travel_and_places" }, european_post_office: { keywords: ["building", "email"], char: "\u{1F3E4}", fitzpatrick_scale: !1, category: "travel_and_places" }, hospital: { keywords: ["building", "health", "surgery", "doctor"], char: "\u{1F3E5}", fitzpatrick_scale: !1, category: "travel_and_places" }, bank: { keywords: ["building", "money", "sales", "cash", "business", "enterprise"], char: "\u{1F3E6}", fitzpatrick_scale: !1, category: "travel_and_places" }, hotel: { keywords: ["building", "accomodation", "checkin"], char: "\u{1F3E8}", fitzpatrick_scale: !1, category: "travel_and_places" }, convenience_store: { keywords: ["building", "shopping", "groceries"], char: "\u{1F3EA}", fitzpatrick_scale: !1, category: "travel_and_places" }, school: { keywords: ["building", "student", "education", "learn", "teach"], char: "\u{1F3EB}", fitzpatrick_scale: !1, category: "travel_and_places" }, love_hotel: { keywords: ["like", "affection", "dating"], char: "\u{1F3E9}", fitzpatrick_scale: !1, category: "travel_and_places" }, wedding: { keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"], char: "\u{1F492}", fitzpatrick_scale: !1, category: "travel_and_places" }, classical_building: { keywords: ["art", "culture", "history"], char: "\u{1F3DB}", fitzpatrick_scale: !1, category: "travel_and_places" }, church: { keywords: ["building", "religion", "christ"], char: "\u26EA", fitzpatrick_scale: !1, category: "travel_and_places" }, mosque: { keywords: ["islam", "worship", "minaret"], char: "\u{1F54C}", fitzpatrick_scale: !1, category: "travel_and_places" }, synagogue: { keywords: ["judaism", "worship", "temple", "jewish"], char: "\u{1F54D}", fitzpatrick_scale: !1, category: "travel_and_places" }, kaaba: { keywords: ["mecca", "mosque", "islam"], char: "\u{1F54B}", fitzpatrick_scale: !1, category: "travel_and_places" }, shinto_shrine: { keywords: ["temple", "japan", "kyoto"], char: "\u26E9", fitzpatrick_scale: !1, category: "travel_and_places" }, watch: { keywords: ["time", "accessories"], char: "\u231A", fitzpatrick_scale: !1, category: "objects" }, iphone: { keywords: ["technology", "apple", "gadgets", "dial"], char: "\u{1F4F1}", fitzpatrick_scale: !1, category: "objects" }, calling: { keywords: ["iphone", "incoming"], char: "\u{1F4F2}", fitzpatrick_scale: !1, category: "objects" }, computer: { keywords: ["technology", "laptop", "screen", "display", "monitor"], char: "\u{1F4BB}", fitzpatrick_scale: !1, category: "objects" }, keyboard: { keywords: ["technology", "computer", "type", "input", "text"], char: "\u2328", fitzpatrick_scale: !1, category: "objects" }, desktop_computer: { keywords: ["technology", "computing", "screen"], char: "\u{1F5A5}", fitzpatrick_scale: !1, category: "objects" }, printer: { keywords: ["paper", "ink"], char: "\u{1F5A8}", fitzpatrick_scale: !1, category: "objects" }, computer_mouse: { keywords: ["click"], char: "\u{1F5B1}", fitzpatrick_scale: !1, category: "objects" }, trackball: { keywords: ["technology", "trackpad"], char: "\u{1F5B2}", fitzpatrick_scale: !1, category: "objects" }, joystick: { keywords: ["game", "play"], char: "\u{1F579}", fitzpatrick_scale: !1, category: "objects" }, clamp: { keywords: ["tool"], char: "\u{1F5DC}", fitzpatrick_scale: !1, category: "objects" }, minidisc: { keywords: ["technology", "record", "data", "disk", "90s"], char: "\u{1F4BD}", fitzpatrick_scale: !1, category: "objects" }, floppy_disk: { keywords: ["oldschool", "technology", "save", "90s", "80s"], char: "\u{1F4BE}", fitzpatrick_scale: !1, category: "objects" }, cd: { keywords: ["technology", "dvd", "disk", "disc", "90s"], char: "\u{1F4BF}", fitzpatrick_scale: !1, category: "objects" }, dvd: { keywords: ["cd", "disk", "disc"], char: "\u{1F4C0}", fitzpatrick_scale: !1, category: "objects" }, vhs: { keywords: ["record", "video", "oldschool", "90s", "80s"], char: "\u{1F4FC}", fitzpatrick_scale: !1, category: "objects" }, camera: { keywords: ["gadgets", "photography"], char: "\u{1F4F7}", fitzpatrick_scale: !1, category: "objects" }, camera_flash: { keywords: ["photography", "gadgets"], char: "\u{1F4F8}", fitzpatrick_scale: !1, category: "objects" }, video_camera: { keywords: ["film", "record"], char: "\u{1F4F9}", fitzpatrick_scale: !1, category: "objects" }, movie_camera: { keywords: ["film", "record"], char: "\u{1F3A5}", fitzpatrick_scale: !1, category: "objects" }, film_projector: { keywords: ["video", "tape", "record", "movie"], char: "\u{1F4FD}", fitzpatrick_scale: !1, category: "objects" }, film_strip: { keywords: ["movie"], char: "\u{1F39E}", fitzpatrick_scale: !1, category: "objects" }, telephone_receiver: { keywords: ["technology", "communication", "dial"], char: "\u{1F4DE}", fitzpatrick_scale: !1, category: "objects" }, phone: { keywords: ["technology", "communication", "dial", "telephone"], char: "\u260E\uFE0F", fitzpatrick_scale: !1, category: "objects" }, pager: { keywords: ["bbcall", "oldschool", "90s"], char: "\u{1F4DF}", fitzpatrick_scale: !1, category: "objects" }, fax: { keywords: ["communication", "technology"], char: "\u{1F4E0}", fitzpatrick_scale: !1, category: "objects" }, tv: { keywords: ["technology", "program", "oldschool", "show", "television"], char: "\u{1F4FA}", fitzpatrick_scale: !1, category: "objects" }, radio: { keywords: ["communication", "music", "podcast", "program"], char: "\u{1F4FB}", fitzpatrick_scale: !1, category: "objects" }, studio_microphone: { keywords: ["sing", "recording", "artist", "talkshow"], char: "\u{1F399}", fitzpatrick_scale: !1, category: "objects" }, level_slider: { keywords: ["scale"], char: "\u{1F39A}", fitzpatrick_scale: !1, category: "objects" }, control_knobs: { keywords: ["dial"], char: "\u{1F39B}", fitzpatrick_scale: !1, category: "objects" }, compass: { keywords: ["magnetic", "navigation", "orienteering"], char: "\u{1F9ED}", fitzpatrick_scale: !1, category: "objects" }, stopwatch: { keywords: ["time", "deadline"], char: "\u23F1", fitzpatrick_scale: !1, category: "objects" }, timer_clock: { keywords: ["alarm"], char: "\u23F2", fitzpatrick_scale: !1, category: "objects" }, alarm_clock: { keywords: ["time", "wake"], char: "\u23F0", fitzpatrick_scale: !1, category: "objects" }, mantelpiece_clock: { keywords: ["time"], char: "\u{1F570}", fitzpatrick_scale: !1, category: "objects" }, hourglass_flowing_sand: { keywords: ["oldschool", "time", "countdown"], char: "\u23F3", fitzpatrick_scale: !1, category: "objects" }, hourglass: { keywords: ["time", "clock", "oldschool", "limit", "exam", "quiz", "test"], char: "\u231B", fitzpatrick_scale: !1, category: "objects" }, satellite: { keywords: ["communication", "future", "radio", "space"], char: "\u{1F4E1}", fitzpatrick_scale: !1, category: "objects" }, battery: { keywords: ["power", "energy", "sustain"], char: "\u{1F50B}", fitzpatrick_scale: !1, category: "objects" }, electric_plug: { keywords: ["charger", "power"], char: "\u{1F50C}", fitzpatrick_scale: !1, category: "objects" }, bulb: { keywords: ["light", "electricity", "idea"], char: "\u{1F4A1}", fitzpatrick_scale: !1, category: "objects" }, flashlight: { keywords: ["dark", "camping", "sight", "night"], char: "\u{1F526}", fitzpatrick_scale: !1, category: "objects" }, candle: { keywords: ["fire", "wax"], char: "\u{1F56F}", fitzpatrick_scale: !1, category: "objects" }, fire_extinguisher: { keywords: ["quench"], char: "\u{1F9EF}", fitzpatrick_scale: !1, category: "objects" }, wastebasket: { keywords: ["bin", "trash", "rubbish", "garbage", "toss"], char: "\u{1F5D1}", fitzpatrick_scale: !1, category: "objects" }, oil_drum: { keywords: ["barrell"], char: "\u{1F6E2}", fitzpatrick_scale: !1, category: "objects" }, money_with_wings: { keywords: ["dollar", "bills", "payment", "sale"], char: "\u{1F4B8}", fitzpatrick_scale: !1, category: "objects" }, dollar: { keywords: ["money", "sales", "bill", "currency"], char: "\u{1F4B5}", fitzpatrick_scale: !1, category: "objects" }, yen: { keywords: ["money", "sales", "japanese", "dollar", "currency"], char: "\u{1F4B4}", fitzpatrick_scale: !1, category: "objects" }, euro: { keywords: ["money", "sales", "dollar", "currency"], char: "\u{1F4B6}", fitzpatrick_scale: !1, category: "objects" }, pound: { keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"], char: "\u{1F4B7}", fitzpatrick_scale: !1, category: "objects" }, moneybag: { keywords: ["dollar", "payment", "coins", "sale"], char: "\u{1F4B0}", fitzpatrick_scale: !1, category: "objects" }, credit_card: { keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"], char: "\u{1F4B3}", fitzpatrick_scale: !1, category: "objects" }, gem: { keywords: ["blue", "ruby", "diamond", "jewelry"], char: "\u{1F48E}", fitzpatrick_scale: !1, category: "objects" }, balance_scale: { keywords: ["law", "fairness", "weight"], char: "\u2696", fitzpatrick_scale: !1, category: "objects" }, toolbox: { keywords: ["tools", "diy", "fix", "maintainer", "mechanic"], char: "\u{1F9F0}", fitzpatrick_scale: !1, category: "objects" }, wrench: { keywords: ["tools", "diy", "ikea", "fix", "maintainer"], char: "\u{1F527}", fitzpatrick_scale: !1, category: "objects" }, hammer: { keywords: ["tools", "build", "create"], char: "\u{1F528}", fitzpatrick_scale: !1, category: "objects" }, hammer_and_pick: { keywords: ["tools", "build", "create"], char: "\u2692", fitzpatrick_scale: !1, category: "objects" }, hammer_and_wrench: { keywords: ["tools", "build", "create"], char: "\u{1F6E0}", fitzpatrick_scale: !1, category: "objects" }, pick: { keywords: ["tools", "dig"], char: "\u26CF", fitzpatrick_scale: !1, category: "objects" }, nut_and_bolt: { keywords: ["handy", "tools", "fix"], char: "\u{1F529}", fitzpatrick_scale: !1, category: "objects" }, gear: { keywords: ["cog"], char: "\u2699", fitzpatrick_scale: !1, category: "objects" }, brick: { keywords: ["bricks"], char: "\u{1F9F1}", fitzpatrick_scale: !1, category: "objects" }, chains: { keywords: ["lock", "arrest"], char: "\u26D3", fitzpatrick_scale: !1, category: "objects" }, magnet: { keywords: ["attraction", "magnetic"], char: "\u{1F9F2}", fitzpatrick_scale: !1, category: "objects" }, gun: { keywords: ["violence", "weapon", "pistol", "revolver"], char: "\u{1F52B}", fitzpatrick_scale: !1, category: "objects" }, bomb: { keywords: ["boom", "explode", "explosion", "terrorism"], char: "\u{1F4A3}", fitzpatrick_scale: !1, category: "objects" }, firecracker: { keywords: ["dynamite", "boom", "explode", "explosion", "explosive"], char: "\u{1F9E8}", fitzpatrick_scale: !1, category: "objects" }, hocho: { keywords: ["knife", "blade", "cutlery", "kitchen", "weapon"], char: "\u{1F52A}", fitzpatrick_scale: !1, category: "objects" }, dagger: { keywords: ["weapon"], char: "\u{1F5E1}", fitzpatrick_scale: !1, category: "objects" }, crossed_swords: { keywords: ["weapon"], char: "\u2694", fitzpatrick_scale: !1, category: "objects" }, shield: { keywords: ["protection", "security"], char: "\u{1F6E1}", fitzpatrick_scale: !1, category: "objects" }, smoking: { keywords: ["kills", "tobacco", "cigarette", "joint", "smoke"], char: "\u{1F6AC}", fitzpatrick_scale: !1, category: "objects" }, skull_and_crossbones: { keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"], char: "\u2620", fitzpatrick_scale: !1, category: "objects" }, coffin: { keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"], char: "\u26B0", fitzpatrick_scale: !1, category: "objects" }, funeral_urn: { keywords: ["dead", "die", "death", "rip", "ashes"], char: "\u26B1", fitzpatrick_scale: !1, category: "objects" }, amphora: { keywords: ["vase", "jar"], char: "\u{1F3FA}", fitzpatrick_scale: !1, category: "objects" }, crystal_ball: { keywords: ["disco", "party", "magic", "circus", "fortune_teller"], char: "\u{1F52E}", fitzpatrick_scale: !1, category: "objects" }, prayer_beads: { keywords: ["dhikr", "religious"], char: "\u{1F4FF}", fitzpatrick_scale: !1, category: "objects" }, nazar_amulet: { keywords: ["bead", "charm"], char: "\u{1F9FF}", fitzpatrick_scale: !1, category: "objects" }, barber: { keywords: ["hair", "salon", "style"], char: "\u{1F488}", fitzpatrick_scale: !1, category: "objects" }, alembic: { keywords: ["distilling", "science", "experiment", "chemistry"], char: "\u2697", fitzpatrick_scale: !1, category: "objects" }, telescope: { keywords: ["stars", "space", "zoom", "science", "astronomy"], char: "\u{1F52D}", fitzpatrick_scale: !1, category: "objects" }, microscope: { keywords: ["laboratory", "experiment", "zoomin", "science", "study"], char: "\u{1F52C}", fitzpatrick_scale: !1, category: "objects" }, hole: { keywords: ["embarrassing"], char: "\u{1F573}", fitzpatrick_scale: !1, category: "objects" }, pill: { keywords: ["health", "medicine", "doctor", "pharmacy", "drug"], char: "\u{1F48A}", fitzpatrick_scale: !1, category: "objects" }, syringe: { keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"], char: "\u{1F489}", fitzpatrick_scale: !1, category: "objects" }, dna: { keywords: ["biologist", "genetics", "life"], char: "\u{1F9EC}", fitzpatrick_scale: !1, category: "objects" }, microbe: { keywords: ["amoeba", "bacteria", "germs"], char: "\u{1F9A0}", fitzpatrick_scale: !1, category: "objects" }, petri_dish: { keywords: ["bacteria", "biology", "culture", "lab"], char: "\u{1F9EB}", fitzpatrick_scale: !1, category: "objects" }, test_tube: { keywords: ["chemistry", "experiment", "lab", "science"], char: "\u{1F9EA}", fitzpatrick_scale: !1, category: "objects" }, thermometer: { keywords: ["weather", "temperature", "hot", "cold"], char: "\u{1F321}", fitzpatrick_scale: !1, category: "objects" }, broom: { keywords: ["cleaning", "sweeping", "witch"], char: "\u{1F9F9}", fitzpatrick_scale: !1, category: "objects" }, basket: { keywords: ["laundry"], char: "\u{1F9FA}", fitzpatrick_scale: !1, category: "objects" }, toilet_paper: { keywords: ["roll"], char: "\u{1F9FB}", fitzpatrick_scale: !1, category: "objects" }, label: { keywords: ["sale", "tag"], char: "\u{1F3F7}", fitzpatrick_scale: !1, category: "objects" }, bookmark: { keywords: ["favorite", "label", "save"], char: "\u{1F516}", fitzpatrick_scale: !1, category: "objects" }, toilet: { keywords: ["restroom", "wc", "washroom", "bathroom", "potty"], char: "\u{1F6BD}", fitzpatrick_scale: !1, category: "objects" }, shower: { keywords: ["clean", "water", "bathroom"], char: "\u{1F6BF}", fitzpatrick_scale: !1, category: "objects" }, bathtub: { keywords: ["clean", "shower", "bathroom"], char: "\u{1F6C1}", fitzpatrick_scale: !1, category: "objects" }, soap: { keywords: ["bar", "bathing", "cleaning", "lather"], char: "\u{1F9FC}", fitzpatrick_scale: !1, category: "objects" }, sponge: { keywords: ["absorbing", "cleaning", "porous"], char: "\u{1F9FD}", fitzpatrick_scale: !1, category: "objects" }, lotion_bottle: { keywords: ["moisturizer", "sunscreen"], char: "\u{1F9F4}", fitzpatrick_scale: !1, category: "objects" }, key: { keywords: ["lock", "door", "password"], char: "\u{1F511}", fitzpatrick_scale: !1, category: "objects" }, old_key: { keywords: ["lock", "door", "password"], char: "\u{1F5DD}", fitzpatrick_scale: !1, category: "objects" }, couch_and_lamp: { keywords: ["read", "chill"], char: "\u{1F6CB}", fitzpatrick_scale: !1, category: "objects" }, sleeping_bed: { keywords: ["bed", "rest"], char: "\u{1F6CC}", fitzpatrick_scale: !0, category: "objects" }, bed: { keywords: ["sleep", "rest"], char: "\u{1F6CF}", fitzpatrick_scale: !1, category: "objects" }, door: { keywords: ["house", "entry", "exit"], char: "\u{1F6AA}", fitzpatrick_scale: !1, category: "objects" }, bellhop_bell: { keywords: ["service"], char: "\u{1F6CE}", fitzpatrick_scale: !1, category: "objects" }, teddy_bear: { keywords: ["plush", "stuffed"], char: "\u{1F9F8}", fitzpatrick_scale: !1, category: "objects" }, framed_picture: { keywords: ["photography"], char: "\u{1F5BC}", fitzpatrick_scale: !1, category: "objects" }, world_map: { keywords: ["location", "direction"], char: "\u{1F5FA}", fitzpatrick_scale: !1, category: "objects" }, parasol_on_ground: { keywords: ["weather", "summer"], char: "\u26F1", fitzpatrick_scale: !1, category: "objects" }, moyai: { keywords: ["rock", "easter island", "moai"], char: "\u{1F5FF}", fitzpatrick_scale: !1, category: "objects" }, shopping: { keywords: ["mall", "buy", "purchase"], char: "\u{1F6CD}", fitzpatrick_scale: !1, category: "objects" }, shopping_cart: { keywords: ["trolley"], char: "\u{1F6D2}", fitzpatrick_scale: !1, category: "objects" }, balloon: { keywords: ["party", "celebration", "birthday", "circus"], char: "\u{1F388}", fitzpatrick_scale: !1, category: "objects" }, flags: { keywords: ["fish", "japanese", "koinobori", "carp", "banner"], char: "\u{1F38F}", fitzpatrick_scale: !1, category: "objects" }, ribbon: { keywords: ["decoration", "pink", "girl", "bowtie"], char: "\u{1F380}", fitzpatrick_scale: !1, category: "objects" }, gift: { keywords: ["present", "birthday", "christmas", "xmas"], char: "\u{1F381}", fitzpatrick_scale: !1, category: "objects" }, confetti_ball: { keywords: ["festival", "party", "birthday", "circus"], char: "\u{1F38A}", fitzpatrick_scale: !1, category: "objects" }, tada: { keywords: ["party", "congratulations", "birthday", "magic", "circus", "celebration"], char: "\u{1F389}", fitzpatrick_scale: !1, category: "objects" }, dolls: { keywords: ["japanese", "toy", "kimono"], char: "\u{1F38E}", fitzpatrick_scale: !1, category: "objects" }, wind_chime: { keywords: ["nature", "ding", "spring", "bell"], char: "\u{1F390}", fitzpatrick_scale: !1, category: "objects" }, crossed_flags: { keywords: ["japanese", "nation", "country", "border"], char: "\u{1F38C}", fitzpatrick_scale: !1, category: "objects" }, izakaya_lantern: { keywords: ["light", "paper", "halloween", "spooky"], char: "\u{1F3EE}", fitzpatrick_scale: !1, category: "objects" }, red_envelope: { keywords: ["gift"], char: "\u{1F9E7}", fitzpatrick_scale: !1, category: "objects" }, email: { keywords: ["letter", "postal", "inbox", "communication"], char: "\u2709\uFE0F", fitzpatrick_scale: !1, category: "objects" }, envelope_with_arrow: { keywords: ["email", "communication"], char: "\u{1F4E9}", fitzpatrick_scale: !1, category: "objects" }, incoming_envelope: { keywords: ["email", "inbox"], char: "\u{1F4E8}", fitzpatrick_scale: !1, category: "objects" }, "e-mail": { keywords: ["communication", "inbox"], char: "\u{1F4E7}", fitzpatrick_scale: !1, category: "objects" }, love_letter: { keywords: ["email", "like", "affection", "envelope", "valentines"], char: "\u{1F48C}", fitzpatrick_scale: !1, category: "objects" }, postbox: { keywords: ["email", "letter", "envelope"], char: "\u{1F4EE}", fitzpatrick_scale: !1, category: "objects" }, mailbox_closed: { keywords: ["email", "communication", "inbox"], char: "\u{1F4EA}", fitzpatrick_scale: !1, category: "objects" }, mailbox: { keywords: ["email", "inbox", "communication"], char: "\u{1F4EB}", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_mail: { keywords: ["email", "inbox", "communication"], char: "\u{1F4EC}", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_no_mail: { keywords: ["email", "inbox"], char: "\u{1F4ED}", fitzpatrick_scale: !1, category: "objects" }, package: { keywords: ["mail", "gift", "cardboard", "box", "moving"], char: "\u{1F4E6}", fitzpatrick_scale: !1, category: "objects" }, postal_horn: { keywords: ["instrument", "music"], char: "\u{1F4EF}", fitzpatrick_scale: !1, category: "objects" }, inbox_tray: { keywords: ["email", "documents"], char: "\u{1F4E5}", fitzpatrick_scale: !1, category: "objects" }, outbox_tray: { keywords: ["inbox", "email"], char: "\u{1F4E4}", fitzpatrick_scale: !1, category: "objects" }, scroll: { keywords: ["documents", "ancient", "history", "paper"], char: "\u{1F4DC}", fitzpatrick_scale: !1, category: "objects" }, page_with_curl: { keywords: ["documents", "office", "paper"], char: "\u{1F4C3}", fitzpatrick_scale: !1, category: "objects" }, bookmark_tabs: { keywords: ["favorite", "save", "order", "tidy"], char: "\u{1F4D1}", fitzpatrick_scale: !1, category: "objects" }, receipt: { keywords: ["accounting", "expenses"], char: "\u{1F9FE}", fitzpatrick_scale: !1, category: "objects" }, bar_chart: { keywords: ["graph", "presentation", "stats"], char: "\u{1F4CA}", fitzpatrick_scale: !1, category: "objects" }, chart_with_upwards_trend: { keywords: ["graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"], char: "\u{1F4C8}", fitzpatrick_scale: !1, category: "objects" }, chart_with_downwards_trend: { keywords: ["graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"], char: "\u{1F4C9}", fitzpatrick_scale: !1, category: "objects" }, page_facing_up: { keywords: ["documents", "office", "paper", "information"], char: "\u{1F4C4}", fitzpatrick_scale: !1, category: "objects" }, date: { keywords: ["calendar", "schedule"], char: "\u{1F4C5}", fitzpatrick_scale: !1, category: "objects" }, calendar: { keywords: ["schedule", "date", "planning"], char: "\u{1F4C6}", fitzpatrick_scale: !1, category: "objects" }, spiral_calendar: { keywords: ["date", "schedule", "planning"], char: "\u{1F5D3}", fitzpatrick_scale: !1, category: "objects" }, card_index: { keywords: ["business", "stationery"], char: "\u{1F4C7}", fitzpatrick_scale: !1, category: "objects" }, card_file_box: { keywords: ["business", "stationery"], char: "\u{1F5C3}", fitzpatrick_scale: !1, category: "objects" }, ballot_box: { keywords: ["election", "vote"], char: "\u{1F5F3}", fitzpatrick_scale: !1, category: "objects" }, file_cabinet: { keywords: ["filing", "organizing"], char: "\u{1F5C4}", fitzpatrick_scale: !1, category: "objects" }, clipboard: { keywords: ["stationery", "documents"], char: "\u{1F4CB}", fitzpatrick_scale: !1, category: "objects" }, spiral_notepad: { keywords: ["memo", "stationery"], char: "\u{1F5D2}", fitzpatrick_scale: !1, category: "objects" }, file_folder: { keywords: ["documents", "business", "office"], char: "\u{1F4C1}", fitzpatrick_scale: !1, category: "objects" }, open_file_folder: { keywords: ["documents", "load"], char: "\u{1F4C2}", fitzpatrick_scale: !1, category: "objects" }, card_index_dividers: { keywords: ["organizing", "business", "stationery"], char: "\u{1F5C2}", fitzpatrick_scale: !1, category: "objects" }, newspaper_roll: { keywords: ["press", "headline"], char: "\u{1F5DE}", fitzpatrick_scale: !1, category: "objects" }, newspaper: { keywords: ["press", "headline"], char: "\u{1F4F0}", fitzpatrick_scale: !1, category: "objects" }, notebook: { keywords: ["stationery", "record", "notes", "paper", "study"], char: "\u{1F4D3}", fitzpatrick_scale: !1, category: "objects" }, closed_book: { keywords: ["read", "library", "knowledge", "textbook", "learn"], char: "\u{1F4D5}", fitzpatrick_scale: !1, category: "objects" }, green_book: { keywords: ["read", "library", "knowledge", "study"], char: "\u{1F4D7}", fitzpatrick_scale: !1, category: "objects" }, blue_book: { keywords: ["read", "library", "knowledge", "learn", "study"], char: "\u{1F4D8}", fitzpatrick_scale: !1, category: "objects" }, orange_book: { keywords: ["read", "library", "knowledge", "textbook", "study"], char: "\u{1F4D9}", fitzpatrick_scale: !1, category: "objects" }, notebook_with_decorative_cover: { keywords: ["classroom", "notes", "record", "paper", "study"], char: "\u{1F4D4}", fitzpatrick_scale: !1, category: "objects" }, ledger: { keywords: ["notes", "paper"], char: "\u{1F4D2}", fitzpatrick_scale: !1, category: "objects" }, books: { keywords: ["literature", "library", "study"], char: "\u{1F4DA}", fitzpatrick_scale: !1, category: "objects" }, open_book: { keywords: ["book", "read", "library", "knowledge", "literature", "learn", "study"], char: "\u{1F4D6}", fitzpatrick_scale: !1, category: "objects" }, safety_pin: { keywords: ["diaper"], char: "\u{1F9F7}", fitzpatrick_scale: !1, category: "objects" }, link: { keywords: ["rings", "url"], char: "\u{1F517}", fitzpatrick_scale: !1, category: "objects" }, paperclip: { keywords: ["documents", "stationery"], char: "\u{1F4CE}", fitzpatrick_scale: !1, category: "objects" }, paperclips: { keywords: ["documents", "stationery"], char: "\u{1F587}", fitzpatrick_scale: !1, category: "objects" }, scissors: { keywords: ["stationery", "cut"], char: "\u2702\uFE0F", fitzpatrick_scale: !1, category: "objects" }, triangular_ruler: { keywords: ["stationery", "math", "architect", "sketch"], char: "\u{1F4D0}", fitzpatrick_scale: !1, category: "objects" }, straight_ruler: { keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"], char: "\u{1F4CF}", fitzpatrick_scale: !1, category: "objects" }, abacus: { keywords: ["calculation"], char: "\u{1F9EE}", fitzpatrick_scale: !1, category: "objects" }, pushpin: { keywords: ["stationery", "mark", "here"], char: "\u{1F4CC}", fitzpatrick_scale: !1, category: "objects" }, round_pushpin: { keywords: ["stationery", "location", "map", "here"], char: "\u{1F4CD}", fitzpatrick_scale: !1, category: "objects" }, triangular_flag_on_post: { keywords: ["mark", "milestone", "place"], char: "\u{1F6A9}", fitzpatrick_scale: !1, category: "objects" }, white_flag: { keywords: ["losing", "loser", "lost", "surrender", "give up", "fail"], char: "\u{1F3F3}", fitzpatrick_scale: !1, category: "objects" }, black_flag: { keywords: ["pirate"], char: "\u{1F3F4}", fitzpatrick_scale: !1, category: "objects" }, rainbow_flag: { keywords: ["flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"], char: "\u{1F3F3}\uFE0F\u200D\u{1F308}", fitzpatrick_scale: !1, category: "objects" }, closed_lock_with_key: { keywords: ["security", "privacy"], char: "\u{1F510}", fitzpatrick_scale: !1, category: "objects" }, lock: { keywords: ["security", "password", "padlock"], char: "\u{1F512}", fitzpatrick_scale: !1, category: "objects" }, unlock: { keywords: ["privacy", "security"], char: "\u{1F513}", fitzpatrick_scale: !1, category: "objects" }, lock_with_ink_pen: { keywords: ["security", "secret"], char: "\u{1F50F}", fitzpatrick_scale: !1, category: "objects" }, pen: { keywords: ["stationery", "writing", "write"], char: "\u{1F58A}", fitzpatrick_scale: !1, category: "objects" }, fountain_pen: { keywords: ["stationery", "writing", "write"], char: "\u{1F58B}", fitzpatrick_scale: !1, category: "objects" }, black_nib: { keywords: ["pen", "stationery", "writing", "write"], char: "\u2712\uFE0F", fitzpatrick_scale: !1, category: "objects" }, memo: { keywords: ["write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"], char: "\u{1F4DD}", fitzpatrick_scale: !1, category: "objects" }, pencil2: { keywords: ["stationery", "write", "paper", "writing", "school", "study"], char: "\u270F\uFE0F", fitzpatrick_scale: !1, category: "objects" }, crayon: { keywords: ["drawing", "creativity"], char: "\u{1F58D}", fitzpatrick_scale: !1, category: "objects" }, paintbrush: { keywords: ["drawing", "creativity", "art"], char: "\u{1F58C}", fitzpatrick_scale: !1, category: "objects" }, mag: { keywords: ["search", "zoom", "find", "detective"], char: "\u{1F50D}", fitzpatrick_scale: !1, category: "objects" }, mag_right: { keywords: ["search", "zoom", "find", "detective"], char: "\u{1F50E}", fitzpatrick_scale: !1, category: "objects" }, heart: { keywords: ["love", "like", "valentines"], char: "\u2764\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, orange_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F9E1}", fitzpatrick_scale: !1, category: "symbols" }, yellow_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49B}", fitzpatrick_scale: !1, category: "symbols" }, green_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49A}", fitzpatrick_scale: !1, category: "symbols" }, blue_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F499}", fitzpatrick_scale: !1, category: "symbols" }, purple_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49C}", fitzpatrick_scale: !1, category: "symbols" }, black_heart: { keywords: ["evil"], char: "\u{1F5A4}", fitzpatrick_scale: !1, category: "symbols" }, broken_heart: { keywords: ["sad", "sorry", "break", "heart", "heartbreak"], char: "\u{1F494}", fitzpatrick_scale: !1, category: "symbols" }, heavy_heart_exclamation: { keywords: ["decoration", "love"], char: "\u2763", fitzpatrick_scale: !1, category: "symbols" }, two_hearts: { keywords: ["love", "like", "affection", "valentines", "heart"], char: "\u{1F495}", fitzpatrick_scale: !1, category: "symbols" }, revolving_hearts: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F49E}", fitzpatrick_scale: !1, category: "symbols" }, heartbeat: { keywords: ["love", "like", "affection", "valentines", "pink", "heart"], char: "\u{1F493}", fitzpatrick_scale: !1, category: "symbols" }, heartpulse: { keywords: ["like", "love", "affection", "valentines", "pink"], char: "\u{1F497}", fitzpatrick_scale: !1, category: "symbols" }, sparkling_heart: { keywords: ["love", "like", "affection", "valentines"], char: "\u{1F496}", fitzpatrick_scale: !1, category: "symbols" }, cupid: { keywords: ["love", "like", "heart", "affection", "valentines"], char: "\u{1F498}", fitzpatrick_scale: !1, category: "symbols" }, gift_heart: { keywords: ["love", "valentines"], char: "\u{1F49D}", fitzpatrick_scale: !1, category: "symbols" }, heart_decoration: { keywords: ["purple-square", "love", "like"], char: "\u{1F49F}", fitzpatrick_scale: !1, category: "symbols" }, peace_symbol: { keywords: ["hippie"], char: "\u262E", fitzpatrick_scale: !1, category: "symbols" }, latin_cross: { keywords: ["christianity"], char: "\u271D", fitzpatrick_scale: !1, category: "symbols" }, star_and_crescent: { keywords: ["islam"], char: "\u262A", fitzpatrick_scale: !1, category: "symbols" }, om: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "\u{1F549}", fitzpatrick_scale: !1, category: "symbols" }, wheel_of_dharma: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "\u2638", fitzpatrick_scale: !1, category: "symbols" }, star_of_david: { keywords: ["judaism"], char: "\u2721", fitzpatrick_scale: !1, category: "symbols" }, six_pointed_star: { keywords: ["purple-square", "religion", "jewish", "hexagram"], char: "\u{1F52F}", fitzpatrick_scale: !1, category: "symbols" }, menorah: { keywords: ["hanukkah", "candles", "jewish"], char: "\u{1F54E}", fitzpatrick_scale: !1, category: "symbols" }, yin_yang: { keywords: ["balance"], char: "\u262F", fitzpatrick_scale: !1, category: "symbols" }, orthodox_cross: { keywords: ["suppedaneum", "religion"], char: "\u2626", fitzpatrick_scale: !1, category: "symbols" }, place_of_worship: { keywords: ["religion", "church", "temple", "prayer"], char: "\u{1F6D0}", fitzpatrick_scale: !1, category: "symbols" }, ophiuchus: { keywords: ["sign", "purple-square", "constellation", "astrology"], char: "\u26CE", fitzpatrick_scale: !1, category: "symbols" }, aries: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u2648", fitzpatrick_scale: !1, category: "symbols" }, taurus: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "\u2649", fitzpatrick_scale: !1, category: "symbols" }, gemini: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264A", fitzpatrick_scale: !1, category: "symbols" }, cancer: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264B", fitzpatrick_scale: !1, category: "symbols" }, leo: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u264C", fitzpatrick_scale: !1, category: "symbols" }, virgo: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u264D", fitzpatrick_scale: !1, category: "symbols" }, libra: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u264E", fitzpatrick_scale: !1, category: "symbols" }, scorpius: { keywords: ["sign", "zodiac", "purple-square", "astrology", "scorpio"], char: "\u264F", fitzpatrick_scale: !1, category: "symbols" }, sagittarius: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u2650", fitzpatrick_scale: !1, category: "symbols" }, capricorn: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "\u2651", fitzpatrick_scale: !1, category: "symbols" }, aquarius: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "\u2652", fitzpatrick_scale: !1, category: "symbols" }, pisces: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "\u2653", fitzpatrick_scale: !1, category: "symbols" }, id: { keywords: ["purple-square", "words"], char: "\u{1F194}", fitzpatrick_scale: !1, category: "symbols" }, atom_symbol: { keywords: ["science", "physics", "chemistry"], char: "\u269B", fitzpatrick_scale: !1, category: "symbols" }, u7a7a: { keywords: ["kanji", "japanese", "chinese", "empty", "sky", "blue-square"], char: "\u{1F233}", fitzpatrick_scale: !1, category: "symbols" }, u5272: { keywords: ["cut", "divide", "chinese", "kanji", "pink-square"], char: "\u{1F239}", fitzpatrick_scale: !1, category: "symbols" }, radioactive: { keywords: ["nuclear", "danger"], char: "\u2622", fitzpatrick_scale: !1, category: "symbols" }, biohazard: { keywords: ["danger"], char: "\u2623", fitzpatrick_scale: !1, category: "symbols" }, mobile_phone_off: { keywords: ["mute", "orange-square", "silence", "quiet"], char: "\u{1F4F4}", fitzpatrick_scale: !1, category: "symbols" }, vibration_mode: { keywords: ["orange-square", "phone"], char: "\u{1F4F3}", fitzpatrick_scale: !1, category: "symbols" }, u6709: { keywords: ["orange-square", "chinese", "have", "kanji"], char: "\u{1F236}", fitzpatrick_scale: !1, category: "symbols" }, u7121: { keywords: ["nothing", "chinese", "kanji", "japanese", "orange-square"], char: "\u{1F21A}", fitzpatrick_scale: !1, category: "symbols" }, u7533: { keywords: ["chinese", "japanese", "kanji", "orange-square"], char: "\u{1F238}", fitzpatrick_scale: !1, category: "symbols" }, u55b6: { keywords: ["japanese", "opening hours", "orange-square"], char: "\u{1F23A}", fitzpatrick_scale: !1, category: "symbols" }, u6708: { keywords: ["chinese", "month", "moon", "japanese", "orange-square", "kanji"], char: "\u{1F237}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, eight_pointed_black_star: { keywords: ["orange-square", "shape", "polygon"], char: "\u2734\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, vs: { keywords: ["words", "orange-square"], char: "\u{1F19A}", fitzpatrick_scale: !1, category: "symbols" }, accept: { keywords: ["ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle"], char: "\u{1F251}", fitzpatrick_scale: !1, category: "symbols" }, white_flower: { keywords: ["japanese", "spring"], char: "\u{1F4AE}", fitzpatrick_scale: !1, category: "symbols" }, ideograph_advantage: { keywords: ["chinese", "kanji", "obtain", "get", "circle"], char: "\u{1F250}", fitzpatrick_scale: !1, category: "symbols" }, secret: { keywords: ["privacy", "chinese", "sshh", "kanji", "red-circle"], char: "\u3299\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, congratulations: { keywords: ["chinese", "kanji", "japanese", "red-circle"], char: "\u3297\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, u5408: { keywords: ["japanese", "chinese", "join", "kanji", "red-square"], char: "\u{1F234}", fitzpatrick_scale: !1, category: "symbols" }, u6e80: { keywords: ["full", "chinese", "japanese", "red-square", "kanji"], char: "\u{1F235}", fitzpatrick_scale: !1, category: "symbols" }, u7981: { keywords: ["kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square"], char: "\u{1F232}", fitzpatrick_scale: !1, category: "symbols" }, a: { keywords: ["red-square", "alphabet", "letter"], char: "\u{1F170}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, b: { keywords: ["red-square", "alphabet", "letter"], char: "\u{1F171}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, ab: { keywords: ["red-square", "alphabet"], char: "\u{1F18E}", fitzpatrick_scale: !1, category: "symbols" }, cl: { keywords: ["alphabet", "words", "red-square"], char: "\u{1F191}", fitzpatrick_scale: !1, category: "symbols" }, o2: { keywords: ["alphabet", "red-square", "letter"], char: "\u{1F17E}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, sos: { keywords: ["help", "red-square", "words", "emergency", "911"], char: "\u{1F198}", fitzpatrick_scale: !1, category: "symbols" }, no_entry: { keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"], char: "\u26D4", fitzpatrick_scale: !1, category: "symbols" }, name_badge: { keywords: ["fire", "forbid"], char: "\u{1F4DB}", fitzpatrick_scale: !1, category: "symbols" }, no_entry_sign: { keywords: ["forbid", "stop", "limit", "denied", "disallow", "circle"], char: "\u{1F6AB}", fitzpatrick_scale: !1, category: "symbols" }, x: { keywords: ["no", "delete", "remove", "cancel", "red"], char: "\u274C", fitzpatrick_scale: !1, category: "symbols" }, o: { keywords: ["circle", "round"], char: "\u2B55", fitzpatrick_scale: !1, category: "symbols" }, stop_sign: { keywords: ["stop"], char: "\u{1F6D1}", fitzpatrick_scale: !1, category: "symbols" }, anger: { keywords: ["angry", "mad"], char: "\u{1F4A2}", fitzpatrick_scale: !1, category: "symbols" }, hotsprings: { keywords: ["bath", "warm", "relax"], char: "\u2668\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, no_pedestrians: { keywords: ["rules", "crossing", "walking", "circle"], char: "\u{1F6B7}", fitzpatrick_scale: !1, category: "symbols" }, do_not_litter: { keywords: ["trash", "bin", "garbage", "circle"], char: "\u{1F6AF}", fitzpatrick_scale: !1, category: "symbols" }, no_bicycles: { keywords: ["cyclist", "prohibited", "circle"], char: "\u{1F6B3}", fitzpatrick_scale: !1, category: "symbols" }, "non-potable_water": { keywords: ["drink", "faucet", "tap", "circle"], char: "\u{1F6B1}", fitzpatrick_scale: !1, category: "symbols" }, underage: { keywords: ["18", "drink", "pub", "night", "minor", "circle"], char: "\u{1F51E}", fitzpatrick_scale: !1, category: "symbols" }, no_mobile_phones: { keywords: ["iphone", "mute", "circle"], char: "\u{1F4F5}", fitzpatrick_scale: !1, category: "symbols" }, exclamation: { keywords: ["heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning"], char: "\u2757", fitzpatrick_scale: !1, category: "symbols" }, grey_exclamation: { keywords: ["surprise", "punctuation", "gray", "wow", "warning"], char: "\u2755", fitzpatrick_scale: !1, category: "symbols" }, question: { keywords: ["doubt", "confused"], char: "\u2753", fitzpatrick_scale: !1, category: "symbols" }, grey_question: { keywords: ["doubts", "gray", "huh", "confused"], char: "\u2754", fitzpatrick_scale: !1, category: "symbols" }, bangbang: { keywords: ["exclamation", "surprise"], char: "\u203C\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, interrobang: { keywords: ["wat", "punctuation", "surprise"], char: "\u2049\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, 100: { keywords: ["score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred"], char: "\u{1F4AF}", fitzpatrick_scale: !1, category: "symbols" }, low_brightness: { keywords: ["sun", "afternoon", "warm", "summer"], char: "\u{1F505}", fitzpatrick_scale: !1, category: "symbols" }, high_brightness: { keywords: ["sun", "light"], char: "\u{1F506}", fitzpatrick_scale: !1, category: "symbols" }, trident: { keywords: ["weapon", "spear"], char: "\u{1F531}", fitzpatrick_scale: !1, category: "symbols" }, fleur_de_lis: { keywords: ["decorative", "scout"], char: "\u269C", fitzpatrick_scale: !1, category: "symbols" }, part_alternation_mark: { keywords: ["graph", "presentation", "stats", "business", "economics", "bad"], char: "\u303D\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, warning: { keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"], char: "\u26A0\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, children_crossing: { keywords: ["school", "warning", "danger", "sign", "driving", "yellow-diamond"], char: "\u{1F6B8}", fitzpatrick_scale: !1, category: "symbols" }, beginner: { keywords: ["badge", "shield"], char: "\u{1F530}", fitzpatrick_scale: !1, category: "symbols" }, recycle: { keywords: ["arrow", "environment", "garbage", "trash"], char: "\u267B\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, u6307: { keywords: ["chinese", "point", "green-square", "kanji"], char: "\u{1F22F}", fitzpatrick_scale: !1, category: "symbols" }, chart: { keywords: ["green-square", "graph", "presentation", "stats"], char: "\u{1F4B9}", fitzpatrick_scale: !1, category: "symbols" }, sparkle: { keywords: ["stars", "green-square", "awesome", "good", "fireworks"], char: "\u2747\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, eight_spoked_asterisk: { keywords: ["star", "sparkle", "green-square"], char: "\u2733\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, negative_squared_cross_mark: { keywords: ["x", "green-square", "no", "deny"], char: "\u274E", fitzpatrick_scale: !1, category: "symbols" }, white_check_mark: { keywords: ["green-square", "ok", "agree", "vote", "election", "answer", "tick"], char: "\u2705", fitzpatrick_scale: !1, category: "symbols" }, diamond_shape_with_a_dot_inside: { keywords: ["jewel", "blue", "gem", "crystal", "fancy"], char: "\u{1F4A0}", fitzpatrick_scale: !1, category: "symbols" }, cyclone: { keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"], char: "\u{1F300}", fitzpatrick_scale: !1, category: "symbols" }, loop: { keywords: ["tape", "cassette"], char: "\u27BF", fitzpatrick_scale: !1, category: "symbols" }, globe_with_meridians: { keywords: ["earth", "international", "world", "internet", "interweb", "i18n"], char: "\u{1F310}", fitzpatrick_scale: !1, category: "symbols" }, m: { keywords: ["alphabet", "blue-circle", "letter"], char: "\u24C2\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, atm: { keywords: ["money", "sales", "cash", "blue-square", "payment", "bank"], char: "\u{1F3E7}", fitzpatrick_scale: !1, category: "symbols" }, sa: { keywords: ["japanese", "blue-square", "katakana"], char: "\u{1F202}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, passport_control: { keywords: ["custom", "blue-square"], char: "\u{1F6C2}", fitzpatrick_scale: !1, category: "symbols" }, customs: { keywords: ["passport", "border", "blue-square"], char: "\u{1F6C3}", fitzpatrick_scale: !1, category: "symbols" }, baggage_claim: { keywords: ["blue-square", "airport", "transport"], char: "\u{1F6C4}", fitzpatrick_scale: !1, category: "symbols" }, left_luggage: { keywords: ["blue-square", "travel"], char: "\u{1F6C5}", fitzpatrick_scale: !1, category: "symbols" }, wheelchair: { keywords: ["blue-square", "disabled", "a11y", "accessibility"], char: "\u267F", fitzpatrick_scale: !1, category: "symbols" }, no_smoking: { keywords: ["cigarette", "blue-square", "smell", "smoke"], char: "\u{1F6AD}", fitzpatrick_scale: !1, category: "symbols" }, wc: { keywords: ["toilet", "restroom", "blue-square"], char: "\u{1F6BE}", fitzpatrick_scale: !1, category: "symbols" }, parking: { keywords: ["cars", "blue-square", "alphabet", "letter"], char: "\u{1F17F}\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, potable_water: { keywords: ["blue-square", "liquid", "restroom", "cleaning", "faucet"], char: "\u{1F6B0}", fitzpatrick_scale: !1, category: "symbols" }, mens: { keywords: ["toilet", "restroom", "wc", "blue-square", "gender", "male"], char: "\u{1F6B9}", fitzpatrick_scale: !1, category: "symbols" }, womens: { keywords: ["purple-square", "woman", "female", "toilet", "loo", "restroom", "gender"], char: "\u{1F6BA}", fitzpatrick_scale: !1, category: "symbols" }, baby_symbol: { keywords: ["orange-square", "child"], char: "\u{1F6BC}", fitzpatrick_scale: !1, category: "symbols" }, restroom: { keywords: ["blue-square", "toilet", "refresh", "wc", "gender"], char: "\u{1F6BB}", fitzpatrick_scale: !1, category: "symbols" }, put_litter_in_its_place: { keywords: ["blue-square", "sign", "human", "info"], char: "\u{1F6AE}", fitzpatrick_scale: !1, category: "symbols" }, cinema: { keywords: ["blue-square", "record", "film", "movie", "curtain", "stage", "theater"], char: "\u{1F3A6}", fitzpatrick_scale: !1, category: "symbols" }, signal_strength: { keywords: ["blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars"], char: "\u{1F4F6}", fitzpatrick_scale: !1, category: "symbols" }, koko: { keywords: ["blue-square", "here", "katakana", "japanese", "destination"], char: "\u{1F201}", fitzpatrick_scale: !1, category: "symbols" }, ng: { keywords: ["blue-square", "words", "shape", "icon"], char: "\u{1F196}", fitzpatrick_scale: !1, category: "symbols" }, ok: { keywords: ["good", "agree", "yes", "blue-square"], char: "\u{1F197}", fitzpatrick_scale: !1, category: "symbols" }, up: { keywords: ["blue-square", "above", "high"], char: "\u{1F199}", fitzpatrick_scale: !1, category: "symbols" }, cool: { keywords: ["words", "blue-square"], char: "\u{1F192}", fitzpatrick_scale: !1, category: "symbols" }, new: { keywords: ["blue-square", "words", "start"], char: "\u{1F195}", fitzpatrick_scale: !1, category: "symbols" }, free: { keywords: ["blue-square", "words"], char: "\u{1F193}", fitzpatrick_scale: !1, category: "symbols" }, zero: { keywords: ["0", "numbers", "blue-square", "null"], char: "0\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, one: { keywords: ["blue-square", "numbers", "1"], char: "1\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, two: { keywords: ["numbers", "2", "prime", "blue-square"], char: "2\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, three: { keywords: ["3", "numbers", "prime", "blue-square"], char: "3\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, four: { keywords: ["4", "numbers", "blue-square"], char: "4\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, five: { keywords: ["5", "numbers", "blue-square", "prime"], char: "5\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, six: { keywords: ["6", "numbers", "blue-square"], char: "6\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, seven: { keywords: ["7", "numbers", "blue-square", "prime"], char: "7\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, eight: { keywords: ["8", "blue-square", "numbers"], char: "8\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, nine: { keywords: ["blue-square", "numbers", "9"], char: "9\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, keycap_ten: { keywords: ["numbers", "10", "blue-square"], char: "\u{1F51F}", fitzpatrick_scale: !1, category: "symbols" }, asterisk: { keywords: ["star", "keycap"], char: "*\u20E3", fitzpatrick_scale: !1, category: "symbols" }, 1234: { keywords: ["numbers", "blue-square"], char: "\u{1F522}", fitzpatrick_scale: !1, category: "symbols" }, eject_button: { keywords: ["blue-square"], char: "\u23CF\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_forward: { keywords: ["blue-square", "right", "direction", "play"], char: "\u25B6\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, pause_button: { keywords: ["pause", "blue-square"], char: "\u23F8", fitzpatrick_scale: !1, category: "symbols" }, next_track_button: { keywords: ["forward", "next", "blue-square"], char: "\u23ED", fitzpatrick_scale: !1, category: "symbols" }, stop_button: { keywords: ["blue-square"], char: "\u23F9", fitzpatrick_scale: !1, category: "symbols" }, record_button: { keywords: ["blue-square"], char: "\u23FA", fitzpatrick_scale: !1, category: "symbols" }, play_or_pause_button: { keywords: ["blue-square", "play", "pause"], char: "\u23EF", fitzpatrick_scale: !1, category: "symbols" }, previous_track_button: { keywords: ["backward"], char: "\u23EE", fitzpatrick_scale: !1, category: "symbols" }, fast_forward: { keywords: ["blue-square", "play", "speed", "continue"], char: "\u23E9", fitzpatrick_scale: !1, category: "symbols" }, rewind: { keywords: ["play", "blue-square"], char: "\u23EA", fitzpatrick_scale: !1, category: "symbols" }, twisted_rightwards_arrows: { keywords: ["blue-square", "shuffle", "music", "random"], char: "\u{1F500}", fitzpatrick_scale: !1, category: "symbols" }, repeat: { keywords: ["loop", "record"], char: "\u{1F501}", fitzpatrick_scale: !1, category: "symbols" }, repeat_one: { keywords: ["blue-square", "loop"], char: "\u{1F502}", fitzpatrick_scale: !1, category: "symbols" }, arrow_backward: { keywords: ["blue-square", "left", "direction"], char: "\u25C0\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_small: { keywords: ["blue-square", "triangle", "direction", "point", "forward", "top"], char: "\u{1F53C}", fitzpatrick_scale: !1, category: "symbols" }, arrow_down_small: { keywords: ["blue-square", "direction", "bottom"], char: "\u{1F53D}", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_up: { keywords: ["blue-square", "direction", "top"], char: "\u23EB", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u23EC", fitzpatrick_scale: !1, category: "symbols" }, arrow_right: { keywords: ["blue-square", "next"], char: "\u27A1\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_left: { keywords: ["blue-square", "previous", "back"], char: "\u2B05\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up: { keywords: ["blue-square", "continue", "top", "direction"], char: "\u2B06\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u2B07\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_right: { keywords: ["blue-square", "point", "direction", "diagonal", "northeast"], char: "\u2197\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_right: { keywords: ["blue-square", "direction", "diagonal", "southeast"], char: "\u2198\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_left: { keywords: ["blue-square", "direction", "diagonal", "southwest"], char: "\u2199\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_left: { keywords: ["blue-square", "point", "direction", "diagonal", "northwest"], char: "\u2196\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_down: { keywords: ["blue-square", "direction", "way", "vertical"], char: "\u2195\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, left_right_arrow: { keywords: ["shape", "direction", "horizontal", "sideways"], char: "\u2194\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrows_counterclockwise: { keywords: ["blue-square", "sync", "cycle"], char: "\u{1F504}", fitzpatrick_scale: !1, category: "symbols" }, arrow_right_hook: { keywords: ["blue-square", "return", "rotate", "direction"], char: "\u21AA\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, leftwards_arrow_with_hook: { keywords: ["back", "return", "blue-square", "undo", "enter"], char: "\u21A9\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_up: { keywords: ["blue-square", "direction", "top"], char: "\u2934\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_down: { keywords: ["blue-square", "direction", "bottom"], char: "\u2935\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, hash: { keywords: ["symbol", "blue-square", "twitter"], char: "#\uFE0F\u20E3", fitzpatrick_scale: !1, category: "symbols" }, information_source: { keywords: ["blue-square", "alphabet", "letter"], char: "\u2139\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, abc: { keywords: ["blue-square", "alphabet"], char: "\u{1F524}", fitzpatrick_scale: !1, category: "symbols" }, abcd: { keywords: ["blue-square", "alphabet"], char: "\u{1F521}", fitzpatrick_scale: !1, category: "symbols" }, capital_abcd: { keywords: ["alphabet", "words", "blue-square"], char: "\u{1F520}", fitzpatrick_scale: !1, category: "symbols" }, symbols: { keywords: ["blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters"], char: "\u{1F523}", fitzpatrick_scale: !1, category: "symbols" }, musical_note: { keywords: ["score", "tone", "sound"], char: "\u{1F3B5}", fitzpatrick_scale: !1, category: "symbols" }, notes: { keywords: ["music", "score"], char: "\u{1F3B6}", fitzpatrick_scale: !1, category: "symbols" }, wavy_dash: { keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"], char: "\u3030\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, curly_loop: { keywords: ["scribble", "draw", "shape", "squiggle"], char: "\u27B0", fitzpatrick_scale: !1, category: "symbols" }, heavy_check_mark: { keywords: ["ok", "nike", "answer", "yes", "tick"], char: "\u2714\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, arrows_clockwise: { keywords: ["sync", "cycle", "round", "repeat"], char: "\u{1F503}", fitzpatrick_scale: !1, category: "symbols" }, heavy_plus_sign: { keywords: ["math", "calculation", "addition", "more", "increase"], char: "\u2795", fitzpatrick_scale: !1, category: "symbols" }, heavy_minus_sign: { keywords: ["math", "calculation", "subtract", "less"], char: "\u2796", fitzpatrick_scale: !1, category: "symbols" }, heavy_division_sign: { keywords: ["divide", "math", "calculation"], char: "\u2797", fitzpatrick_scale: !1, category: "symbols" }, heavy_multiplication_x: { keywords: ["math", "calculation"], char: "\u2716\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, infinity: { keywords: ["forever"], char: "\u267E", fitzpatrick_scale: !1, category: "symbols" }, heavy_dollar_sign: { keywords: ["money", "sales", "payment", "currency", "buck"], char: "\u{1F4B2}", fitzpatrick_scale: !1, category: "symbols" }, currency_exchange: { keywords: ["money", "sales", "dollar", "travel"], char: "\u{1F4B1}", fitzpatrick_scale: !1, category: "symbols" }, copyright: { keywords: ["ip", "license", "circle", "law", "legal"], char: "\xA9\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, registered: { keywords: ["alphabet", "circle"], char: "\xAE\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, tm: { keywords: ["trademark", "brand", "law", "legal"], char: "\u2122\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, end: { keywords: ["words", "arrow"], char: "\u{1F51A}", fitzpatrick_scale: !1, category: "symbols" }, back: { keywords: ["arrow", "words", "return"], char: "\u{1F519}", fitzpatrick_scale: !1, category: "symbols" }, on: { keywords: ["arrow", "words"], char: "\u{1F51B}", fitzpatrick_scale: !1, category: "symbols" }, top: { keywords: ["words", "blue-square"], char: "\u{1F51D}", fitzpatrick_scale: !1, category: "symbols" }, soon: { keywords: ["arrow", "words"], char: "\u{1F51C}", fitzpatrick_scale: !1, category: "symbols" }, ballot_box_with_check: { keywords: ["ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick"], char: "\u2611\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, radio_button: { keywords: ["input", "old", "music", "circle"], char: "\u{1F518}", fitzpatrick_scale: !1, category: "symbols" }, white_circle: { keywords: ["shape", "round"], char: "\u26AA", fitzpatrick_scale: !1, category: "symbols" }, black_circle: { keywords: ["shape", "button", "round"], char: "\u26AB", fitzpatrick_scale: !1, category: "symbols" }, red_circle: { keywords: ["shape", "error", "danger"], char: "\u{1F534}", fitzpatrick_scale: !1, category: "symbols" }, large_blue_circle: { keywords: ["shape", "icon", "button"], char: "\u{1F535}", fitzpatrick_scale: !1, category: "symbols" }, small_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F538}", fitzpatrick_scale: !1, category: "symbols" }, small_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F539}", fitzpatrick_scale: !1, category: "symbols" }, large_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F536}", fitzpatrick_scale: !1, category: "symbols" }, large_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "\u{1F537}", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle: { keywords: ["shape", "direction", "up", "top"], char: "\u{1F53A}", fitzpatrick_scale: !1, category: "symbols" }, black_small_square: { keywords: ["shape", "icon"], char: "\u25AA\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, white_small_square: { keywords: ["shape", "icon"], char: "\u25AB\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, black_large_square: { keywords: ["shape", "icon", "button"], char: "\u2B1B", fitzpatrick_scale: !1, category: "symbols" }, white_large_square: { keywords: ["shape", "icon", "stone", "button"], char: "\u2B1C", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle_down: { keywords: ["shape", "direction", "bottom"], char: "\u{1F53B}", fitzpatrick_scale: !1, category: "symbols" }, black_medium_square: { keywords: ["shape", "button", "icon"], char: "\u25FC\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, white_medium_square: { keywords: ["shape", "stone", "icon"], char: "\u25FB\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, black_medium_small_square: { keywords: ["icon", "shape", "button"], char: "\u25FE", fitzpatrick_scale: !1, category: "symbols" }, white_medium_small_square: { keywords: ["shape", "stone", "icon", "button"], char: "\u25FD", fitzpatrick_scale: !1, category: "symbols" }, black_square_button: { keywords: ["shape", "input", "frame"], char: "\u{1F532}", fitzpatrick_scale: !1, category: "symbols" }, white_square_button: { keywords: ["shape", "input"], char: "\u{1F533}", fitzpatrick_scale: !1, category: "symbols" }, speaker: { keywords: ["sound", "volume", "silence", "broadcast"], char: "\u{1F508}", fitzpatrick_scale: !1, category: "symbols" }, sound: { keywords: ["volume", "speaker", "broadcast"], char: "\u{1F509}", fitzpatrick_scale: !1, category: "symbols" }, loud_sound: { keywords: ["volume", "noise", "noisy", "speaker", "broadcast"], char: "\u{1F50A}", fitzpatrick_scale: !1, category: "symbols" }, mute: { keywords: ["sound", "volume", "silence", "quiet"], char: "\u{1F507}", fitzpatrick_scale: !1, category: "symbols" }, mega: { keywords: ["sound", "speaker", "volume"], char: "\u{1F4E3}", fitzpatrick_scale: !1, category: "symbols" }, loudspeaker: { keywords: ["volume", "sound"], char: "\u{1F4E2}", fitzpatrick_scale: !1, category: "symbols" }, bell: { keywords: ["sound", "notification", "christmas", "xmas", "chime"], char: "\u{1F514}", fitzpatrick_scale: !1, category: "symbols" }, no_bell: { keywords: ["sound", "volume", "mute", "quiet", "silent"], char: "\u{1F515}", fitzpatrick_scale: !1, category: "symbols" }, black_joker: { keywords: ["poker", "cards", "game", "play", "magic"], char: "\u{1F0CF}", fitzpatrick_scale: !1, category: "symbols" }, mahjong: { keywords: ["game", "play", "chinese", "kanji"], char: "\u{1F004}", fitzpatrick_scale: !1, category: "symbols" }, spades: { keywords: ["poker", "cards", "suits", "magic"], char: "\u2660\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, clubs: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2663\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, hearts: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2665\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, diamonds: { keywords: ["poker", "cards", "magic", "suits"], char: "\u2666\uFE0F", fitzpatrick_scale: !1, category: "symbols" }, flower_playing_cards: { keywords: ["game", "sunset", "red"], char: "\u{1F3B4}", fitzpatrick_scale: !1, category: "symbols" }, thought_balloon: { keywords: ["bubble", "cloud", "speech", "thinking", "dream"], char: "\u{1F4AD}", fitzpatrick_scale: !1, category: "symbols" }, right_anger_bubble: { keywords: ["caption", "speech", "thinking", "mad"], char: "\u{1F5EF}", fitzpatrick_scale: !1, category: "symbols" }, speech_balloon: { keywords: ["bubble", "words", "message", "talk", "chatting"], char: "\u{1F4AC}", fitzpatrick_scale: !1, category: "symbols" }, left_speech_bubble: { keywords: ["words", "message", "talk", "chatting"], char: "\u{1F5E8}", fitzpatrick_scale: !1, category: "symbols" }, clock1: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F550}", fitzpatrick_scale: !1, category: "symbols" }, clock2: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F551}", fitzpatrick_scale: !1, category: "symbols" }, clock3: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F552}", fitzpatrick_scale: !1, category: "symbols" }, clock4: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F553}", fitzpatrick_scale: !1, category: "symbols" }, clock5: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F554}", fitzpatrick_scale: !1, category: "symbols" }, clock6: { keywords: ["time", "late", "early", "schedule", "dawn", "dusk"], char: "\u{1F555}", fitzpatrick_scale: !1, category: "symbols" }, clock7: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F556}", fitzpatrick_scale: !1, category: "symbols" }, clock8: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F557}", fitzpatrick_scale: !1, category: "symbols" }, clock9: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F558}", fitzpatrick_scale: !1, category: "symbols" }, clock10: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F559}", fitzpatrick_scale: !1, category: "symbols" }, clock11: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55A}", fitzpatrick_scale: !1, category: "symbols" }, clock12: { keywords: ["time", "noon", "midnight", "midday", "late", "early", "schedule"], char: "\u{1F55B}", fitzpatrick_scale: !1, category: "symbols" }, clock130: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55C}", fitzpatrick_scale: !1, category: "symbols" }, clock230: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55D}", fitzpatrick_scale: !1, category: "symbols" }, clock330: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55E}", fitzpatrick_scale: !1, category: "symbols" }, clock430: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F55F}", fitzpatrick_scale: !1, category: "symbols" }, clock530: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F560}", fitzpatrick_scale: !1, category: "symbols" }, clock630: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F561}", fitzpatrick_scale: !1, category: "symbols" }, clock730: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F562}", fitzpatrick_scale: !1, category: "symbols" }, clock830: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F563}", fitzpatrick_scale: !1, category: "symbols" }, clock930: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F564}", fitzpatrick_scale: !1, category: "symbols" }, clock1030: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F565}", fitzpatrick_scale: !1, category: "symbols" }, clock1130: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F566}", fitzpatrick_scale: !1, category: "symbols" }, clock1230: { keywords: ["time", "late", "early", "schedule"], char: "\u{1F567}", fitzpatrick_scale: !1, category: "symbols" }, afghanistan: { keywords: ["af", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, aland_islands: { keywords: ["\xC5land", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, albania: { keywords: ["al", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, algeria: { keywords: ["dz", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, american_samoa: { keywords: ["american", "ws", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, andorra: { keywords: ["ad", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, angola: { keywords: ["ao", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, anguilla: { keywords: ["ai", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, antarctica: { keywords: ["aq", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, antigua_barbuda: { keywords: ["antigua", "barbuda", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, argentina: { keywords: ["ar", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, armenia: { keywords: ["am", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, aruba: { keywords: ["aw", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, australia: { keywords: ["au", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, austria: { keywords: ["at", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, azerbaijan: { keywords: ["az", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, bahamas: { keywords: ["bs", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, bahrain: { keywords: ["bh", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, bangladesh: { keywords: ["bd", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, barbados: { keywords: ["bb", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, belarus: { keywords: ["by", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, belgium: { keywords: ["be", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, belize: { keywords: ["bz", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, benin: { keywords: ["bj", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, bermuda: { keywords: ["bm", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, bhutan: { keywords: ["bt", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, bolivia: { keywords: ["bo", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, caribbean_netherlands: { keywords: ["bonaire", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, bosnia_herzegovina: { keywords: ["bosnia", "herzegovina", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, botswana: { keywords: ["bw", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, brazil: { keywords: ["br", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, british_indian_ocean_territory: { keywords: ["british", "indian", "ocean", "territory", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, british_virgin_islands: { keywords: ["british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, brunei: { keywords: ["bn", "darussalam", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, bulgaria: { keywords: ["bg", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, burkina_faso: { keywords: ["burkina", "faso", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, burundi: { keywords: ["bi", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, cape_verde: { keywords: ["cabo", "verde", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, cambodia: { keywords: ["kh", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, cameroon: { keywords: ["cm", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, canada: { keywords: ["ca", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, canary_islands: { keywords: ["canary", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, cayman_islands: { keywords: ["cayman", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, central_african_republic: { keywords: ["central", "african", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, chad: { keywords: ["td", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, chile: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, cn: { keywords: ["china", "chinese", "prc", "flag", "country", "nation", "banner"], char: "\u{1F1E8}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, christmas_island: { keywords: ["christmas", "island", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, cocos_islands: { keywords: ["cocos", "keeling", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, colombia: { keywords: ["co", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, comoros: { keywords: ["km", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, congo_brazzaville: { keywords: ["congo", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, congo_kinshasa: { keywords: ["congo", "democratic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, cook_islands: { keywords: ["cook", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, costa_rica: { keywords: ["costa", "rica", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, croatia: { keywords: ["hr", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, cuba: { keywords: ["cu", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, curacao: { keywords: ["cura\xE7ao", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, cyprus: { keywords: ["cy", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, czech_republic: { keywords: ["cz", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, denmark: { keywords: ["dk", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, djibouti: { keywords: ["dj", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, dominica: { keywords: ["dm", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, dominican_republic: { keywords: ["dominican", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1E9}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, ecuador: { keywords: ["ec", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, egypt: { keywords: ["eg", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, el_salvador: { keywords: ["el", "salvador", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, equatorial_guinea: { keywords: ["equatorial", "gn", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, eritrea: { keywords: ["er", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, estonia: { keywords: ["ee", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, ethiopia: { keywords: ["et", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, eu: { keywords: ["european", "union", "flag", "banner"], char: "\u{1F1EA}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, falkland_islands: { keywords: ["falkland", "islands", "malvinas", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, faroe_islands: { keywords: ["faroe", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, fiji: { keywords: ["fj", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, finland: { keywords: ["fi", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, fr: { keywords: ["banner", "flag", "nation", "france", "french", "country"], char: "\u{1F1EB}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, french_guiana: { keywords: ["french", "guiana", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, french_polynesia: { keywords: ["french", "polynesia", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, french_southern_territories: { keywords: ["french", "southern", "territories", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, gabon: { keywords: ["ga", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, gambia: { keywords: ["gm", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, georgia: { keywords: ["ge", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, de: { keywords: ["german", "nation", "flag", "country", "banner"], char: "\u{1F1E9}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, ghana: { keywords: ["gh", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, gibraltar: { keywords: ["gi", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, greece: { keywords: ["gr", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, greenland: { keywords: ["gl", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, grenada: { keywords: ["gd", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, guadeloupe: { keywords: ["gp", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, guam: { keywords: ["gu", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, guatemala: { keywords: ["gt", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, guernsey: { keywords: ["gg", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, guinea: { keywords: ["gn", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, guinea_bissau: { keywords: ["gw", "bissau", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, guyana: { keywords: ["gy", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, haiti: { keywords: ["ht", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, honduras: { keywords: ["hn", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, hong_kong: { keywords: ["hong", "kong", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, hungary: { keywords: ["hu", "flag", "nation", "country", "banner"], char: "\u{1F1ED}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, iceland: { keywords: ["is", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, india: { keywords: ["in", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, indonesia: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, iran: { keywords: ["iran,", "islamic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, iraq: { keywords: ["iq", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, ireland: { keywords: ["ie", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, isle_of_man: { keywords: ["isle", "man", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, israel: { keywords: ["il", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, it: { keywords: ["italy", "flag", "nation", "country", "banner"], char: "\u{1F1EE}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, cote_divoire: { keywords: ["ivory", "coast", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, jamaica: { keywords: ["jm", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, jp: { keywords: ["japanese", "nation", "flag", "country", "banner"], char: "\u{1F1EF}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, jersey: { keywords: ["je", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, jordan: { keywords: ["jo", "flag", "nation", "country", "banner"], char: "\u{1F1EF}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, kazakhstan: { keywords: ["kz", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, kenya: { keywords: ["ke", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, kiribati: { keywords: ["ki", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, kosovo: { keywords: ["xk", "flag", "nation", "country", "banner"], char: "\u{1F1FD}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, kuwait: { keywords: ["kw", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, kyrgyzstan: { keywords: ["kg", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, laos: { keywords: ["lao", "democratic", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, latvia: { keywords: ["lv", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, lebanon: { keywords: ["lb", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, lesotho: { keywords: ["ls", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, liberia: { keywords: ["lr", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, libya: { keywords: ["ly", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, liechtenstein: { keywords: ["li", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, lithuania: { keywords: ["lt", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, luxembourg: { keywords: ["lu", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, macau: { keywords: ["macao", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, macedonia: { keywords: ["macedonia,", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, madagascar: { keywords: ["mg", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, malawi: { keywords: ["mw", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, malaysia: { keywords: ["my", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, maldives: { keywords: ["mv", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, mali: { keywords: ["ml", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, malta: { keywords: ["mt", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, marshall_islands: { keywords: ["marshall", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, martinique: { keywords: ["mq", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F6}", fitzpatrick_scale: !1, category: "flags" }, mauritania: { keywords: ["mr", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, mauritius: { keywords: ["mu", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, mayotte: { keywords: ["yt", "flag", "nation", "country", "banner"], char: "\u{1F1FE}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, mexico: { keywords: ["mx", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, micronesia: { keywords: ["micronesia,", "federated", "states", "flag", "nation", "country", "banner"], char: "\u{1F1EB}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, moldova: { keywords: ["moldova,", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, monaco: { keywords: ["mc", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, mongolia: { keywords: ["mn", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, montenegro: { keywords: ["me", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, montserrat: { keywords: ["ms", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, morocco: { keywords: ["ma", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, mozambique: { keywords: ["mz", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, myanmar: { keywords: ["mm", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, namibia: { keywords: ["na", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, nauru: { keywords: ["nr", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, nepal: { keywords: ["np", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, netherlands: { keywords: ["nl", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, new_caledonia: { keywords: ["new", "caledonia", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, new_zealand: { keywords: ["new", "zealand", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, nicaragua: { keywords: ["ni", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, niger: { keywords: ["ne", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, nigeria: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, niue: { keywords: ["nu", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, norfolk_island: { keywords: ["norfolk", "island", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, northern_mariana_islands: { keywords: ["northern", "mariana", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F2}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, north_korea: { keywords: ["north", "korea", "nation", "flag", "country", "banner"], char: "\u{1F1F0}\u{1F1F5}", fitzpatrick_scale: !1, category: "flags" }, norway: { keywords: ["no", "flag", "nation", "country", "banner"], char: "\u{1F1F3}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, oman: { keywords: ["om_symbol", "flag", "nation", "country", "banner"], char: "\u{1F1F4}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, pakistan: { keywords: ["pk", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, palau: { keywords: ["pw", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, palestinian_territories: { keywords: ["palestine", "palestinian", "territories", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, panama: { keywords: ["pa", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, papua_new_guinea: { keywords: ["papua", "new", "guinea", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, paraguay: { keywords: ["py", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, peru: { keywords: ["pe", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, philippines: { keywords: ["ph", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, pitcairn_islands: { keywords: ["pitcairn", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, poland: { keywords: ["pl", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, portugal: { keywords: ["pt", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, puerto_rico: { keywords: ["puerto", "rico", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, qatar: { keywords: ["qa", "flag", "nation", "country", "banner"], char: "\u{1F1F6}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, reunion: { keywords: ["r\xE9union", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, romania: { keywords: ["ro", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, ru: { keywords: ["russian", "federation", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, rwanda: { keywords: ["rw", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, st_barthelemy: { keywords: ["saint", "barth\xE9lemy", "flag", "nation", "country", "banner"], char: "\u{1F1E7}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, st_helena: { keywords: ["saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, st_kitts_nevis: { keywords: ["saint", "kitts", "nevis", "flag", "nation", "country", "banner"], char: "\u{1F1F0}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, st_lucia: { keywords: ["saint", "lucia", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, st_pierre_miquelon: { keywords: ["saint", "pierre", "miquelon", "flag", "nation", "country", "banner"], char: "\u{1F1F5}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, st_vincent_grenadines: { keywords: ["saint", "vincent", "grenadines", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, samoa: { keywords: ["ws", "flag", "nation", "country", "banner"], char: "\u{1F1FC}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, san_marino: { keywords: ["san", "marino", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, sao_tome_principe: { keywords: ["sao", "tome", "principe", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, saudi_arabia: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, senegal: { keywords: ["sn", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, serbia: { keywords: ["rs", "flag", "nation", "country", "banner"], char: "\u{1F1F7}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, seychelles: { keywords: ["sc", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, sierra_leone: { keywords: ["sierra", "leone", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, singapore: { keywords: ["sg", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, sint_maarten: { keywords: ["sint", "maarten", "dutch", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FD}", fitzpatrick_scale: !1, category: "flags" }, slovakia: { keywords: ["sk", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, slovenia: { keywords: ["si", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, solomon_islands: { keywords: ["solomon", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, somalia: { keywords: ["so", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, south_africa: { keywords: ["south", "africa", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, south_georgia_south_sandwich_islands: { keywords: ["south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1EC}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, kr: { keywords: ["south", "korea", "nation", "flag", "country", "banner"], char: "\u{1F1F0}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, south_sudan: { keywords: ["south", "sd", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, es: { keywords: ["spain", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, sri_lanka: { keywords: ["sri", "lanka", "flag", "nation", "country", "banner"], char: "\u{1F1F1}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, sudan: { keywords: ["sd", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1E9}", fitzpatrick_scale: !1, category: "flags" }, suriname: { keywords: ["sr", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, swaziland: { keywords: ["sz", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, sweden: { keywords: ["se", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, switzerland: { keywords: ["ch", "flag", "nation", "country", "banner"], char: "\u{1F1E8}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, syria: { keywords: ["syrian", "arab", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F8}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, taiwan: { keywords: ["tw", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, tajikistan: { keywords: ["tj", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EF}", fitzpatrick_scale: !1, category: "flags" }, tanzania: { keywords: ["tanzania,", "united", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, thailand: { keywords: ["th", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, timor_leste: { keywords: ["timor", "leste", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F1}", fitzpatrick_scale: !1, category: "flags" }, togo: { keywords: ["tg", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, tokelau: { keywords: ["tk", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F0}", fitzpatrick_scale: !1, category: "flags" }, tonga: { keywords: ["to", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F4}", fitzpatrick_scale: !1, category: "flags" }, trinidad_tobago: { keywords: ["trinidad", "tobago", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F9}", fitzpatrick_scale: !1, category: "flags" }, tunisia: { keywords: ["tn", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, tr: { keywords: ["turkey", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F7}", fitzpatrick_scale: !1, category: "flags" }, turkmenistan: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, turks_caicos_islands: { keywords: ["turks", "caicos", "islands", "flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1E8}", fitzpatrick_scale: !1, category: "flags" }, tuvalu: { keywords: ["flag", "nation", "country", "banner"], char: "\u{1F1F9}\u{1F1FB}", fitzpatrick_scale: !1, category: "flags" }, uganda: { keywords: ["ug", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1EC}", fitzpatrick_scale: !1, category: "flags" }, ukraine: { keywords: ["ua", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, united_arab_emirates: { keywords: ["united", "arab", "emirates", "flag", "nation", "country", "banner"], char: "\u{1F1E6}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, uk: { keywords: ["united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack"], char: "\u{1F1EC}\u{1F1E7}", fitzpatrick_scale: !1, category: "flags" }, england: { keywords: ["flag", "english"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, scotland: { keywords: ["flag", "scottish"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, wales: { keywords: ["flag", "welsh"], char: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}", fitzpatrick_scale: !1, category: "flags" }, us: { keywords: ["united", "states", "america", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1F8}", fitzpatrick_scale: !1, category: "flags" }, us_virgin_islands: { keywords: ["virgin", "islands", "us", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EE}", fitzpatrick_scale: !1, category: "flags" }, uruguay: { keywords: ["uy", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1FE}", fitzpatrick_scale: !1, category: "flags" }, uzbekistan: { keywords: ["uz", "flag", "nation", "country", "banner"], char: "\u{1F1FA}\u{1F1FF}", fitzpatrick_scale: !1, category: "flags" }, vanuatu: { keywords: ["vu", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1FA}", fitzpatrick_scale: !1, category: "flags" }, vatican_city: { keywords: ["vatican", "city", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1E6}", fitzpatrick_scale: !1, category: "flags" }, venezuela: { keywords: ["ve", "bolivarian", "republic", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, vietnam: { keywords: ["viet", "nam", "flag", "nation", "country", "banner"], char: "\u{1F1FB}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, wallis_futuna: { keywords: ["wallis", "futuna", "flag", "nation", "country", "banner"], char: "\u{1F1FC}\u{1F1EB}", fitzpatrick_scale: !1, category: "flags" }, western_sahara: { keywords: ["western", "sahara", "flag", "nation", "country", "banner"], char: "\u{1F1EA}\u{1F1ED}", fitzpatrick_scale: !1, category: "flags" }, yemen: { keywords: ["ye", "flag", "nation", "country", "banner"], char: "\u{1F1FE}\u{1F1EA}", fitzpatrick_scale: !1, category: "flags" }, zambia: { keywords: ["zm", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1F2}", fitzpatrick_scale: !1, category: "flags" }, zimbabwe: { keywords: ["zw", "flag", "nation", "country", "banner"], char: "\u{1F1FF}\u{1F1FC}", fitzpatrick_scale: !1, category: "flags" }, united_nations: { keywords: ["un", "flag", "banner"], char: "\u{1F1FA}\u{1F1F3}", fitzpatrick_scale: !1, category: "flags" }, pirate_flag: { keywords: ["skull", "crossbones", "flag", "banner"], char: "\u{1F3F4}\u200D\u2620\uFE0F", fitzpatrick_scale: !1, category: "flags" } });
var ZH = function(ns) {
  HH(To, ns);
  function To() {
    var Eo = ns !== null && ns.apply(this, arguments) || this;
    return Eo.elementRef = mH.createRef(), Eo;
  }
  return To.prototype.componentDidMount = function() {
    var Eo = this, In = this.props.locale;
    this.config = fH(fH({
      inline: !1,
      skin: !1,
      content_css: !1,
      height: 400,
      language: !In || In === "zh-CN" ? "zh_CN" : "en",
      branding: !1,
      plugins: ["advlist", "autolink", "link", "image", "lists", "charmap", "preview", "anchor", "pagebreak", "searchreplace", "wordcount", "visualblocks", "visualchars", "code", "fullscreen", "insertdatetime", "media", "nonbreaking", "table", "emoticons", "template", "help"],
      toolbar: "undo redo | blocks | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image | preview media | fontfamily fontsize forecolor backcolor emoticons | print help",
      menu: {
        file: {
          title: "File",
          items: "newdocument restoredraft | preview | print "
        },
        edit: {
          title: "Edit",
          items: "undo redo | cut copy paste | selectall | searchreplace"
        },
        view: {
          title: "View",
          items: "code | visualaid visualchars visualblocks | preview fullscreen"
        },
        insert: {
          title: "Insert",
          items: "image link media template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime"
        },
        format: {
          title: "Format",
          items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontsize align | forecolor backcolor | removeformat"
        },
        tools: {
          title: "Tools",
          items: "code wordcount"
        },
        table: {
          title: "Table",
          items: "inserttable | cell row column | tableprops deletetable"
        },
        help: {
          title: "Help",
          items: "help"
        }
      },
      paste_data_images: !0
    }, this.props.config), {
      target: this.elementRef.current,
      readOnly: this.props.disabled,
      setup: function(Jn) {
        Eo.editor = Jn, Jn.on("init", function(uo) {
          Eo.initEditor(uo, Jn);
        });
      }
    }), JI.init(this.config);
  }, To.prototype.componentDidUpdate = function(Eo) {
    var In, Jn = this.props;
    Jn.model !== Eo.model && Jn.model !== this.currentContent && ((In = this.editor) === null || In === void 0 || In.setContent(Jn.model || ""));
  }, To.prototype.componentWillUnmount = function() {
    JI.remove(this.editor);
  }, To.prototype.initEditor = function(Eo, In) {
    var Jn = this, uo = this.props, ho = uo.model, Kt = uo.onModelChange, Bt = uo.outputFormat, $t = uo.onFocus, Un = uo.onBlur, Ao = ho || "";
    In.setContent(Ao), Kt && In.on("change keyup setcontent", function(tn) {
      var mt = In.getContent({
        format: Bt
      });
      mt !== Jn.currentContent && (Jn.currentContent = mt, Kt(mt));
    }), $t && In.on("focus", $t), Un && In.on("blur", Un);
  }, To.prototype.render = function() {
    return /* @__PURE__ */ VH("textarea", {
      ref: this.elementRef
    });
  }, To.defaultProps = {
    outputFormat: "html"
  }, To;
}(mH.Component);
JI.addI18n("zh_CN", {
  Redo: "\u91CD\u505A",
  Undo: "\u64A4\u9500",
  Cut: "\u526A\u5207",
  Copy: "\u590D\u5236",
  Paste: "\u7C98\u8D34",
  "Select all": "\u5168\u9009",
  "New document": "\u65B0\u6587\u4EF6",
  Ok: "\u786E\u5B9A",
  Cancel: "\u53D6\u6D88",
  "Visual aids": "\u7F51\u683C\u7EBF",
  Bold: "\u7C97\u4F53",
  Italic: "\u659C\u4F53",
  Underline: "\u4E0B\u5212\u7EBF",
  Strikethrough: "\u5220\u9664\u7EBF",
  Superscript: "\u4E0A\u6807",
  Subscript: "\u4E0B\u6807",
  "Clear formatting": "\u6E05\u9664\u683C\u5F0F",
  "Align left": "\u5DE6\u8FB9\u5BF9\u9F50",
  "Align center": "\u4E2D\u95F4\u5BF9\u9F50",
  "Align right": "\u53F3\u8FB9\u5BF9\u9F50",
  Justify: "\u4E24\u7AEF\u5BF9\u9F50",
  "Bullet list": "\u9879\u76EE\u7B26\u53F7",
  "Numbered list": "\u7F16\u53F7\u5217\u8868",
  "Decrease indent": "\u51CF\u5C11\u7F29\u8FDB",
  "Increase indent": "\u589E\u52A0\u7F29\u8FDB",
  Close: "\u5173\u95ED",
  Formats: "\u683C\u5F0F",
  "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": "\u4F60\u7684\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u6253\u5F00\u526A\u8D34\u677F\uFF0C\u8BF7\u4F7F\u7528Ctrl+X/C/V\u7B49\u5FEB\u6377\u952E\u3002",
  Headers: "\u6807\u9898",
  "Header 1": "\u6807\u98981",
  "Header 2": "\u6807\u98982",
  "Header 3": "\u6807\u98983",
  "Header 4": "\u6807\u98984",
  "Header 5": "\u6807\u98985",
  "Header 6": "\u6807\u98986",
  Headings: "\u6807\u9898",
  "Heading 1": "\u6807\u98981",
  "Heading 2": "\u6807\u98982",
  "Heading 3": "\u6807\u98983",
  "Heading 4": "\u6807\u98984",
  "Heading 5": "\u6807\u98985",
  "Heading 6": "\u6807\u98986",
  Preformatted: "\u9884\u5148\u683C\u5F0F\u5316\u7684",
  Div: "Div",
  Pre: "Pre",
  Code: "\u4EE3\u7801",
  Paragraph: "\u6BB5\u843D",
  Blockquote: "\u5F15\u6587\u533A\u5757",
  Inline: "\u6587\u672C",
  Blocks: "\u57FA\u5757",
  "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "\u5F53\u524D\u4E3A\u7EAF\u6587\u672C\u7C98\u8D34\u6A21\u5F0F\uFF0C\u518D\u6B21\u70B9\u51FB\u53EF\u4EE5\u56DE\u5230\u666E\u901A\u7C98\u8D34\u6A21\u5F0F\u3002",
  Fonts: "\u5B57\u4F53",
  "Font Sizes": "\u5B57\u53F7",
  Class: "\u7C7B\u578B",
  "Browse for an image": "\u6D4F\u89C8\u56FE\u50CF",
  OR: "\u6216",
  "Drop an image here": "\u62D6\u653E\u4E00\u5F20\u56FE\u50CF\u81F3\u6B64",
  Upload: "\u4E0A\u4F20",
  Block: "\u5757",
  Align: "\u5BF9\u9F50",
  Default: "\u9ED8\u8BA4",
  Circle: "\u7A7A\u5FC3\u5706",
  Disc: "\u5B9E\u5FC3\u5706",
  Square: "\u65B9\u5757",
  "Lower Alpha": "\u5C0F\u5199\u82F1\u6587\u5B57\u6BCD",
  "Lower Greek": "\u5C0F\u5199\u5E0C\u814A\u5B57\u6BCD",
  "Lower Roman": "\u5C0F\u5199\u7F57\u9A6C\u5B57\u6BCD",
  "Upper Alpha": "\u5927\u5199\u82F1\u6587\u5B57\u6BCD",
  "Upper Roman": "\u5927\u5199\u7F57\u9A6C\u5B57\u6BCD",
  "Anchor...": "\u951A\u70B9...",
  Name: "\u540D\u79F0",
  Id: "\u6807\u8BC6\u7B26",
  "Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "\u6807\u8BC6\u7B26\u5E94\u8BE5\u4EE5\u5B57\u6BCD\u5F00\u5934\uFF0C\u540E\u8DDF\u5B57\u6BCD\u3001\u6570\u5B57\u3001\u7834\u6298\u53F7\u3001\u70B9\u3001\u5192\u53F7\u6216\u4E0B\u5212\u7EBF\u3002",
  "You have unsaved changes are you sure you want to navigate away?": "\u4F60\u8FD8\u6709\u6587\u6863\u5C1A\u672A\u4FDD\u5B58\uFF0C\u786E\u5B9A\u8981\u79BB\u5F00\uFF1F",
  "Restore last draft": "\u6062\u590D\u4E0A\u6B21\u7684\u8349\u7A3F",
  "Special character...": "\u7279\u6B8A\u5B57\u7B26...",
  "Source code": "\u6E90\u4EE3\u7801",
  "Insert/Edit code sample": "\u63D2\u5165/\u7F16\u8F91\u4EE3\u7801\u793A\u4F8B",
  Language: "\u8BED\u8A00",
  "Code sample...": "\u793A\u4F8B\u4EE3\u7801...",
  "Color Picker": "\u9009\u8272\u5668",
  R: "R",
  G: "G",
  B: "B",
  "Left to right": "\u4ECE\u5DE6\u5230\u53F3",
  "Right to left": "\u4ECE\u53F3\u5230\u5DE6",
  "Emoticons...": "\u8868\u60C5\u7B26\u53F7...",
  "Metadata and Document Properties": "\u5143\u6570\u636E\u548C\u6587\u6863\u5C5E\u6027",
  Title: "\u6807\u9898",
  Keywords: "\u5173\u952E\u8BCD",
  Description: "\u63CF\u8FF0",
  Robots: "\u673A\u5668\u4EBA",
  Author: "\u4F5C\u8005",
  Encoding: "\u7F16\u7801",
  Fullscreen: "\u5168\u5C4F",
  Action: "\u64CD\u4F5C",
  Shortcut: "\u5FEB\u6377\u952E",
  Help: "\u5E2E\u52A9",
  Address: "\u5730\u5740",
  "Focus to menubar": "\u79FB\u52A8\u7126\u70B9\u5230\u83DC\u5355\u680F",
  "Focus to toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u5DE5\u5177\u680F",
  "Focus to element path": "\u79FB\u52A8\u7126\u70B9\u5230\u5143\u7D20\u8DEF\u5F84",
  "Focus to contextual toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u4E0A\u4E0B\u6587\u83DC\u5355",
  "Insert link (if link plugin activated)": "\u63D2\u5165\u94FE\u63A5 (\u5982\u679C\u94FE\u63A5\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Save (if save plugin activated)": "\u4FDD\u5B58(\u5982\u679C\u4FDD\u5B58\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Find (if searchreplace plugin activated)": "\u67E5\u627E(\u5982\u679C\u67E5\u627E\u66FF\u6362\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Plugins installed ({0}):": "\u5DF2\u5B89\u88C5\u63D2\u4EF6 ({0}):",
  "Premium plugins:": "\u4F18\u79C0\u63D2\u4EF6\uFF1A",
  "Learn more...": "\u4E86\u89E3\u66F4\u591A...",
  "You are using {0}": "\u4F60\u6B63\u5728\u4F7F\u7528 {0}",
  Plugins: "\u63D2\u4EF6",
  "Handy Shortcuts": "\u5FEB\u6377\u952E",
  "Horizontal line": "\u6C34\u5E73\u5206\u5272\u7EBF",
  "Insert/edit image": "\u63D2\u5165/\u7F16\u8F91\u56FE\u7247",
  "Image description": "\u56FE\u7247\u63CF\u8FF0",
  Source: "\u5730\u5740",
  Dimensions: "\u5927\u5C0F",
  "Constrain proportions": "\u4FDD\u6301\u7EB5\u6A2A\u6BD4",
  General: "\u666E\u901A",
  Advanced: "\u9AD8\u7EA7",
  Style: "\u6837\u5F0F",
  "Vertical space": "\u5782\u76F4\u8FB9\u8DDD",
  "Horizontal space": "\u6C34\u5E73\u8FB9\u8DDD",
  Border: "\u8FB9\u6846",
  "Insert image": "\u63D2\u5165\u56FE\u7247",
  "Image...": "\u56FE\u7247...",
  "Image list": "\u56FE\u7247\u5217\u8868",
  "Rotate counterclockwise": "\u9006\u65F6\u9488\u65CB\u8F6C",
  "Rotate clockwise": "\u987A\u65F6\u9488\u65CB\u8F6C",
  "Flip vertically": "\u5782\u76F4\u7FFB\u8F6C",
  "Flip horizontally": "\u6C34\u5E73\u7FFB\u8F6C",
  "Edit image": "\u7F16\u8F91\u56FE\u7247",
  "Image options": "\u56FE\u7247\u9009\u9879",
  "Zoom in": "\u653E\u5927",
  "Zoom out": "\u7F29\u5C0F",
  Crop: "\u88C1\u526A",
  Resize: "\u8C03\u6574\u5927\u5C0F",
  Orientation: "\u65B9\u5411",
  Brightness: "\u4EAE\u5EA6",
  Sharpen: "\u9510\u5316",
  Contrast: "\u5BF9\u6BD4\u5EA6",
  "Color levels": "\u989C\u8272\u5C42\u6B21",
  Gamma: "\u4F3D\u9A6C\u503C",
  Invert: "\u53CD\u8F6C",
  Apply: "\u5E94\u7528",
  Back: "\u540E\u9000",
  "Insert date/time": "\u63D2\u5165\u65E5\u671F/\u65F6\u95F4",
  "Date/time": "\u65E5\u671F/\u65F6\u95F4",
  "Insert/Edit Link": "\u63D2\u5165/\u7F16\u8F91\u94FE\u63A5",
  "Insert/edit link": "\u63D2\u5165/\u7F16\u8F91\u94FE\u63A5",
  "Text to display": "\u663E\u793A\u6587\u5B57",
  Url: "\u5730\u5740",
  "Open link in...": "\u94FE\u63A5\u6253\u5F00\u4F4D\u7F6E...",
  "Current window": "\u5F53\u524D\u7A97\u53E3",
  None: "\u65E0",
  "New window": "\u5728\u65B0\u7A97\u53E3\u6253\u5F00",
  "Remove link": "\u5220\u9664\u94FE\u63A5",
  Anchors: "\u951A\u70B9",
  "Link...": "\u94FE\u63A5...",
  "Paste or type a link": "\u7C98\u8D34\u6216\u8F93\u5165\u94FE\u63A5",
  "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u4E3A\u90AE\u4EF6\u5730\u5740\uFF0C\u9700\u8981\u52A0\u4E0Amailto:\u524D\u7F00\u5417\uFF1F",
  "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u5C5E\u4E8E\u5916\u90E8\u94FE\u63A5\uFF0C\u9700\u8981\u52A0\u4E0Ahttp://:\u524D\u7F00\u5417\uFF1F",
  "Link list": "\u94FE\u63A5\u5217\u8868",
  "Insert video": "\u63D2\u5165\u89C6\u9891",
  "Insert/edit video": "\u63D2\u5165/\u7F16\u8F91\u89C6\u9891",
  "Insert/edit media": "\u63D2\u5165/\u7F16\u8F91\u5A92\u4F53",
  "Alternative source": "\u955C\u50CF",
  "Alternative source URL": "\u66FF\u4EE3\u6765\u6E90\u7F51\u5740",
  "Media poster (Image URL)": "\u5C01\u9762(\u56FE\u7247\u5730\u5740)",
  "Paste your embed code below:": "\u5C06\u5185\u5D4C\u4EE3\u7801\u7C98\u8D34\u5728\u4E0B\u9762:",
  Embed: "\u5185\u5D4C",
  "Media...": "\u591A\u5A92\u4F53...",
  "Nonbreaking space": "\u4E0D\u95F4\u65AD\u7A7A\u683C",
  "Page break": "\u5206\u9875\u7B26",
  "Paste as text": "\u7C98\u8D34\u4E3A\u6587\u672C",
  Preview: "\u9884\u89C8",
  "Print...": "\u6253\u5370...",
  Save: "\u4FDD\u5B58",
  Find: "\u67E5\u627E",
  "Replace with": "\u66FF\u6362\u4E3A",
  Replace: "\u66FF\u6362",
  "Replace all": "\u5168\u90E8\u66FF\u6362",
  Previous: "\u4E0A\u4E00\u4E2A",
  Next: "\u4E0B\u4E00\u4E2A",
  "Find and replace...": "\u67E5\u627E\u5E76\u66FF\u6362...",
  "Could not find the specified string.": "\u672A\u627E\u5230\u641C\u7D22\u5185\u5BB9.",
  "Match case": "\u533A\u5206\u5927\u5C0F\u5199",
  "Find whole words only": "\u5168\u5B57\u5339\u914D",
  "Spell check": "\u62FC\u5199\u68C0\u67E5",
  Ignore: "\u5FFD\u7565",
  "Ignore all": "\u5168\u90E8\u5FFD\u7565",
  Finish: "\u5B8C\u6210",
  "Add to Dictionary": "\u6DFB\u52A0\u5230\u5B57\u5178",
  "Insert table": "\u63D2\u5165\u8868\u683C",
  "Table properties": "\u8868\u683C\u5C5E\u6027",
  "Delete table": "\u5220\u9664\u8868\u683C",
  Cell: "\u5355\u5143\u683C",
  Row: "\u884C",
  Column: "\u5217",
  "Cell properties": "\u5355\u5143\u683C\u5C5E\u6027",
  "Merge cells": "\u5408\u5E76\u5355\u5143\u683C",
  "Split cell": "\u62C6\u5206\u5355\u5143\u683C",
  "Insert row before": "\u5728\u4E0A\u65B9\u63D2\u5165",
  "Insert row after": "\u5728\u4E0B\u65B9\u63D2\u5165",
  "Delete row": "\u5220\u9664\u884C",
  "Row properties": "\u884C\u5C5E\u6027",
  "Cut row": "\u526A\u5207\u884C",
  "Copy row": "\u590D\u5236\u884C",
  "Paste row before": "\u7C98\u8D34\u5230\u4E0A\u65B9",
  "Paste row after": "\u7C98\u8D34\u5230\u4E0B\u65B9",
  "Insert column before": "\u5728\u5DE6\u4FA7\u63D2\u5165",
  "Insert column after": "\u5728\u53F3\u4FA7\u63D2\u5165",
  "Delete column": "\u5220\u9664\u5217",
  Cols: "\u5217",
  Rows: "\u884C",
  Width: "\u5BBD",
  Height: "\u9AD8",
  "Cell spacing": "\u5355\u5143\u683C\u5916\u95F4\u8DDD",
  "Cell padding": "\u5355\u5143\u683C\u5185\u8FB9\u8DDD",
  "Show caption": "\u663E\u793A\u6807\u9898",
  Left: "\u5DE6\u5BF9\u9F50",
  Center: "\u5C45\u4E2D",
  Right: "\u53F3\u5BF9\u9F50",
  "Cell type": "\u5355\u5143\u683C\u7C7B\u578B",
  Scope: "\u8303\u56F4",
  Alignment: "\u5BF9\u9F50\u65B9\u5F0F",
  "H Align": "\u6C34\u5E73\u5BF9\u9F50",
  "V Align": "\u5782\u76F4\u5BF9\u9F50",
  Top: "\u9876\u90E8\u5BF9\u9F50",
  Middle: "\u5782\u76F4\u5C45\u4E2D",
  Bottom: "\u5E95\u90E8\u5BF9\u9F50",
  "Header cell": "\u8868\u5934\u5355\u5143\u683C",
  "Row group": "\u884C\u7EC4",
  "Column group": "\u5217\u7EC4",
  "Row type": "\u884C\u7C7B\u578B",
  Header: "\u8868\u5934",
  Body: "\u8868\u4F53",
  Footer: "\u8868\u5C3E",
  "Border color": "\u8FB9\u6846\u989C\u8272",
  "Insert template...": "\u63D2\u5165\u6A21\u677F...",
  Templates: "\u6A21\u677F",
  Template: "\u6A21\u677F",
  "Text color": "\u6587\u5B57\u989C\u8272",
  "Background color": "\u80CC\u666F\u8272",
  "Custom...": "\u81EA\u5B9A\u4E49...",
  "Custom color": "\u81EA\u5B9A\u4E49\u989C\u8272",
  "No color": "\u65E0",
  "Remove color": "\u79FB\u9664\u989C\u8272",
  "Table of Contents": "\u5185\u5BB9\u5217\u8868",
  "Show blocks": "\u663E\u793A\u533A\u5757\u8FB9\u6846",
  "Show invisible characters": "\u663E\u793A\u4E0D\u53EF\u89C1\u5B57\u7B26",
  "Word count": "\u5B57\u6570",
  Count: "\u8BA1\u6570",
  Document: "\u6587\u6863",
  Selection: "\u9009\u62E9",
  Words: "\u5355\u8BCD",
  "Words: {0}": "\u5B57\u6570\uFF1A{0}",
  "{0} words": "{0} \u5B57",
  File: "\u6587\u4EF6",
  Edit: "\u7F16\u8F91",
  Insert: "\u63D2\u5165",
  View: "\u89C6\u56FE",
  Format: "\u683C\u5F0F",
  Table: "\u8868\u683C",
  Tools: "\u5DE5\u5177",
  "Powered by {0}": "\u7531{0}\u9A71\u52A8",
  "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "\u5728\u7F16\u8F91\u533A\u6309ALT-F9\u6253\u5F00\u83DC\u5355\uFF0C\u6309ALT-F10\u6253\u5F00\u5DE5\u5177\u680F\uFF0C\u6309ALT-0\u67E5\u770B\u5E2E\u52A9",
  "Image title": "\u56FE\u7247\u6807\u9898",
  "Border width": "\u8FB9\u6846\u5BBD\u5EA6",
  "Border style": "\u8FB9\u6846\u6837\u5F0F",
  Error: "\u9519\u8BEF",
  Warn: "\u8B66\u544A",
  Valid: "\u6709\u6548",
  "To open the popup, press Shift+Enter": "\u6309Shitf+Enter\u952E\u6253\u5F00\u5BF9\u8BDD\u6846",
  "Rich Text Area. Press ALT-0 for help.": "\u7F16\u8F91\u533A\u3002\u6309Alt+0\u952E\u6253\u5F00\u5E2E\u52A9\u3002",
  "System Font": "\u7CFB\u7EDF\u5B57\u4F53",
  "Failed to upload image: {0}": "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25: {0}",
  "Failed to load plugin: {0} from url {1}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25: {0} \u6765\u81EA\u94FE\u63A5 {1}",
  "Failed to load plugin url: {0}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25 \u94FE\u63A5: {0}",
  "Failed to initialize plugin: {0}": "\u63D2\u4EF6\u521D\u59CB\u5316\u5931\u8D25: {0}",
  example: "\u793A\u4F8B",
  Search: "\u641C\u7D22",
  All: "\u5168\u90E8",
  Currency: "\u8D27\u5E01",
  Text: "\u6587\u5B57",
  Quotations: "\u5F15\u7528",
  Mathematical: "\u6570\u5B66",
  "Extended Latin": "\u62C9\u4E01\u8BED\u6269\u5145",
  Symbols: "\u7B26\u53F7",
  Arrows: "\u7BAD\u5934",
  "User Defined": "\u81EA\u5B9A\u4E49",
  "dollar sign": "\u7F8E\u5143\u7B26\u53F7",
  "currency sign": "\u8D27\u5E01\u7B26\u53F7",
  "euro-currency sign": "\u6B27\u5143\u7B26\u53F7",
  "colon sign": "\u5192\u53F7",
  "cruzeiro sign": "\u514B\u9C81\u8D5B\u7F57\u5E01\u7B26\u53F7",
  "french franc sign": "\u6CD5\u90CE\u7B26\u53F7",
  "lira sign": "\u91CC\u62C9\u7B26\u53F7",
  "mill sign": "\u5BC6\u5C14\u7B26\u53F7",
  "naira sign": "\u5948\u62C9\u7B26\u53F7",
  "peseta sign": "\u6BD4\u585E\u5854\u7B26\u53F7",
  "rupee sign": "\u5362\u6BD4\u7B26\u53F7",
  "won sign": "\u97E9\u5143\u7B26\u53F7",
  "new sheqel sign": "\u65B0\u8C22\u514B\u5C14\u7B26\u53F7",
  "dong sign": "\u8D8A\u5357\u76FE\u7B26\u53F7",
  "kip sign": "\u8001\u631D\u57FA\u666E\u7B26\u53F7",
  "tugrik sign": "\u56FE\u683C\u91CC\u514B\u7B26\u53F7",
  "drachma sign": "\u5FB7\u62C9\u514B\u9A6C\u7B26\u53F7",
  "german penny symbol": "\u5FB7\u56FD\u4FBF\u58EB\u7B26\u53F7",
  "peso sign": "\u6BD4\u7D22\u7B26\u53F7",
  "guarani sign": "\u74DC\u62C9\u5C3C\u7B26\u53F7",
  "austral sign": "\u6FB3\u5143\u7B26\u53F7",
  "hryvnia sign": "\u683C\u91CC\u592B\u5C3C\u4E9A\u7B26\u53F7",
  "cedi sign": "\u585E\u5730\u7B26\u53F7",
  "livre tournois sign": "\u91CC\u5F17\u5F17\u5C14\u7B26\u53F7",
  "spesmilo sign": "spesmilo\u7B26\u53F7",
  "tenge sign": "\u575A\u6208\u7B26\u53F7",
  "indian rupee sign": "\u5370\u5EA6\u5362\u6BD4",
  "turkish lira sign": "\u571F\u8033\u5176\u91CC\u62C9",
  "nordic mark sign": "\u5317\u6B27\u9A6C\u514B",
  "manat sign": "\u9A6C\u7EB3\u7279\u7B26\u53F7",
  "ruble sign": "\u5362\u5E03\u7B26\u53F7",
  "yen character": "\u65E5\u5143\u5B57\u6837",
  "yuan character": "\u4EBA\u6C11\u5E01\u5143\u5B57\u6837",
  "yuan character, in hong kong and taiwan": "\u5143\u5B57\u6837\uFF08\u6E2F\u53F0\u5730\u533A\uFF09",
  "yen/yuan character variant one": "\u5143\u5B57\u6837\uFF08\u5927\u5199\uFF09",
  "Loading emoticons...": "\u52A0\u8F7D\u8868\u60C5\u7B26\u53F7...",
  "Could not load emoticons": "\u4E0D\u80FD\u52A0\u8F7D\u8868\u60C5\u7B26\u53F7",
  People: "\u4EBA\u7C7B",
  "Animals and Nature": "\u52A8\u7269\u548C\u81EA\u7136",
  "Food and Drink": "\u98DF\u7269\u548C\u996E\u54C1",
  Activity: "\u6D3B\u52A8",
  "Travel and Places": "\u65C5\u6E38\u548C\u5730\u70B9",
  Objects: "\u7269\u4EF6",
  Flags: "\u65D7\u5E1C",
  Characters: "\u5B57\u7B26",
  "Characters (no spaces)": "\u5B57\u7B26(\u65E0\u7A7A\u683C)",
  "{0} characters": "{0} \u4E2A\u5B57\u7B26",
  "Error: Form submit field collision.": "\u9519\u8BEF: \u8868\u5355\u63D0\u4EA4\u5B57\u6BB5\u51B2\u7A81\u3002",
  "Error: No form element found.": "\u9519\u8BEF: \u6CA1\u6709\u8868\u5355\u63A7\u4EF6\u3002",
  Update: "\u66F4\u65B0",
  "Color swatch": "\u989C\u8272\u6837\u672C",
  Turquoise: "\u9752\u7EFF\u8272",
  Green: "\u7EFF\u8272",
  Blue: "\u84DD\u8272",
  Purple: "\u7D2B\u8272",
  "Navy Blue": "\u6D77\u519B\u84DD",
  "Dark Turquoise": "\u6DF1\u84DD\u7EFF\u8272",
  "Dark Green": "\u6DF1\u7EFF\u8272",
  "Medium Blue": "\u4E2D\u84DD\u8272",
  "Medium Purple": "\u4E2D\u7D2B\u8272",
  "Midnight Blue": "\u6DF1\u84DD\u8272",
  Yellow: "\u9EC4\u8272",
  Orange: "\u6A59\u8272",
  Red: "\u7EA2\u8272",
  "Light Gray": "\u6D45\u7070\u8272",
  Gray: "\u7070\u8272",
  "Dark Yellow": "\u6697\u9EC4\u8272",
  "Dark Orange": "\u6DF1\u6A59\u8272",
  "Dark Red": "\u6DF1\u7EA2\u8272",
  "Medium Gray": "\u4E2D\u7070\u8272",
  "Dark Gray": "\u6DF1\u7070\u8272",
  "Light Green": "\u6D45\u7EFF\u8272",
  "Light Yellow": "\u6D45\u9EC4\u8272",
  "Light Red": "\u6D45\u7EA2\u8272",
  "Light Purple": "\u6D45\u7D2B\u8272",
  "Light Blue": "\u6D45\u84DD\u8272",
  "Dark Purple": "\u6DF1\u7D2B\u8272",
  "Dark Blue": "\u6DF1\u84DD\u8272",
  Black: "\u9ED1\u8272",
  White: "\u767D\u8272",
  "Switch to or from fullscreen mode": "\u5207\u6362\u5168\u5C4F\u6A21\u5F0F",
  "Open help dialog": "\u6253\u5F00\u5E2E\u52A9\u5BF9\u8BDD\u6846",
  history: "\u5386\u53F2",
  styles: "\u6837\u5F0F",
  formatting: "\u683C\u5F0F\u5316",
  alignment: "\u5BF9\u9F50",
  indentation: "\u7F29\u8FDB",
  "permanent pen": "\u8BB0\u53F7\u7B14",
  comments: "\u5907\u6CE8",
  "Format Painter": "\u683C\u5F0F\u5237",
  "Insert/edit iframe": "\u63D2\u5165/\u7F16\u8F91\u6846\u67B6",
  Capitalization: "\u5927\u5199",
  lowercase: "\u5C0F\u5199",
  UPPERCASE: "\u5927\u5199",
  "Title Case": "\u9996\u5B57\u6BCD\u5927\u5199",
  "Permanent Pen Properties": "\u6C38\u4E45\u7B14\u5C5E\u6027",
  "Permanent pen properties...": "\u6C38\u4E45\u7B14\u5C5E\u6027...",
  Font: "\u5B57\u4F53",
  Size: "\u5B57\u53F7",
  "More...": "\u66F4\u591A...",
  "Spellcheck Language": "\u62FC\u5199\u68C0\u67E5\u8BED\u8A00",
  "Select...": "\u9009\u62E9...",
  Preferences: "\u9996\u9009\u9879",
  Yes: "\u662F",
  No: "\u5426",
  "Keyboard Navigation": "\u952E\u76D8\u6307\u5F15",
  Version: "\u7248\u672C",
  Anchor: "\u951A\u70B9",
  "Special character": "\u7279\u6B8A\u7B26\u53F7",
  "Code sample": "\u4EE3\u7801\u793A\u4F8B",
  Color: "\u989C\u8272",
  Emoticons: "\u8868\u60C5",
  "Document properties": "\u6587\u6863\u5C5E\u6027",
  Image: "\u56FE\u7247",
  "Insert link": "\u63D2\u5165\u94FE\u63A5",
  Target: "\u6253\u5F00\u65B9\u5F0F",
  Link: "\u94FE\u63A5",
  Poster: "\u5C01\u9762",
  Media: "\u5A92\u4F53",
  Print: "\u6253\u5370",
  Prev: "\u4E0A\u4E00\u4E2A",
  "Find and replace": "\u67E5\u627E\u548C\u66FF\u6362",
  "Whole words": "\u5168\u5B57\u5339\u914D",
  Spellcheck: "\u62FC\u5199\u68C0\u67E5",
  Caption: "\u6807\u9898",
  "Insert template": "\u63D2\u5165\u6A21\u677F"
});
export {
  ZH as default
};
